<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->

# JNI Example

These files serve to illustrate how you can interoperate with CQL generated code
in Java.

## The Java entry point

This is the main program. It calls some stored procedures using the generated
JNI wrappers. The point of `make.sh` (below) is to generate all the JNI needed
to use the CQL in `Sample.sql`. There are standard JNI helpers to create the
runtime environment, but those aer not specific to any given set of procedures.
See below.

* `./MyJava.java`

## Database access

This is the JNI class that opens the database for us and gives us a handle.  You
should replace this as needed or use an alternative. In the Java world the
`sqlite3 *` that is the database is just a `long` so it's easy to project it
from whatever database source you might have.

* `./std_jni/com_acme_cgsql_CQLDb.c`
* `./com/acme/cgsql/CQLDb.java`

## Result set access

This is the JNI class that captures a result set with the generic interface to
access any of the defined columns dynamically.  Note that the metadata of the
CQL result set is verified against the calls so this is still type-safe.

* `./std_jni/com_acme_cgsql_CQLResultSet.c`
* `./com/acme/cgsql/CQLResultSet.java`

## View Model Abstract class

This class provides the basic shape for all of the generated ViewModel classes.
The python generates subtypes of this class.

* `./com/acme/cgsql/CQLViewModel.java`

More specifically, `CQLResultSet` uses standard JNI methods to read the
primitive types out of any result set.  The compiler produce a subclass of
`CQLViewModel` that uses `CQLResultSet` to do its job.  The JNI C file
`com_acme_cgsql_CQLResultSet.c` has the necessary calls to the CQL and Java
runtime to do that reading.  Each of the functions is just a few lines of code.
The `.h` files associated with `./com/acme/*` are auto-generated by `java -h`
from the their declared `.java` wrappers and hence are not checked in.  `CQLDb`
creates a simple memory database, you can replace it with whatever you need.

## Encoded Types

A very simple very bad string encoder for the CQL encoded string type is provided.
You can investigate the "vault" options to learn more.  This one is only useful
as a test tool.

* `./com/acme/cgsql/CQLEncodedString.java`

## The CQL to access

* `./Sample.sql`

This file has several test procedures.  The most important is a stored procedure
that creates a table, puts stuff in it, and then returns its contents.  This is
in some sense the core of the demo.  Everything else is scaffolding.

## The JNI Generator

The CQL compiler is used to generated JSON to describe the exact contents of
`Sample.sql`. The python reads the generated JSON and creates first the Java
wrappers and then the necessary C code to support them.  It is invoked twice.
You can make as many or as few units of JNI as you like since the JSON bundles
could be created from amalgamations of `.sql` files.  Alternatively,
`./cqljava.py` would be trivially extended to take more than one input and
create a unitary output for all the input files.

* `./cqljava.py`

## Building Tools

Use `make.sh` to build and execute the JNI demo.  Use `clean.sh` to clean up the
build artifacts afterwards.

* `./make.sh`
* `./clean.sh`

Build notes:

* set `JAVA_HOME` to the location of your JDK, for `jni.h` and friends.
* set `SQLITE_PATH` to the location of your SQLite installation if you want to
  use an amalgam build of SQLITE rather than just use `-lsqlite3`

`make.sh` is itself pretty straightforward though it is longish. It's not done
with "better" build technology just so that it can showcase exactly what needs
to happen with a minimum of clutter.  The build steps are all very simple
and can be readily turned into `cmake` or whatever.
