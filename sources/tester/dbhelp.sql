/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

-- This file generates dbhelp.c, dbhelp.c is licensed per the below.

-- ------ cql-verify db helpers

@echo c, "\n";
@echo c, "\n";
@echo c, "//\n";
@echo c, "// This file is auto-generated by dbhelp.sql, it is checked in just\n";
@echo c, "// in case CQL is broken by a change.  The Last Known Good Verifier\n";
@echo c, "// can be used to verify the tests pass again, or report failures\n";
@echo c, "// while things are still otherwise broken.  Rebuild with 'regen.sh'\n";
@echo c, "//\n";
@echo c, "\n";


@echo c, "#undef cql_error_trace\n";
@echo c, "#define cql_error_trace() fprintf(stderr, \"SQL Failure %d %s: %s %d\\n\", _rc_, sqlite3_errmsg(_db_), __FILE__, __LINE__)\n";

declare proc printf no check;

-- setup the table and the index
create procedure dbhelp_setup()
begin
  create table test_output(
     line integer not null,
     data text not null
  );

  create index __idx__test_lines on test_output (line);

  create table source_input(
     line integer not null,
     data text not null
  );

  create index __idx__source_lines on source_input (line);
end;

create procedure dbhelp_prev_line(line_ integer not null, out prev integer not null)
begin
  begin try
     set prev := (select ifnull(max(line),-1) from test_output where line < line_);
  end try;
  begin catch
     set prev := 0;
  end catch;
end;

-- add a row to the output table (test_output)
-- this comes from the test output/results file
create procedure dbhelp_add(line integer not null, data text not null)
begin
  insert into test_output values (line, data);
end;

-- add a row to the input table (source_input)
-- these comes from the test/input .sql file
create procedure dbhelp_add_source(line integer not null, data text not null)
begin
  insert into source_input values (line, data);
end;

-- dump all the output lines that were associated with the given input line
create procedure dbhelp_dump_output(line_ integer not null)
begin
  declare C cursor for select * from test_output where line = line_;
  loop fetch C
  begin
    call printf('%s', C.data);
  end;
end;

-- find the statement that came after line_
-- search the results of that statement for the indicated pattern
create proc dbhelp_find(line_ integer not null, pattern text not null, out search_line integer not null, out found integer not null)
begin
  /* the pattern match line is before the statement that generates the output like so:

     1:  -- TEST : something
     2:  -- + foo                           <-- we have this line number, e.g. 2
     3:  -- - bar
     4:  select something where something;  <-- we need this line number, e.g. 4

     We need to find the number of a line in the test output that has been charged to an input line greater than the one we are on.
  */
  begin try
    set search_line := (select line from test_output where line >= line_ limit 1);
  end try;
  begin catch
    call printf("no lines come after %d\n", line_);
    call printf("available test output lines: %d\n", (select count(*) from test_output));
    call printf("max line number: %d\n", (select max(line) from test_output));
    throw;
  end catch;

  -- once we have it, search for matches on that line and return the number we found
  set found := (select count(*) from test_output where line = search_line and data like pattern);
end;

-- dump all of the input lines starting from line1 up to but not including line2
create procedure dbhelp_dump_source(line1 integer not null, line2 integer not null)
begin
  declare C cursor for select * from source_input where line > line1 and line <= line2;
  loop fetch C
  begin
    call printf('%s', C.data);
  end;
end;

-- make a rowset with all of the input lines
create procedure dbhelp_source()
begin
  select * from source_input;
end;
