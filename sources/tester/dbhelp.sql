/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

-- This file generates dbhelp.c, dbhelp.c is licensed per the below.

-- ------ cql-verify db helpers

@echo c, "\n";
@echo c, "\n";
@echo c, "//\n";
@echo c, "// This file (dbhelp.c) is auto-generated by dbhelp.sql, it is checked in just\n";
@echo c, "// in case CQL is broken by a change.  The Last Known Good Verifier\n";
@echo c, "// can be used to verify the tests pass again, or report failures\n";
@echo c, "// while things are still otherwise broken.  Rebuild with 'regen.sh'\n";
@echo c, "//\n";
@echo c, "\n";


@echo c, "#undef cql_error_trace\n";
@echo c, "#define cql_error_trace() fprintf(stderr, \"SQL Failure %d %s: %s %d\\n\", _rc_, sqlite3_errmsg(_db_), __FILE__, __LINE__)\n";

declare proc printf no check;

-- setup the table and the index
create procedure dbhelp_setup()
begin
  create table test_output(
     line integer not null,
     data text not null
  );

  create index __idx__test_lines on test_output (line);

  create table source_input(
     line integer not null,
     data text not null
  );

  create index __idx__source_lines on source_input (line);
end;

create procedure dbhelp_prev_line(line_ integer not null, out prev integer not null)
begin
  begin try
     set prev := (select ifnull(max(line),-1) from test_output where line < line_);
  end try;
  begin catch
     set prev := 0;
  end catch;
end;

-- add a row to the output table (test_output)
-- this comes from the test output/results file
create procedure dbhelp_add(line integer not null, data text not null)
begin
  insert into test_output values (line, data);
end;

-- add a row to the input table (source_input)
-- these comes from the test/input .sql file
create procedure dbhelp_add_source(line integer not null, data text not null)
begin
  insert into source_input values (line, data);
end;

-- dump all the output lines that were associated with the given input line
create procedure dbhelp_dump_output(line_ integer not null)
begin
  declare C cursor for select * from test_output where line = line_;
  loop fetch C
  begin
    call printf('%s', C.data);
  end;
end;

-- find the statement that came after line_
-- search the results of that statement for the indicated pattern
create proc dbhelp_find(line_ integer not null, pattern text not null, out search_line integer not null, out found integer not null)
begin
  /* the pattern match line is before the statement that generates the output like so:

     1:  -- TEST : something
     2:  -- + foo                           <-- we have this line number, e.g. 2
     3:  -- - bar
     4:  select something where something;  <-- we need this line number, e.g. 4

     We need to find the number of a line in the test output that has been charged to an input line greater than the one we are on.
  */
  begin try
    set search_line := (select line from test_output where line >= line_ limit 1);
  end try;
  begin catch
    call printf("no lines come after %d\n", line_);
    call printf("available test output lines: %d\n", (select count(*) from test_output));
    call printf("max line number: %d\n", (select max(line) from test_output));
    throw;
  end catch;

  -- once we have it, search for matches on that line and return the number we found
  set found := (select count(*) from test_output where line = search_line and data like pattern);
end;

-- dump all of the input lines starting from line1 up to but not including line2
create procedure dbhelp_dump_source(line1 integer not null, line2 integer not null)
begin
  declare C cursor for select * from source_input where line > line1 and line <= line2;
  loop fetch C
  begin
    call printf('%s', C.data);
  end;
end;

-- make a rowset with all of the input lines
create procedure dbhelp_source()
begin
  select * from source_input;
end;

declare function cql_fopen(name text!, mode text!) create object<file>;
declare function readline_object_file(f object<file>!) create text;
declare function atoi_at_text(str text!, `offset` int!) int!;
declare function len_text(self text!) int!;
declare function starts_with_text(haystack text!, needle text!) bool!;
declare function index_of_text(haystack text!, needle text!) int!;

proc dbhelp_main(args cql_string_list!)
begin
  let argc := args.count;
  let i := 0;

  if argc != 3 then
    printf("usage cql-verify foo.sql foo.out\n");
    printf("cql-verify is a test tool.  It processes the input foo.sql\n");
    printf("looking for patterns to match in the CQL output foo.out\n");
    throw;
  end if;

  dbhelp_setup();

  let prefix := "The statement ending at line ";

  -- store the test and output file names
  let sql_name := ifnull_throw(args[1]);
  let result_name := ifnull_throw(args[2]);

  let sql := cql_fopen(sql_name, "r");
  if sql is null then
    printf("unable to open file '%s'\n", sql_name);
    throw;
  end if;

  let result := cql_fopen(result_name, "r");
  if result is null then
    printf("unable to open file '%s'\n", result_name);
    throw;
  end if;

  let line := 0;

  let len := prefix::len();
  var data text;

  -- first we read the test results, we're looking for sentinel lines
  -- that tell us where in the input these results came from
  -- each result will be charged to the input line it is associated
  -- with.  The prefix introduces those lines

  while true
  begin
    set data := result:::readline();
    if data is null leave;

    -- lines in the output that start with the prefix demark 
    -- output that corresponds to the given input line

    let loc := data::index_of(prefix);
    
    if loc >= 0 then
      line := data::atoi_at(loc + len);
    end if;

    -- add the indicated text to the database indexed by the line it was on
    insert into test_output values (line, data);
  end;
  result := null;

  -- now we're going to read the entire test file and store it in
  -- the database indexed by line.  We're going to do this so that
  -- we can go backwards for forwards in the lines easily using
  -- the database.  We can select ranges of lines, that sort of thing.

  set line := 1;
  
  while true
  begin
    set data := sql:::readline();
    if data is null leave;

    insert into source_input values (line, data);
    line += 1;
  end;
  sql := null;

end;

