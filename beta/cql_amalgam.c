/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// @generated SignedSource<<deadbeef8badf00ddefec8edfacefeed>>

#ifdef _MSC_VER
  // suppress fopen warning in MSC
  #define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef CQL_NO_SYSTEM_HEADERS

// If you are a different environment you might not want all of these
// or you might want different ones.  You can include your own preamble
// to get the system symbols or you can adjust it.  Simply copy these
// headers as a starting point and then make your equivalents.

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <inttypes.h>
#include <setjmp.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#ifndef _MSC_VER
#include <libgen.h>
#else
#define PATH_MAX 255
#endif

#endif

#define CQL_AMALGAM 1
#define YYERROR_VERBOSE 1

typedef uint8_t bool_t;
typedef long long int llint_t;
typedef const char *CSTR;

// In the amalgam build, most things do not need to be visible.  Only the
// API exported by the amalgam should be extern so as to avoid contamination
// of the namespace.

#define cql_noexport static
#define cql_export extern

// the declaration will always come first and once, that becomes the new definition
#define cql_data_decl(x) static x;

// the definition is redundant, strip it
#define cql_data_defn(x)

// map the global yy parser variables and functions to something not likely to conflict

#define yy_flex_debug cql_yy_flex_debug
#define yychar cql_yychar
#define yyin cql_yyin
#define yyleng cql_yyleng
#define yylineno cql_yylineno
#define yylval cql_yylval
#define yynerrs cql_yynerrs
#define yyout cql_yyout
#define yytext cql_yytext

#define yy_create_buffer cql_yy_create_buffer
#define yy_delete_buffer cql_yy_delete_buffer
#define yy_flush_buffer cql_yy_flush_buffer
#define yy_scan_buffer cql_yy_scan_buffer
#define yy_scan_bytes cql_yy_scan_bytes
#define yy_scan_string cql_yy_scan_string
#define yy_switch_to_buffer cql_yy_switch_to_buffer
#define yyalloc cql_yyalloc
#define yyerror cql_yyerror
#define yyfree cql_yyfree
#define yyget_debug cql_yyget_debug
#define yyget_in cql_yyget_in
#define yyget_leng cql_yyget_leng
#define yyget_lineno cql_yyget_lineno
#define yyget_out cql_yyget_out
#define yyget_text cql_yyget_text
#define yylex cql_yylex
#define yylex_destroy cql_yylex_destroy
#define yyparse cql_yyparse
#define yypop_buffer_state cql_yypop_buffer_state
#define yypush_buffer_state cql_yypush_buffer_state
#define yyrealloc cql_yyrealloc
#define yyrestart cql_yyrestart
#define yyset_debug cql_yyset_debug
#define yyset_in cql_yyset_in
#define yyset_lineno cql_yyset_lineno
#define yyset_out cql_yyset_out

#ifndef _MSC_VER
#pragma clang diagnostic push
#endif

#ifndef CQL_NO_DIAGNOSTIC_BLOCK
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// enable lots of extra warnings for cql

#ifndef _MSC_VER

#pragma clang diagnostic error "-Wall"

// in case your compiler doesn't have some of the below
#pragma clang diagnostic ignored "-Wunknown-warning-option"

#pragma clang diagnostic error "-Wduplicate-method-match"
#pragma clang diagnostic error "-Wparentheses"
#pragma clang diagnostic error "-Wreturn-type"
#pragma clang diagnostic error "-Wshadow"
#pragma clang diagnostic error "-Wunguarded-availability"
#pragma clang diagnostic error "-Wuninitialized"
#pragma clang diagnostic error "-Wunknown-pragmas"
#pragma clang diagnostic error "-Wimplicit-int-conversion"
#pragma clang diagnostic error "-Wshorten-64-to-32"
#pragma clang diagnostic error "-Wsign-conversion"
#pragma clang diagnostic error "-Wconversion"
#pragma clang diagnostic error "-Werror=format-extra-args"
#pragma clang diagnostic error "-Werror=format-security"
#pragma clang diagnostic error "-Werror=format="

#ifdef NDEBUG
// Many symbols are "unused" becuase they only appear in asserts, so we have to suppress
// those warnings in a non-debug build.
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-function"
#else
// The debug build should be clean
#pragma clang diagnostic error "-Wunused-variable"
#pragma clang diagnostic error "-Wunused-function"
#endif

#endif

#ifndef __clang__
#ifndef _Nonnull
    /* Hide Clang-only nullability specifiers if not Clang */
    #define _Nonnull
    #define _Nullable
#endif
#endif

#ifndef _MSC_VER

#if defined(CQL_AMALGAM_LEAN)
// in this version there are going to be unused stubs a-plenty
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#endif

#endif

#ifdef _MSC_VER
#define _printf_checking_(x,y)
#define _Noreturn
#else
#define _printf_checking_(x,y) __attribute__ (( format( printf, x, y ) ))
#endif
#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This is a simple growable memory buffer, it may have arbitrary
// binary in it.  It's the peer to charbuf for bytes.



#define BYTEBUF_GROWTH_SIZE 1024

typedef struct bytebuf {
  char *_Nullable ptr;   // pointer to stored data, if any
  uint32_t used;         // bytes used in current buffer
  uint32_t max;          // max bytes in current buffer
} bytebuf;

cql_noexport void bytebuf_open(bytebuf *_Nonnull buf);
cql_noexport void bytebuf_close(bytebuf *_Nonnull buf);
cql_noexport void *_Nonnull bytebuf_alloc(bytebuf *_Nonnull buf, uint32_t needed);
cql_noexport void bytebuf_append(bytebuf *_Nonnull buf, const void *_Nonnull bytes, uint32_t count);

// helper macro for new from a bufferÃŸ
#define bytebuf_new(buf, T) ((T*)bytebuf_alloc(buf, sizeof(T)))

// helper macro to append a normal variable
#define bytebuf_append_var(buf, var) bytebuf_append(buf, &var, sizeof(var))

// cleanup a non-null buffer
#define BYTEBUF_CLEANUP(b) if (b) {bytebuf_close(b); b = NULL; }
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


#define CHARBUF_INTERNAL_SIZE 1024
#define CHARBUF_GROWTH_SIZE 1024

typedef struct charbuf
{
  char *ptr;      // pointer to stored data, if any
  uint32_t used;  // bytes used in current buffer
  uint32_t max;   // max bytes in current buffer

  // builtin buffer storage
  char internal[CHARBUF_INTERNAL_SIZE];
} charbuf;

typedef struct pending_charbuf {
  charbuf *buf;
  struct pending_charbuf *prev;
} pending_charbuf;

cql_data_decl( int32_t charbuf_open_count );
cql_data_decl( pending_charbuf *__charbufs_in_flight );

cql_noexport void bopen(charbuf* b);
cql_noexport void bclose(charbuf *b);
cql_noexport void bclear(charbuf *b);
cql_noexport void release_open_charbufs(void);
cql_noexport void vbprintf(charbuf *b, const char *format, va_list args);
cql_noexport void bprintf(charbuf *b, const char *format, ...) _printf_checking_(2, 3);
cql_noexport CSTR dup_printf(const char *format, ...) _printf_checking_(1, 2);
cql_noexport void bputc(charbuf *b, char c);
cql_noexport void bindent(charbuf *output, charbuf *input, int32_t indent);
cql_noexport bool_t breadline(charbuf *output, CSTR *data);

#define CHARBUF_OPEN(x) \
  int32_t __saved_charbuf_count##x = charbuf_open_count; \
  charbuf x; \
  pending_charbuf pending_charbuf_##x; \
  pending_charbuf_##x.prev = __charbufs_in_flight; \
  pending_charbuf_##x.buf = &x; \
  __charbufs_in_flight = &pending_charbuf_##x; \
  bopen(&x)

#define CHARBUF_CLOSE(x) \
  bclose(&x); \
  Invariant(__saved_charbuf_count##x == charbuf_open_count); \
  __charbufs_in_flight = __charbufs_in_flight->prev \

// These helpers push a buffer and use it for the output temporarily.
// When the buffer is finished (at END_INDENT) bindent is used to
// indent it by the indicated amount.  They assume the output buffer is called
// "output".
#define BEGIN_INDENT(name, level) \
  charbuf *name##_saved = output; \
  int32_t name##_level = level; \
  CHARBUF_OPEN(name); \
  output = &name;

#define END_INDENT(name) \
  output = name##_saved; \
  bindent(output, &name, name##_level); \
  CHARBUF_CLOSE(name);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



// each symbol table entry is a key/value pair
// the key is always a char *, the value can be anything
typedef struct symtab_entry {
 const char *_Nullable sym;
 void *_Nullable val;
} symtab_entry;

// The symbol table itself is the usual close hash table form
// we need the used count and the capacity to manage it
// additionally the hash function and the comparision function
// can be changed.  There is a teardown function that can be
// provided to clean up the payloads when the table is deleted.
// The normal cleanup just deletes the payload array.  The
// strings are assumed to be long-lived and owned by something else
// like the AST.
typedef struct symtab {
  uint32_t count;
  uint32_t capacity;
  symtab_entry *_Nullable payload;
  uint32_t (*_Nonnull hash)(const char *_Nonnull str);
  int32_t (*_Nonnull cmp)(const char *_Nonnull c1, const char *_Nonnull c2);
  void (*_Nullable teardown)(void *_Nonnull val);
} symtab;

#define SYMTAB_INIT_SIZE 4
#define SYMTAB_LOAD_FACTOR .75

cql_noexport symtab *_Nonnull symtab_new_case_sens(void);
cql_noexport symtab *_Nonnull symtab_new(void);
cql_noexport void symtab_delete(symtab *_Nonnull syms);
cql_noexport bool_t symtab_add(symtab *_Nonnull syms, const char *_Nonnull sym_new, void *_Nullable val_new);
cql_noexport symtab_entry *_Nullable symtab_find(symtab *_Nullable syms, const char *_Nonnull sym_needed);

// Special case support for symbol table of byte buffers, char buffers, nested symbol tables
// these are commmon.
cql_noexport bytebuf *_Nonnull symtab_ensure_bytebuf(symtab *_Nonnull syms, const char *_Nonnull sym_new);
cql_noexport void symtab_append_bytes(symtab *_Nonnull syms, const char *_Nonnull sym_new, const void *_Nullable bytes, size_t count);
cql_noexport symtab *_Nonnull symtab_ensure_symtab(symtab *_Nonnull syms, const char *_Nonnull name);
cql_noexport bool_t symtab_add_symtab(symtab *_Nonnull syms, CSTR _Nonnull name, symtab *_Nonnull data);
cql_noexport charbuf *_Nonnull symtab_ensure_charbuf(symtab *_Nonnull syms, const char *_Nonnull sym_new);

// patternlint-disable-next-line prefer-sized-ints-in-msys
cql_noexport int default_symtab_comparator(symtab_entry *_Nonnull entry1, symtab_entry *_Nonnull entry2);

// patternlint-disable-next-line prefer-sized-ints-in-msys
cql_noexport symtab_entry *_Nonnull symtab_copy_sorted_payload(symtab *_Nonnull syms, int (*_Nonnull comparator)(symtab_entry *_Nonnull entry1, symtab_entry *_Nonnull entry2));

#define SYMTAB_CLEANUP(x)  if (x) { symtab_delete(x); x = NULL; }
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


typedef struct minipool {
  struct minipool *_Nullable next;
  char *_Nullable bytes;
  char *_Nullable current;
  uint32_t available;
} minipool;

#define MINIBLOCK (1024*64)

cql_noexport void minipool_open(minipool *_Nullable *_Nonnull pool);
cql_noexport void minipool_close(minipool *_Nullable *_Nonnull pool);
cql_noexport void *_Nonnull minipool_alloc(minipool *_Nonnull pool, uint32_t needed);


// lazy free service for misc pool contents

typedef struct lazy_free {
  struct lazy_free *_Nullable next;
  void *_Nullable context;
  void (*_Nonnull teardown)(void *_Nullable context);
} lazy_free;

cql_noexport void add_lazy_free(lazy_free *_Nonnull p);
cql_noexport void run_lazy_frees(void);

#define _pool_new(p, x) ((x*)minipool_alloc(p, (int32_t)sizeof(x)))
#define _pool_new_array(p, x, c) ((x*)minipool_alloc(p, c*(int32_t)sizeof(x)))

#define _ast_pool_new(x) _pool_new(ast_pool, x)
#define _ast_pool_new_array(x, c) _pool_new_array(ast_pool, x, c)

cql_data_decl( minipool *_Nullable ast_pool );
cql_data_decl( minipool *_Nullable str_pool );
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// super simple linked list handlers


// no need to free this list anymore minipool will do it for
// you automatically at the end of a CQL run.
// @see minipool
typedef struct list_item {
  struct ast_node *ast;
  struct list_item *next;
} list_item;

cql_noexport void add_item_to_list(list_item **head, struct ast_node *ast);
cql_noexport void reverse_list(list_item **head);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Assorted definitions for the CQL abstract syntax tree



#define GENERIC_IS_TEMP       0x1
#define GENERIC_IF_NOT_EXISTS 0x2

#define VTAB_IS_EPONYMOUS     0x4

#define TABLE_IS_TEMP         GENERIC_IS_TEMP
#define TABLE_IF_NOT_EXISTS   GENERIC_IF_NOT_EXISTS
#define TABLE_IS_NO_ROWID     0x0004

#define VIEW_IS_TEMP          GENERIC_IS_TEMP
#define VIEW_IF_NOT_EXISTS    GENERIC_IF_NOT_EXISTS

#define TRIGGER_IS_TEMP       GENERIC_IS_TEMP
#define TRIGGER_IF_NOT_EXISTS GENERIC_IF_NOT_EXISTS
#define TRIGGER_BEFORE        0x0004
#define TRIGGER_AFTER         0x0008
#define TRIGGER_INSTEAD_OF    0x0010
#define TRIGGER_UPDATE        0x0020
#define TRIGGER_DELETE        0x0040
#define TRIGGER_INSERT        0x0080
#define TRIGGER_FOR_EACH_ROW  0x0100

#define PROC_FLAG_BASIC          0
#define PROC_FLAG_STRUCT_TYPE    1
#define PROC_FLAG_USES_DML       2
#define PROC_FLAG_USES_OUT       4
#define PROC_FLAG_USES_OUT_UNION 8

#define INDEX_UNIQUE        1
#define INDEX_IFNE          2

#define RAISE_IGNORE        0
#define RAISE_ROLLBACK      1
#define RAISE_ABORT         2
#define RAISE_FAIL          3

#define ON_CONFLICT_ROLLBACK   0
#define ON_CONFLICT_ABORT      1
#define ON_CONFLICT_FAIL       2
#define ON_CONFLICT_IGNORE     3
#define ON_CONFLICT_REPLACE    4

#define FK_ON_UPDATE   0xF0
#define FK_ON_DELETE   0x0F

#define FK_SET_NULL    0x01
#define FK_SET_DEFAULT 0x02
#define FK_CASCADE     0x03
#define FK_RESTRICT    0x04
#define FK_NO_ACTION   0x05

#define FK_DEFERRABLES         0xF00
#define FK_NOT_DEFERRABLE      0x800
#define FK_DEFERRABLE          0x400
#define FK_INITIALLY_DEFERRED  0x200
#define FK_INITIALLY_IMMEDIATE 0x100

#define TRANS_DEFERRED 1
#define TRANS_IMMEDIATE 2
#define TRANS_EXCLUSIVE 3

#define ENFORCE_FK_ON_UPDATE 1
#define ENFORCE_FK_ON_DELETE 2
#define ENFORCE_STRICT_JOIN 3
#define ENFORCE_UPSERT_STMT 4
#define ENFORCE_WINDOW_FUNC 5
#define ENFORCE_CAST 6
#define ENFORCE_WITHOUT_ROWID 7
#define ENFORCE_TRANSACTION 8
#define ENFORCE_SELECT_IF_NOTHING 9
#define ENFORCE_INSERT_SELECT 10
#define ENFORCE_TABLE_FUNCTION 11
#define ENFORCE_SIGN_FUNCTION 12
#define ENFORCE_IS_TRUE 13
#define ENFORCE_CURSOR_HAS_ROW 14
#define ENFORCE_UPDATE_FROM 15
#define ENFORCE_AND_OR_NOT_NULL_CHECK 16

#define COMPOUND_OP_UNION 1
#define COMPOUND_OP_UNION_ALL 2
#define COMPOUND_OP_INTERSECT 3
#define COMPOUND_OP_EXCEPT 4

#define PUBLIC_REGION 0
#define PRIVATE_REGION 1

#define EXPLAIN_NONE 1
#define EXPLAIN_QUERY_PLAN 2

#define FRAME_TYPE_RANGE                 0x00001
#define FRAME_TYPE_ROWS                  0x00002
#define FRAME_TYPE_GROUPS                0x00004
#define FRAME_TYPE_FLAGS                 0x00007 // bit mask for the frame spec type

#define FRAME_BOUNDARY_UNBOUNDED         0x00008
#define FRAME_BOUNDARY_PRECEDING         0x00010
#define FRAME_BOUNDARY_CURRENT_ROW       0x00020
#define FRAME_BOUNDARY_FLAGS             0x00038 // bit mask for the frame spec boundary

#define FRAME_BOUNDARY_START_UNBOUNDED   0x00040
#define FRAME_BOUNDARY_START_PRECEDING   0x00080
#define FRAME_BOUNDARY_START_CURRENT_ROW 0x00100
#define FRAME_BOUNDARY_START_FOLLOWING   0x00200
#define FRAME_BOUNDARY_START_FLAGS       0x003C0 // bit mask for the frame spec boundary start

#define FRAME_BOUNDARY_END_PRECEDING     0x00400
#define FRAME_BOUNDARY_END_CURRENT_ROW   0x00800
#define FRAME_BOUNDARY_END_FOLLOWING     0x01000
#define FRAME_BOUNDARY_END_UNBOUNDED     0x02000
#define FRAME_BOUNDARY_END_FLAGS         0x03C00 // bit mask for the frame spec boundary end

#define FRAME_EXCLUDE_NO_OTHERS          0x04000
#define FRAME_EXCLUDE_CURRENT_ROW        0x08000
#define FRAME_EXCLUDE_GROUP              0x10000
#define FRAME_EXCLUDE_TIES               0x20000
#define FRAME_EXCLUDE_NONE               0x40000
#define FRAME_EXCLUDE_FLAGS              0x7C000 // bit mask for the frame spec boundary end

#define NUM_INT 0
#define NUM_LONG 1
#define NUM_REAL 2
#define NUM_BOOL 3

typedef struct ast_node {
  const char *_Nonnull type;
  struct sem_node *_Nullable sem;
  struct ast_node *_Nullable parent;
  int32_t lineno;
  CSTR _Nonnull filename;
  struct ast_node *_Nullable left;
  struct ast_node *_Nullable right;
} ast_node;

typedef struct int_ast_node {
  const char *_Nonnull type;
  struct sem_node *_Nullable sem;
  struct ast_node *_Nullable parent;
  int32_t lineno;
  CSTR _Nonnull filename;
  int64_t value;
} int_ast_node;

#define STRING_TYPE_SQL 0
#define STRING_TYPE_C 1
#define STRING_TYPE_QUOTED_ID 2

typedef struct str_ast_node {
  const char *_Nonnull type;
  struct sem_node *_Nullable sem;
  struct ast_node *_Nullable parent;
  int32_t lineno;
  CSTR _Nonnull filename;
  const char *_Nullable value;
  uint8_t str_type;
} str_ast_node;

typedef struct num_ast_node {
  const char *_Nonnull type;
  struct sem_node *_Nullable sem;
  struct ast_node *_Nullable parent;
  int32_t lineno;
  CSTR _Nonnull filename;
  int32_t num_type;
  const char *_Nullable value;
} num_ast_node;

typedef struct {
  ast_node *_Nonnull def;
  int32_t type;
  int32_t count_context;
} macro_info;

cql_noexport CSTR _Nullable install_macro_args(ast_node *_Nonnull ast);
cql_noexport void new_macro_formals(void);
cql_noexport void delete_macro_formals(void);
cql_noexport bool_t set_macro_info(CSTR _Nonnull name, int32_t macro_type, ast_node *_Nonnull ast);
cql_noexport bool_t set_macro_arg_info(CSTR _Nonnull name, int32_t macro_type, ast_node *_Nonnull ast);
cql_noexport macro_info *_Nullable get_macro_arg_info(CSTR _Nonnull name);
cql_noexport macro_info *_Nullable get_macro_info(CSTR _Nonnull name);
cql_noexport void expand_macros(ast_node *_Nonnull root);
cql_noexport int32_t macro_arg_type(ast_node *_Nonnull macro_arg);
cql_noexport int32_t resolve_macro_name(CSTR _Nonnull name);
cql_noexport ast_node *_Nonnull new_macro_arg_node(ast_node *_Nonnull arg);
cql_noexport ast_node *_Nonnull new_macro_arg_ref_node(CSTR _Nonnull name);
cql_noexport ast_node *_Nonnull new_macro_ref_node(CSTR _Nonnull name, ast_node *_Nullable args);
cql_noexport CSTR _Nonnull macro_type_from_name(CSTR _Nonnull name);

// from the lexer
extern int yylineno;
cql_data_decl( char *_Nullable current_file );

cql_data_decl ( CSTR _Nullable base_fragment_name );

cql_data_decl( bool_t macro_expansion_errors );

cql_data_decl( minipool *_Nullable ast_pool );

#define _ast_pool_new(x) _pool_new(ast_pool, x)
#define _ast_pool_new_array(x, c) _pool_new_array(ast_pool, x, c)

// reset location to make sure it's not used by the next new nodes. If any
// new node is created without setting location then the app will crash.
#define AST_REWRITE_INFO_START() \
  ast_reset_rewrite_info()

// end reset location session and make sure SET and RESET were used in synced
#define AST_REWRITE_INFO_END() \
  Contract(!current_file && yylineno == -1)

// any new nodes will be charged to this location
#define AST_REWRITE_INFO_SET(lineno, filename) \
  Contract(!current_file && yylineno == -1); \
  ast_set_rewrite_info(lineno, filename)

// reset the location to make sure it's not used by the next new nodes
#define AST_REWRITE_INFO_RESET() \
  Contract(current_file && yylineno > 0); \
  ast_reset_rewrite_info()

// any new nodes will be charged to this location
#define AST_REWRITE_INFO_SAVE() \
  int32_t lineno_saved = yylineno; \
  CSTR current_file_saved = current_file; \
  ast_reset_rewrite_info()

// reset the location to make sure it's not used by the next new nodes
#define AST_REWRITE_INFO_RESTORE() \
  ast_set_rewrite_info(lineno_saved, current_file_saved);


cql_noexport void ast_set_rewrite_info(int32_t lineno, CSTR _Nonnull filename);
cql_noexport void ast_reset_rewrite_info(void);

cql_noexport void ast_init(void);
cql_noexport void ast_cleanup(void);

cql_noexport ast_node *_Nonnull new_ast(const char *_Nonnull type, ast_node *_Nullable l, ast_node *_Nullable r);
cql_noexport ast_node *_Nonnull new_ast_num(int32_t type, const char *_Nonnull value);
cql_noexport ast_node *_Nonnull new_ast_option(int32_t value);
cql_noexport ast_node *_Nonnull new_ast_str(CSTR _Nonnull value);
cql_noexport ast_node *_Nonnull new_ast_cstr(CSTR _Nonnull value);
cql_noexport ast_node *_Nonnull new_ast_qstr_escaped(CSTR _Nonnull value);
cql_noexport ast_node *_Nonnull new_ast_qstr_quoted(CSTR _Nonnull value);
cql_noexport ast_node *_Nonnull new_ast_blob(CSTR _Nonnull value);

cql_noexport bool_t is_ast_int(ast_node *_Nullable node);
cql_noexport bool_t is_ast_str(ast_node *_Nullable node);
cql_noexport bool_t is_ast_num(ast_node *_Nullable node);
cql_noexport bool_t is_ast_blob(ast_node *_Nullable node);

cql_noexport bool_t is_any_macro_ref(ast_node *_Nullable ast);
cql_noexport bool_t is_macro_def(ast_node *_Nonnull ast);
cql_noexport bool_t is_macro_ref(ast_node *_Nullable ast);
cql_noexport bool_t is_macro_arg_ref(ast_node *_Nullable ast);

cql_noexport bool_t is_select_variant(ast_node *_Nullable ast);
cql_noexport bool_t is_row_source(ast_node *_Nullable ast);
cql_noexport bool_t is_delete_stmt(ast_node *_Nullable ast);
cql_noexport bool_t is_insert_stmt(ast_node *_Nullable ast);
cql_noexport bool_t is_update_stmt(ast_node *_Nullable ast);
cql_noexport bool_t is_upsert_stmt(ast_node *_Nullable ast);

cql_noexport bool_t is_select_func(ast_node *_Nonnull ast);
cql_noexport bool_t is_non_select_func(ast_node *_Nonnull ast);

cql_noexport bool_t is_strlit(ast_node *_Nullable node);
cql_noexport bool_t is_id(ast_node *_Nullable node);
cql_noexport bool_t is_qname(CSTR _Nonnull subject);
cql_noexport bool_t is_qid(ast_node *_Nullable node);
cql_noexport bool_t is_id_or_dot(ast_node *_Nullable node);
cql_noexport bool_t is_primitive(ast_node *_Nullable  node);
cql_noexport bool_t is_proc(ast_node *_Nullable node);
cql_noexport bool_t is_region(ast_node *_Nonnull ast);

cql_noexport ast_node *_Nullable get_proc_params(ast_node *_Nonnull ast);
cql_noexport ast_node *_Nonnull get_proc_name(ast_node *_Nonnull ast);
cql_noexport ast_node *_Nullable get_func_params(ast_node *_Nonnull func_stmt);

cql_noexport bool_t ast_has_left(ast_node *_Nullable node);
cql_noexport bool_t ast_has_right(ast_node *_Nullable enode);

cql_noexport void ast_set_right(ast_node *_Nonnull parent, ast_node *_Nullable right);
cql_noexport void ast_set_left(ast_node *_Nonnull parent, ast_node *_Nullable left);

cql_noexport bool_t print_ast_value(struct ast_node *_Nonnull node);
cql_noexport void print_ast_type(ast_node *_Nonnull node);
cql_noexport void print_ast(ast_node *_Nullable node, ast_node *_Nullable parent, int32_t pad, bool_t flip);
cql_noexport void print_root_ast(ast_node *_Nullable node);

cql_noexport void ast_reset_rewrite_info(void);
cql_noexport ast_node *_Nullable ast_clone_tree(ast_node *_Nullable ast);
cql_noexport CSTR _Nonnull convert_cstrlit(CSTR _Nonnull cstr);

cql_noexport CSTR _Nonnull get_compound_operator_name(int32_t compound_operator);

#define INSERT_DUMMY_DEFAULTS 1
#define INSERT_DUMMY_NULLABLES 2

/*
  SQLite understands the following binary operators, in order from LOWEST to HIGHEST precedence:
  NOTE: this is NOT the C binding order (!!!)
  NOTE: this MUST match the tokens in cql.y
  PRI_OR
  PRI_AND
  PRI_EQUALITY =    ==   !=   <>   IS   IS NOT   IN   LIKE   GLOB   MATCH   REGEXP
  PRI_INEQUALITY <    <=   >    >=
  PRI_BINARY <<   >>   &    |
  PRI_ADD     +    -
  PRI_MUL     *    /    %
  PRI_CONCAT  ||
  PRI_TILDE ~
  PRI_REVERSE_APPLY : []
*/

#define has_hex_prefix(s) (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))

#define EXPR_PRI_ROOT -999
#define EXPR_PRI_ASSIGN 0
#define EXPR_PRI_OR 1
#define EXPR_PRI_AND 2
#define EXPR_PRI_NOT 3
#define EXPR_PRI_BETWEEN 5  // between is the same as equality, left to right
#define EXPR_PRI_EQUALITY 5
#define EXPR_PRI_INEQUALITY 6
#define EXPR_PRI_BINARY 7
#define EXPR_PRI_ADD 8
#define EXPR_PRI_MUL 9
#define EXPR_PRI_CONCAT 10
#define EXPR_PRI_COLLATE 11
#define EXPR_PRI_TILDE 12
#define EXPR_PRI_REVERSE_APPLY 13

/* from the SQLite grammar

%left OR.
%left AND.
%right NOT.
%left IS MATCH LIKE_KW BETWEEN IN ISNULL NOTNULL NE EQ.
%left GT LE LT GE.
%right ESCAPE.    NYI in CQL
%left BITAND BITOR LSHIFT RSHIFT.
%left PLUS MINUS.
%left STAR SLASH REM.
%left CONCAT.
%left COLLATE.
%right BITNOT.

*/

// relevant C binding order
#define C_EXPR_PRI_ROOT -999
#define C_EXPR_PRI_ASSIGN 0
#define C_EXPR_PRI_LOR 1
#define C_EXPR_PRI_LAND 2
#define C_EXPR_PRI_BOR  3
#define C_EXPR_PRI_BAND 4
#define C_EXPR_PRI_EQ_NE 5
#define C_EXPR_PRI_LT_GT 6
#define C_EXPR_PRI_SHIFT 7
#define C_EXPR_PRI_ADD 8
#define C_EXPR_PRI_MUL 9
#define C_EXPR_PRI_UNARY 10
#define C_EXPR_PRI_HIGHEST 999

#define JOIN_INNER 1
#define JOIN_CROSS 2
#define JOIN_LEFT_OUTER 3
#define JOIN_RIGHT_OUTER 4
#define JOIN_LEFT 5
#define JOIN_RIGHT 6

#define EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, stmt_list) \
  Contract(is_ast_stmt_list(stmt_list)); \
  ast_node *stmt = stmt_list->left; \
  ast_node *misc_attrs = NULL; \
  if (is_ast_stmt_and_attr(stmt)) { \
    misc_attrs = stmt->left; \
    stmt = stmt->right; \
    Contract(is_ast_misc_attrs(misc_attrs)); \
  }

#define EXTRACT_STMT(stmt, stmt_list) \
  Contract(is_ast_stmt_list(stmt_list)); \
  ast_node *stmt = stmt_list->left; \
  if (is_ast_stmt_and_attr(stmt)) { \
    stmt = stmt->right; \
  }

// Use this macro from within a single node processor to reach out and get the attributes that apply to that
// node, which would be hanging off the parent ast node, if present.
#define EXTRACT_MISC_ATTRS(ast, misc_attrs) \
  ast_node *misc_attrs = NULL; \
  if (is_ast_stmt_and_attr(ast->parent)) { \
    misc_attrs = ast->parent->left; \
    Contract(is_ast_misc_attrs(misc_attrs)); \
  }

#define EXTRACT_ANY(name, node) \
  ast_node *name = node;

#define EXTRACT_ANY_NOTNULL(name, node) \
  ast_node *name = node; \
  Contract(node);

#define EXTRACT_NAMED(name, type, node) \
  ast_node *name = node; \
  Contract(!name || is_ast_##type(name));

#define EXTRACT_NAMED_NOTNULL(name, type, node) \
  ast_node *name = node; \
  Contract(name && is_ast_##type(name));

#define EXTRACT(type, node) EXTRACT_NAMED(type, type, node)

#define EXTRACT_NOTNULL(type, node) EXTRACT_NAMED_NOTNULL(type, type, node)

#define EXTRACT_STRING(name, node) \
  Contract(is_ast_str(node)); \
  const char *name = ((str_ast_node *)(node))->value; \
  Contract(name);

#define EXTRACT_NAME_AST(name_ast, node) \
  Contract(is_id(node) || is_ast_at_id(node)); \
  ast_node *name_ast = (node);

#define EXTRACT_BLOBTEXT(name, node) \
  Contract(is_ast_blob(node)); \
  const char *name = ((str_ast_node *)(node))->value; \
  Contract(name);

#define EXTRACT_NUM_TYPE(num_type, node) \
  Contract(is_ast_num(node)); \
  int32_t num_type = ((num_ast_node *)(node))->num_type;

#define EXTRACT_NUM_VALUE(val, node) \
  Contract(is_ast_num(node)); \
  CSTR val = ((num_ast_node *)(node))->value; \
  Contract(val);

#define EXTRACT_OPTION(name, node) \
  Contract(is_ast_int(node)); \
  int32_t name = (int32_t)((int_ast_node *)(node))->value;

#define EXTRACT_NAMED_NAME_AND_SCOPE(name, scope, node) \
  Contract(is_id_or_dot(node)); \
  CSTR name, scope; \
  if (is_id(node)) { \
    name = ((str_ast_node *)(node))->value; \
    scope = NULL; \
  } \
   else { \
    name = ((str_ast_node *)(node->right))->value; \
    scope = ((str_ast_node *)(node->left))->value; \
  }

#define EXTRACT_NAME_AND_SCOPE(node) \
  EXTRACT_NAMED_NAME_AND_SCOPE(name, scope, node)

// For searching proc dependencies/attributes
typedef void (*find_ast_str_node_callback)(CSTR _Nonnull found_name, ast_node *_Nonnull str_ast, void *_Nullable context);
typedef void (*find_ast_num_node_callback)(CSTR _Nonnull found_name, ast_node *_Nonnull num_ast, void *_Nullable context);

typedef struct table_callbacks {
  bool_t notify_table_or_view_drops;
  bool_t notify_fk;
  bool_t notify_triggers;
  bool_t do_not_recurse_views;
  symtab *_Nullable visited_any_table;
  symtab *_Nullable visited_insert;
  symtab *_Nullable visited_update;
  symtab *_Nullable visited_delete;
  symtab *_Nullable visited_from;
  symtab *_Nullable visited_proc;
  find_ast_str_node_callback _Nullable callback_any_table;
  find_ast_str_node_callback _Nullable callback_any_view;
  find_ast_str_node_callback _Nullable callback_inserts;
  find_ast_str_node_callback _Nullable callback_updates;
  find_ast_str_node_callback _Nullable callback_deletes;
  find_ast_str_node_callback _Nullable callback_from;
  find_ast_str_node_callback _Nullable callback_proc;
  void (*_Nullable callback_final_processing)(void *_Nullable callback_context);
  void *_Nullable callback_context;
} table_callbacks;

cql_noexport void find_table_refs(table_callbacks *_Nonnull data, ast_node *_Nonnull node);
cql_noexport void continue_find_table_node(table_callbacks *_Nonnull callbacks, ast_node *_Nonnull node);


// Signature of function finding annotation values
typedef uint32_t (*find_annotation_values)(
    ast_node *_Nullable misc_attr_list,
    find_ast_str_node_callback _Nonnull callback,
    void *_Nullable callback_context);

cql_noexport uint32_t find_ok_table_scan(
   ast_node *_Nonnull list,
   find_ast_str_node_callback _Nonnull callback,
   void *_Nullable context);

cql_noexport uint32_t find_autodrops(
   ast_node *_Nonnull list,
   find_ast_str_node_callback _Nonnull callback,
   void *_Nullable context);

cql_noexport uint32_t find_identity_columns(
  ast_node *_Nullable misc_attr_list,
  find_ast_str_node_callback _Nonnull callback,
  void *_Nullable callback_context);

cql_noexport uint32_t find_cql_alias_of(
  ast_node *_Nonnull misc_attr_list,
  find_ast_str_node_callback _Nonnull callback,
  void *_Nullable context
);

cql_noexport uint32_t find_attribute_str(
  ast_node *_Nonnull misc_attr_list,
  find_ast_str_node_callback _Nullable callback,
  void *_Nullable context,
  const char *_Nonnull attribute_name);

cql_noexport uint32_t exists_attribute_str(
  ast_node *_Nullable misc_attr_list,
  const char *_Nonnull attribute_name);

cql_noexport uint32_t find_backed_table_attr(ast_node *_Nonnull misc_attr_list);
cql_noexport uint32_t find_backing_table_attr(ast_node *_Nonnull misc_attr_list);

cql_noexport CSTR _Nullable get_named_string_attribute_value(ast_node *_Nonnull misc_attr_list, CSTR _Nonnull name);
cql_noexport bool_t find_named_attr(ast_node *_Nonnull misc_attr_list, CSTR _Nonnull name);

cql_noexport uint32_t find_query_plan_branch(
  ast_node *_Nonnull list,
  find_ast_num_node_callback _Nonnull callback,
  void *_Nullable context
);

cql_noexport bool_t is_table_blob_storage(ast_node *_Nonnull ast);
cql_noexport bool_t is_table_backing(ast_node *_Nonnull ast);
cql_noexport bool_t is_table_backed(ast_node *_Nonnull ast);

// Callback whenever a misc_attr node is found in find_misc_attrs().
typedef void (*find_ast_misc_attr_callback)(
  CSTR _Nullable misc_attr_prefix,
  CSTR _Nonnull misc_attr_name,
  ast_node *_Nullable ast_misc_attr_value_list,
  void *_Nullable context);

cql_noexport void find_misc_attrs(
  ast_node *_Nullable misc_attr_list,
  find_ast_misc_attr_callback _Nonnull misc_attr_callback,
  void *_Nullable context);

cql_noexport size_t ends_in_cursor(CSTR _Nonnull str);
cql_noexport size_t ends_in_set(CSTR _Nonnull str);

cql_noexport void replace_node(ast_node *_Nonnull old, ast_node *_Nonnull new);

#ifdef CQL_AMALGAM

  // In the amalgam build we see this file only once, we emit the definitions as statics
  // AST_EMIT_DEFS is irrelevant in this mode.  This is the easy case.

  #define AST_VIS static
  #define AST_DATA_DECL(x)
  #define AST_DATA_DEFN(x) AST_VIS x
  #define AST_DEF(x) x

#else

  // In the non amalgam build we need the ".h" version that declares things
  // except one time the ".c" version that defines things.  This is the hard case.

  #ifdef AST_EMIT_DEFS
    #define AST_DEF(x) x
  #else
    #define AST_DEF(x)
  #endif

  #define AST_VIS extern
  #define AST_DATA_DECL(x) AST_VIS x
  #define AST_DATA_DEFN(x) AST_DEF(x)

#endif

AST_DATA_DECL( CSTR _Nonnull k_ast_int );
AST_DATA_DECL( CSTR _Nonnull k_ast_num );
AST_DATA_DECL( CSTR _Nonnull k_ast_str );
AST_DATA_DECL( CSTR _Nonnull k_ast_blob );

AST_DATA_DEFN( CSTR _Nonnull k_ast_int = "int" );
AST_DATA_DEFN( CSTR _Nonnull k_ast_num = "num" );
AST_DATA_DEFN( CSTR _Nonnull k_ast_str = "str" );
AST_DATA_DEFN( CSTR _Nonnull k_ast_blob = "blb" );

#define AST_DECL_CHECK(x) \
  AST_DATA_DECL(const char *_Nonnull k_ast_ ## x;) \
  AST_DATA_DEFN(const char *_Nonnull k_ast_ ## x = #x;) \
  AST_VIS bool_t is_ast_ ## x(ast_node *_Nullable n); \
  AST_DEF(AST_VIS  bool_t is_ast_ ## x(ast_node *_Nullable n) {return n && (n->type == k_ast_ ## x);  })

#define AST(x) \
  AST_DECL_CHECK(x) \
  AST_VIS ast_node *_Nonnull new_ast_ ## x(ast_node *_Nullable l, ast_node *_Nullable r); \
  AST_DEF(AST_VIS ast_node *_Nonnull new_ast_ ## x(ast_node *_Nullable l, ast_node *_Nullable r) { return new_ast(k_ast_ ## x, l, r); })

#define AST1(x) \
  AST_DECL_CHECK(x) \
  AST_VIS ast_node *_Nonnull new_ast_ ## x(ast_node *_Nullable l); \
  AST_DEF(AST_VIS ast_node *_Nonnull new_ast_ ## x(ast_node *_Nullable l) { return new_ast(k_ast_ ## x, l, NULL); })

#define AST0(x) \
  AST_DECL_CHECK(x) \
  AST_VIS ast_node *_Nonnull new_ast_ ## x(void); \
  AST_DEF(AST_VIS ast_node *_Nonnull new_ast_ ## x() { return new_ast(k_ast_ ## x, NULL, NULL); })

#ifndef _MSC_VER

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

#endif

AST(add)
AST(add_eq)
AST(alter_table_add_column_stmt)
AST(and)
AST(and_eq)
AST(arg_list)
AST(array)
AST(assign)
AST(autoinc_and_conflict_clause)
AST(between)
AST(between_rewrite)
AST(bin_and)
AST(bin_or)
AST(call)
AST(call_arg_list)
AST(call_filter_clause)
AST(call_stmt)
AST(case_expr)
AST(case_list)
AST(cast_expr)
AST(check_def)
AST(child_result)
AST(child_results)
AST(col_attrs_check)
AST(col_attrs_collate)
AST(col_attrs_default)
AST(col_attrs_fk)
AST(col_attrs_hidden)
AST(col_attrs_not_null)
AST(col_attrs_pk)
AST(col_attrs_unique)
AST(col_calc)
AST(col_calcs)
AST(col_def)
AST(col_def_name_type)
AST(col_def_type_attrs)
AST(col_key_list)
AST(collate)
AST(column_calculation)
AST(columns_values);
AST(concat);
AST(cond_action)
AST(conflict_target)
AST(connector)
AST(const_stmt)
AST(const_value)
AST(const_values)
AST(create_attr)
AST(create_index_on_list)
AST(create_index_stmt)
AST(create_proc_stmt)
AST(create_table_name_flags)
AST(create_table_stmt)
AST(create_trigger_stmt)
AST(create_view_stmt)
AST(create_virtual_table_stmt)
AST(cte_binding)
AST(cte_binding_list)
AST(cte_decl)
AST(cte_table)
AST(cte_tables)
AST(cte_tables_macro_def)
AST(cte_tables_macro_ref)
AST(declare_const_stmt)
AST(declare_cursor)
AST(declare_cursor_like_name)
AST(declare_cursor_like_select)
AST(declare_cursor_like_typed_names)
AST(declare_deployable_region_stmt);
AST(declare_enum_stmt)
AST(declare_func_no_check_stmt)
AST(declare_func_stmt)
AST(declare_group_stmt)
AST(declare_interface_stmt)
AST(declare_named_type)
AST(declare_proc_stmt)
AST(declare_schema_region_stmt);
AST(declare_select_func_no_check_stmt)
AST(declare_select_func_stmt)
AST(declare_value_cursor)
AST(declare_vars_type)
AST(delete_attr)
AST(delete_returning_stmt)
AST(delete_stmt)
AST(div)
AST(div_eq)
AST(dot)
AST(drop_index_stmt)
AST(drop_table_stmt)
AST(drop_trigger_stmt)
AST(drop_view_stmt)
AST(echo_stmt)
AST(elseif)
AST(enum_value)
AST(enum_values)
AST(eq)
AST(explain_stmt)
AST(expr_assign)
AST(expr_list)
AST(expr_macro_def)
AST(expr_macro_ref)
AST(expr_name)
AST(expr_names)
AST(fetch_call_stmt)
AST(fetch_stmt)
AST(fetch_values_stmt)
AST(fk_def)
AST(fk_info)
AST(fk_target)
AST(fk_target_options)
AST(flags_names_attrs)
AST(for_stmt)
AST(for_info)
AST(frame_boundary)
AST(frame_boundary_end)
AST(frame_boundary_opts)
AST(frame_boundary_start)
AST(from_shape);
AST(func_params_return)
AST(ge)
AST(glob)
AST(groupby_list)
AST(gt)
AST(guard_stmt)
AST(if_alt)
AST(if_stmt)
AST(ifdef_stmt)
AST(ifndef_stmt)
AST(in_pred)
AST(index_names_and_attrs)
AST(indexed_column)
AST(indexed_columns)
AST(indexed_columns_conflict_clause)
AST(insert_dummy_spec);
AST(insert_list)
AST(insert_returning_stmt)
AST(insert_stmt)
AST(is)
AST(is_not)
AST(jex1)
AST(jex2)
AST(join_clause)
AST(join_cond)
AST(join_target)
AST(join_target_list)
AST(le)
AST(let_stmt)
AST(like)
AST(loop_stmt)
AST(ls_eq)
AST(lshift)
AST(lt)
AST(macro_args)
AST(macro_formal)
AST(macro_formals)
AST(macro_name_formals)
AST(match)
AST(misc_attr)
AST(misc_attr_value_list)
AST(misc_attrs)
AST(mod)
AST(mod_eq)
AST(module_info)
AST(mul)
AST(mul_eq)
AST(name_columns_values);
AST(name_list)
AST(named_result)
AST(ne)
AST(not_between)
AST(not_glob)
AST(not_in)
AST(not_like)
AST(not_match)
AST(not_regexp)
AST(op_stmt)
AST(op_vals)
AST(opt_frame_spec)
AST(or)
AST(or_eq)
AST(orderby_item)
AST(orderby_list)
AST(out_union_parent_child_stmt)
AST(param)
AST(param_detail)
AST(params)
AST(pk_def)
AST(pre)
AST(proc_name_type)
AST(proc_params_stmts)
AST(query_parts_macro_def)
AST(query_parts_macro_ref)
AST(raise);
AST(range)
AST(recreate_attr)
AST(regexp)
AST(region_list);
AST(region_spec);
AST(reverse_apply)
AST(reverse_apply_poly_args)
AST(rs_eq)
AST(rshift)
AST(schema_ad_hoc_migration_stmt);
AST(seed_stub)
AST(select_core)
AST(select_core_compound)
AST(select_core_list)
AST(select_core_macro_def)
AST(select_core_macro_ref)
AST(select_expr)
AST(select_expr_list)
AST(select_expr_list_con)
AST(select_expr_macro_def)
AST(select_expr_macro_ref)
AST(select_from_etc)
AST(select_groupby)
AST(select_having)
AST(select_if_nothing_expr)
AST(select_if_nothing_or_null_expr)
AST(select_limit)
AST(select_offset)
AST(select_orderby)
AST(select_stmt)
AST(select_where)
AST(sensitive_attr);
AST(set_from_cursor)
AST(shape_def)
AST(shape_expr)
AST(shape_exprs)
AST(shared_cte)
AST(stmt_and_attr)
AST(stmt_list)
AST(stmt_list_macro_def)
AST(stmt_list_macro_ref);
AST(str_chain)
AST(sub)
AST(sub_eq)
AST(switch_body);
AST(switch_case);
AST(switch_stmt);
AST(table_flags_attrs);
AST(table_function);
AST(table_join);
AST(table_or_subquery);
AST(table_or_subquery_list);
AST(text_args);
AST(trigger_action);
AST(trigger_body_vers);
AST(trigger_condition);
AST(trigger_def);
AST(trigger_op_target);
AST(trigger_operation);
AST(trigger_target_action);
AST(trigger_when_stmts);
AST(trycatch_stmt)
AST(type_check_expr)
AST(typed_name)
AST(typed_names)
AST(unknown_macro_arg)
AST(unknown_macro_ref)
AST(unknown_macro_def)
AST(unq_def)
AST(update_cursor_stmt)
AST(update_entry)
AST(update_from)
AST(update_list)
AST(update_orderby)
AST(update_set)
AST(update_returning_stmt)
AST(update_stmt)
AST(update_where)
AST(upsert_returning_stmt)
AST(upsert_stmt)
AST(upsert_update)
AST(values)
AST(version_annotation)
AST(view_and_attrs)
AST(view_details)
AST(view_details_select)
AST(when)
AST(while_stmt)
AST(window_defn)
AST(window_defn_orderby)
AST(window_func_inv)
AST(window_name_defn)
AST(window_name_defn_list)
AST(with_delete_stmt)
AST(with_insert_stmt)
AST(with_select_stmt)
AST(with_update_stmt)
AST(with_upsert_stmt)
AST0(all)
AST0(col_attrs_autoinc)
AST0(commit_return_stmt);
AST0(commit_trans_stmt);
AST0(continue_stmt)
AST0(default_columns_values);
AST0(distinct)
AST0(distinctrow)
AST0(end_schema_region_stmt);
AST0(enforce_pop_stmt);
AST0(enforce_push_stmt);
AST0(enforce_reset_stmt);
AST0(following)
AST0(in)
AST0(inout)
AST0(insert_normal);
AST0(insert_or_abort);
AST0(insert_or_fail);
AST0(insert_or_ignore);
AST0(insert_or_replace);
AST0(insert_or_rollback);
AST0(insert_replace);
AST0(keep_table_name_in_aliases_stmt)
AST0(leave_stmt)
AST0(null)
AST0(nullsfirst)
AST0(nullslast)
AST0(on)
AST0(out)
AST0(previous_schema_stmt);
AST0(return_stmt)
AST0(rollback_return_stmt);
AST0(schema_upgrade_script_stmt);
AST0(select_nothing_stmt)
AST0(select_values)
AST0(star)
AST0(throw_stmt)
AST0(type_cursor)
AST0(using)
AST1(asc)
AST1(at_id);
AST1(begin_schema_region_stmt);
AST1(begin_trans_stmt);
AST1(close_stmt)
AST1(column_spec);
AST1(const)
AST1(create_data_type);
AST1(cte_tables_macro_arg);
AST1(cte_tables_macro_arg_ref)
AST1(declare_out_call_stmt)
AST1(declare_proc_no_check_stmt)
AST1(desc)
AST1(else)
AST1(emit_constants_stmt)
AST1(emit_enums_stmt)
AST1(emit_group_stmt)
AST1(enforce_normal_stmt);
AST1(enforce_strict_stmt);
AST1(exists_expr)
AST1(expr_macro_arg)
AST1(expr_macro_arg_ref)
AST1(expr_stmt)
AST1(groupby_item)
AST1(is_false)
AST1(is_not_false)
AST1(is_not_true)
AST1(is_true)
AST1(macro_text)
AST1(not)
AST1(notnull);
AST1(opt_as_alias)
AST1(opt_filter_clause)
AST1(opt_groupby)
AST1(opt_having)
AST1(opt_limit)
AST1(opt_offset)
AST1(opt_orderby)
AST1(opt_partition_by)
AST1(opt_select_window)
AST1(opt_where)
AST1(out_stmt)
AST1(out_union_stmt)
AST1(proc_savepoint_stmt);
AST1(query_parts_macro_arg);
AST1(query_parts_macro_arg_ref)
AST1(release_savepoint_stmt);
AST1(rollback_trans_stmt);
AST1(savepoint_stmt);
AST1(schema_unsub_stmt);
AST1(schema_upgrade_version_stmt);
AST1(select_core_macro_arg);
AST1(select_core_macro_arg_ref)
AST1(select_expr_macro_arg);
AST1(select_expr_macro_arg_ref)
AST1(select_if_nothing_throw_expr)
AST1(select_if_nothing_or_null_throw_expr)
AST1(select_opts)
AST1(stmt_list_macro_arg);
AST1(stmt_list_macro_arg_ref);
AST1(table_star)
AST1(tilde)
AST1(type_blob)
AST1(type_bool)
AST1(type_int)
AST1(type_long)
AST1(type_object)
AST1(type_real)
AST1(type_text)
AST1(uminus)
AST1(unknown_macro_arg_ref)
AST1(window_clause)
AST1(with)
AST1(with_recursive)

#ifndef _MSC_VER
#pragma clang diagnostic pop
#endif/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


typedef uint64_t sem_t;

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// minimal stuff goes here

cql_noexport void sem_main(ast_node *node);
cql_noexport void sem_cleanup(void);
cql_noexport void print_sem_type(struct sem_node *sem);

#else


//
// The key semantic type information
//
// The rules:
//   * if sem_type is STRUCT then sptr is not null
//   * if sem_type is JOIN then jptr is not null
//   * if node is on a table or a view element, which is a STRUCT
//     then jptr is also not null as an optimization
//   * in all other cases neither is populated
//
// Tables and Views have both their sptr and jptr filled out
// because the first thing you're going to do with a table/view is
// join it to something and so the base case of a 1 table join happens
// all the time.  To make this easier that jptr is pre-populated as
// an optimization.
//

// @lint-ignore-every LINEWRAP

#define sem_not(x) u64_not(x)

typedef struct table_node {
  int64_t type_hash;                // if the type has hash code, this will be it
  list_item *index_list;            // the list of indices that use this table (so we can recreate them together if needed)
  int16_t key_count;                // number of key columns
  int16_t *key_cols;                // the key column indices (ast allocated)
  int16_t notnull_count;            // number of notnull columns
  int16_t *notnull_cols;            // the notnull column indices (ast allocated)
  int16_t value_count  ;            // number of value (non-key) columns
  int16_t *value_cols;              // the non-key column indices (ast allocated)
} table_node;

typedef struct sem_node {
  sem_t sem_type;                   // core type plus flags
  CSTR name;                        // for named expressions in select columns etc.
  CSTR kind;                        // the Foo in object<Foo>, not a variable or column name
  CSTR error;                       // error text for test output, not used otherwise
  CSTR backed_table;                // if this is a column in a backed table, the name of that table
  struct sem_struct *sptr;          // encoded struct if any
  struct sem_join *jptr;            // encoded join if any
  int32_t create_version;           // create version if any (really only for tables and columns)
  int32_t delete_version;           // delete version if any (really only for tables and columns)
  bool_t unsubscribed;              // true if unsubscribed (applies only to tables or views)
  bool_t recreate;                  // for tables only, true if marked @recreate
  CSTR recreate_group_name;         // for tables only, the name of the recreate group if they are in one
  CSTR region;                      // the schema region, if applicable; null means unscoped (default)
  symtab *used_symbols;             // for select statements, we need to know which of the ids in the select list was used, if any
  struct eval_node *value;          // for enum values we have to store the evaluated constant value of each member of the enum
  table_node *table_info;           // extra info unique to tables (above)
} sem_node;

// for tables and views and the result of a select

typedef struct sem_struct {
  CSTR struct_name;               // struct name
  uint32_t count;                 // count of fields
  CSTR *names;                    // field names
  CSTR *kinds;                    // the "kind" text of each column, if any, e.g. integer<foo> foo is the kind
  sem_t *semtypes;                // typecode for each field
  bool_t is_backed;               // original backed table source
} sem_struct;

// for the data type of (parts of) the FROM clause
// sometimes I refer to as a "joinscope"

typedef struct sem_join {
  uint32_t count;                 // count of table/views in the join
  CSTR *names;                    // names of the table/view
  struct sem_struct **tables;     // struct type of each table/view
} sem_join;

typedef struct recreate_annotation {
  CSTR target_name;               // the name of the target
  CSTR group_name;                // group name or "" if no group (not null, safe to sort)
  ast_node *target_ast;           // top level target (table, view, or index)
  ast_node *annotation_ast;       // the actual annotation
  int32_t ordinal;                // when sorting we want to use the original order (reversed actually) within a group
  int32_t group_ordinal;          // when sorting we want to use the group ordinal that we will obtain from a topological sort on recreate group dependency tree
} recreate_annotation;

typedef struct schema_annotation {
  int32_t ordinal;                // this will be the original annotation order
  int32_t version;                // the version number (always > 0)
  ast_node *target_ast;           // top level target (table, view, or index)
  CSTR target_name;               // the name of the target
  uint32_t annotation_type;       // one of the codes below for the type of annotation
  ast_node *annotation_ast;       // the actual annotation
  int32_t column_ordinal;         // -1 if not a column
  ast_node *column_ast;           // a particular column if column annotation
} schema_annotation;

// Note: schema annotations are processed in the indicated order: the numbers matter!
#define SCHEMA_ANNOTATION_INVALID 0
#define SCHEMA_ANNOTATION_FIRST 1
#define SCHEMA_ANNOTATION_UNSUB 1
#define SCHEMA_ANNOTATION_CREATE_TABLE 2
#define SCHEMA_ANNOTATION_CREATE_COLUMN 3
#define SCHEMA_ANNOTATION_DELETE_TRIGGER 4
#define SCHEMA_ANNOTATION_DELETE_VIEW 5
#define SCHEMA_ANNOTATION_DELETE_INDEX 6
#define SCHEMA_ANNOTATION_DELETE_COLUMN 7
#define SCHEMA_ANNOTATION_DELETE_TABLE 8
#define SCHEMA_ANNOTATION_AD_HOC 9
#define SCHEMA_ANNOTATION_LAST 9

#define SEM_TYPE_NULL 0         // the subtree is a null literal (not just nullable)
#define SEM_TYPE_BOOL 1         // the subtree is a bool
#define SEM_TYPE_INTEGER 2      // the subtree is an integer
#define SEM_TYPE_LONG_INTEGER 3 // the subtree is a long_integer
#define SEM_TYPE_REAL 4         // the subtree is a real
#define SEM_TYPE_TEXT 5         // the subtree is a text type
#define SEM_TYPE_BLOB 6         // the subtree is a blob type
#define SEM_TYPE_OBJECT 7       // the subtree is any object type
#define SEM_TYPE_STRUCT 8       // the subtree is a table/view
#define SEM_TYPE_JOIN 9         // the subtree is a join
#define SEM_TYPE_ERROR 10       // marks the subtree as having a problem
#define SEM_TYPE_OK 11          // sentinel for ok but no type info
#define SEM_TYPE_PENDING 12     // sentinel for type calculation in flight
#define SEM_TYPE_REGION 13      // the ast is a schema region
#define SEM_TYPE_CURSOR_FORMAL 14 // this is used for the cursor parameter type uniquely
#define SEM_TYPE_CORE 0xff      // bit mask for the core types

#define SEM_TYPE_MAX_UNITARY (SEM_TYPE_OBJECT+1) // the last unitary type

#define SEM_TYPE_NOTNULL               _64(0x0100) // set if and only if null is not possible
#define SEM_TYPE_HAS_DEFAULT           _64(0x0200) // set for table columns with a default
#define SEM_TYPE_AUTOINCREMENT         _64(0x0400) // set for table columns with autoinc
#define SEM_TYPE_VARIABLE              _64(0x0800) // set for variables and parameters
#define SEM_TYPE_IN_PARAMETER          _64(0x1000) // set for in parameters (can mix with below)
#define SEM_TYPE_OUT_PARAMETER         _64(0x2000) // set for out parameters (can mix with above)
#define SEM_TYPE_DML_PROC              _64(0x4000) // set for stored procs that have DML/DDL
#define SEM_TYPE_HAS_SHAPE_STORAGE     _64(0x8000) // set for a cursor with simplified fetch syntax
#define SEM_TYPE_CREATE_FUNC          _64(0x10000) // set for a function that returns a created object +1 ref
#define SEM_TYPE_SELECT_FUNC          _64(0x20000) // set for a sqlite UDF function declaration
#define SEM_TYPE_DELETED              _64(0x40000) // set for columns that are not visible in the current schema version
#define SEM_TYPE_VALIDATED            _64(0x80000) // set if item has already been validated against previous schema
#define SEM_TYPE_USES_OUT            _64(0x100000) // set if proc has a one rowresult using the OUT statement
#define SEM_TYPE_USES_OUT_UNION      _64(0x200000) // set if proc uses the OUT UNION form for multi row result
#define SEM_TYPE_PK                  _64(0x400000) // set if column is a primary key
#define SEM_TYPE_FK                  _64(0x800000) // set if column is a foreign key
#define SEM_TYPE_UK                 _64(0x1000000) // set if column is a unique key
#define SEM_TYPE_VALUE_CURSOR       _64(0x2000000) // set only if SEM_TYPE_HAS_SHAPE_STORAGE is set and the cursor has no statement
#define SEM_TYPE_SENSITIVE          _64(0x4000000) // set if the object is privacy sensitive
#define SEM_TYPE_DEPLOYABLE         _64(0x8000000) // set if the object is a deployable region
#define SEM_TYPE_BOXED             _64(0x10000000) // set if a cursor's lifetime is managed by a box object
#define SEM_TYPE_HAS_CHECK         _64(0x20000000) // set for table column with a "check" clause
#define SEM_TYPE_HAS_COLLATE       _64(0x40000000) // set for table column with a "collate" clause
#define SEM_TYPE_INFERRED_NOTNULL  _64(0x80000000) // set if inferred to not be nonnull (but was originally nullable)
#define SEM_TYPE_VIRTUAL          _64(0x100000000) // set if and only if this is a virtual table
#define SEM_TYPE_HIDDEN_COL       _64(0x200000000) // set if and only if hidden column on a virtual table
#define SEM_TYPE_TVF              _64(0x400000000) // set if and only table node is a table valued function
#define SEM_TYPE_IMPLICIT         _64(0x800000000) // set if and only the variable was declare implicitly (via declare out)
#define SEM_TYPE_CALLS_OUT_UNION _64(0x1000000000) // set if proc calls an out union proc for a result
#define SEM_TYPE_ALIAS           _64(0x2000000000) // set only for aliases of a select when analyzing its where clause
#define SEM_TYPE_INIT_REQUIRED   _64(0x4000000000) // set for variables that require initialization before use
#define SEM_TYPE_INIT_COMPLETE   _64(0x8000000000) // set when SEM_TYPE_INIT_REQUIRED is present to indicate initialization
#define SEM_TYPE_INLINE_CALL    _64(0x10000000000) // set when a proc_as_func call in SQL can be executed safely by inlining the SQL
#define SEM_TYPE_SERIALIZE      _64(0x20000000000) // set when a cursor will need serialization features
#define SEM_TYPE_HAS_ROW        _64(0x40000000000) // set on auto cursors to indicate that they are known to have a row
#define SEM_TYPE_FETCH_INTO     _64(0x80000000000) // set if the cursor is used with fetch into
#define SEM_TYPE_WAS_SET       _64(0x100000000000) // set on in args if they are set (hence we own the value)
#define SEM_TYPE_BACKING       _64(0x200000000000) // set on tables that are used for backing store
#define SEM_TYPE_BACKED        _64(0x400000000000) // set on tables/exprs that have a backing store
#define SEM_TYPE_PARTIAL_PK    _64(0x800000000000) // set if column is a primary key
#define SEM_TYPE_QID          _64(0x1000000000000) // set if column has a `quoted` name
#define SEM_TYPE_CONSTANT     _64(0x2000000000000) // set for variables marked immutable and cannot be reassigned
#define SEM_TYPE_FLAGS        _64(0x3FFFFFFFFFF00) // all the flag bits we have so far

// All `sem_try_resolve_*` functions return either `SEM_RESOLVE_CONTINUE` to
// indicate that another resolver should be tried, or `SEM_RESOLVE_STOP` to
// indicate that the correct resolver was found. Continuing implies that no
// failure has (yet) occurred, but stopping implies neither success nor failure.
typedef enum {
  SEM_RESOLVE_CONTINUE = 0,
  SEM_RESOLVE_STOP = 1
} sem_resolve;

cql_noexport sem_t core_type_of(sem_t sem_type);
cql_noexport sem_t sensitive_flag(sem_t sem_type);
cql_noexport CSTR coretype_string(sem_t sem_type);

cql_noexport bool_t is_virtual_ast(ast_node *ast);
cql_noexport bool_t is_deleted(ast_node *ast);
cql_noexport bool_t is_single_flag(sem_t sem_type);
cql_noexport bool_t is_bool(sem_t sem_type);
cql_noexport bool_t is_real(sem_t sem_type);
cql_noexport bool_t is_string_compat(sem_t sem_type);
cql_noexport bool_t is_blob_compat(sem_t sem_type);
cql_noexport bool_t is_object_compat(sem_t sem_type);
cql_noexport bool_t is_create_func(sem_t sem_type);
cql_noexport bool_t is_long(sem_t sem_type);
cql_noexport bool_t is_any_int(sem_t sem_type);
cql_noexport bool_t is_numeric(sem_t sem_type);
cql_noexport bool_t is_numeric_compat(sem_t sem_type);
cql_noexport bool_t is_numeric_expr(ast_node *expr);
cql_noexport bool_t is_unitary(sem_t sem_type);
cql_noexport bool_t is_struct(sem_t sem_type);
cql_noexport bool_t is_cursor(sem_t sem_type);
cql_noexport bool_t is_auto_cursor(sem_t sem_type);
cql_noexport bool_t is_primary_key(sem_t sem_type);
cql_noexport bool_t is_partial_pk(sem_t sem_type);
cql_noexport bool_t is_foreign_key(sem_t sem_type);
cql_noexport bool_t is_sem_error(sem_node *sem);
cql_noexport bool_t is_error(ast_node *ast);
cql_noexport bool_t is_not_nullable(sem_t sem_type);
cql_noexport bool_t is_variable(sem_t sem_type);
cql_noexport bool_t is_in_parameter(sem_t sem_type);
cql_noexport bool_t is_out_parameter(sem_t sem_type);
cql_noexport bool_t is_cursor_formal(sem_t sem_type);
cql_noexport bool_t was_set_variable(sem_t sem_type);
cql_noexport bool_t is_backing(sem_t sem_type);
cql_noexport bool_t is_backed(sem_t sem_type);
cql_noexport bool_t is_inout_parameter(sem_t sem_type);
cql_noexport bool_t is_dml_proc(sem_t sem_type);
cql_noexport bool_t is_text(sem_t sem_type);
cql_noexport bool_t is_blob(sem_t sem_type);
cql_noexport bool_t is_object(sem_t sem_type);
cql_noexport bool_t is_ref_type(sem_t sem_type);
cql_noexport bool_t is_inferred_notnull(sem_t sem_type);
cql_noexport bool_t is_nullable(sem_t sem_type);
cql_noexport bool_t is_null_type(sem_t sem_type);
cql_noexport bool_t is_constant(sem_t sem_type);
cql_noexport bool_t has_result_set(ast_node *ast);
cql_noexport bool_t has_out_stmt_result(ast_node *ast);
cql_noexport bool_t has_out_union_call(ast_node *ast);
cql_noexport bool_t has_out_union_stmt_result(ast_node *ast);
cql_noexport bool_t is_autotest_dummy_table(CSTR name);
cql_noexport bool_t is_autotest_dummy_insert(CSTR name);
cql_noexport bool_t is_autotest_dummy_select(CSTR name);
cql_noexport bool_t is_autotest_dummy_result_set(CSTR name);
cql_noexport bool_t is_autotest_dummy_test(CSTR name);
cql_noexport bool_t is_referenceable_by_foreign_key(ast_node *ref_table, CSTR column_name);
cql_noexport bool_t is_inline_func_call(ast_node *call_ast);
cql_noexport bool_t is_proc_private(ast_node *proc_stmt);
cql_noexport bool_t is_proc_suppress_result_set(ast_node *proc_stmt);
cql_noexport bool_t is_proc_suppress_getters(ast_node *proc_stmt);
cql_noexport bool_t is_proc_emit_setters(ast_node *proc_stmt);
cql_noexport bool_t is_proc_shared_fragment(ast_node *ast);
cql_noexport bool_t is_alias_ast(ast_node *ast);
cql_noexport CSTR get_inserted_table_alias_string_override(ast_node *ast);

cql_noexport ast_node *new_maybe_qstr(CSTR name);
cql_noexport ast_node* new_str_or_qstr(CSTR name, sem_t sem_type);
cql_noexport CSTR sem_get_name(ast_node *ast);
cql_noexport ast_node *sem_get_name_ast(ast_node *ast);
cql_noexport CSTR create_group_id(CSTR group_name, CSTR table_name);

// Exit if schema validation directive was seen
cql_noexport void exit_on_validating_schema(void);

cql_noexport void sem_main(ast_node *node);
cql_noexport void sem_cleanup(void);
cql_noexport void print_sem_type(struct sem_node *sem);
cql_noexport int32_t sem_column_index(sem_struct *sptr, CSTR name);

cql_noexport ast_node *find_proc(CSTR name);
cql_noexport bytebuf *find_proc_arg_info(CSTR name);
cql_noexport ast_node *find_local_or_global_variable(CSTR name);
cql_noexport ast_node *find_region(CSTR name);
cql_noexport struct cg_blob_mappings_struct *find_backing_info(CSTR name);
cql_noexport CSTR find_op(CSTR op_key);
cql_noexport ast_node *find_func(CSTR name);
cql_noexport ast_node *find_unchecked_func(CSTR name);
cql_noexport ast_node *find_table_or_view_even_deleted(CSTR name);
cql_noexport ast_node *find_usable_and_not_deleted_table_or_view(CSTR name, ast_node *err_target, CSTR msg);
cql_noexport symtab *find_default_values(CSTR name);
cql_noexport bool_t add_default_values(symtab *def_values, CSTR name);
cql_noexport void sem_resolve_id(ast_node *ast, CSTR name, CSTR scope);
cql_noexport ast_node *find_enum(CSTR name);
cql_noexport ast_node *find_recreate_migrator(CSTR name);
cql_noexport ast_node *find_constant_group(CSTR name);
cql_noexport ast_node *find_variable_group(CSTR name);
cql_noexport ast_node *find_constant(CSTR name);
cql_noexport int32_t find_col_in_sptr(sem_struct *sptr, CSTR name);
cql_noexport ast_node *sem_get_col_default_value(ast_node *attrs);
cql_noexport void sem_accumulate_full_region_image(symtab *regions, CSTR name);
cql_noexport void sem_accumulate_public_region_image(symtab *regions, CSTR name);
cql_noexport sem_t find_column_type(CSTR table_name, CSTR column_name);

#define LIKEABLE_FOR_ARGS   1
#define LIKEABLE_FOR_VALUES 2

cql_noexport ast_node *sem_find_shape_def(ast_node *shape_def, int32_t likeable_for);
cql_noexport ast_node *sem_find_shape_def_base(ast_node *like_ast, int32_t likeable_for);
cql_noexport ast_node *sem_find_likeable_from_expr_type(ast_node *var);
cql_noexport ast_node *find_named_type(CSTR name);

cql_noexport void record_error(ast_node *ast);
cql_noexport void record_ok(ast_node *ast);
cql_noexport void report_error(ast_node *ast, CSTR msg, CSTR subject);
cql_noexport void sem_one_stmt(ast_node *ast);
cql_noexport void sem_root_expr(ast_node *node, uint32_t expr_context);
cql_noexport void sem_expr(ast_node *node);
cql_noexport void sem_cursor(ast_node *ast);
cql_noexport ast_node *find_arg_bundle(CSTR name);
cql_noexport bool_t add_arg_bundle(ast_node *ast, CSTR name);
cql_noexport void sem_add_flags(ast_node *ast, sem_t flags);
cql_noexport ast_node *first_arg(ast_node *arg_list);
cql_noexport ast_node *second_arg(ast_node *arg_list);
cql_noexport ast_node *third_arg(ast_node *arg_list);
cql_noexport void sem_verify_no_anon_no_null_columns(ast_node *ast);
cql_noexport void sem_verify_identical_columns(ast_node *expected, ast_node *actual, CSTR target);
cql_noexport void sem_validate_cursor_blob_compat(ast_node *ast_error, ast_node *cursor, ast_node *blob, ast_node *dest, ast_node *src);
cql_noexport void sem_any_shape(ast_node *ast);
cql_noexport sem_node *new_sem(sem_t sem_type);
cql_noexport bool_t sem_verify_assignment(ast_node *ast, sem_t sem_type_needed, sem_t sem_type_found, CSTR var_name);
cql_noexport void sem_any_row_source(ast_node *node);
cql_noexport ast_node *sem_recover_with_stmt(ast_node *ast);
cql_noexport ast_node *sem_skip_with(ast_node *ast);
cql_noexport bool_t is_table_not_physical(ast_node *table_ast);

#endif

// the current chain of common table expressions (for WITH clauses)
typedef struct cte_state {
  struct cte_state *prev;
  symtab *ctes;
} cte_state;

cql_data_decl( bytebuf *schema_annotations );
cql_data_decl( bytebuf *recreate_annotations );

cql_data_decl( struct list_item *all_tables_list );
cql_data_decl( struct list_item *all_subscriptions_list );
cql_data_decl( struct list_item *all_functions_list );
cql_data_decl( struct list_item *all_views_list );
cql_data_decl( struct list_item *all_indices_list );
cql_data_decl( struct list_item *all_triggers_list );
cql_data_decl( struct list_item *all_regions_list );
cql_data_decl( struct list_item *all_ad_hoc_list );
cql_data_decl( struct list_item *all_select_functions_list );
cql_data_decl( struct list_item *all_enums_list );
cql_data_decl( struct list_item *all_constant_groups_list );
cql_data_decl( symtab *schema_regions );
cql_data_decl( ast_node *current_proc );
cql_data_decl( charbuf *error_capture );
cql_data_decl( cte_state *cte_cur );
cql_data_decl( symtab *ref_sources_for_target_table );
cql_data_decl( symtab *ref_targets_for_source_table );

// These are the symbol tables with the accumulated included/excluded regions
cql_data_decl( symtab *included_regions );
cql_data_decl( symtab *excluded_regions );
cql_data_decl( sem_t global_proc_flags );

// This is the table for all the migration procs for any recreate procs or groups
// that might need them, these are the second form of ad hoc schema migration
cql_data_decl( symtab *ad_hoc_recreate_actions );

// If the current context is a upsert statement
cql_data_decl( bool_t in_upsert );
cql_data_decl( bool_t in_upsert_rewrite );

// hold the table ast query in the current upsert statement.
cql_data_decl ( ast_node *current_upsert_table_ast );
// This is the symbol table with the recreate group dependencies where an edge B -> A means A FKs to B
cql_data_decl( symtab *recreate_group_deps );

// Truthy when the @keep_table_name_in_aliases_stmt directive is used.
cql_data_decl( bool_t keep_table_name_in_aliases );
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// cql - pronounced "see-queue-el" is a basic tool for enabling stored
//       procedures for SQLite. The tool does this by parsing a language
//       not unlike typical SQL stored procedure forms available in
//       MySql and SQL Server.
//
//       Broadly speaking compilation is as follows:
//         * SQL statements such as SELECT/INSERT/UPDATE/DELETE
//           are converted into calls to SQLite to do the work.
//           Any variables in those statements are converted into
//           the appropriate binding and and results are read out
//           with the usual SQLite column reading.
//         * Stored procedure control flow is converted into the equivalent
//           C directly.  So for instance an 'IF' in the SQL becomes
//           a correlated 'if' in the generated code.
//
//       The result of this is that CQL produces, "The C you could have
//       written yourself using the SQLite API to do that database operation."
//       CQL does this in a less brittle and type-safe way that is far
//       more maintainable.
//
// Design principles:
//
//  1. Keep each pass in one file (simple, focused, and easy refactor)
//  2. Use simple printable AST parse nodes (no separate #define per AST node type)
//  3. 100% coverage of all logic, no exceptions.




#ifndef CQL_AMALGAM

// as well as the integration points.
#define cql_noexport extern
#define cql_export extern
#define cql_data_decl(x) extern x
#define cql_data_defn(x) x

#endif

typedef uint8_t bool_t;
typedef long long int llint_t;


#define u32_not(x) ((uint32_t)(~(x)))
#define u64_not(x) ((uint64_t)(~(x)))

#if LONG_MAX > 0x7fffffff
#define _64(x) x##L
#else
#define _64(x) x##LL
#endif

// patternlint-disable-next-line prefer-sized-ints-in-msys
int main(int argc, char **argv);

// we need this for some callbacks
struct charbuf;

typedef struct cmd_options {
  bool_t test;
  bool_t echo_input;
  bool_t hide_builtins;
  bool_t print_ast;
  bool_t ast_no_echo;
  bool_t print_dot;
  bool_t expand;
  bool_t semantic;
  bool_t codegen;
  bool_t compress;
  bool_t generate_exports;
  bool_t run_unit_tests;
  bool_t nolines;
  bool_t schema_exclusive;
  char *rt;
  char **file_names;
  uint32_t file_names_count;
  char **include_paths;
  uint32_t include_paths_count;
  char **defines;
  uint32_t defines_count;
  char **include_regions;
  uint32_t include_regions_count;
  char **exclude_regions;
  uint32_t exclude_regions_count;
  int32_t min_schema_version;
  char *c_include_path;
  char *c_include_namespace;
  char *cqlrt;
  bool_t dev;                           // option use to activate features in development or dev features
} cmd_options;

cql_data_decl( cmd_options options );

#define Invariant assert
#define Contract assert

#define _new(x) ((x*)malloc(sizeof(x)))
#define _new_array(x,c) ((x*)malloc(c*sizeof(x)))

#define CQL_NICE_LITERAL_NAME_LIMIT 32

// note this is not easily changed, storage for used strach variables is in an unsigned long long
#define CQL_MAX_STACK 128

typedef const char *CSTR;

typedef enum cg_symbol_case {
  cg_symbol_case_snake,
  cg_symbol_case_pascal,
  cg_symbol_case_camel,
} cg_symbol_case;

cql_data_decl( const char *global_proc_name );

typedef struct ast_node *ast_ptr;

typedef struct rtdata {
  // the command line name of this result type
  const char *name;

  // The main code generator function that will be executed.
  void (*code_generator)(ast_ptr root);

  // The number of file names required by the rt. Use -1 for a variable number
  // of file names that will be verified by the code generator itself based on
  // the arguments passed t it
  int32_t required_file_names_count;

  // A string to add before any header contents (include copyright, autogen comments, runtime include, etc).
  const char *header_prefix;

  // The default "cqlrt.h" for this code type
  const char *cqlrt;

  // the formatting string into which the filename above is placed
  const char *cqlrt_template;

  // A begin string to wrap the contents of the header file.
  const char *header_wrapper_begin;

  // A end string to wrap the contents of the header file.
  const char *header_wrapper_end;

  // A string to add before any source contents (include copyright, autogen comments, etc).
  const char *source_prefix;

  // A begin string to wrap the contents of the source file.
  const char *source_wrapper_begin;

  // A end string to wrap the contents of the source file.
  const char *source_wrapper_end;

  // A string to add before any import file contents (include copyright, autgen comments, etc).
  const char *exports_prefix;

  // The case to use for symbols.
  cg_symbol_case symbol_case;

  // If enabled, macros will be generated to test equality between 2 list/index pairs.
  bool_t generate_equality_macros;

  // Called for each proc name that is processed.
  void (*register_proc_name)(const char *proc_name);

  // Predicate function to determine whether to implicitly generate the copy function for a result set.
  // The cql:generate_copy attribute overrides the value, if specified.
  bool_t (*proc_should_generate_copy)(const char *proc_name);

  // Provides a chance to add some extra definitions to the result set type, specify if extra stuff needed.
  void (*result_set_type_decl_extra)(struct charbuf *output, CSTR sym, CSTR ref);

  // Prefix for public symbol.
  const char *symbol_prefix;

  // Prefix for private implementation symbol.
  const char *impl_symbol_prefix;

  // Visibility attribute for generated functions.
  const char *symbol_visibility;

  // The include library for the encode type for a string object.
  const char *cql_string_ref_encode_include;

  void (*cql_post_common_init)(void);
} rtdata;

cql_data_decl( rtdata *rt );

cql_noexport void cql_cleanup_and_exit(int32_t code);

// output to "stderr"
cql_noexport void cql_error(const char *format, ...) _printf_checking_(1, 2);

// output to "stdout"
cql_noexport void cql_output(const char *format, ...) _printf_checking_(1, 2);

// Creates a file in write mode. Aborts if there's any error.
cql_export FILE *cql_open_file_for_write(CSTR file_name);

// Create file, write the data to it, and close the file
cql_export void cql_write_file(const char *file_name, const char *data);

cql_noexport void line_directive(const char *directive);

cql_export void cql_emit_error(const char *err);

cql_export void cql_emit_output(const char *out);

cql_data_decl( char *current_file );

cql_noexport CSTR get_last_doc_comment();

cql_noexport CSTR cql_builtin_text();

cql_noexport void cql_setup_for_builtins(void);

cql_noexport int32_t macro_type_from_str(CSTR type);
cql_noexport int32_t macro_arg_type(struct ast_node *ast);

cql_noexport void cql_cleanup_open_includes(void);
cql_noexport void cql_reset_open_includes(void);

cql_noexport bool_t cql_is_defined(CSTR name);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


// string literal swizzlers

#define PRETTY_QUOTE_SINGLE_LINE 0
#define PRETTY_QUOTE_MULTI_LINE 1
#define PRETTY_QUOTE_C 0
#define PRETTY_QUOTE_JSON 2

cql_noexport void cg_decode_string_literal(CSTR _Nonnull str, charbuf *_Nonnull output);
cql_noexport void cg_encode_string_literal(CSTR _Nonnull str, charbuf *_Nonnull output);
cql_noexport void cg_encode_char_as_c_string_literal(char c, charbuf *_Nonnull output);
cql_noexport void cg_encode_char_as_json_string_literal(char c, charbuf *_Nonnull output);

cql_noexport void cg_encode_json_string_literal(CSTR _Nonnull str, charbuf *_Nonnull output);
cql_noexport void cg_encode_c_string_literal(CSTR _Nonnull str, charbuf *_Nonnull output);
cql_noexport void cg_decode_c_string_literal(CSTR _Nonnull str, charbuf *_Nonnull output);
cql_noexport void cg_pretty_quote_plaintext(CSTR _Nonnull str, charbuf *_Nonnull output, uint32_t flags);
cql_noexport void cg_remove_slash_star_and_star_slash(charbuf *_Nonnull b);
cql_noexport void cg_pretty_quote_compressed_text(CSTR _Nonnull str, charbuf *_Nonnull output);
cql_noexport void cg_encode_qstr(charbuf *_Nonnull output, CSTR _Nonnull qstr);
cql_noexport void cg_decode_qstr(charbuf *_Nonnull output, CSTR _Nonnull qstr);
cql_noexport void cg_unquote_encoded_qstr(charbuf *_Nonnull output, CSTR _Nonnull qstr);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// minimal stuff goes here (none at this point)

#else


#define EVAL_NIL {0, 0, 0, 0, false}

#define EVAL_FORMAT_NORMAL 1
#define EVAL_FORMAT_FOR_C 2
#define EVAL_FORMAT_FOR_LUA 3

typedef struct eval_node {
  sem_t sem_type;
  int64_t int64_value;
  int32_t int32_value;
  double  real_value;
  bool_t  bool_value;
} eval_node;

cql_noexport void eval_init();
cql_noexport void eval_cleanup();
cql_noexport void eval(ast_node *_Nonnull expr, eval_node *_Nonnull result);
cql_noexport ast_node *_Nonnull eval_set(ast_node *_Nonnull expr, eval_node *_Nonnull result);
cql_noexport void eval_cast_to(eval_node *_Nonnull result, sem_t sem_type);
cql_noexport void eval_add_one(eval_node *_Nonnull result);
cql_noexport void eval_format_number(eval_node *_Nonnull result, int32_t format_mode, charbuf *_Nonnull output);

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



cql_data_decl( int32_t gen_stmt_level );

cql_noexport void gen_init(void);
cql_noexport void gen_cleanup(void);
cql_noexport void gen_printf(const char *_Nonnull format, ...) _printf_checking_(1, 2);
cql_noexport void gen_set_output_buffer(struct charbuf *_Nonnull buffer);

typedef void (*_Nonnull gen_func)(ast_node *_Nonnull ast);

cql_noexport CSTR _Nonnull gen_type_hash(ast_node *_Nonnull ast);
cql_noexport CSTR _Nonnull get_field_hash(CSTR _Nonnull cname, sem_t sem_type);
cql_noexport void gen_stmt_list_to_stdout(ast_node *_Nullable ast);
cql_noexport void gen_select_core(ast_node *_Nonnull ast);
cql_noexport void gen_one_stmt_to_stdout(ast_node *_Nonnull ast);
cql_noexport void gen_misc_attrs_to_stdout(ast_node *_Nonnull ast);
cql_noexport void gen_root_expr(ast_node *_Nonnull ast);
cql_noexport void gen_param(ast_node *_Nonnull ast);
cql_noexport void gen_col_or_key(ast_node *_Nonnull ast);
cql_noexport void gen_params(ast_node *_Nonnull ast);
cql_noexport void gen_declare_proc_from_create_or_decl(ast_node *_Nonnull ast);
cql_noexport void gen_declare_proc_closure(ast_node *_Nonnull ast, symtab *_Nullable already_done);
cql_noexport void gen_declare_interface_stmt(ast_node *_Nonnull ast);
cql_noexport void gen_one_stmt(ast_node *_Nonnull stmt);
cql_noexport void gen_one_stmt_and_misc_attrs(ast_node *_Nonnull stmt);
cql_noexport void gen_misc_attrs(ast_node *_Nonnull ast);
cql_noexport void gen_misc_attr_value(ast_node *_Nonnull ast);
cql_noexport void gen_misc_attr_value_list(ast_node *_Nonnull ast);
cql_noexport void gen_fk_action(int32_t action);
cql_noexport void gen_insert_type(ast_node *_Nonnull ast);
cql_noexport void gen_col_key_list(ast_node *_Nonnull list);
cql_noexport void gen_typed_names(ast_node *_Nullable ast);
cql_noexport void gen_data_type(ast_node *_Nonnull ast);
cql_noexport void gen_name_for_msg(ast_node *_Nonnull name_ast, charbuf *_Nonnull output);
cql_noexport void bprint_maybe_qname(charbuf *_Nonnull output, CSTR _Nonnull name);

// automatically sets the output buffer and printf's the results of the above
cql_noexport void gen_to_stdout(ast_node *_Nullable ast, gen_func fn);

// signature for a callback, you get your context plus the ast
// if you return true then the normal output is suppressed
// in any case the output you provide is emitted
typedef bool_t (*_Nullable gen_sql_callback)(struct ast_node *_Nonnull ast, void *_Nullable context, charbuf *_Nonnull output);

// These modes control the overall style of the output
enum gen_sql_mode {
  gen_mode_echo,          // Prints everything in the original, with standard whitespace and parentheses
  gen_mode_sql,           // Prints the AST formatted for SQLite consumption, omits anything CQL specific
  gen_mode_no_annotations // Equivalent to gen_mode_echo without versioning attributes or generic attributes
                          // * @create, @delete, @recreate, and @attribute are removed
                          // * statements like @echo are not affected, nor is the type specifier @sensitive
};

// Callbacks allow you to significantly alter the generated sql, see the particular flags below.
typedef struct gen_sql_callbacks {
  // Each time a local/global variable is encountered in the AST, this callback is invoked
  // this is to allow the variable reference to be noted and replaced with ? in the generated SQL
  gen_sql_callback _Nullable variables_callback;
  void *_Nullable variables_context;

  // Each time a column definition is emitted this callback is invoked, it may choose to
  // suppress that column.  This is used to remove columns that were added in later schema
  // versions from the baseline schema.
  gen_sql_callback _Nullable col_def_callback;
  void *_Nullable col_def_context;

  // This callback is used to force the "IF NOT EXISTS" form of DDL statements when generating
  // schema upgrade steps.  e.g. a "CREATE TABLE Foo declarations get "IF NOT EXISTS" added
  // to them in upgrade steps.
  gen_sql_callback _Nullable if_not_exists_callback;
  void *_Nullable if_not_exists_context;

  // This callback is used to allow the caller to rename some table references to other names
  // Normally this is used to make replacements in shared fragments
  gen_sql_callback _Nullable table_rename_callback;
  void *_Nullable table_rename_context;

  // This callback is used to expand CALL sequences inside of a CTE expression inline
  // the normal response will be to recursively generate the SQL for the procedure
  // and emit it to the output stream
  gen_sql_callback _Nullable cte_proc_callback;
  void *_Nullable cte_proc_context;

  // This callback is used to expand inline function call sequences inside of a SQL expression
  // the normal response will be to recursively generate the SQL for the function fragment
  // and emit it to the output stream.  This is for the fragment case.
  gen_sql_callback _Nullable func_callback;
  void *_Nullable func_context;

  gen_sql_callback _Nullable call_expr_callback;
  void *_Nullable call_expr_context;

  // This callback is used to suppress any particular CTE that we might need to omit from a select statement
  // normally this causes us to check the name of the CTE against a blocklist
  gen_sql_callback _Nullable cte_suppress_callback;
  void *_Nullable cte_suppress_context;

  // This callback is used to override entire if/else statements
  gen_sql_callback _Nullable if_stmt_callback;
  void *_Nullable if_stmt_context;

  // This callback allows named types to be resolved when comparing ASTs during
  // semantic analysis.
  gen_sql_callback _Nullable named_type_callback;
  void *_Nullable named_type_context;

  // This callback allows embedded <X SET> types to be recursively walked
  // during emission of exports
  gen_sql_callback _Nullable set_kind_callback;
  void *_Nullable set_kind_context;

  // If true, hex literals are converted to decimal.  This is for JSON which does not support hex literals.
  bool_t convert_hex;

  // If true casts like "CAST(NULL as TEXT)" are reduced to just NULL.  The type information is not needed
  // by SQLite so it just wastes space.
  bool_t minify_casts;

  // If true then unused aliases in select statements are elided to save space.  This is safe because
  // CQL always binds the top level select statement by ordinal anyway.
  bool_t minify_aliases;

  // mode to print cql statement: gen_mode_echo, gen_mode_sql, gen_mode_no_annotations.
  // gen_mode_sql mode causes the AS part of virtual table to be suppressed
  enum gen_sql_mode mode;

  // If CQL finds a column such as 'x' below'
  //
  // create table foo(
  //   x long_int primary key autoincrement
  // );
  //
  // that column must be converted to this form:
  //
  // create table foo(
  //   x integer primary key autoincrement
  // );
  //
  // This is because SQLite mandates that autoincrement must be exactly
  // in the second example above however, it is also the case that in SQLite
  // an integer can store a 64 bit value.  So sending "integer" to SQLite while
  // keeping the sense that the column is to be treated as 64 bits in CQL works
  // just fine.
  //
  // However, when we are emitting CQL (rather than SQL) we want to keep
  // the original long_int type so as not to lose fidelity when processing
  // schema for other semantic checks (such as matching FK data types).
  //
  // This flag is for that purpose: It tells us that the target isn't SQLite
  // and we don't need to do the mapping (yet). Indeed, we shouldn't, or the
  // types will be messed up.
  //
  // In short, if CQL is going to process the output again, use this flag
  // to control the autoincrement transform.  It might be possible to fold
  // this flag with the mode flag but it's sufficiently weird that this
  // extra documentation and special handling is probably worth the extra
  // boolean storage.
  bool_t long_to_int_conv;

  // bool_t escape attributes for Lua [[builtin]] looks like it ends a lua comment
  bool_t escape_attributes_for_lua;

  // Each time a table value function is encountered in the AST, this callback is invoked
  // this is to allow the table value function reference to be noted and replaced with table name in the generated SQL
  gen_sql_callback _Nullable table_function_callback;
  void *_Nullable table_function_context;
} gen_sql_callbacks;

cql_noexport void init_gen_sql_callbacks(gen_sql_callbacks *_Nullable callbacks);

// Generate helper methods

cql_noexport void gen_with_callbacks(ast_node *_Nonnull ast, gen_func fn, gen_sql_callbacks *_Nullable _callbacks);
cql_noexport void gen_col_def_with_callbacks(ast_node *_Nonnull ast, gen_sql_callbacks *_Nullable _callbacks);
cql_noexport void gen_statement_with_callbacks(ast_node *_Nonnull ast, gen_sql_callbacks *_Nullable _callbacks);
cql_noexport void gen_statement_and_attributes_with_callbacks(ast_node *_Nonnull ast, gen_sql_callbacks *_Nullable _callbacks);
cql_noexport void gen_any_text_arg(ast_node *_Nonnull ast);

cql_noexport bool_t eval_variables_callback(ast_node *_Nonnull ast);
cql_noexport bool_t eval_column_callback(ast_node *_Nonnull ast);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * \file
 * Functions and types for CRC checks.
 *
 * Generated on Wed Jun  5 12:56:23 2019
 * by pycrc v0.9.2, https://pycrc.org
 * using the configuration:
 *  - Width         = 64
 *  - Poly          = 0x42f0e1eba9ea3693
 *  - XorIn         = 0xffffffffffffffff
 *  - ReflectIn     = True
 *  - XorOut        = 0xffffffffffffffff
 *  - ReflectOut    = True
 *  - Algorithm     = table-driven
 *
 * This file defines the functions crc_init(), crc_update() and crc_finalize().
 *
 * The crc_init() function returns the inital \c crc value and must be called
 * before the first call to crc_update().
 * Similarly, the crc_finalize() function must be called after the last call
 * to crc_update(), before the \c crc is being used.
 * is being used.
 *
 * The crc_update() function can be called any number of times (including zero
 * times) in between the crc_init() and crc_finalize() calls.
 *
 * This pseudo-code shows an example usage of the API:
 * \code{.c}
 * crc_t crc;
 * unsigned char data[MAX_DATA_LEN];
 * size_t data_len;
 *
 * crc = crc_init();
 * while ((data_len = read_data(data, MAX_DATA_LEN)) > 0) {
 *     crc = crc_update(crc, data, data_len);
 * }
 * crc = crc_finalize(crc);
 * \endcode
 */
#ifndef CRC64XZ_H
#define CRC64XZ_H


#ifdef __cplusplus
extern "C" {
#endif



/**
 * The definition of the used algorithm.
 *
 * This is not used anywhere in the generated code, but it may be used by the
 * application code to call algorithm-specific code, if desired.
 */
#define CRC_ALGO_TABLE_DRIVEN 1


/**
 * The type of the CRC values.
 *
 * This type must be big enough to contain at least 64 bits.
 */
typedef uint_fast64_t crc_t;


/**
 * Calculate the initial crc value.
 *
 * \return     The initial crc value.
 */
static inline crc_t crc_init(void)
{
    return 0xffffffffffffffff;
}


/**
 * Update the crc value with new data.
 *
 * \param[in] crc      The current crc value.
 * \param[in] data     Pointer to a buffer of \a data_len bytes.
 * \param[in] data_len Number of bytes in the \a data buffer.
 * \return             The updated crc value.
 */
cql_noexport crc_t crc_update(crc_t crc, const void *data, size_t data_len);


/**
 * Calculate the final crc value.
 *
 * \param[in] crc  The current crc value.
 * \return     The final crc value.
 */
static inline crc_t crc_finalize(crc_t crc)
{
    return crc ^ 0xffffffffffffffff;
}


#ifdef __cplusplus
}           /* closing brace for extern "C" */
#endif

#endif      /* CRC64XZ_H */
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



// When emitting code for a sql statement you might need to prepare it expecting
// to use the sql statement yourself, or you may just want to run the SQL.
// CG_PREPARE indicates a result is expected.
#define CG_PREPARE 0            // so we can be explicit about not 1
#define CG_EXEC 1
#define CG_MINIFY_ALIASES 2
#define CG_NO_MINIFY_ALIASES 0  // so we can be explicit about not 2

// currently used only in DASM but of interest to all the code generators in the future
#define CG_EMIT_ONLY_BINDING 4  // assume the statement is ready to be bound, emit only the bindings
#define CG_EMIT_ONLY_PREPARE 8  // emit only the prepare, omitting the bindings which will be done later using the above

// To understand the PUSH/POP eval macros, and generally all the expression state
// macros you have to understand the overall theory of operation of the expression
// code generation.  In a traditional evaluation you could walk the tree and assemble
// the net expression just like we do when we produce SQL in the gen_* walk.  However,
// this doesn't work for SQL->C transpilation because of nullable types and compound
// expressions.
//   * Nullable types
//     The problem here is that the nullable has an is_null and an value field
//     in order to represent the possibily null state of something like a bool.
//     There is no one expression type that can hold all of that and we can't do
//     things like multiply a struct or otherwise accumulate expression state.
//     To solve this problem we keep a stack of local variables with intermediate
//     nullable results.  The result of evaluation is then TWO strings, one of which
//     is a string to get the value of the current expression and one of which is
//     a similar string to find out if that expression is null.  When a temporary is used
//     code generation will emit the necessary code to load the temporary variable
//     and then produce "variable.is_null" and "variable.value" as the pieces.
//   * Compound expressions
//     Many expressions cannot be evaluated without control flow logic.  The simplest
//     example is logical AND with short-circuit.  Knowing that the AND, and even its
//     fragements might need logic emitted you have to take the same approach --
//     you allocate a scratch variable to hold the answer, then compute it.  The same
//     approach lets you resole CASE/WHEN, IN, and BETWEEN, among others.  All of
//     these might require temporary variables and control flow.
// With the above general approach in mind, it becomes possible to keep building up
// subexpressions as long as nothing forces you to spill to locals.  So you can do
// 1+2*3 and so forth all you like and keep getting a nice simple string.  This gives
// you the best combination of simple, readable output with correct SQL semantics.
//
// The upshot of all this is that everything in sight gets an is_null and value
// buffer to write into.  Those pieces are then used to assemble any necessary evaluation.
//
// The pri argument tells the callee the context you intend to use the result.
// For instance if the result of this expression evaluation is going to be used
// as the left size of == you would pass in EXPR_PRI_COMP.  This tells the evaluator
// if the left side has binding strength weaker then == it must add parens because
// it will be used in the context of == by its caller.

#define CG_PUSH_MAIN_INDENT(tag, indent) \
CHARBUF_OPEN(tag##_buf); \
charbuf *tag##_main_saved = cg_main_output; \
int32_t tag##_indent = indent; \
cg_main_output = &tag##_buf; \

#define CG_PUSH_MAIN_INDENT2(tag) \
CG_PUSH_MAIN_INDENT(tag, 2)

#define CG_POP_MAIN_INDENT(tag) \
cg_main_output = tag##_main_saved; \
bindent(cg_main_output, &tag##_buf, tag##_indent); \
CHARBUF_CLOSE(tag##_buf);

#define CG_TEMP_STMT_BASE_NAME(index, output) \
  if (index == 0) { bprintf(output, "_temp"); } else { bprintf(output, "_temp%d", index);  }

#define CG_TEMP_STMT_NAME(index, output) \
  { CG_TEMP_STMT_BASE_NAME(index, output); bprintf(output, "_stmt"); }

// Several code generators track the nesting level of their blocks for
// various purposes, mostly indenting and diagnostic output.
cql_data_decl( int32_t stmt_nesting_level );

// This is the first of two major outputs, this one holds the .h file output
// it will get the prototypes of all the functions we generate.
cql_data_decl( charbuf *_Nullable cg_header_output );

// This is current place where statements should be going.  It begins
// as a buffer that holds the original.c file but it is normal for this
// to get temporarily redirected into other places, such as the body of
// a stored proc.
cql_data_decl( charbuf *_Nullable cg_main_output );

// This will spill into the main buffer at the end.  String literals go here.
cql_data_decl( charbuf *_Nullable cg_constants_output );

// This will spill into the main buffer at the end.  Extern declarations go here
cql_data_decl( charbuf *_Nullable cg_fwd_ref_output );

// All local variable declarations are hoisted to the front of the resulting C.
// This prevents C lexical scoping from affecting SQL scoping rules.
cql_data_decl( charbuf *_Nullable cg_declarations_output );

// Scratch variables go into their own section and will go out adjacent to
// local variable declarations.
cql_data_decl( charbuf *_Nullable cg_scratch_vars_output );

// Any on-exit cleanup goes here. This is going to be the code to finalize
// any sql statements that were generated and also to release any strings
// we were holding on to.
cql_data_decl( charbuf *_Nullable cg_cleanup_output );

// The definitions of all of the statement pieces go into this section
cql_data_decl( charbuf *_Nullable cg_pieces_output );

// Prints a symbol name, along with any configured prefix, to the specified buffer.
// Multiple CSTRs may be supplied to build the name, which will be concatenated
// together.  The configured symbol case will be applied to the full symbol name.
// The prefix will be included as specified.
//
// All input names are assumed to be in snake case already.
cql_noexport void cg_sym_name(cg_symbol_case symbol_case, charbuf *_Nonnull output, CSTR _Nonnull symbol_prefix, CSTR _Nonnull name, ...);

// Initializes all of the common buffers and sym tables.
cql_noexport void cg_common_init(void);

// cleanup the global state
cql_noexport void cg_common_cleanup(void);

// Exit if any semantic errors
cql_noexport void cql_exit_on_semantic_errors(ast_node *_Nullable head);

// Exit if no global proc name specified
cql_noexport void exit_on_no_global_proc(void);

// For the common case of "semantic-only" nodes
cql_noexport void cg_no_op(ast_node *_Nonnull ast);

cql_noexport int32_t cg_find_first_line(ast_node *_Nonnull ast);

typedef struct cg_blob_mappings_struct {
  CSTR _Nullable get_key_type;
  CSTR _Nullable get_val_type;  // unused
  CSTR _Nullable get_key;
  CSTR _Nullable get_val;
  CSTR _Nullable create_key;
  CSTR _Nullable create_val;
  CSTR _Nullable update_key;
  CSTR _Nullable update_val;
  bool_t key_use_offsets;
  bool_t val_use_offsets;
  bool_t use_json;
  bool_t use_jsonb;
} cg_blob_mappings_t;

// Hashing helpers

cql_noexport crc_t crc_charbuf(charbuf *_Nonnull input);
cql_noexport int64_t sha256_charbuf(charbuf *_Nonnull input);

// name foratting helpers

cql_noexport void cg_emit_name(charbuf *_Nonnull output, CSTR _Nonnull name, bool_t qid);
cql_noexport void cg_emit_name_ast(charbuf *_Nonnull output, ast_node *_Nonnull name_ast);
cql_noexport void cg_emit_sptr_index(charbuf *_Nonnull output, sem_struct *_Nonnull sptr, uint32_t i);

#define CG_CHARBUF_OPEN_SYM_WITH_PREFIX(name, symbol_prefix, ...) \
CHARBUF_OPEN(name); \
cg_sym_name(rt->symbol_case, &name, symbol_prefix, ##__VA_ARGS__, NULL)

#define CG_CHARBUF_OPEN_SYM(name, ...) \
CG_CHARBUF_OPEN_SYM_WITH_PREFIX(name, rt->symbol_prefix, ##__VA_ARGS__)

// These are pre-loaded with pointers to functions for handling the
// root statements and functions.
cql_data_decl( symtab *_Nullable cg_stmts );
cql_data_decl( symtab *_Nullable cg_funcs );
cql_data_decl( symtab *_Nullable cg_exprs );

// Used by the cte_proc_context attribute in gen_sql_callbacks
typedef struct {
  gen_sql_callbacks *_Nonnull callbacks;
  bool_t minify_aliases;
} cte_proc_call_info;

// loop constants for the type of loop we are in, for is special
// because it has a continue lable
#define LOOP_NONE 0
#define LOOP_ANY 1
#define LOOP_FOR 2
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



cql_noexport void cg_c_main(struct ast_node *_Nonnull root);
cql_noexport void cg_c_cleanup(void);

// Make a temporary buffer for the evaluation results using the canonical
// naming convention.  This might exit having burned some stack slots
// for its result variables, that's normal.
#define CG_PUSH_EVAL(expr, pri) \
CHARBUF_OPEN(expr##_is_null); \
CHARBUF_OPEN(expr##_value); \
cg_expr(expr, &expr##_is_null, &expr##_value, pri);

// Close the buffers used for the above.
// The scratch stack is not restored so that any temporaries used in
// the evaluation of expr will not be re-used prematurely.  They
// can't be used again until either the expression is finished,
// or they have been captured in a less-nested result variable.
#define CG_POP_EVAL(expr) \
CHARBUF_CLOSE(expr##_value); \
CHARBUF_CLOSE(expr##_is_null);

// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers
// with the text needed to refer to the variable.  cg_scratch_var picks the name
// based on stack level-and type.
#define CG_PUSH_TEMP(name, sem_type) \
CHARBUF_OPEN(name); \
CHARBUF_OPEN(name##_is_null); \
CHARBUF_OPEN(name##_value); \
cg_scratch_var(NULL, sem_type, &name, &name##_is_null, &name##_value); \
stack_level++;

// Release the buffers for the temporary, restore the stack level.
#define CG_POP_TEMP(name) \
CHARBUF_CLOSE(name##_value); \
CHARBUF_CLOSE(name##_is_null); \
CHARBUF_CLOSE(name); \
stack_level--;

// Make a scratch variable to hold the final result of an evaluation.
// It may or may not be used.  It should be the first thing you put
// so that it is on the top of your stack.  This only saves the slot.
// If you use this variable you can reclaim other temporaries that come
// from deeper in the tree since they will no longer be needed.
#define CG_RESERVE_RESULT_VAR(ast, sem_type) \
int32_t stack_level_reserved = stack_level; \
sem_t sem_type_reserved = sem_type; \
ast_node *ast_reserved = ast; \
CHARBUF_OPEN(result_var); \
CHARBUF_OPEN(result_var_is_null); \
CHARBUF_OPEN(result_var_value); \
stack_level++;

// If the result variable is going to be used, this writes its name
// and .value and .is_null into the is_null and value fields.
#define CG_USE_RESULT_VAR() \
int32_t stack_level_now = stack_level; \
stack_level = stack_level_reserved; \
cg_scratch_var(ast_reserved, sem_type_reserved, &result_var, &result_var_is_null, &result_var_value); \
stack_level = stack_level_now; \
Invariant(result_var.used > 1); \
bprintf(is_null, "%s", result_var_is_null.ptr); \
bprintf(value, "%s", result_var_value.ptr)

// Release the buffer holding the name of the variable.
// If the result variable was used, we can re-use any temporaries
// with a bigger number.  They're no longer needed since they
// are captured in this result.  We know it was used if it
// has .used > 1 (there is always a trailing null so empty is 1).
#define CG_CLEANUP_RESULT_VAR() \
if (result_var.used > 1) stack_level = stack_level_reserved + 1; \
CHARBUF_CLOSE(result_var_value); \
CHARBUF_CLOSE(result_var_is_null); \
CHARBUF_CLOSE(result_var);

// This does reserve and use in one step
#define CG_SETUP_RESULT_VAR(ast, sem_type) \
CG_RESERVE_RESULT_VAR(ast, sem_type); \
CG_USE_RESULT_VAR();

#define CG_BEGIN_ADJUST_FOR_OUTARG(var, sem_type_var) \
CHARBUF_OPEN(adjusted_target); \
/* for out parameters we need to do *name */ \
if (is_out_parameter(sem_type_var)) { \
  bprintf(&adjusted_target, "*%s", var); \
  var = adjusted_target.ptr; \
}

#define CG_END_ADJUST_FOR_OUTARG() \
CHARBUF_CLOSE(adjusted_target);

// This is the symbol table for all the tokens.
// This saves us from having a giant switch for the AST types
// and for the builtin functions.
//
// Note: semantic analysis knows about more function than code-gen does
// that's because many functions are only legal in the context of SQL
// so we have no codegen for them.  But we do need to verify correctness.
#define STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_ ## x)
#define NO_OP_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_no_op)
#define FUNC_INIT(x) symtab_add(cg_funcs, # x, (void *)cg_func_ ## x)
#define EXPR_INIT(x, func, str, pri_new) \
  static cg_expr_dispatch expr_disp_ ## x = { func, str, pri_new }; \
  symtab_add(cg_exprs, k_ast_ ## x, (void *)&expr_disp_ ## x);

typedef void (*cg_expr_dispatch_func)(ast_node *_Nonnull ast,
                                      CSTR _Nonnull op,
                                      charbuf *_Nonnull is_null,
                                      charbuf *_Nonnull value,
                                      int32_t pri,
                                      int32_t pri_new);

// for dispatching expression types
typedef struct cg_expr_dispatch {
  cg_expr_dispatch_func _Nonnull func;
  CSTR _Nonnull str;
  int32_t pri_new;
} cg_expr_dispatch;

#define DDL_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_any_ddl_stmt)
#define STD_DML_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_std_dml_exec_stmt)
#define STD_PREP_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_std_dml_prep_stmt)

/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



cql_noexport void cg_lua_main(struct ast_node *_Nonnull root);
cql_noexport void cg_lua_cleanup(void);

typedef void (*cg_lua_expr_dispatch_func)(ast_node *_Nonnull ast,
                                      CSTR _Nonnull op,
                                      charbuf *_Nonnull value,
                                      int32_t pri,
                                      int32_t pri_new);

// for dispatching expression types
typedef struct cg_lua_expr_dispatch {
  cg_lua_expr_dispatch_func _Nonnull func;
  CSTR _Nonnull str;
  int32_t pri_new;
} cg_lua_expr_dispatch;

#define LUA_STD_PREP_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_lua_std_dml_prep_stmt)
#define LUA_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_lua_ ## x)
#define LUA_NO_OP_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_lua_no_op)
#define LUA_DDL_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_lua_any_ddl_stmt)
#define LUA_STD_DML_STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_lua_std_dml_exec_stmt)
#define LUA_FUNC_INIT(x) symtab_add(cg_funcs, # x, (void *)cg_lua_func_ ## x)
#define LUA_EXPR_INIT(x, func, str, pri_new) \
  static cg_lua_expr_dispatch expr_disp_ ## x = { func, str, pri_new }; \
  symtab_add(cg_exprs, k_ast_ ## x, (void *)&expr_disp_ ## x);

// Make a temporary buffer for the evaluation results using the canonical
// naming convention.  This might exit having burned some stack slots
// for its result variables, that's normal.
#define CG_LUA_PUSH_EVAL(expr, pri) \
CHARBUF_OPEN(expr##_value); \
cg_lua_expr(expr, &expr##_value, pri);

// Close the buffers used for the above.
// The scratch stack is not restored so that any temporaries used in
// the evaluation of expr will not be re-used prematurely.  They
// can't be used again until either the expression is finished,
// or they have been captured in a less-nested result variable.
#define CG_LUA_POP_EVAL(expr) \
CHARBUF_CLOSE(expr##_value);

// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers
// with the text needed to refer to the variable.  cg_scratch_var picks the name
// based on stack level-and type.
#define CG_LUA_PUSH_TEMP(name, sem_type) \
CHARBUF_OPEN(name); \
CHARBUF_OPEN(name##_value); \
cg_lua_scratch_var(NULL, sem_type, &name, &name##_value); \
lua_stack_level++;

// Release the buffers for the temporary, restore the stack level.
#define CG_LUA_POP_TEMP(name) \
CHARBUF_CLOSE(name##_value); \
CHARBUF_CLOSE(name); \
lua_stack_level--;

// Make a scratch variable to hold the final result of an evaluation.
// It may or may not be used.  It should be the first thing you put
// so that it is on the top of your stack.  This only saves the slot.
// If you use this variable you can reclaim other temporaries that come
// from deeper in the tree since they will no longer be needed.
#define CG_LUA_RESERVE_RESULT_VAR(ast, sem_type) \
int32_t lua_stack_level_reserved = lua_stack_level; \
sem_t sem_type_reserved = sem_type; \
ast_node *ast_reserved = ast; \
CHARBUF_OPEN(result_var); \
CHARBUF_OPEN(result_var_value); \
lua_stack_level++;

// If the result variable is going to be used, this writes its name and .value and into the outputs
#define CG_LUA_USE_RESULT_VAR() \
int32_t lua_stack_level_now = lua_stack_level; \
lua_stack_level = lua_stack_level_reserved; \
cg_lua_scratch_var(ast_reserved, sem_type_reserved, &result_var, &result_var_value); \
lua_stack_level = lua_stack_level_now; \
Invariant(result_var.used > 1); \
bprintf(value, "%s", result_var_value.ptr)

// Release the buffer holding the name of the variable.
// If the result variable was used, we can re-use any temporaries
// with a bigger number.  They're no longer needed since they
// are captured in this result.  We know it was used if it
// has .used > 1 (there is always a trailing null so empty is 1).
#define CG_LUA_CLEANUP_RESULT_VAR() \
if (result_var.used > 1) lua_stack_level = lua_stack_level_reserved + 1; \
CHARBUF_CLOSE(result_var_value); \
CHARBUF_CLOSE(result_var);

// This does reserve and use in one step
#define CG_LUA_SETUP_RESULT_VAR(ast, sem_type) \
CG_LUA_RESERVE_RESULT_VAR(ast, sem_type); \
CG_LUA_USE_RESULT_VAR();
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



cql_noexport void cg_json_schema_main(struct ast_node *root);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



// Entry point for cql query plan result type.
// The result type takes as an input a cql with one or many sql or cql statements
// It codegen a CQL stored proc that print out the query plan report of all
// elegible sql statement in the input. All sql statement are not eligible to
// run in an explain statement, this is the reason why we used in the previous
// sentence the word eligible.
// The query plan report contains:
//   - the target sql statement
//   - the list of algorithm used in the target sql statement
//   - the sequence of execution of the plan for the target sql statement

cql_noexport void cg_query_plan_main(struct ast_node *root);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



cql_noexport void cg_schema_main(struct ast_node *root);
cql_noexport void cg_schema_upgrade_main(struct ast_node *root);
cql_noexport void cg_schema_sqlite_main(struct ast_node *root);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */




// Entry point for cg_stats result time

// This type takes as input the AST and emits aggregated
// statistics about its AST shape on a per-proc basis in CSV form.
// This output help you to understand the nature of your procs

cql_noexport void cg_stats_main(struct ast_node *root);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



cql_noexport void cg_test_helpers_main(struct ast_node *root);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


cql_noexport char *_Nonnull Strdup(const char *_Nonnull s);
cql_noexport int32_t StrCaseCmp(const char *_Nonnull s1, const char *_Nonnull s2);
cql_noexport int32_t StrNCaseCmp(const char *_Nonnull s1, const char *_Nonnull s2, size_t n);
cql_noexport bool_t StrEndsWith(const char *_Nonnull haystack, const char *_Nonnull needle);

// On Windows, the normal versions of some of these function assert on non-ASCII
// characters when using a debug CRT library. These alternative versions allow
// us to avoid "ctype.h" entirely.
cql_noexport bool_t IsAlpha(char c);
cql_noexport bool_t IsDigit(char c);
cql_noexport bool_t IsLower(char c);
cql_noexport bool_t IsUpper(char c);
cql_noexport bool_t IsXDigit(char c);
cql_noexport char ToLower(char c);
cql_noexport char ToUpper(char c);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// minimal stuff goes here

#else


cql_noexport void rewrite_insert_list_from_shape(ast_node *_Nonnull ast, ast_node *_Nonnull from_shape, uint32_t count);
cql_noexport void rewrite_like_column_spec_if_needed(ast_node *_Nonnull columns_values);
cql_noexport void rewrite_from_shape_if_needed(ast_node *_Nonnull ast_stmt, ast_node *_Nonnull columns_values);
cql_noexport bool_t rewrite_col_key_list(ast_node *_Nullable ast);
cql_noexport ast_node *_Nonnull rewrite_gen_data_type(sem_t sem_type, CSTR _Nullable kind);
cql_noexport ast_node *_Nonnull rewrite_gen_full_column_list(sem_struct *_Nonnull sptr);
cql_noexport void rewrite_expr_names_to_columns_values(ast_node *_Nonnull columns_values);
cql_noexport void rewrite_select_stmt_to_columns_values(ast_node *_Nonnull columns_values);
cql_noexport void rewrite_empty_column_list(ast_node *_Nonnull columns_values, sem_struct *_Nonnull sptr);
cql_noexport void rewrite_iif(ast_node *_Nonnull ast);
cql_noexport bool_t rewrite_ast_star_if_needed(ast_node *_Nullable arg_list, ast_node *_Nonnull proc_name_ast);
cql_noexport bool_t rewrite_shape_forms_in_list_if_needed(ast_node *_Nullable arg_list);
cql_noexport void rewrite_cte_name_list_from_columns(ast_node *_Nonnull ast, ast_node *_Nonnull select_core);
cql_noexport void rewrite_params(ast_node *_Nullable head, bytebuf *_Nullable args_info);
cql_noexport void rewrite_typed_names(ast_node *_Nullable head);
cql_noexport void rewrite_data_type_if_needed(ast_node *_Nonnull ast);
cql_noexport void rewrite_right_col_def_type_attrs_if_needed(ast_node *_Nonnull ast);
cql_noexport void rewrite_nullable_to_notnull(ast_node *_Nonnull ast);
cql_noexport void rewrite_guard_stmt_to_if_stmt(ast_node *_Nonnull ast);
cql_noexport void rewrite_printf_inserting_casts_as_needed(ast_node *_Nonnull ast, CSTR _Nonnull format_string);
cql_noexport void rewrite_select_expr_list(ast_node *_Nonnull ast, sem_join *_Nullable jptr_from);
cql_noexport void rewrite_out_union_parent_child_stmt(ast_node *_Nonnull ast);
cql_noexport void rewrite_shared_fragment_from_backed_table(ast_node *_Nonnull backed_table);
cql_noexport void rewrite_select_for_backed_tables(ast_node *_Nonnull stmt, list_item *_Nonnull backed_tables_list);
cql_noexport void rewrite_reverse_apply(ast_node *_Nonnull head);
cql_noexport void rewrite_reverse_apply_polymorphic(ast_node *_Nonnull head);
cql_noexport void rewrite_insert_statement_for_backed_table(ast_node *_Nonnull ast, list_item *_Nullable backed_tables_list);
cql_noexport void rewrite_delete_statement_for_backed_table(ast_node *_Nonnull ast, list_item *_Nullable backed_tables_list);
cql_noexport void rewrite_update_statement_for_backed_table(ast_node *_Nonnull ast, list_item *_Nullable backed_tables_list);
cql_noexport void rewrite_upsert_statement_for_backed_table(ast_node *_Nonnull ast, list_item *_Nullable backed_tables_list);
cql_noexport void rewrite_func_call_as_proc_call(ast_node *_Nonnull ast);
cql_noexport void rewrite_array_as_call(ast_node *_Nonnull expr, CSTR _Nonnull new_name);
cql_noexport void rewrite_op_equals_assignment_if_needed(ast_node *_Nonnull expr, CSTR _Nonnull op);
cql_noexport void rewrite_append_arg(ast_node *_Nonnull call, ast_node *_Nonnull arg);
cql_noexport CSTR _Nonnull rewrite_type_suffix(sem_t sem_type);
cql_noexport void rewrite_dot_as_call(ast_node *_Nonnull dot, CSTR _Nonnull new_name);
cql_noexport ast_node *_Nonnull rewrite_column_values_as_update_list(ast_node *_Nonnull columns_values);
cql_noexport void rewrite_as_select_expr(ast_node *_Nonnull ast);
cql_noexport bool_t try_rewrite_op_as_call(ast_node *_Nonnull ast, CSTR _Nonnull op);
cql_noexport void rewrite_backed_column_references_in_ast(ast_node *_Nonnull root, ast_node *_Nonnull backed_table);
cql_noexport void rewrite_star_and_table_star_as_columns_calc(ast_node *_Nullable select_expr_list, sem_join *_Nonnull jptr);

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


cql_noexport rtdata *find_rtdata(CSTR name);
cql_noexport void rt_cleanup(void);
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// MIT license applies only to the extent that this file has been modified
// from the public domain version, which, as it happens, is barely at all.
//
// The original header with claritications from its github readme is
// included here including the public domain nature of the original code,
// and attribution to the original author.

/*********************************************************************
* Filename:   sha256.h
* Author:     Brad Conte (brad AT bradconte.com)
* Release:    This code is released into the public domain free of any
*             restrictions. The author requests acknowledgement if the
*             code is used, but does not require it.
*             This code is provided free of any liability and without
*             any quality claims by the author.
* Disclaimer: This code is presented "as is" without any guarantees.
* Details:    Defines the API for the corresponding SHA1 implementation.
*********************************************************************/

#ifndef SHA256_H
#define SHA256_H

/*************************** HEADER FILES ***************************/

/****************************** MACROS ******************************/
#define SHA256_BLOCK_SIZE 32            // SHA256 outputs a 32 byte digest

/**************************** DATA TYPES ****************************/
typedef uint8_t SHA256_BYTE;   // 8-bit byte
typedef uint32_t SHA256_WORD;   // 32-bit word (portable type)

typedef struct {
  SHA256_BYTE data[64];
  SHA256_WORD datalen;
  uint64_t bitlen;
  SHA256_WORD state[8];
} SHA256_CTX;

/*********************** FUNCTION DECLARATIONS **********************/
void sha256_init(SHA256_CTX *ctx);
void sha256_update(SHA256_CTX *ctx, const SHA256_BYTE data[], size_t len);
void sha256_final(SHA256_CTX *ctx, SHA256_BYTE hash[]);

#endif   // SHA256_H
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// minimal stuff goes here (none at this point)

#else

//
// A `printf_iterator` allows for analysis of SQLite printf format strings. It
// should be used in the following manner:
//
//   1. Allocate `sizeof_printf_iterator` bytes of memory.
//   2. Initialize it with `printf_iterator_init`.
//   3. Call `printf_iterator_next` to get the type of each substitution until
//      either `SEM_TYPE_OK` (indicating success and no more substitutions) or
//      `SEM_TYPE_ERROR` (indicating a problem with the format string).
//   4. Make no futher calls to `printf_iterator_next`.
//
// Attempts have been made to capture the vast majority of possible errors that
// can exist in a SQLite format string, including many "harmless" cases that
// could nevertheless be surprising or confusing. Certain features of SQLite
// format strings that do not make sense in the presence of CQL have been
// disallowed.
//


// The opaque type of the iterator.
typedef struct printf_iterator printf_iterator;

// To create a `printf_iterator`, allocate `sizeof_printf_iterator` bytes of
// memory and then call `printf_iterator_init` to initialize it.
extern size_t sizeof_printf_iterator;

// Initializes a `printf_iterator` with an optional `format_strlit` (used for
// reporting errors) and a decoded format string (i.e., the format string absent
// any surrounding quotes). This must be called before `printf_iterator_next`.
cql_noexport void printf_iterator_init(printf_iterator *iterator, ast_node *format_strlit, CSTR format_string);

// Attempts to parse the next substitution in the format string returning one
// of the following:
//
//   - A core type if a substitution was found:
//     - `SEM_TYPE_INTEGER`
//     - `SEM_TYPE_LONG_INTEGER`
//     - `SEM_TYPE_REAL`
//     - `SEM_TYPE_STRING`
//
//   - `SEM_TYPE_OK` if the format string was parsed successfully and no
//      substitutions remain.
//
//   - `SEM_TYPE_ERROR` if an error was encountered.
//
// In the lattermost two cases, parsing is finished and `printf_iterator_next`
// must not be called again.
cql_noexport sem_t printf_iterator_next(printf_iterator *iterator);

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


// Pushes a normal context that unsets all improvements made within it when it
// is popped. This should be used in most cases.
#define FLOW_PUSH_CONTEXT_NORMAL() \
  void *flow_context_normal; \
  _flow_push_context_normal();

// Pops a normal context.
#define FLOW_POP_CONTEXT_NORMAL() \
  (void)flow_context_normal; \
  _flow_pop_context_normal();

// Pushes a branch group context for an IF, CASE, et cetera.
#define FLOW_PUSH_CONTEXT_BRANCH_GROUP() \
  void *flow_context_branch_group; \
  _flow_push_context_branch_group();

// Pops a branch group context.
#define FLOW_POP_CONTEXT_BRANCH_GROUP() \
  (void)flow_context_branch_group; \
  _flow_pop_context_branch_group();

// Pushes a branch context. This must only be used within a branch group context
// and must be used for all branches within it. (For empty branches with no
// statements, one may use `flow_context_branch_group_add_empty_branch` instead
// of pushing and immediately popping a new branch context.)
#define FLOW_PUSH_CONTEXT_BRANCH() \
  void *flow_context_branch; \
  _flow_push_context_branch();

// Pops a branch context.
#define FLOW_POP_CONTEXT_BRANCH() \
  (void)flow_context_branch; \
  _flow_pop_context_branch();

// Pushes a jump context. This should be used for statement lists where control
// flow can jump to the end of the context (e.g., TRY via THROW (or a CALL
// containing a THROW), WHILE and LOOP via CONTINUE and LEAVE, et cetera). It
// should not be used for statement lists merely because of the possibility of
// an early RETURN: Jump contexts are specifically designed to safely manage
// the setting and unsetting of improvements *within* a procedure.
#define FLOW_PUSH_CONTEXT_JUMP() \
  void *flow_context_jump; \
  _flow_push_context_jump();

// Pops a jump context.
#define FLOW_POP_CONTEXT_JUMP() \
  (void)flow_context_jump; \
  _flow_pop_context_jump();

// Sets `flag` on `*type`. This must not be called if the flag is already set or
// if a flow context is not in effect.
cql_noexport void flow_set_flag_for_type(sem_t flag, sem_t *type);

// Un-sets `flag` on `*type`. This must not be called unless the flag is already
// set or if a flow context is not in effect.
cql_noexport void flow_unset_flag_for_type(sem_t flag, sem_t *type);

// Indicates that the current branch group context will (or does) contain a
// catch-all branch or otherwise covers all possible cases. This must only be
// called while the current flow context is a branch group context. If this is
// not called, it will be assumed that all cases are not covered.
cql_noexport void flow_set_context_branch_group_covers_all_cases(bool_t covers_all_cases);

// Adds an empty branch to the current branch group context. It is equivalent to
// `FLOW_PUSH_CONTEXT_BRANCH` immediately followed by `FLOW_POP_CONTEXT_BRANCH`
// and exists only for the sake of convenience.
cql_noexport void flow_context_branch_group_add_empty_branch();

// Records the fact that the current context *always* jumps until the end of the
// nearest enclosing jump context (if any) or any statement thereafter. If this
// is called when no jump context is in effect, it is assumed that the jump is
// to a statement beyond all current contexts (as is the case with a RETURN, or
// with a THROW with no enclosing TRY block).
//
// This function can be used in any context, but it only has an effect when the
// current context is a branch context. When the current context is a branch
// context, recording the fact that the branch always jumps may allow additional
// improvements to persist after the end of the enclosing branch group.
cql_noexport void flow_set_context_always_jumps(bool_t always_jumps);

cql_noexport void _flow_push_context_normal();
cql_noexport void _flow_pop_context_normal();
cql_noexport void _flow_push_context_branch_group();
cql_noexport void _flow_pop_context_branch_group();
cql_noexport void _flow_push_context_branch();
cql_noexport void _flow_pop_context_branch();
cql_noexport void _flow_push_context_jump();
cql_noexport void _flow_pop_context_jump();
// no extra .h files
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Assorted definitions for the CQL abstract syntax tree

#define AST_EMIT_DEFS 1


// uncomment for HEX
// #define AST_EMIT_HEX 1

// uncomment to check parent values as the ast is walked
// #define EMIT_BROKEN_AST_WARNING 1

// to print the AST with no echo of the source use
// the --ast_no_echo flag.  This is useful for debugging
// the AST itself.

cql_data_defn( minipool *ast_pool );
cql_data_defn( minipool *str_pool );
cql_data_defn( char *_Nullable current_file );
cql_data_defn( bool_t macro_expansion_errors );

static symtab *macro_table;
static symtab *macro_arg_table;
static symtab *macro_arg_type_from_ast_type;

typedef struct macro_state_t {
  CSTR name;
  CSTR file;
  int32_t line;
  struct macro_state_t *parent;
  symtab *args;
} macro_state_t;

static macro_state_t macro_state;
static CSTR expanding_proc;
static bool in_macro_args;
static int32_t current_macro_count;
static int32_t next_macro_count;

// Helper object to just hold info in find_attribute_str(...) and
// find_attribute_num(...)
typedef struct misc_attrs_type {
  CSTR attribute_name;
  void * context;
  find_ast_str_node_callback str_node_callback;
  find_ast_num_node_callback num_node_callback;
  bool_t presence_only;
  uint32_t count;
} misc_attrs_type;

#undef MACRO_INIT
#define MACRO_INIT(x) \
  symtab_add(macro_arg_type_from_ast_type, k_ast_ ## x ## _macro_ref, (void*)k_ast_ ## x ## _macro_arg); \
  symtab_add(macro_arg_type_from_ast_type, k_ast_ ## x ## _macro_arg_ref, (void*)k_ast_ ## x ## _macro_arg);

// initialization for the ast and macro expansion pass
cql_noexport void ast_init() {
  minipool_open(&ast_pool);
  minipool_open(&str_pool);
  macro_table = symtab_new();
  macro_arg_type_from_ast_type = symtab_new();
  delete_macro_formals();
  macro_expansion_errors = false;

  // this makes the table that tells us what kind of macro arg we should create
  // from the given kind of macro reference or node
  MACRO_INIT(expr);
  MACRO_INIT(stmt_list);
  MACRO_INIT(query_parts);
  MACRO_INIT(cte_tables);
  MACRO_INIT(select_core);
  MACRO_INIT(select_expr);
  MACRO_INIT(unknown);

  macro_state.line = -1;
  macro_state.file = "<Unknown>";
  macro_state.name = "None";
  macro_state.parent = NULL;
  expanding_proc = NULL;
  in_macro_args = false;
  current_macro_count = 0;
  next_macro_count = 1;
}

cql_noexport void ast_cleanup() {
  delete_macro_formals();
  SYMTAB_CLEANUP(macro_table);
  SYMTAB_CLEANUP(macro_arg_type_from_ast_type);
  minipool_close(&ast_pool);
  minipool_close(&str_pool);
  run_lazy_frees();
  expanding_proc = NULL;
}

// When a rewrite begins outside the context of normal parsing we do not know
// what file and line number should be attributed to the new nodes. This tells
// us what that line info should be.
cql_noexport void ast_set_rewrite_info(int32_t lineno, CSTR filename) {
  yylineno = lineno;
  current_file = (char *)filename;
}

// When we're done with a rewrite we do not want the old info to linger so it is
// immediately cleaned up. The macros assert that the state is clean.
cql_noexport void ast_reset_rewrite_info() {
  yylineno = -1;
  current_file = NULL;
}

// Any number node
cql_noexport bool_t is_ast_num(ast_node *node) {
  return node && (node->type == k_ast_num);
}

// The integer node is not for numeric integers in the grammar This is used
// where there is an enumeration of values like a join type that can be
// represented as an int.  We don't store numbers like this because it would
// require us to faithfully parse all the hard cases and since we're just going
// to re-emit them anyway it seems silly to avoid lossless encode and decode
// when we can just store the string. Hence this is not for numerics.
cql_noexport bool_t is_ast_int(ast_node *node) {
  return node && (node->type == k_ast_int);
}

// Any of the various string payloads
// * identifiers
// * string literals
// * quoted string literals
// * macro names
cql_noexport bool_t is_ast_str(ast_node *node) {
  return node && (node->type == k_ast_str);
}

// A blob literal, only valid in SQL contexts. We don't allow blob literals in
// other contexts because there is no way to emit such a literal without a
// runtime initializer which we aren't willing to do.
cql_noexport bool_t is_ast_blob(ast_node *node) {
  return node && (node->type == k_ast_blob);
}

// This is a quoted identifier `foo bar`
cql_noexport bool_t is_qid(ast_node *node) {
  return is_ast_str(node) && ((str_ast_node *)node)->str_type == STRING_TYPE_QUOTED_ID;
}

cql_noexport bool_t is_qname(CSTR subject) {
  return subject[0] == 'X' && subject[1] == '_' && strchr(subject+2, 'X');
}

// Any string literal (they are alway normalized to SQL format, 'xyz')
cql_noexport bool_t is_strlit(ast_node *node) {
  return is_ast_str(node) && ((str_ast_node *)node)->value[0] == '\'';
}

// Any normal identifier (could be `foo`)
cql_noexport bool_t is_id(ast_node *node) {
  return is_ast_str(node) && ((str_ast_node *)node)->value[0] != '\'';
}

// The root name types foo and foo.bar
cql_noexport bool_t is_id_or_dot(ast_node *node) {
  return is_id(node) || is_ast_dot(node);
}

// Any of the leaf types
cql_noexport bool_t is_primitive(ast_node *node) {
  return is_ast_num(node) || is_ast_str(node) || is_ast_blob(node) || is_ast_int(node);
}

// Any of the procedure types (create or declare)
cql_noexport bool_t is_proc(ast_node *node) {
  return is_ast_create_proc_stmt(node) || is_ast_declare_proc_stmt(node);
}

// Any of the region types
cql_noexport bool_t is_region(ast_node *ast) {
  return is_ast_declare_schema_region_stmt(ast) ||
         is_ast_declare_deployable_region_stmt(ast);
}

// Any of the select forms note that is_ast_select_nothing_stmt(ast) is not a
// a generally usable form so it can only appear in a few places and
// therefore is not included here.  It has to have its own checks in exactly
// those places.  In most places it simply won't do.
cql_noexport bool_t is_select_variant(ast_node *ast) {
  return is_ast_select_stmt(ast) ||
         is_ast_with_select_stmt(ast);
}

// These are all the things you could reasonably feed to a cursor or that
// might be a source of rows in a query in a procedure.  These can affect
// the return type of a procedure if they are "loose" in that procedure.
cql_noexport bool_t is_row_source(ast_node *ast) {
  // note that only insert and delete returning are supported at this time
  return is_ast_select_stmt(ast) ||
         is_ast_explain_stmt(ast) ||
         is_ast_select_nothing_stmt(ast) ||
         is_ast_upsert_returning_stmt(ast) ||
         is_ast_update_returning_stmt(ast) ||
         is_ast_insert_returning_stmt(ast) ||
         is_ast_delete_returning_stmt(ast) ||
         is_ast_with_select_stmt(ast);
}

// Any of the delete forms
cql_noexport bool_t is_delete_stmt(ast_node *ast) {
  return is_ast_delete_stmt(ast) ||
         is_ast_delete_returning_stmt(ast) ||
         is_ast_with_delete_stmt(ast);
}

// Any of the update forms
cql_noexport bool_t is_update_stmt(ast_node *ast) {
  return is_ast_update_stmt(ast) ||
         is_ast_update_returning_stmt(ast) ||
         is_ast_with_update_stmt(ast);
}

// Any of the update forms
cql_noexport bool_t is_upsert_stmt(ast_node *ast) {
  return is_ast_upsert_stmt(ast) ||
         is_ast_upsert_returning_stmt(ast) ||
         is_ast_with_upsert_stmt(ast);
}

// Any of the insert forms
cql_noexport bool_t is_insert_stmt(ast_node *ast) {
  return is_ast_insert_stmt(ast) ||
         is_ast_with_insert_stmt(ast) ||
         is_ast_insert_returning_stmt(ast) ||
         is_ast_upsert_stmt(ast) ||
         is_ast_with_upsert_stmt(ast);
}

// True if there is left node and it is not null
// This is handy for tree walks.  Primtives have
// and they are normally processed as ast_node *
// even though they are not.  They have effectively
// a common base type.  But left/right is not in it.
cql_noexport bool_t ast_has_left(ast_node *node) {
  if (is_primitive(node)) {
    return false;
  }
  return (node->left != NULL);
}

// As above, right node.
cql_noexport bool_t ast_has_right(ast_node *node) {
  if (is_primitive(node)) {
    return false;
  }
  return (node->right != NULL);
}

// Sets the right node but also sets the parent node of the node on the right to
// the new parent.  Always use this helper because code invariably forgets to
// set the parent causing a broken tree otherwise.
cql_noexport void ast_set_right(ast_node *parent, ast_node *right)  {
  parent->right = right;
  if (right) {
    right->parent = parent;
  }
}

// As above, left node.
cql_noexport void ast_set_left(ast_node *parent, ast_node *left) {
  parent->left = left;
  if (left) {
    left->parent = parent;
  }
}

// Create a new ast node witht he given left and right. Sets the file and line
// number from the global state. Sets the parent node of the provided children
// to the new node.
cql_noexport ast_node *new_ast(
  CSTR type,
  ast_node *left,
  ast_node *right)
{
  Contract(current_file && yylineno > 0);
  ast_node *ast = _ast_pool_new(ast_node);
  ast->type = type;
  ast->left = left;
  ast->right = right;
  ast->lineno = yylineno;
  ast->filename = current_file;
  ast->sem = NULL;

  if (left) left->parent = ast;
  if (right) right->parent = ast;

  return ast;
}

// Reflecting the fact that this is information about a fact in the AST and not
// a number it's called new_ast_option for option.
cql_noexport ast_node *new_ast_option(int32_t value) {
  Contract(current_file && yylineno > 0);
  int_ast_node *iast = _ast_pool_new(int_ast_node);
  iast->type = k_ast_int;
  iast->value = value;
  iast->lineno = yylineno;
  iast->filename = current_file;
  iast->sem = NULL;
  return (ast_node *)iast;
}

// Create a new string node for a string literal or identifier. These are sql
// literals by default so we use that string type.  The string is stored as is,
// no normalization is done.  This is important because we want to be able to
// round trip the string literals through the AST without losing any
// information.  The str_type might be changed after the node is created.
// Identifiers are stored as is, but quoted identifiers are escaped.
// Identifiers are not quoted.
cql_noexport ast_node *new_ast_str(CSTR value) {
  Contract(current_file && yylineno > 0);
  Contract(value);
  str_ast_node *sast = _ast_pool_new(str_ast_node);
  sast->type = k_ast_str;
  sast->value = value;
  sast->lineno = yylineno;
  sast->filename = current_file;
  sast->sem = NULL;
  sast->str_type = STRING_TYPE_SQL;
  return (ast_node *)sast;
}

// Create a new numeric node.  As discussed above the numeric is encoded in
// string form.  We do not even try to normalize it.  This is especially
// important for floating point literals.  We do not want to lose anything
// between the CQL code and the target compiler. We assume that floating point
// processing might be slightly different in C vs. SQLite or Lua.  Hence we keep
// the constant fixed.
cql_noexport ast_node *new_ast_num(int32_t num_type, CSTR value) {
  Contract(current_file && yylineno > 0);
  Contract(value);
  num_ast_node *nast = _ast_pool_new(num_ast_node);
  nast->type = k_ast_num;
  nast->value = value;
  nast->lineno = yylineno;
  nast->filename = current_file;
  nast->sem = NULL;
  nast->num_type = num_type;
  Contract(nast->value);
  return (ast_node *)nast;
}

// Creates a new blob literal.  As with numerics we
// simply store the text of the literal and pass it through.
cql_noexport ast_node *new_ast_blob(CSTR value) {
  Contract(current_file && yylineno > 0);
  str_ast_node *sast = _ast_pool_new(str_ast_node);
  sast->type = k_ast_blob;
  sast->value = value;
  sast->lineno = yylineno;
  sast->filename = current_file;
  sast->sem = NULL;
  return (ast_node *)sast;
}

// Get the compound operator name. As with almost all other aspects of the AST
// the AST is known to be good by contract and this is enforced.  Any badly
// formed AST is not tolerated anywhere which keeps it clean.
cql_noexport CSTR get_compound_operator_name(
  int32_t compound_operator)
{
  CSTR result = NULL;

  switch (compound_operator) {
    case COMPOUND_OP_EXCEPT:
      result = "EXCEPT";
      break;
    case COMPOUND_OP_INTERSECT:
      result = "INTERSECT";
      break;
    case COMPOUND_OP_UNION:
      result = "UNION";
      break;
    case COMPOUND_OP_UNION_ALL:
      result = "UNION ALL";
      break;
  }

  Invariant(result);
  return result;
}

// This converts C string literal syntax into SQL string literal syntax the test
// of the program expects the SQL style literals.  We support C style literals
// largely because they pass through the C pre-processor better. Even stuff like
// the empty string '' causes annoying warnings.  However the escaping is
// lightly different.  Also C string literals have useful escape sequences
cql_noexport CSTR convert_cstrlit(CSTR cstr) {
  CHARBUF_OPEN(decoded);
  CHARBUF_OPEN(encoded);
  cg_decode_c_string_literal(cstr, &decoded);
  cg_encode_string_literal(decoded.ptr, &encoded);

  CSTR result = Strdup(encoded.ptr);
  CHARBUF_CLOSE(encoded);
  CHARBUF_CLOSE(decoded);
  return result;
}

// Just like SQL string literal but we record that the origin of the string was
// the C format. When we decode this node we will format it in the C way.  But
// in the AST it's stored in the SQL way.
cql_noexport ast_node *new_ast_cstr(CSTR value) {
  value = convert_cstrlit(value);
  str_ast_node *sast = (str_ast_node *)new_ast_str(value);
  sast->str_type = STRING_TYPE_C;
  return (ast_node *)sast;
}

// This makes a new QID node starting from already escaped ID text.  So for
// instance `a b` is X_aX20b.  We do not escaped the text again or wrap it in
// quotes. We verify that it looks like escaped text.
cql_noexport ast_node *new_ast_qstr_escaped(CSTR value) {
  Contract(value);
  Contract(value[0] != '`');

  str_ast_node *sast = (str_ast_node *)new_ast_str(value);
  sast->str_type = STRING_TYPE_QUOTED_ID;
  return (ast_node *)sast;
}

// This makes a new QID node starting form the quoted identifier like `a b`.  We
// have to escape it first and then we store that name.  Lots of the code is
// oblivious to the fact that the id was escaped.  e.g. All the C  and Lua
// codegen correctly uses the escaped name and never deals with unescaping.
// This means the bulk of the compiler doesn't have to know about the escaping.
// The exceptions are the forgatting code in gen_sql and the ast building code
// in rewrite.c
cql_noexport ast_node *new_ast_qstr_quoted(CSTR value) {
  Contract(value);
  Contract(value[0] == '`');
  ast_node *result;

  CHARBUF_OPEN(encoded);
    cg_encode_qstr(&encoded, value);
    result = new_ast_qstr_escaped(Strdup(encoded.ptr));
  CHARBUF_CLOSE(encoded);

  return result;
}

// for indenting, it just holds spaces.
static char padbuffer[4096];

// Emits the value of the node if it is a leaf node. Returns true such a value
// was emitted.
cql_noexport bool_t print_ast_value(struct ast_node *node) {
  bool_t ret = false;

  if (is_ast_str(node)) {
    EXTRACT_STRING(str, node);

#ifdef AST_EMIT_HEX
    cql_output("%llx: ", (long long)node);
#endif
    cql_output("%s", padbuffer);
    if (is_strlit(node)) {
      cql_output("{strlit %s}", str);
    }
    else {
      if (is_qid(node)) {
        CHARBUF_OPEN(tmp);
          cg_decode_qstr(&tmp, str);
          cql_output("{name %s}", tmp.ptr);
        CHARBUF_CLOSE(tmp);
      }
      else {
        cql_output("{name %s}", str);
      }
    }
    ret = true;
  }

  if (is_ast_num(node)) {
#ifdef AST_EMIT_HEX
    cql_output("%llx: ", (long long)node);
#endif
    cql_output("%s", padbuffer);

    EXTRACT_NUM_TYPE(num_type, node);
    EXTRACT_NUM_VALUE(val, node);

    if (num_type == NUM_BOOL) {
      cql_output("{bool %s}", val);
    }
    else if (num_type == NUM_INT) {
      cql_output("{int %s}", val);
    }
    else if (num_type == NUM_LONG) {
      cql_output("{longint %s}", val);
    }
    else if (num_type == NUM_REAL) {
      cql_output("{dbl %s}", val);
    }
    ret = true;
  }

  if (is_ast_blob(node)) {
#ifdef AST_EMIT_HEX
    cql_output("%llx: ", (long long)node);
#endif
    EXTRACT_BLOBTEXT(value, node);
    cql_output("%s", padbuffer);
    cql_output("{blob %s}", value);
    ret = true;
  }

  if (is_ast_int(node)) {
#ifdef AST_EMIT_HEX
    cql_output("%llx: ", (long long)node);
#endif
    cql_output("%s", padbuffer);

    // The join type case is common enough that we have special code for it.
    // The rest are just formatted as a number.
    int_ast_node *inode = (int_ast_node *)node;
    cql_output("{int %lld}", (llint_t)inode->value);
    if (node->parent->type == k_ast_join_target) {
      CSTR out = NULL;
      switch (inode->value) {
        case JOIN_INNER:       out = "{join_inner}";       break;
        case JOIN_CROSS:       out = "{join_cross}";       break;
        case JOIN_LEFT_OUTER:  out = "{join_left_outer}";  break;
        case JOIN_RIGHT_OUTER: out = "{join_right_outer}"; break;
        case JOIN_LEFT:        out = "{join_left}";        break;
        case JOIN_RIGHT:       out = "{join_right}";       break;
      }
      Contract(out); // if this fails there is a bogus join type in the AST
      cql_output(" %s", out);
    }
    ret = true;
  }

  if (ret && node->sem) {
    cql_output(": ");
    print_sem_type(node->sem);
  }

  if (ret) {
    cql_output("\n");
  }

  return ret;
}

// Prints the node type and the semantic info if there is any
cql_noexport void print_ast_type(ast_node *node) {
  cql_output("%s", padbuffer);
  cql_output("{%s}", node->type);
  if (node->sem) {
    cql_output(": ");
    print_sem_type(node->sem);
  }
  cql_output("\n");
}

// Helper function to get the parameters node out of the ast for a proc.
cql_noexport ast_node *get_proc_params(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast) || is_ast_declare_proc_stmt(ast));
  // works for both
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  return params;
}

// Helper function to get the proc name from a declare_proc_stmt or
// create_proc_stmt
cql_noexport ast_node *get_proc_name(ast_node *ast) {
  if (is_ast_create_proc_stmt(ast)) {
    return ast->left;
  }

  Contract(is_ast_declare_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_name_type, ast->left);
  return proc_name_type->left;
}

cql_noexport bool_t is_select_func(ast_node *ast) {
  return is_ast_declare_select_func_no_check_stmt(ast) || is_ast_declare_select_func_stmt(ast);
}

cql_noexport bool_t is_non_select_func(ast_node *ast) {
  return is_ast_declare_func_no_check_stmt(ast) || is_ast_declare_func_stmt(ast);
}

// Helper function to get the parameters node out of the ast for a func.
cql_noexport ast_node *get_func_params(ast_node *ast) {
  Contract(is_select_func(ast) || is_non_select_func(ast));

  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT(params, func_params_return->left);
  return params;
}

// Helper function to extract the list of attribute.
// Walk through a misc_attrs node and call the callbacks :
//  - find_ast_misc_attr_callback if misc_attr node is found
// Let's take the example below and see what values will be passed to callbacks
// e.g:
//  [[foo=(baa, (name, 'nelly'))]]
//  [[base=raoul]]
//  create procedure sample()
//  begin
//    select * from baa;
//  end;
//
//  1- find_ast_misc_attr_callback("cql", "foo", <(baa, (name, 'nelly'))>, <context>)
//  2- find_ast_misc_attr_callback("cql", "foo", <raoul>, <context>)
//  3- End
cql_noexport void find_misc_attrs(
  ast_node *_Nullable ast_misc_attrs,
  find_ast_misc_attr_callback _Nonnull misc_attr_callback,
  void *_Nullable context)
{
  Contract(is_ast_misc_attrs(ast_misc_attrs));

  for (ast_node *misc_attrs = ast_misc_attrs; misc_attrs; misc_attrs = misc_attrs->right) {
    Invariant(is_ast_misc_attrs(misc_attrs));
    ast_node *misc_attr = misc_attrs->left;
    ast_node *misc_attr_key = misc_attr->left;
    ast_node *values = misc_attr->right;
    CSTR misc_attr_prefix = NULL;
    CSTR misc_attr_name = NULL;

    if (is_ast_dot(misc_attr_key)) {
      EXTRACT_STRING(prefix, misc_attr_key->left);
      EXTRACT_STRING(name, misc_attr_key->right);
      misc_attr_prefix = prefix;
      misc_attr_name = name;
    }
    else {
      EXTRACT_STRING(name, misc_attr_key);
      misc_attr_name = name;
    }

    Invariant(misc_attr_name);
    misc_attr_callback(misc_attr_prefix, misc_attr_name, values, context);
  }
}

// This callback helper dispatches matching string or list of string values for
// the indicated cql:attribute_name.  Non-string values are ignored in this
// path.  Note that the attribute might be badly formed hence there are few
// Contract enforcement here.  We can't crash if the value is unexpected we just
// don't recognize it as properly attributed for whatever (e.g. it just isn't a
// base fragment decl if it has an integer value for the fragment name)
static void ast_find_ast_misc_attr_callback(
  CSTR misc_attr_prefix,
  CSTR misc_attr_name,
  ast_node *ast_misc_attr_values,
  void *_Nullable context)
{
  misc_attrs_type* misc = (misc_attrs_type*) context;

  // First make sure that there is a prefix and name and that they match
  if (misc_attr_prefix &&
      misc_attr_name &&
      !StrCaseCmp(misc_attr_prefix, "cql") &&
      !StrCaseCmp(misc_attr_name, misc->attribute_name)) {

    // callback regardless of value, could be any payload
    if (misc->presence_only) {
      Invariant(!misc->str_node_callback);
      misc->count++;
      return;
    }

    // The attribute value might be a string or a list of strings.
    // Non-string, non-list attributes are ignored for this callback type
    if (is_ast_str(ast_misc_attr_values)) {
      if (misc->str_node_callback) {
        EXTRACT_STRING(value, ast_misc_attr_values);
        misc->str_node_callback(value, ast_misc_attr_values, misc->context);
      }
      misc->count++;
    }
    else if (is_ast_misc_attr_value_list(ast_misc_attr_values)) {
      for (ast_node *list = ast_misc_attr_values; list; list = list->right) {
        // any non-string values are ignored, loop over the rest calling on each string
        if (is_ast_str(list->left)) {
          EXTRACT_STRING(value, list->left);
          if (misc->str_node_callback) {
            misc->str_node_callback(value, list->left, misc->context);
          }
          misc->count++;
        }
      }
    }
    else if (is_ast_num(ast_misc_attr_values)) {
      if (misc->num_node_callback) {
        EXTRACT_NUM_VALUE(value, ast_misc_attr_values);
        misc->num_node_callback(value, ast_misc_attr_values, misc->context);
      }
    }
  }
}

// Helper function to extract the specified string type attribute (if any) from
// the misc attributes provided, and invoke the callback function
cql_noexport uint32_t find_attribute_str(
  ast_node *_Nonnull misc_attr_list,
  find_ast_str_node_callback _Nullable callback,
  void *_Nullable context,
  const char *attribute_name)
{
  Contract(is_ast_misc_attrs(misc_attr_list));

  misc_attrs_type misc = {
    .str_node_callback = callback,
    .context = context,
    .attribute_name = attribute_name,
    .count = 0,
  };

  find_misc_attrs(misc_attr_list, ast_find_ast_misc_attr_callback, &misc);
  return misc.count;
}

// check for the presence of the given attribute (duplicates are ok)
cql_noexport bool_t find_named_attr(
  ast_node *_Nonnull misc_attr_list,
  CSTR _Nonnull name)
{
  Contract(is_ast_misc_attrs(misc_attr_list));

  misc_attrs_type misc = {
    .presence_only = 1,
    .attribute_name = name,
    .count = 0,
  };

  find_misc_attrs(misc_attr_list, ast_find_ast_misc_attr_callback, &misc);
  return !!misc.count;
}

// Helper function to extract the specified number type attribute (if any) from
// the misc attributes provided, and invoke the callback function
cql_noexport uint32_t find_attribute_num(
  ast_node *_Nonnull misc_attr_list,
  find_ast_num_node_callback _Nullable callback,
  void *_Nullable context,
  const char *attribute_name)
{
  Contract(is_ast_misc_attrs(misc_attr_list));

  misc_attrs_type misc = {
    .num_node_callback = callback,
    .context = context,
    .attribute_name = attribute_name,
    .count = 0,
  };

  find_misc_attrs(misc_attr_list, ast_find_ast_misc_attr_callback, &misc);
  return misc.count;
}

// This callback helper tests only if the attribute matches the search condition
// the value is irrelevant for this type of attribute
static void ast_exists_ast_misc_attr_callback(
  CSTR misc_attr_prefix,
  CSTR misc_attr_name,
  ast_node *ast_misc_attr_values,
  void *_Nullable context)
{
  misc_attrs_type* misc = (misc_attrs_type*) context;

  // First make sure that there is a prefix and name and that they match
  if (misc_attr_prefix &&
      misc_attr_name &&
      !StrCaseCmp(misc_attr_prefix, "cql") &&
      !StrCaseCmp(misc_attr_name, misc->attribute_name)) {
          misc->count++;
  }
}

// Helper function to return count of given string type attribute in the misc
// attributes provided
cql_noexport uint32_t exists_attribute_str(
  ast_node *_Nullable misc_attr_list,
  CSTR attribute_name)
{
  misc_attrs_type misc = {
    .str_node_callback = NULL,
    .context = NULL,
    .attribute_name = attribute_name,
    .count = 0,
  };

  if (misc_attr_list) {
    Contract(is_ast_misc_attrs(misc_attr_list));
    find_misc_attrs(misc_attr_list, ast_exists_ast_misc_attr_callback, &misc);
  }

  return misc.count;
}

// Helper function to extract the ok_table_scan nodes (if any) from the misc attributes
// provided, and invoke the callback function.
cql_noexport uint32_t find_ok_table_scan(
  ast_node *_Nonnull list,
  find_ast_str_node_callback _Nonnull callback,
  void *_Nullable context)
{
  return find_attribute_str(list, callback, context, "ok_table_scan");
}

cql_noexport uint32_t find_query_plan_branch(
  ast_node *_Nonnull list,
  find_ast_num_node_callback _Nonnull callback,
  void *_Nullable context)
{
  return find_attribute_num(list, callback, context, "query_plan_branch");
}

// Helper function to extract the auto-drop nodes (if any) from the misc
// attributes provided, and invoke the callback function.
cql_noexport uint32_t find_autodrops(
  ast_node *_Nonnull list,
  find_ast_str_node_callback _Nonnull callback,
  void *_Nullable context)
{
  return find_attribute_str(list, callback, context, "autodrop");
}

// Helper function to extract the identity columns (if any) from the misc
// attributes provided, and invoke the callback function
cql_noexport uint32_t find_identity_columns(
  ast_node *_Nullable misc_attr_list,
  find_ast_str_node_callback _Nonnull callback,
  void *_Nullable context)
{
  return find_attribute_str(misc_attr_list, callback, context, "identity");
}

// Helper function to select out the cql:alias_of attribute This is really only
// interesting to C codegen.  It forces the compiler to emit an extra #define as
// well as the function prototype so that some common native function can
// implement several equivalent but perhaps different by CQL type external
// functions.
cql_noexport uint32_t find_cql_alias_of(
  ast_node *_Nonnull misc_attr_list,
  find_ast_str_node_callback _Nonnull callback,
  void *_Nullable context)
{
  return find_attribute_str(misc_attr_list, callback, context, "alias_of");
}

// Helper function to extract the blob storage node (if any) from the misc attributes
cql_noexport bool_t find_blob_storage_attr(ast_node *_Nonnull misc_attr_list)
{
  return find_named_attr(misc_attr_list, "blob_storage");
}

// Helper function to extract the backing table node (if any) from the misc attributes
cql_noexport uint32_t find_backing_table_attr(ast_node *_Nonnull misc_attr_list)
{
  return find_named_attr(misc_attr_list, "backing_table");
}

// Helper function to extract the backed table node (if any) from the misc attributes
cql_noexport uint32_t find_backed_table_attr(ast_node *_Nonnull misc_attr_list)
{
  return find_attribute_str(misc_attr_list, NULL, NULL, "backed_by");
}

// helper to look for the blob storage attribute
cql_noexport bool_t is_table_blob_storage(ast_node *ast) {
  Contract(is_ast_create_table_stmt(ast) || is_ast_create_virtual_table_stmt(ast));
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  return misc_attrs && find_blob_storage_attr(misc_attrs);
}

// helper to look for the backed table attribute
cql_noexport bool_t is_table_backed(ast_node *ast) {
  Contract(is_ast_create_table_stmt(ast) || is_ast_create_virtual_table_stmt(ast));
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  return misc_attrs && find_backed_table_attr(misc_attrs);
}

// helper to look for the backing table attribute
cql_noexport bool_t is_table_backing(ast_node *ast) {
  Contract(is_ast_create_table_stmt(ast) || is_ast_create_virtual_table_stmt(ast));
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  return misc_attrs && find_backing_table_attr(misc_attrs);
}

// This can be easily called in the debugger
cql_noexport void print_root_ast(ast_node *node) {
  print_ast(node, NULL, 0, false);
}

cql_noexport void print_ast(ast_node *node, ast_node *parent, int32_t pad, bool_t flip) {
  if (pad == 0) {
    padbuffer[0] = '\0';
  }

  if (!node) {
    return;
  }

// Verifies that the parent pointer is corrent
#ifdef EMIT_BROKEN_AST_WARNING
  if (ast_has_right(node) && node->right->parent != node) {
    cql_output("%llx ast broken right", (long long)node);
    broken(node);
  }

  if (ast_has_left(node) && node->left->parent != node) {
    cql_output("%llx ast broken left", (long long)node);
    broken(node);
  }
#endif

  if (print_ast_value(node)) {
    return;
  }

  if (is_ast_stmt_list(parent) && is_ast_stmt_list(node)) {
    print_ast(node->left, node, pad, !node->right);
    print_ast(node->right, node, pad, 1);
  }
  else {
    if (pad == 2) {
      if (parent && is_ast_stmt_list(parent)) {
        EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, parent);

        if (options.hide_builtins && misc_attrs && find_named_attr(misc_attrs, "builtin")) {
          return;
        }

        cql_output("\n");
        cql_output("The statement ending at line %d\n\n", node->lineno);
        gen_stmt_level = 1;

        if (misc_attrs) {
          gen_misc_attrs_to_stdout(misc_attrs);
        }

        if (!options.ast_no_echo) {
          gen_one_stmt_to_stdout(stmt);
          cql_output("\n");
        }

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)
        // sem off, nothing to print here
#else
        // print any error text
        if (stmt->sem && stmt->sem->sem_type == SEM_TYPE_ERROR && stmt->sem->error) {
          cql_output("%s\n", stmt->sem->error);
        }
#endif
      }
    }

#ifdef AST_EMIT_HEX
    cql_output("%llx: ", (long long)node);
#endif
    print_ast_type(node);
    if (flip && pad >= 2) {
      padbuffer[pad-2] = ' ';
    }
    if (pad == 0) {
      padbuffer[pad] = ' ';
    }
    else {
      padbuffer[pad] = '|';
    }
    padbuffer[pad+1] = ' ';
    padbuffer[pad+2] = '\0';
    print_ast(node->left, node, pad+2, !node->right);
    print_ast(node->right, node, pad+2, 1);
    padbuffer[pad] = '\0';
  }
}

// Recursively finds table nodes, executing the callback for each that is found.
// The callback will not be executed more than once for the same table name.
cql_noexport void continue_find_table_node(
  table_callbacks *callbacks,
  ast_node *node)
{
  // Check the type of node so that we can find the direct references to tables.
  // We can't know the difference between a table or view in the ast, so we will
  // need to later find the definition to see if it points to a
  // create_table_stmt to distinguish from views.

  find_ast_str_node_callback alt_callback = NULL;
  symtab *alt_visited = NULL;
  ast_node *table_or_view_name_ast = NULL;

  if (is_ast_cte_table(node)) {
    EXTRACT_ANY_NOTNULL(cte_body, node->right);

    // This is a proxy node, it doesn't contribute anything
    // any nested select does not run.
    if (is_ast_like(cte_body)) {
      return;
    }
  }
  else if (is_ast_shared_cte(node)) {
    // If we're on a shared CTE usage, then we recurse into the CALL and we
    // recurse into the binding list.  The CALL should not be handled like a
    // normal procedure call, the body is inlined.  Note that the existence of
    // the fragment is meant to be transparent to anyone downstream -- this
    // isn't a normal call that might be invisible to us we *must* have the
    // fragment because we're talking about a semantically valid shared cte
    // binding.

    EXTRACT_NOTNULL(call_stmt, node->left);
    EXTRACT(cte_binding_list, node->right);

    EXTRACT_NAME_AST(name_ast, call_stmt->left);
    EXTRACT_STRING(name, name_ast);
    ast_node *proc = find_proc(name);
    if (proc) {
      // Look through the proc definition for tables. Just call through recursively.
      continue_find_table_node(callbacks, proc);
    }

    if (cte_binding_list) {
      continue_find_table_node(callbacks, cte_binding_list);
    }

    // no further recursion is needed
    return;
  }
  else if (is_ast_declare_cursor_like_select(node)) {
    // There is a select in this declaration but it doesn't really run, it's just type info
    // so that doesn't count.  So we don't recurse here.
    return;
  }
  else if (is_ast_cte_binding(node)) {
    EXTRACT_ANY_NOTNULL(actual, node->left);

    // handle this just like a normal table usage in a select statement (because it is)
    table_or_view_name_ast = actual;
    alt_callback = callbacks->callback_from;
    alt_visited = callbacks->visited_from;
  }
  else if (is_ast_table_or_subquery(node)) {
    EXTRACT_ANY_NOTNULL(factor, node->left);
    if (is_ast_str(factor) || is_ast_at_id(factor)) {
      // the other table factor cases (there are several) do not have a string payload
      table_or_view_name_ast = factor;
      alt_callback = callbacks->callback_from;
      alt_visited = callbacks->visited_from;
    }
  }
  else if (is_ast_fk_target(node)) {
    // If we're walking a table then we'll also walk its FKs normally we don't
    // start by walking tables anyway so this doesn't run if you do a standard
    // walk of a procedure.
    if (callbacks->notify_fk) {
      EXTRACT_NAME_AST(name_ast, node->left);
      table_or_view_name_ast = name_ast;
    }
  }
  else if (is_ast_drop_view_stmt(node) || is_ast_drop_table_stmt(node)) {
    if (callbacks->notify_table_or_view_drops) {
      EXTRACT_NAME_AST(name_ast, node->right);
      table_or_view_name_ast = name_ast;
    }
  }
  else if (is_ast_trigger_target_action(node)) {
    if (callbacks->notify_triggers) {
      EXTRACT_NAME_AST(name_ast, node->left);
      table_or_view_name_ast = name_ast;
    }
  }
  else if (is_ast_delete_stmt(node)) {
    EXTRACT_NAME_AST(name_ast, node->left);
    table_or_view_name_ast = name_ast;
    alt_callback = callbacks->callback_deletes;
    alt_visited = callbacks->visited_delete;
  }
  else if (is_ast_insert_stmt(node)) {
    EXTRACT(name_columns_values, node->right);
    EXTRACT_NAME_AST(name_ast, name_columns_values->left);
    table_or_view_name_ast = name_ast;
    alt_callback = callbacks->callback_inserts;
    alt_visited = callbacks->visited_insert;
  }
  else if (is_ast_update_stmt(node)) {
    EXTRACT_ANY(name_ast, node->left);
    // name_ast node is NULL if update statement is part of an upsert statement
    if (name_ast) {
      table_or_view_name_ast = name_ast;
      alt_callback = callbacks->callback_updates;
      alt_visited = callbacks->visited_update;
    }
  }
  else if (is_ast_call_stmt(node) | is_ast_call(node)) {
    // Both cases have the name in the node left so we can consolidate the check
    // to see if it's a proc is redundant in the call_stmt case but it lets us
    // share code so we just go with it.  The other case is a possible
    // proc_as_func call so we must check if the target is a proc.

    EXTRACT_NAME_AST(name_ast, node->left);
    EXTRACT_STRING(name, name_ast);
    ast_node *proc = find_proc(name);

    if (proc) {
      // this only happens for ast_call but this check is safe for both
      if (name_ast->sem && (name_ast->sem->sem_type & SEM_TYPE_INLINE_CALL)) {
        // Look through the proc definition for tables because the target will
        // be inlined
        continue_find_table_node(callbacks, proc);
      }

      EXTRACT_STRING(canon_name, get_proc_name(proc));
      if (callbacks->callback_proc) {
        if (symtab_add(callbacks->visited_proc, canon_name, proc)) {
          callbacks->callback_proc(canon_name, proc, callbacks->callback_context);
        }
      }
    }
  }

  if (table_or_view_name_ast) {
    // Find the definition and see if we have a create_table_stmt.
    EXTRACT_STRING(table_or_view_name, table_or_view_name_ast);
    ast_node *table_or_view = find_table_or_view_even_deleted(table_or_view_name);

    // It's not actually possible to use a deleted table or view in a procedure.
    // If the name lookup here says that we found something deleted it means
    // that we have actually found a CTE that is an alias for a deleted table or
    // view. In that case, we don't want to add the thing we found to the
    // dependency set we are creating.  We don't want to make this CTE an error
    // because its reasonable to replace a deleted table/view with CTE of the
    // same name. Hence we simply filter out deleted tables/views here.
    if (table_or_view && table_or_view->sem->delete_version > 0) {
      table_or_view = NULL;
    }

    // Make sure we don't process a table or view that we've already processed.
    if (table_or_view) {
      if (is_ast_create_table_stmt(table_or_view)) {
        EXTRACT_NOTNULL(create_table_name_flags, table_or_view->left);
        EXTRACT_STRING(canonical_name, create_table_name_flags->right);

        // Found a table, execute the callback.
        if (symtab_add(callbacks->visited_any_table, canonical_name, table_or_view)) {
          callbacks->callback_any_table(canonical_name, table_or_view, callbacks->callback_context);
        }

        // Emit the second callback if any.
        if (alt_callback && symtab_add(alt_visited, canonical_name, table_or_view)) {
          alt_callback(canonical_name, table_or_view, callbacks->callback_context);
        }
      }
      else {
        Contract(is_ast_create_view_stmt(table_or_view));
        EXTRACT_NOTNULL(view_and_attrs, table_or_view->right);
        EXTRACT_NOTNULL(view_details_select, view_and_attrs->left);
        EXTRACT_NOTNULL(view_details, view_details_select->left);
        EXTRACT_STRING(canonical_name, view_details->left);

        if (symtab_add(callbacks->visited_any_table, canonical_name, table_or_view)) {
          // Report the view itself
          if (callbacks->callback_any_view) {
            callbacks->callback_any_view(canonical_name, table_or_view, callbacks->callback_context);
          }

          if (!callbacks->do_not_recurse_views) {
            // Look through the view definition for tables. Just call through recursively.
            continue_find_table_node(callbacks, table_or_view);
          }
        }
      }
    }
  }

  // Check the left and right nodes.
  if (ast_has_left(node)) {
    continue_find_table_node(callbacks, node->left);
  }

  if (ast_has_right(node)) {
    continue_find_table_node(callbacks, node->right);
  }
}

// Find references in a proc and invoke the corresponding callback on them
// this is useful for dependency analysis.
cql_noexport void find_table_refs(
  table_callbacks *callbacks,
  ast_node *node)
{
  // Each kind of callback needs its own symbol table because, for instance, you
  // might see a table as an insert and also as an update. If we use a single
  // visited table like we used to then the second kind of usage would not get
  // recorded.

  // Note: we don't need a seperate table for visiting views and visiting tables
  // any given name can only be a view or a table, never both.
  callbacks->visited_any_table = symtab_new();
  callbacks->visited_insert = symtab_new();
  callbacks->visited_update = symtab_new();
  callbacks->visited_delete = symtab_new();
  callbacks->visited_from = symtab_new();
  callbacks->visited_proc = symtab_new();

  continue_find_table_node(callbacks, node);

  if (callbacks->callback_final_processing) {
    callbacks->callback_final_processing(callbacks->callback_context);
  }

  SYMTAB_CLEANUP(callbacks->visited_any_table);
  SYMTAB_CLEANUP(callbacks->visited_insert);
  SYMTAB_CLEANUP(callbacks->visited_update);
  SYMTAB_CLEANUP(callbacks->visited_delete);
  SYMTAB_CLEANUP(callbacks->visited_from);
  SYMTAB_CLEANUP(callbacks->visited_proc);
}

cql_noexport size_t ends_in_cursor(CSTR str) {
  const char tail[] = " CURSOR";
  return StrEndsWith(str, tail) ? sizeof(tail) - 1 : 0;
}

cql_noexport size_t ends_in_set(CSTR str) {
  const char tail[] = " SET";
  return StrEndsWith(str, tail) ? sizeof(tail) - 1 : 0;
}

// store the discovered attribute in the given storage
static void record_string_value(
  CSTR _Nonnull name,
  ast_node *_Nonnull _misc_attr,
  void *_Nullable _context)
{
  if (_context) {
    CSTR *target = (CSTR *)_context;
    *target = name;
  }
}

// Helper function extracts the named string fragment and gets its value as a
// string. If there is no such attribute or the attribute is not a string, you
// get NULL.
cql_noexport CSTR get_named_string_attribute_value(
  ast_node *_Nonnull misc_attr_list,
  CSTR _Nonnull name)
{
  CSTR result = NULL;
  find_attribute_str(misc_attr_list, record_string_value, &result, name);
  return result;
}

// Copy the whole tree recursively
cql_noexport ast_node *ast_clone_tree(ast_node *_Nullable ast) {
  if (!ast) {
     return NULL;
  }
  else if (is_ast_num(ast)) {
    num_ast_node *nast = _ast_pool_new(num_ast_node);
    *nast = *(num_ast_node *)ast;
    return (ast_node*)nast;
  }
  else if (is_ast_str(ast) || is_ast_blob(ast)) {
    str_ast_node *sast = _ast_pool_new(str_ast_node);
    *sast = *(str_ast_node *)ast;
    return (ast_node*)sast;
  }
  else if (is_ast_int(ast)) {
    int_ast_node *iast = _ast_pool_new(int_ast_node);
    *iast = *(int_ast_node *)ast;
    return (ast_node*)iast;
  }
  ast_node *_ast = _ast_pool_new(ast_node);
  *_ast = *ast;
  ast_set_left(_ast, ast_clone_tree(ast->left));
  ast_set_right(_ast, ast_clone_tree(ast->right));
  return _ast;
}

// a new macro body context has happened, clear the existing context and make a
// new symbol table for macro arguments.  This will be the x! and y! in
// @macro(expr) foo!(x! expr, y! expr)
cql_noexport void new_macro_formals() {
  delete_macro_formals();
  macro_arg_table = symtab_new();
}

// The macro body has ended, clean the symbol table
cql_noexport void delete_macro_formals() {
  SYMTAB_CLEANUP(macro_arg_table);
}

// A new macro definition has appeared we need to record:
//  * The name
//  * The type
//  * the ast node of the body
// The name in the table will be foo! so we add the ! to the symbol name
// From this point on foo! will resolve to a macro so it's not possible
// to redeclare foo! -- any such attempt will not look like an indentifer
// followed by a macro name.
cql_noexport bool_t set_macro_info(CSTR name, int32_t macro_type, ast_node *ast) {
  macro_info *minfo = _ast_pool_new(macro_info);
  minfo->def = ast;
  minfo->type = macro_type;
  minfo->count_context = -1;  // this will never be used

  return symtab_add(macro_table, name, minfo);
}

// Recover the macro info given the name (if it exists).
cql_noexport macro_info *get_macro_info(CSTR name) {
  symtab_entry *entry = symtab_find(macro_table, name);
  return entry ? (macro_info *)(entry->val) : NULL;
}

// As above, but for macro arguments.  These are the formal arguments of any
// macro. The processing is the same except that it goes in a different table.
// Duplicates lead to errors.
cql_noexport bool_t set_macro_arg_info(
  CSTR name, int32_t macro_type,
  ast_node *ast)
{
  macro_info *minfo = _ast_pool_new(macro_info);
  minfo->def = ast;
  minfo->type = macro_type;
  minfo->count_context = current_macro_count;
  return symtab_add(macro_arg_table, name, minfo);
}

// Recover the macro info given the name (if it exists).
cql_noexport macro_info *get_macro_arg_info(CSTR name) {
  symtab_entry *entry = symtab_find(macro_arg_table, name);
  return entry ? (macro_info *)(entry->val) : NULL;
}

cql_noexport bool_t is_any_macro_ref(ast_node *ast) {
  return is_macro_ref(ast) || is_macro_arg_ref(ast);
}

cql_noexport bool_t is_macro_ref(ast_node *ast) {
  return ast && StrEndsWith(ast->type, "_macro_ref");
}

cql_noexport bool_t is_macro_arg_ref(ast_node *ast) {
  return ast && StrEndsWith(ast->type, "_macro_arg_ref");
}

cql_noexport bool_t is_macro_def(ast_node *ast) {
  return ast && StrEndsWith(ast->type, "_macro_def");
}

cql_noexport bool_t is_macro_arg_type(ast_node *ast) {
  return ast && StrEndsWith(ast->type, "_macro_arg");
}

// Look for the name first as an argument and then as a macro body.
cql_noexport int32_t resolve_macro_name(CSTR name) {
  macro_info *minfo;
  if (macro_arg_table) {
    minfo = get_macro_arg_info(name);
    if (minfo) {
      return minfo->type;
    }
  }
  minfo = get_macro_info(name);
  return minfo ? minfo->type : EOF;
}

// A new macro is being defined. We need to add the types of all of the
// parameter formals into the parameter table
cql_noexport CSTR install_macro_args(ast_node *macro_formals) {
  new_macro_formals();
  for ( ; macro_formals; macro_formals = macro_formals->right) {
    Contract(is_ast_macro_formals(macro_formals));
    EXTRACT_NOTNULL(macro_formal, macro_formals->left);

    EXTRACT_STRING(name, macro_formal->left);
    EXTRACT_STRING(type, macro_formal->right);

    // these are the only two cases for now
    int32_t macro_type = macro_type_from_str(type);
    bool_t success = set_macro_arg_info(name, macro_type, macro_formal);
    if (!success) {
      return name;
    }
  }

  return NULL;
}

// Replaces the new node for the old node in the tree by swapping it in as the
// child of the old node's parent. This isn't the preferred way to do node
// swapping, we normally wish to avoid changing the identify of the current node
// so in rewrite.c we almost always do old->type = new->type and then change the
// left and right but in this case it's normal, even common, for the node type
// to change to one of the leaf types and they are different sizes so we have to
// use the more general mechanism. This means we might have to refetch
// parent->left or right to get the new value of the node.
cql_noexport void replace_node(ast_node *_Nonnull old, ast_node *_Nonnull new) {
  if (old->parent->left == old) {
   ast_set_left(old->parent, new);
  }
  else {
   ast_set_right(old->parent, new);
  }
}

// This is the trickier macro expansion case.  It happens for all
// the list types. Let's make it concrete by discussing it for
// statements and statement lists.  The grammar allows a statement
// list macro to appear anywhere a statement can appear.  Statements
// always happen inside of statement lists.  It sort of has to be
// that way because you want these to all work:
//
// while true         while true        while true
// begin              begin             begin
//   foo!();            other stuff;      foo!();
//   other stuff;       foo!();         end;
// end;               end;
//
// So basically the statement macro which is itself a list
// is in the tree where a statement belongs.  Let's make a quick picture:
//
// stmt_list[1]  <--- "parent" arg points here
//   macro!
//   stmt_list[2]  --> this could be nulll
//     other_stuff
//     NULL;
//
// After macro! is expanded we get this picture:
//
//     stmt_list[3]
//       macro_body[1]
//       stmt_list [4]  --> this could be nulll
//         macro_body[2]
//         NULL         --> final right pointer must link in
//
// We need to thread these together
// where macro! was in the tree macro_body[1] must go
// stmt_list[1]->right must be changed to point to stmt_list[4]
// The final right pointer (stmt_list[4] in this case) must
// point to stmt_list[2] to continue the chain.  The first left node
// of the body must become the first left node of the existing parent.
//
// This (which never actually fully exists)
//
// stmt_list[1]  <--- "parent" arg points here
//     stmt_list[3]
//       macro_body[1]
//       stmt_list [4]  --> this could be nulll
//         macro_body[2]
//         NULL         --> final right pointer must link in
//   stmt_list[2]  --> this could be nulll
//     other_stuff
//     NULL;
//
// Becomes:
//
// stmt_list[1]  <--- "parent" arg points here
//   macro_body[1]
//   stmt_list [4]  --> this could be nulll
//     macro_body[2]
//     stmt_list[2]  --> this could be nulll
//       other_stuff
//       NULL;
//
// i.e., it looks like an noraml statement list again.
// To do this we only need to change 3 pointers.
// As it happens, "it just works" even if some of those
// lists are abbreviated. For in stance maybe there is no
// stmt_list[4] or maybe there is no stmt_list[2].  These
// both just cut the list short just like they should.
//
// The same logic works for all the list types because they all
// have exactly the same shape.  In CQL, lists are a chain of right
// pointers with the payload on the left.
static bool_t spliced_macro_into_list(
  ast_node *parent,
  ast_node *new)
{
  // if it isn't one of the list types, don't use this method
  if (!(
    is_ast_stmt_list(new) ||
    is_ast_cte_tables(new) ||
    is_ast_select_core_list(new) ||
    is_ast_select_expr_list(new))) {
      return false;
  }

  if (is_macro_arg_type(parent)) {
    return false;
  }

  // OK we have something that is like a list node already and
  // it is located where an item should be.  We just need to
  // unwrap it.

  // insert the new item into the list
  ast_set_left(parent, new->left);

  // march to the end of the "new" list
  ast_node *end = new;
  while (end->right) {
    end = end->right;
  }

  // link the end of the new list to what came after the new item
  ast_set_right(end, parent->right);
  ast_set_right(parent, new->right);
  return true;
}

// The arguments to @TEXT are either string literals, which we expand using the
// decode function or else they are macro pieces which we expand using
// gen_any_text_arg.  Either way they land unencoded into the output
// buffer.  The @TEXT handler will then quote them, the @ID handler will not.
static void expand_text_args(
  charbuf *output,
  ast_node *text_args)
{
  for (; text_args; text_args = text_args->right) {
    Contract(is_ast_text_args(text_args));
    EXTRACT_ANY_NOTNULL(txt, text_args->left);

    // string literals are handled specially because we need to
    // strip the quotes from them!
    if (is_strlit(txt)) {
      EXTRACT_STRING(str, txt);
      cg_decode_string_literal(str, output);
    }
    else {
      // everything else we just expand with the expressiohn formatter
      gen_sql_callbacks callbacks;
      init_gen_sql_callbacks(&callbacks);
      callbacks.mode = gen_mode_echo;
      gen_set_output_buffer(output);
      gen_with_callbacks(txt, gen_any_text_arg, &callbacks);
    }
  }
}

// Report a macro-related error at the given spot with the given message We walk
// up the chain of macro expansions and report all those too because macro
// debugging is hard without this info.
static void report_macro_error(
  ast_node *ast,
  CSTR msg,
  CSTR subj)
{
   cql_error("%s:%d:1: error: in %s : %s%s%s%s%s%s%s\n",
     ast->filename,
     ast->lineno,
     ast->type,
     msg,
     subj ? " (" : "",
     subj ? macro_type_from_name(subj) : "",
     subj ? ")" : "",
     subj ? " '" : "",
     subj,
     subj ? "'" : "");

  macro_state_t *p = &macro_state;
  while (p->parent) {
    cql_error(" -> '%s!' in %s:%d\n", p->name, p->file, p->line);
    p = p->parent;
  }

  if (expanding_proc) {
    cql_error(" -> in procedure %s\n", expanding_proc);
  }
  macro_expansion_errors = 1;
}

// for @MACRO_FILE -- this gives us the file in which macro expansion began.
// Very useful for assert macros and such. Note that @MACRO_FILE doesn't yet
// support path trimming like @FILE but it will.
static CSTR get_macro_file() {
  macro_state_t *p = &macro_state;
  macro_state_t *prev = p;
  while (p->parent) {
    prev = p;
    p = p->parent;
  }
  return prev->file;
}

// for @MACRO_LINE -- this gives us the line in which macro expansion began.
// Very useful for assert macros and such.
static int32_t get_macro_line() {
  macro_state_t *p = &macro_state;
  macro_state_t *prev = p;
  while (p->parent) {
    prev = p;
    p = p->parent;
  }
  return prev->line;
}

// @ID(x) will take a given string and covert it into an identifier. Which is to
// say it will decode the string and verify that it is a legal identifier.  This
// operation is only interesting if the body of the @ID is @TEXT.  Any other
// body wouldn't have needed wrapping in the first place.  On interesting trick
// you can do with @ID is this.   The "bar" in "foo.bar" is NOT an expression,
// it's only a name.  Therefore an EXPR macro cannot be used there.  i.e.
// foo.bar! doesn't work.  BUT foo.@ID(bar!) can work. Currently it has to be
// @ID(@TEXT(bar!)) but this will soon change.  @ID could assume the @TEXT if
// there is not one there.  @ID *is* a valid name so it can go in places expr!
// could not go.
static void expand_at_id(ast_node *ast) {
  Contract(is_ast_at_id(ast));

  expand_macros(ast->left);
  if (in_macro_args) {
    // Do not do any further expansion while we are in a macro arg context
    // things like @proc and so forth must wait.  All we do here is evaluate
    // the macro references and the macro arg references. @proc has to wait
    // because the macro args might not be in a procedure yet.
    return;
  }

  CHARBUF_OPEN(str);
  expand_text_args(&str, ast->left);

  CSTR p = str.ptr;
  bool_t ok = true;

  if (p[0] == '_' || (p[0] >= 'a' && p[0] <= 'z') || (p[0] >= 'A' && p[0] <= 'Z')) {
    p++;
    while (p[0]) {
      if (p[0] == '_' ||
         (p[0] >= 'a' && p[0] <= 'z') ||
         (p[0] >= 'A' && p[0] <= 'Z') ||
         (p[0] >= '0' && p[0] <= '9')) {
            p++;
           continue;
      }
      ok = false;
      break;
    }
  }
  else {
     ok = false;
  }

  if (!ok) {
    report_macro_error(ast, "CQL0085: @ID expansion is not a valid identifier", str.ptr);
  }

  ast_node *new = new_ast_str(Strdup(str.ptr));
  replace_node(ast, new);
  new->lineno = ast->lineno;
  new->filename = ast->filename;
  CHARBUF_CLOSE(str);
}

// Use the helper to concatenate the arguments then encode them as a string. We
// use C style literals because newlines etc. are likely in the output and so
// the resulting literal will be much more readable if it is escaped.
static void expand_at_text(ast_node *ast) {
  Contract(is_ast_macro_text(ast));

  expand_macros(ast->left);
  if (in_macro_args) {
    // Do not do any further expansion while we are in a macro arg context
    // things like @proc and so forth must wait.  All we do here is evaluate
    // the macro references and the macro arg references. @proc has to wait
    // because the macro args might not be in a procedure yet.
    return;
  }

  CHARBUF_OPEN(tmp);
  CHARBUF_OPEN(quote);

  expand_text_args(&tmp, ast->left);
  cg_encode_string_literal(tmp.ptr, &quote);
  ast_node *new = new_ast_str(Strdup(quote.ptr));
  str_ast_node *sast = (str_ast_node *)new;
  sast->str_type = STRING_TYPE_C;
  replace_node(ast, new);

  new->lineno = ast->lineno;
  new->filename = ast->filename;

  CHARBUF_CLOSE(quote);
  CHARBUF_CLOSE(tmp);
}

// Handles the special identifiers @MACRO_LINE and @MACRO_FILE which need
// treatment in the macro pass.  @FILE and @LINE to not require the macro stack
// so they can be handled later like all the other constants.
static void expand_special_ids(ast_node *ast) {
  Contract(is_ast_str(ast));
  EXTRACT_STRING(name, ast);

  // note that these were all normalized to uppercase in the parsing phase

  if (!strcmp(name, "@MACRO_LINE")) {
    ast_node *num = new_ast_num(NUM_INT, dup_printf("%d", get_macro_line()));
    replace_node(ast, num);
  }
  else if (!strcmp(name, "@MACRO_FILE")) {
    CHARBUF_OPEN(tmp);
    cg_encode_string_literal(get_macro_file(), &tmp);
    ((str_ast_node *)ast)->value = Strdup(tmp.ptr);
    CHARBUF_CLOSE(tmp);
  }
  else if (!strcmp(name, "@TMP")) {
    CHARBUF_OPEN(tmp2);
    bprintf(&tmp2, "tmp_%d", current_macro_count);
    ((str_ast_node *)ast)->value = Strdup(tmp2.ptr);
    CHARBUF_CLOSE(tmp2);
  }
  else if (!in_macro_args && !strcmp(name, "@PROC")) {
    // Do not do any further expansion while we are in a macro arg context
    // things like @proc and so forth must wait.  All we do here is evaluate
    // the macro references and the macro arg references. @proc has to wait
    // because the macro args might not be in a procedure yet.
    if (!expanding_proc) {
      report_macro_error(ast,
        "CQL0252: @PROC literal can only appear inside of procedures", "no proc");
      return;
    }

    ast_node *context = ast->parent;
    if (is_ast_savepoint_stmt(context) ||
        is_ast_release_savepoint_stmt(context) ||
        is_ast_rollback_trans_stmt(context)) {
      ((str_ast_node *)ast)->value = expanding_proc;  // a durable name already
      return;
    }

    // otherwise make a string literal
    CHARBUF_OPEN(tmp3);
    cg_encode_string_literal(expanding_proc, &tmp3);
    ((str_ast_node *)ast)->value = Strdup(tmp3.ptr);
    CHARBUF_CLOSE(tmp3);
  }
}

// Here we handle a discovered macro reference
// We have to do several things:
//  * clone the body of the macro or arg
//  * set up the macro arguments for expansion if it is a macro ref
//  * validate the arguments if necessary
//  * recursively expand the macro body
//  * link in the expanded body into the correct spot with one of the helpers
static void expand_macro_refs(ast_node *ast) {
  Contract(is_any_macro_ref(ast));
  EXTRACT_STRING(name, ast->left);

  ast_node *parent = ast->parent;

  // @TEXT and @ID take any macro, and the macro arg node is already checked when we
  // invoke the macros, so those are good universally, otherwise we check for context
  // for the macro types that can only appear in certain places
  if (!is_ast_text_args(parent) && !is_macro_arg_type(parent)) {
    bool wrong = false;

    // this tells us that the current macro is select_core
    bool_t select_core_macro = is_ast_select_core_macro_ref(ast) || is_ast_select_core_macro_arg_ref(ast);

    // this tell us that a select core macro can go there and only select core macros
    bool_t select_core_valid = is_ast_select_core_list(parent);

    // the location is ONLY valid for this macro type and this macro type is ONLY valid for this location
    // so if only one is true it's wrong.  If any are wrong it's an error
    wrong |= select_core_macro ^ select_core_valid;

    // these are all the other types

    bool_t stmt_list_macro = is_ast_stmt_list_macro_ref(ast) || is_ast_stmt_list_macro_arg_ref(ast);
    bool_t stmt_list_valid = is_ast_stmt_list(parent);
    wrong |= stmt_list_macro ^ stmt_list_valid;

    bool_t cte_tables_macro = is_ast_cte_tables_macro_ref(ast) || is_ast_cte_tables_macro_arg_ref(ast);
    bool_t cte_tables_valid = is_ast_cte_tables(parent);
    wrong |= cte_tables_macro ^ cte_tables_valid;

    bool_t select_expr_macro = is_ast_select_expr_macro_ref(ast) || is_ast_select_expr_macro_arg_ref(ast);
    bool_t select_expr_valid = is_ast_select_expr_list(parent);
    wrong |= select_expr_macro ^ select_expr_valid;

    // is_ast_update_from could work here but not supported in grammar yet
    // just || that in to the valid locations when it is supported
    bool_t query_parts_macro = is_ast_query_parts_macro_ref(ast) || is_ast_query_parts_macro_arg_ref(ast);
    bool_t query_parts_valid = is_ast_table_or_subquery(parent);
    wrong |= query_parts_macro ^ query_parts_valid;

    // having done all of those tests the only thing we didn't do was verify that the expr macro
    // appears where it belongs however we have now ruled out all macro insertion locations other
    // than the expr macro ones, which are legion. Anything other than an expr macro cannot appear
    // in other than its locked down locations and the locked down locations will not hold expr
    // macros so we have covered all locations.  This is why we check all the types and all
    // the locations every time.

    if (wrong) {
      report_macro_error(ast, "CQL0082: macro or argument used where it is not allowed", name);
      return;
    }
  }

  macro_info *minfo = NULL;
  bool_t is_ref = is_macro_ref(ast);

  // we have either a macro ref or a macro arg ref, nothing else can be here
  if (is_ref) {
    EXTRACT(macro_args, ast->right);

    // expand the arguments to the macro before using them, if there are any
    if (macro_args) {
      expand_macros(macro_args);
    }

    // get the info, we need the definition of this macro
    minfo = get_macro_info(name);
  }
  else {
    // get the info, we need the definition of this macro argument
    minfo = get_macro_arg_info(name);
  }

  // the macro was never defined, it's unknown...
  if (!minfo) {
    report_macro_error(ast, "CQL0083: macro reference is not a valid macro", name);
    return;
  }

  Invariant(minfo);
  ast_node *copy = ast_clone_tree(minfo->def);

  // the body is handing off the right if we copied a macro def
  // it's on the left if we copied a macro arg
  ast_node *body = is_ref ? copy->right : copy->left;

  // save the current args and stuff for our new context and for error
  // reporting...
  macro_state_t macro_state_saved = macro_state;

  if (is_ref) {
    // It's a macro reference, we need to set up the argument values
    // We'll save the current macro args and replace them with the
    // new after validation.  The type and number must be correct.
    EXTRACT_NOTNULL(macro_name_formals, minfo->def->left);
    EXTRACT(macro_formals, macro_name_formals->right);
    EXTRACT_STRING(macro_name, macro_name_formals->left);
    EXTRACT(macro_args, ast->right);

    // we're going to recurse, link up the states so we have a stack of them
    // these are like our frame pointers.  We also remember the local names
    // and so forth.  This gives us much better diagnostics
    macro_state.parent = &macro_state_saved;
    macro_state.line = ast->lineno;
    macro_state.file = ast->filename;
    macro_state.name = macro_name;
    macro_arg_table = macro_state.args = symtab_new();

    // Loop over each formal, we match the type of the argument
    // that is provided against the formal that is required.
    // The number arguments and type of arguments must match exactly.
    while (macro_formals && macro_args) {
      EXTRACT_NOTNULL(macro_formal, macro_formals->left);
      EXTRACT_STRING(formal_name, macro_formal->left);
      EXTRACT_ANY_NOTNULL(macro_arg, macro_args->left);
      EXTRACT_STRING(type, macro_formal->right);

      int32_t macro_type = macro_type_from_str(type);
      set_macro_arg_info(formal_name, macro_type, macro_arg);

      if (macro_arg_type(macro_arg) != macro_type) {
        report_macro_error(macro_arg, "CQL0086: macro type mismatch in argument", formal_name);
        goto cleanup;
      }

      macro_formals = macro_formals->right;
      macro_args = macro_args->right;
    }

    // formals left -> not enough args
    if (macro_formals) {
      report_macro_error(macro_formals->left, "CQL0087: not enough arguments to macro", macro_name);
      goto cleanup;
    }

    // args left -> too many args
    if (macro_args) {
      report_macro_error(macro_args->left, "CQL0087: too many arguments to macro", macro_name);
      goto cleanup;
    }
  }

  // This is subtle.  We have to remember the current macro count
  // because we're going to change it, fair enough, now recall that we
  // use this count to make unique names for the macro args.  There is
  // the internal variable @tmp that generates such a name.  Each
  // time we enter a new macro expansion, we upcount that variable
  // so that the next @tmp gets a new name.  So far so good.  Now considerr
  // this code:
  //
  //
  // macro(expr) two!(z! expr)
  // begin
  //   z! + z!
  // end;
  //
  // @macro(stmt_list) one!(x! expr, y! expr)
  // begin
  //   let @tmp(x) := x!;
  //   let @id(y!) := inner!(@tmp(x));
  // end;
  // 
  // one(expensive(100), zz)
  //
  // This must expand into:
  //
  // LET tmp_1x := expensive(100);
  // LET zz := tmp_1x + tmp_1x;
  //
  // Now the thing is the @TMP is going to be expanded inside of
  // `inner` and that will be a new macro context.  The body
  // of the macro argument x! which flows to z! must remember
  // that it was created in the context of `one` and not `two`.
  // This is why we have the count_context field in the macro_info.
  //
  // When we created the macro we saved the current count in the
  // count_context field.  Now we're going to change the count
  // to the saved value to evaluate that macro body now.
  //
  // Now if this isn't a macro argument, but another macro body
  // then we're in a new context and we upcount the macro count
  // as usual.  Note that we never restore next_macro_count,
  // it counts up inexorably and is never reset until the next
  // run.
    
  int32_t saved_macro_count = current_macro_count;

  if (is_ref) {
    // Macro reference, new macro count
    current_macro_count = next_macro_count++;
  }
  else {
    // macro argument, reuse saved count from arg's context
    current_macro_count = minfo->count_context;
  }

  // it's hugely important to expand what you're going to replace FIRST
  // and then slot it in. Otherwise the recursion is n^2 depth!!!
  expand_macros(body);

  current_macro_count = saved_macro_count;

  // its normal for body to have been replaced in the tree, we re-compute it
  // so that we get the expanded version.  Same rules as before
  body = is_ref ? copy->right : copy->left;

  // the query parts are already under a table_or_subquery node
  // because of the macro position, if there is a redundant one
  // in the arg tree, skip it.  We don't need two such wrappers
  // it makes extra (()) in the output
  if (is_ast_table_or_subquery_list(body) && body->right == NULL) {
    EXTRACT_NOTNULL(table_or_subquery, body->left);
    if (is_ast_join_clause(table_or_subquery->left) && table_or_subquery->right == NULL) {
      body = table_or_subquery->left;
    }
  }

  // now we splice the expanded tree into the place where the macro was

  if (is_ast_text_args(parent)) {
    // easy case, we just plunk in the node
    replace_node(ast, body);
  }
  else if (spliced_macro_into_list(parent, body)) {
    // spliced_macro_into_list, it's done above
    // this is where we have something like a statement
    // list but it's in the place where a statement should
    // go. We have to hoist the statement list node out
    // and link it into the statements. All the list
    // types have this issue and they all work the same.
  }
  else  {
    // everything else is a direct subtree replace
    replace_node(ast, body);
  }

cleanup:
  if (macro_state.args != macro_state_saved.args && macro_state.args) {
    // delete the args if we made new ones
    symtab_delete(macro_state.args);
  }

  // node that we cloned the current state so this is a no-op if
  // we didn't recurse.  But it makes the flow cleaner.
  macro_state = macro_state_saved;
  macro_arg_table = macro_state.args;
}

// Make a macro arg node of the correct type for the kind of macro_ref we have.
// This lets us do foo!(a!, b!, c!) without having to specify the arg type like
// we usually do.  So arg forwarding is easier.  Node that we do not use this
// helper to wrap an arg node.  We use it we need an arg type from an expression
// or a macro ref and we don't know which kind it is. That's sort of the whole
// point of this helper.  If the macro arg wrapping is explicit like
// ROWS(a_select_core) we wouldn't be here.
cql_noexport ast_node *new_macro_arg_node(ast_node *arg) {
  Contract(!is_macro_arg_type(arg));

  CSTR type = arg->type;
  CSTR node_type = k_ast_expr_macro_arg;
  symtab_entry *entry = symtab_find(macro_arg_type_from_ast_type, type);

  if (entry) {
    // expr_macro arguments are not wrapped so anything that
    // is unwrapped is an expr_macro_arg
    node_type = (CSTR)entry->val;
  }

  return new_ast(node_type, arg, NULL);
}

// This is the main recursive workhorse. It expands macros and macro related
// constructs in place. Later passes do not see macros except for the macro
// definition nodes. Which could actually have been removed also but we don't.
// Maybe we will some day. Later passes ignore those.
cql_export void expand_macros(ast_node *_Nonnull node) {

tail_recurse:
  if (!options.semantic && options.test && macro_state.line != -1) {
    // in test mode charge the whole macro to the expansion
    // so we can attribute the AST better
    node->lineno = macro_state.line;
  }

  if (is_ast_ifdef_stmt(node) || is_ast_ifndef_stmt(node)) {
    EXTRACT_ANY_NOTNULL(evaluation, node->left);
    EXTRACT_NOTNULL(pre, node->right);

    if (is_ast_is_true(evaluation)) {
       node = pre->left;
    }
    else {
       node = pre->right;
    }

    if (node)
      goto tail_recurse;
    return;
  }

  // do not recurse into macro definitions
  if (is_macro_def(node)) {
    return;
  }

  // handle @ID
  if (is_ast_at_id(node)) {
    expand_at_id(node);
    return;
  }

  // handle @TEXT
  if (is_ast_macro_text(node)) {
    expand_at_text(node);
    return;
  }

  // handle @MACRO_LINE and @MACRO_FILE
  if (is_ast_str(node)) {
    expand_special_ids(node);
    return;
  }

  // expand macros and macro arguments in place
  if (is_any_macro_ref(node)) {
    expand_macro_refs(node);
    return;
  }

  if (!in_macro_args && is_ast_macro_args(node)) {
    in_macro_args = true;
    if (ast_has_right(node)) {
      expand_macros(node->right);
    }
    if (ast_has_left(node)) {
      expand_macros(node->left);
    }
    in_macro_args = false;
    return;
  }

  // Do not tail recurse on create proc so that we can do the cleanup
  // after the proc is expanded.  This is here to reset the expanding_proc
  // variable.  That's it.
  if (is_ast_create_proc_stmt(node)) {
    // the name might be a macro, expand it first...
    expand_macros(node->left);

    // the @proc special id is valid inside the body
    EXTRACT_STRING(name, node->left);
    expanding_proc = name;
    expand_macros(node->right);
    expanding_proc = NULL;
    return;
  }

  // Check the left and right nodes.
  if (ast_has_left(node)) {
    // If there is no right child we can do tail recursion on the left
    // this helps a little but it isn't that important, the
    // next one is the one that really matters.  But there are lots of
    // AST1 nodes in the AST schema, this hits all of those.
    if (!ast_has_right(node)) {
      node = node->left;
      goto tail_recurse;
    }
    expand_macros(node->left);
  }

  // tail recursion here is super important becuase the statement list
  // and be very long and it is a chain of right pointers.  There might
  // be hundreds or even thousands of top level statements in a file.
  if (ast_has_right(node)) {
    // tail recursion
    node = node->right;
    goto tail_recurse;
  }
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


// The open operations simply zeros the buffer contents
cql_noexport void bytebuf_open(bytebuf *_Nonnull buf) {
  buf->max = 0;
  buf->ptr = 0;
  buf->used = 0;
}

// The close operation releases any allocated memory
// Note that bytebuf itself is most often on the stack so it's not freed
// if the bytebuf was allocated it's owned by whoever allocated it.
cql_noexport void bytebuf_close(bytebuf *_Nonnull buf) {
  free(buf->ptr);
  buf->max = 0;
  buf->ptr = NULL;
}

// This creates the needed space in the bytebuf, the buffer grows if it has to.
// The newly allocated memory begins with garbage data..
cql_noexport void *_Nonnull bytebuf_alloc(bytebuf *_Nonnull buf, uint32_t needed) {
  uint32_t avail = buf->max - buf->used;

  if (needed > avail) {
    buf->max += needed + BYTEBUF_GROWTH_SIZE;
    char *newptr = _new_array(char, buf->max);

    if (buf->used) memcpy(newptr, buf->ptr, buf->used);

    free(buf->ptr);
    buf->ptr = newptr;
  }

  void *result = buf->ptr + buf->used;
  buf->used += needed;
  return result;
}

// The most common operation is to append into an existing bytebuf, this is the alloc operation
// followed by a copy.  Callers often do other things like retain embedded pointers or whatnot
// but the bytebuf is below anything like that.
cql_noexport void bytebuf_append(bytebuf *_Nonnull buf, const void *_Nonnull bytes, uint32_t count) {
  void *mem = bytebuf_alloc(buf, count);
  memcpy(mem, bytes, count);
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Perform codegen of the various nodes to "C".

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_CG_C)

// stubs to avoid link errors.
cql_noexport void cg_c_main(ast_node *head) {}
cql_noexport void cg_c_init(void) {}
cql_noexport void cg_c_cleanup() {}

#else



static void cg_expr(ast_node *node, charbuf *is_null, charbuf *value, int32_t pri);
static void cg_stmt_list(ast_node *node);
static void cg_get_column(sem_t sem_type, CSTR cursor, int32_t index, CSTR var, charbuf *output);
static void cg_binary(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new);
static void cg_store_same_type(charbuf *output, CSTR var, sem_t sem_type, CSTR is_null, CSTR value);
static void cg_store(charbuf *output, CSTR var, sem_t sem_type_var, sem_t sem_type_expr, CSTR is_null, CSTR value);
static void cg_call_stmt_with_cursor(ast_node *ast, CSTR cursor_name);
static void cg_proc_result_set(ast_node *ast);
static void cg_var_decl(charbuf *output, sem_t sem_type, CSTR base_name, bool_t is_full_decl);
static void cg_emit_external_arglist(ast_node *expr_list, charbuf *prep, charbuf *invocation, charbuf *cleanup);
static void cg_call_named_external(CSTR name, ast_node *expr_list);
static void cg_user_func(ast_node *ast, charbuf *is_null, charbuf *value);
static void cg_copy(charbuf *output, CSTR var, sem_t sem_type_var, CSTR value);
static void cg_insert_dummy_spec(ast_node *ast);
static void cg_release_out_arg_before_call(sem_t sem_type_arg, sem_t sem_type_param, CSTR name);
static void cg_refs_offset(charbuf *output, sem_struct *sptr, CSTR offset_sym_name, CSTR struct_name);
static void cg_col_offsets(charbuf *output, sem_struct *sptr, CSTR sym_name, CSTR struct_name);
static void cg_declare_simple_var(sem_t sem_type, CSTR name);
static void cg_data_type(charbuf *output, sem_t sem_type);
cql_noexport uint32_t cg_statement_pieces(CSTR in, charbuf *output);

cql_noexport void cg_c_init(void);

// This lets us emit proc or func args and get back the state we need to continue
typedef struct {
   bool_t need_comma;   // do we need a comma before the next param
   charbuf *output;     // where does the output go
   ast_node *params;    // these are the formal parameters
   ast_node *arg_list;  // these are the actual arguments
} proc_params_info;

static void cg_emit_proc_params(proc_params_info *info);

// Emits a sql statement with bound args.  Returns temp statement index used if any
static int32_t cg_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_exec);

// These globals represent the major state of the code-generator

// True if we are presently emitting a stored proc
static bool_t in_proc = false;

// True if we presently declaring a variable group
static bool_t in_var_group_decl = false;

// True if we presently emitting  a variable group
static bool_t in_var_group_emit = false;

// True if we are in a loop (hence the statement might run again)
static int32_t cg_in_loop = LOOP_NONE;

// exports file if we are outputing exports
static charbuf *exports_output = NULL;

// The stack level, which facilitates safe re-use of scratch variables.
static int32_t stack_level = 0;

// Every string literal in a compiland gets a unique number.  This is it.
static int32_t string_literals_count = 0;

// Every output string piece gets unique number, the offset of the string in the frag buffer
// this tracks the biggest number we've seen so far.
static int32_t piece_last_offset = 0;

// Case statements might need to generate a unique label for their "else" code
// We count the statements to make an easy label
static int32_t case_statement_count = 0;

// We need a local to hold the (const char *) conversion of a string reference
// when calling out to external code. This gives each such temporary a unique name.
static int32_t temp_cstr_count = 0;

// This tells us if we needed a temporary statement to do an exec or prepare
// with no visible statement result.  If we emitted the temporary we have to
// clean it up.  Examples of this set x := (select 1);   or  DELETE from foo;
static bool_t temp_statement_emitted = false;

// This tells us if we have already emitted the declaration for the dummy data
// seed variable holder _seed_ in the current context.
static bool_t seed_declared;

// Each catch block needs a unique pair of labels, they are numbered.
static int32_t catch_block_count = 0;

// Each for loop needs a unique continue label, they are numbered.
static int32_t for_loop_count = 0;
static int32_t for_loop_cur = 0;

// Used to give us a clue about when it might be smart to emit diagnostic
// output but otherwise uninteresting.  We increment this on ever nested block.
cql_data_defn( int32_t stmt_nesting_level );

#define CQL_CLEANUP_DEFAULT_LABEL "cql_cleanup"

// In the event of a failure of a sql block or a throw we need to emit
// a goto to the current cleanup target. This is it.  Try/catch manipulate this.
static CSTR error_target = CQL_CLEANUP_DEFAULT_LABEL;

#define CQL_RCTHROWN_DEFAULT "SQLITE_OK"  // no variable at the root level, it's just "ok"
// When we need the most recent caught error code we have to use the variable that is
// holding the right value.  Each catch scope has its own corresponding to the error
// that it caught.

#define CQL_PROTO_NORMAL false
#define CQL_FORCE_FETCH_RESULTS true

static CSTR rcthrown_current = CQL_RCTHROWN_DEFAULT;
static int32_t rcthrown_index = 0;
static bool_t rcthrown_used = false;

// We set this to true when we have used the error target in the current context
// The current context is either the current procedure or the current try/catch
// block If this is true we need to emit the cleanup label.
static bool_t error_target_used = false;

// We set this to true if a "return" statement happened in a proc.  This also
// forces the top level "cql_cleanup" to be emitted.  We need a different flag
// for this because no matter how deeply nested we are "return" goes to the
// outermost error target. If this is set we will emit that top level target
// even if there were no other uses.
static bool_t return_used = false;

// String literals are frequently duplicated, we want a unique constant for each
// piece of text
static symtab *string_literals;

// Statement text pieces are frequently duplicated, we want a unique constant
// for each chunk of DML/DDL To avoid confusion with shared fragments and/or
// extension fragments we call the bits of text used to create SQL with the
// --compress option "pieces"
static symtab *text_pieces;

// When emitting procedure declarations we do not want duplicates Especially
// when recursing over referenced procedures via object<proc_name SET>
static symtab *emitted_proc_decls;

// The current shared fragment number in the current procdure
static int32_t proc_cte_index;

// This is the mapping between the original parameter name and the aliased name
// for a particular parameter of a particular shared CTE fragment
static symtab *proc_arg_aliases;

// This tells us if we are currently processing an inline fragment in which case
// we know there are no local variables only parameters and those have been
// remapped as part of the inlining process
static bool_t in_inline_function_fragment;

// This is the mapping between the original CTE and the aliased name
// for a particular parameter of a particular shared CTE fragment
static symtab *proc_cte_aliases;

// Shared fragment management state
// These are the important fragment classifications, we can use simpler codegen if
// some of these are false.
static bool_t has_conditional_fragments;
static bool_t has_shared_fragments;
static bool_t has_variables;

// Each prepared statement in a proc gets a unique index
static int32_t c_prepared_statement_index;

// Each bound statement in a proc gets a unique index
static int32_t cur_bound_statement;

// this holds the text of the generated SQL broken at fragment boundaries
static bytebuf shared_fragment_strings = {NULL, 0, 0};

// these track the current and max predicate number, these correspond 1:1 with a
// fragment string in the shared_fragment_strings buffer
static int32_t max_fragment_predicate = 0;
static int32_t cur_fragment_predicate = 0;

// These track the current variable count, we snapshot the previous count before
// generating each fragment string so we know how many variables were in there
// we use these to emit the appropriate booleans for each bound variable
static int32_t prev_variable_count;
static int32_t cur_variable_count;

// Emit the line directive, escape the file name using the C convention
static void cg_line_directive(CSTR filename, int32_t lineno, charbuf *output) {
  if (options.test || options.nolines) {
    return;
  }

  CHARBUF_OPEN(tmp);
  cg_encode_c_string_literal(filename, &tmp);
  bprintf(output, "#line %d %s\n", lineno, tmp.ptr);
  CHARBUF_CLOSE(tmp);
}

// Use the recursive search to emit the smallest line number in this subtree
static void cg_line_directive_min(ast_node *ast, charbuf *output) {
  int32_t lineno = cg_find_first_line(ast);
  cg_line_directive(ast->filename, lineno, output);
}

// The line number in the node is the last line number in the subtree because
// that is when the REDUCE operation happened when building the AST.
static void cg_line_directive_max(ast_node *ast, charbuf *output) {
  cg_line_directive(ast->filename, ast->lineno, output);
}

// The situation in CQL is that most statements, even single line statements,
// end up generating many lines of C.  So the normal situation is that you need
// to emit additional # directives to stay on the same line you were already on.
// In fact basically the situation is that you want to stay on your current line
// until the next time you see an explicit switch.  So what we do here is this:
//
// * when we see a # line directive  (e.g. # 32 "foo") we remember that line
// * if we are in a proc, emit the last such directive (just the line number) before each line
// * when we find an actual #line directive, we don't also emit the last known directive too
// * no additional outputs outside of procedures
// * we use the #define _PROC_ and #undef _PROC_ markers to know if we are in a proc
//
// Typical output:
//
// # 1 "foo.sql"
//
// /*
// CREATE PROC foo ()
// BEGIN
//   IF 1 THEN
//     CALL printf("one");
//   ELSE
//     CALL printf("two");
//   END IF;
// END;
// */
//
// #define _PROC_ "foo"
// # 1
// void foo(void) {
// # 3 "x"
//   if (1) {
// # 4 "x"
//     printf("one");
// # 4
//   }
// # 4
//   else {
// # 6 "x"
//     printf("two");
// # 6
//   }
// # 6
//
// # 6
// }
// #undef _PROC_
//
static void cg_insert_line_directives(CSTR input, charbuf *output)
{
   CHARBUF_OPEN(last_line_directive);
   CHARBUF_OPEN(line);

   CSTR start_proc = "#define _PROC_ "; // this marks the start of a proc
   size_t start_proc_len = strlen(start_proc);

   CSTR line_directive = "\x23line ";  // this marks the end of a proc
   size_t line_directive_len = strlen(line_directive);

   CSTR end_proc = "#undef _PROC_";  // this marks the end of a proc
   size_t end_proc_len = strlen(end_proc);

   // true between the markers above (i.e. in the text of a procedure)
   bool_t now_in_proc = false;

   // true immediately after we see something like # 32 "foo.sql" in the input
   bool_t suppress_because_new_directive = false;

   while (breadline(&line, &input)) {
      CSTR trim = line.ptr;
      while (*trim == ' ') trim++;

      if (!strncmp(trim, start_proc, start_proc_len)) {
        // entering a procedure, we will start to emit additional line
        // directives to stay on the same line
        bprintf(output, "%s\n", line.ptr);
        now_in_proc = true;
        continue;
      }
      else if (!strncmp(trim, end_proc, end_proc_len)) {
        // leaving a procedure, we will no longer emit additional line
        // directives to stay on the same line
        bprintf(output, "%s\n", line.ptr);
        now_in_proc = false;
        continue;
      }
      else if ((trim[0] == '#' && trim[1] == ' ') || !strncmp(trim, line_directive, line_directive_len)) {
        bclear(&last_line_directive);
        bprintf(&last_line_directive, "%s", trim);
        bprintf(output, "%s\n", last_line_directive.ptr);
        char* line_start = strchr(last_line_directive.ptr, ' ');
        char* next_space = strchr(line_start + 1, ' ');
        if (next_space) *next_space = '\0';

        // this prevents us from emitting the sequence
        // #line 32 "foo.sql"
        // #line 32
        // the second # 32 would be a waste...
        suppress_because_new_directive = true;
        continue;
      }

      if (last_line_directive.ptr[0] && !suppress_because_new_directive && now_in_proc) {
        // this forces us to stay on the current line until we explicitly switch
        // lines every line becomes
        // #line 32
        // [whatever]
        bprintf(output, "%s\n", last_line_directive.ptr);
      }

      suppress_because_new_directive = false;
      bprintf(output, "%s\n", line.ptr);
   }

  CHARBUF_CLOSE(line);
  CHARBUF_CLOSE(last_line_directive);
}

// return the symbol name for the string literal if there is one
static CSTR find_literal(CSTR str) {
  symtab_entry *entry = symtab_find(string_literals, str);
  return entry ? entry->val : NULL;
}

// The current proc name or null
static CSTR current_proc_name() {
  if (current_proc) {
    ast_node *proc_name_ast = get_proc_name(current_proc);
    EXTRACT_STRING(proc_name, proc_name_ast);
    return proc_name;
  }

  return NULL;
}

// Generate an error if the given expression is true (note this drives tracing)
static void cg_error_on_expr(CSTR expr) {
  bprintf(cg_main_output, "if (%s) { cql_error_trace(); goto %s; }\n", expr, error_target);
  error_target_used = true;
}

// Generate an error if the return code is not the required value
// (helper for common case)
static void cg_error_on_rc_notequal(CSTR required) {
  CHARBUF_OPEN(tmp);
  bprintf(&tmp, "_rc_ != %s", required);
  cg_error_on_expr(tmp.ptr);
  CHARBUF_CLOSE(tmp);
}

// Generate an error if the return code is not SQLITE_OK (helper for common case)
static void cg_error_on_not_sqlite_ok() {
  cg_error_on_expr("_rc_ != SQLITE_OK");
}

// This tells us if a subtree should be wrapped in ()
// Basically we know the binding strength of the context (pri) and the current
// element (pri_new) Weaker contexts get parens.  Equal contexts get parens on
// the right side because all ops are left to right associtive in SQL. Stronger
// child contexts never need parens because the operator already binds tighter
// than its parent in the tree.
static bool_t needs_paren(ast_node *ast, int32_t pri_new, int32_t pri) {
  // If the priorities are different then parens are needed if and only if the
  // new priority (this node) is weaker than the containing priority (the parent node)

  if (pri_new != pri) {
    return pri_new < pri;
  }

  // If equal binding strength, put parens on the right of the expression
  // because our entire world is left associative.
  //
  //  so e.g.  *(a, /(b,c)) becomes a*(b/c);

  return ast->parent->right == ast;
}

// We have a series of masks to remember if we have emitted any given scratch
// variable. We might need several temporaries at the same level if different
// types appear at the same level but in practice we tend not to run into such
// things.  Mostly this works very well at arranging for the same scratch
// nullable int (or whatever) to be re-used in every statement.  The stack depth
// is limited to bundles of 64bits with thisrepresentation. One bit for each
// stack level tracks if the temp has been generated.  This could be extended
// if needed...
typedef struct cg_type_masks {
  uint64_t reals[CQL_MAX_STACK/64];
  uint64_t bools[CQL_MAX_STACK/64];
  uint64_t ints[CQL_MAX_STACK/64];
  uint64_t longs[CQL_MAX_STACK/64];
  uint64_t strings[CQL_MAX_STACK/64];
  uint64_t objects[CQL_MAX_STACK/64];
  uint64_t blobs[CQL_MAX_STACK/64];
} cg_type_masks;

// There is one set of masks for nullables and another for not-nullables.
// The later doesn't get used very frequently...
typedef struct cg_scratch_masks {
  cg_type_masks nullables;
  cg_type_masks notnullables;
} cg_scratch_masks;

// Any new name context might need new temporaries, this points to the current
// context.  In practice it is set when we start processing a proc and it
// is cleared when we exit that proc.
static cg_scratch_masks *_Nullable cg_current_masks;

// Just like it sounds
static void cg_zero_masks(cg_scratch_masks *_Nonnull masks) {
  memset(masks, 0, sizeof(*masks));
}

// emit the type decl for the reference and the typeid if needed (msys only)
static void cg_result_set_type_decl(charbuf *output, CSTR sym, CSTR ref) {
  // The result type might be defined several times if a base fragment is
  // included in many outputs they are all equivalent so we guard them here.
  // For normal queries this doesn't happen because you only include the proc
  // once.  The other parts of the base fragment are idempotent to the compiler
  // so no need to guard those prototypes.  Indeed if they are different because
  // of a build problem, best to let the compiler complain.  If you generated
  // all the base fragments from the same proc they MUST be the same result so
  // errors in those parts are for sure build issues.

  bprintf(output, "#ifndef result_set_type_decl_%s\n", sym);
  bprintf(output, "#define result_set_type_decl_%s 1\n", sym);
  bprintf(output, "cql_result_set_type_decl(%s, %s);\n", sym, ref);

  // If the result type needs extra type info, let it do so.
  if (rt->result_set_type_decl_extra) rt->result_set_type_decl_extra(output, sym, ref);
  bprintf(output, "#endif\n");
}

// When emitting a variable reference, you might want the full local variable
// defintion or just the declaration parts as they would appear in a prototype.
#define CG_VAR_DECL_PROTO 0
#define CG_VAR_DECL_FULL 1

// When emitting parameters we might need to use aliased names
// for reference types that are mutated.  We only need to do this
// when emitting the primary proc definition
#define CG_PROC_PARAMS_NO_ALIAS 0
#define CG_PROC_PARAMS_IN_ALIAS 1

// Emit the nullability annotation for a BLOB, OBJECT, or TEXT variable.
static void cg_var_nullability_annotation(charbuf *output, sem_t sem_type) {
  Contract(is_ref_type(sem_type));

  if (is_out_parameter(sem_type) && !is_in_parameter(sem_type)) {
    // In the case of an OUT NOT NULL variable (but *not* an INOUT NOT NULL
    // variable), we annotate with _Nullable despite the NOT NULL because
    // purpose of calling the procedure is to initialize the location pointed to
    // with a value. Accordingly, the value at the location pointed to should be
    // NULL before the call. For example, `TEXT t OUT NOT NULL` should become
    // `cql_string_ref _Nullable *_Nonnull t`, whereas `TEXT t INOUT NOT NULL`
    // should become `cql_string_ref _Nonnull *_Nonnull t`.
    bprintf(output, "_Nullable ");
  }
  else if (is_not_nullable(sem_type)) {
    bprintf(output, "_Nonnull ");
  }
  else {
    bprintf(output, "_Nullable ");
  }
}

static void cg_emit_null_init(charbuf *output, bool_t is_full_decl) {
  if (is_full_decl) {
    bprintf(output, " = NULL");
  }
}

static void cg_emit_zero_init(charbuf *output, bool_t is_full_decl) {
  if (is_full_decl) {
    bprintf(output, " = 0");
  }
}

static void cg_emit_isnull_init(charbuf *output, bool_t is_full_decl) {
  if (is_full_decl) {
    bprintf(output, " = { .is_null = 1 }");
  }
}

// Emit a declaration for a local whose name is base_name and whose type is
// given by sem_type.   Is_local really only decides if we add ";\n" to the end
// of the output.  This lets us use the same helper for list of arg-prototypes
// as a list of declarations. The real "trick" here is:
//  * flags might say it's an output parameter in which case we declare a
//    pointer
//  * flags might indicate nullable, in which case we need the struct version
//  * text is always a reference, nullable or no.  But if you make a text local
//    then we also gotta clean it up.
//  * if the declaration is for a variable then we initialize the variable to 0,
//    or NULL as appropriate
static void cg_var_decl(charbuf *output, sem_t sem_type, CSTR base_name, bool_t is_full_decl) {
  Contract(is_unitary(sem_type) || is_cursor_formal(sem_type));
  Contract(!is_null_type(sem_type)); // null alias never gets here
  Contract(cg_main_output);

  sem_t core_type = core_type_of(sem_type);
  bool_t notnull = is_not_nullable(sem_type);

  CHARBUF_OPEN(name);
  if (is_out_parameter(sem_type)) {
    bprintf(&name, "*_Nonnull ");
  }
  bprintf(&name, "%s", base_name);

  switch (core_type) {
    case SEM_TYPE_CURSOR_FORMAL:
      bprintf(output, "cql_dynamic_cursor *_Nonnull %s", name.ptr);
      cg_emit_null_init(output, is_full_decl);
      break;

    case SEM_TYPE_INTEGER:
      if (notnull) {
        bprintf(output, "cql_int32 %s", name.ptr);
        cg_emit_zero_init(output, is_full_decl);
      }
      else {
        bprintf(output, "cql_nullable_int32 %s", name.ptr);
        cg_emit_isnull_init(output, is_full_decl);
      }
      break;

    case SEM_TYPE_TEXT:
      bprintf(output, "cql_string_ref ");
      if (!is_full_decl) {
        cg_var_nullability_annotation(output, sem_type);
      }
      bprintf(output, "%s", name.ptr);
      cg_emit_null_init(output, is_full_decl);
      if (is_full_decl) {
        bprintf(cg_cleanup_output, "  cql_string_release(%s);\n", name.ptr);
      }
      break;

    case SEM_TYPE_BLOB:
      bprintf(output, "cql_blob_ref ");
      if (!is_full_decl) {
        cg_var_nullability_annotation(output, sem_type);
      }
      bprintf(output, "%s", name.ptr);
      cg_emit_null_init(output, is_full_decl);
      if (is_full_decl) {
        bprintf(cg_cleanup_output, "  cql_blob_release(%s);\n", name.ptr);
      }
      break;

    case SEM_TYPE_OBJECT:
      bprintf(output, "cql_object_ref ");
      if (!is_full_decl) {
        cg_var_nullability_annotation(output, sem_type);
      }
      bprintf(output, "%s", name.ptr);
      cg_emit_null_init(output, is_full_decl);
      if (is_full_decl) {
        bprintf(cg_cleanup_output, "  cql_object_release(%s);\n", name.ptr);
      }
      break;

    case SEM_TYPE_LONG_INTEGER:
      if (notnull) {
        bprintf(output, "cql_int64 %s", name.ptr);
        cg_emit_zero_init(output, is_full_decl);
      }
      else {
        bprintf(output, "cql_nullable_int64 %s", name.ptr);
        cg_emit_isnull_init(output, is_full_decl);
      }
      break;

    case SEM_TYPE_REAL:
      if (notnull) {
        bprintf(output, "cql_double %s", name.ptr);
        cg_emit_zero_init(output, is_full_decl);
      }
      else {
        bprintf(output, "cql_nullable_double %s", name.ptr);
        cg_emit_isnull_init(output, is_full_decl);
      }
      break;

    case SEM_TYPE_BOOL:
      if (notnull) {
        bprintf(output, "cql_bool %s", name.ptr);
        cg_emit_zero_init(output, is_full_decl);
      }
      else {
        bprintf(output, "cql_nullable_bool %s", name.ptr);
        cg_emit_isnull_init(output, is_full_decl);
      }
      break;
  }

  if (is_full_decl) {
    bprintf(output, ";\n");
  }
  CHARBUF_CLOSE(name);
}

// Emits the correct _result_set_ref type based on the sem_type and kind the
// idea here is that we're generating the return type of a getter function and
// the getter is returning a result set.  The type kind will have the actual
// name of the procedure that originally created the result set.  The type will
// be something like OBJECT<Foo SET> -- we're going to use the "Foo" in the
// result set type as this corresponds to the result set that the "Foo"
// procedure creates.
static void cg_result_set_type_from_kind(charbuf *output, sem_t sem_type, CSTR kind) {
  CHARBUF_OPEN(temp);

  // pull out everything up to the leading space before " SET"
  CSTR p = kind;
  for (p = kind; *p != ' '; p++) {
    bputc(&temp, *p);
  }

  CG_CHARBUF_OPEN_SYM(result_set_ref, temp.ptr, "_result_set_ref");
    bprintf(output, "%s ", result_set_ref.ptr);
  CHARBUF_CLOSE(result_set_ref);

  CHARBUF_CLOSE(temp);

  cg_var_nullability_annotation(output, sem_type);
}

// We're looking for OBJECT<Foo SET>
static bool_t is_result_set_type(sem_t sem_type, CSTR kind) {
  return core_type_of(sem_type) == SEM_TYPE_OBJECT && kind && ends_in_set(kind);
}

// This helper generates results for function return types as the name
// indicates. The only thing that's going on here is that we would like the
// return type of the result reader functions to be the correct result set type
// if the return is of type object<procname SET>.   Normally the type kind does
// not affect codegen at all, integer<foo> and integer<bar> both generate
// integer types but in this case we're talking about a result set reader and
// the result set has in it sub result sets.  This is public C interface to to
// save everyone from doing the casting it happens automatically.
static void cg_col_reader_type(charbuf *output, sem_t sem_type, CSTR kind, CSTR base_name) {
  if (is_result_set_type(sem_type, kind)) {
    cg_result_set_type_from_kind(output, sem_type, kind);
    bprintf(output, "%s", base_name);
  }
  else {
    cg_var_decl(output, sem_type, base_name, CG_VAR_DECL_PROTO);
  }
}


// Sometimes when we need a scratch variable to store an intermediate result we
// can avoid the scratch variable entirely and use the target of the assignment
// in flight for the storage.  For instance:
//   declare x, y integer;
//   set y := 1;
//   set x := y + 3;
// generates:
//   cql_set_notnull(y, 1);
//   cql_set_nullable(x, y.is_null, y.value + 3);
//
// A scratch variable is not used to hold the result of the RHS of the set
// because the target of the assignment is known and compatible. The target must
// match the exact type including nullability.  Note bogus sensitive assignments
// or incompatible assignments were already ruled out in semantic analysis.
static bool_t is_assignment_target_reusable(ast_node *ast, sem_t sem_type) {
  if (ast && ast->parent && (is_ast_assign(ast->parent) || is_ast_let_stmt(ast->parent))) {
    EXTRACT_NAME_AST(name_ast, ast->parent->left);
    sem_t sem_type_target = name_ast->sem->sem_type;
    sem_type_target &= (SEM_TYPE_CORE | SEM_TYPE_NOTNULL);
    return sem_type_target == sem_type;
  }
  return false;
}

// The scratch variable helper uses the given sem_type and the current stack
// level to create a temporary variable name for that type at that level. If the
// variable does not already have a declaration (as determined by the masks)
// then a declaration is added to the scratch_vars section.  This is one of the
// root ways of getting an .is_null and .value back.  Note that not null
// variables always have a .is_null of "0" which becomes important when deciding
// how to assign one result to another.  Everything stays uniform.
static void cg_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *is_null, charbuf *value) {
  Contract(is_unitary(sem_type));
  Contract(!is_null_type(sem_type));

  sem_t core_type = core_type_of(sem_type);
  sem_type &= (SEM_TYPE_CORE | SEM_TYPE_NOTNULL);

  Contract(stack_level < CQL_MAX_STACK);

  // Try to avoid creating a scratch variable if we can use the target of an
  // assignment in flight.
  if (is_assignment_target_reusable(ast, sem_type)) {
    Invariant(ast && ast->parent && ast->parent->left);
    EXTRACT_NAME_AST(name_ast, ast->parent->left);
    EXTRACT_STRING(name, name_ast);
    if (is_out_parameter(name_ast->sem->sem_type)) {
      bprintf(var, "*%s", name);
    }
    else {
      bprintf(var, "%s", name);
    }
  }
  else {
    // Generate a scratch variable name of the correct type.  We don't generate
    // the declaration of any given scratch variable more than once.  We use the
    // current stack level to make the name.  This means that have to burn a
    // stack level if you want more than one scratch.  Stacklevel is normally
    // increased by the CG_PUSH_EVAL macro which does the recursion but it can
    // also be manually increased if temporaries are needed for some other
    // reason.  Any level of recursion is expected to fix all that.
    CSTR prefix;

    cg_type_masks *pmask;
    if (is_nullable(sem_type)) {
      pmask = &cg_current_masks->nullables;
      prefix = "_tmp_n";
    }
    else {
      pmask = &cg_current_masks->notnullables;
      prefix = "_tmp";
    }

    uint64_t *usedmask = NULL;

    switch (core_type) {
      case SEM_TYPE_INTEGER:
        bprintf(var, "%s_int_%d", prefix, stack_level);
        usedmask = pmask->ints;
        break;
      case SEM_TYPE_BLOB:
        bprintf(var, "%s_blob_%d", prefix, stack_level);
        usedmask = pmask->blobs;
        break;
      case SEM_TYPE_OBJECT:
        bprintf(var, "%s_object_%d", prefix, stack_level);
        usedmask = pmask->objects;
        break;
      case SEM_TYPE_TEXT:
        bprintf(var, "%s_text_%d", prefix, stack_level);
        usedmask = pmask->strings;
        break;
      case SEM_TYPE_LONG_INTEGER:
        bprintf(var, "%s_int64_%d", prefix, stack_level);
        usedmask = pmask->longs;
        break;
      case SEM_TYPE_REAL:
        bprintf(var, "%s_double_%d", prefix, stack_level);
        usedmask = pmask->reals;
        break;
      case SEM_TYPE_BOOL:
        bprintf(var, "%s_bool_%d", prefix, stack_level);
        usedmask = pmask->bools;
        break;
    }

    int32_t index = stack_level/64;
    uint64_t mask = ((uint64_t)1) << (stack_level % 64);

    // Emit scratch if needed.
    if (!(usedmask[index] & mask)) {
      cg_var_decl(cg_scratch_vars_output, sem_type, var->ptr, CG_VAR_DECL_FULL);
      usedmask[index] |= mask;
    }
  }

  // If the is_null and value expressions are desired, generate them here.
  if (is_null && value) {
    if (is_ref_type(sem_type)) {
      // note that because reference types begin initialized to null we have to
      // check their value even though they are "non-null" so the is_null
      // expression can't be 0 for these ever.
      bprintf(is_null, "!%s", var->ptr);
      bprintf(value, "%s", var->ptr);
    }
    else if (is_not_nullable(sem_type)) {
      bprintf(is_null, "0");
      bprintf(value, "%s", var->ptr);
    }
    else {
      bprintf(is_null, "%s.is_null", var->ptr);
      bprintf(value, "%s.value", var->ptr);
    }
  }
}

// This helper deals with one of the most common situations we have a nullable
// result that has to go into the result variable "var" and it's coming from one
// or two nullable sources.  The standard combine rules are that if eiter is
// null the result must be null.  However, some might be known to be not-null at
// compile time.  This function generates a call to the best runtime helper.  By
// doing it here all of the callers do not have to know all of the cases.  Here
// "val" is some arithmetic or logical combination of the values.
static void cg_combine_nullables(charbuf *out, CSTR var, CSTR l_is_null, CSTR r_is_null, CSTR val) {
  // generate the optimal set expression for the target nullable

  if (!strcmp(l_is_null, "1") || !strcmp(r_is_null, "1")) {
    // either known to be null, result is null
    bprintf(out, "cql_set_null(%s);\n", var);
  }
  else if (!strcmp(l_is_null, "0") && !strcmp(r_is_null, "0")) {
    // both known to be not null
    bprintf(out, "cql_set_notnull(%s, %s);\n", var, val);
  }
  else if (!strcmp(l_is_null, "0")) {
    // left known to be not null, null if right is null
    // Note: the target of the assignment is only compatible with the source, not identical
    // So the macro here generates the assignment field by field which gives free conversions.
    bprintf(out, "cql_set_nullable(%s, %s, %s);\n", var, r_is_null, val);
  }
  else if (!strcmp(r_is_null, "0")) {
    // right known to be not null, null if left is null
    // Note: the target of the assignment is only compatible with the source, not identical
    // So the macro here generates the assignment field by field which gives free conversions.
    bprintf(out, "cql_set_nullable(%s, %s, %s);\n", var, l_is_null, val);
  }
  else {
    // either could be null
    bprintf(out, "cql_combine_nullables(%s, %s, %s, %s);\n", var, l_is_null, r_is_null, val);
  }
}

// We pass this on to the general combine handler, letting it think the second
// operand was not null. There is of course no second operand.  We do this
// because one of the args might be a null literal or known not null for some
// other reason in which case we can make vastly simpler code.  That logic is
// already done in the above in the general case.  This call probably ends up in
// cg_set_nullable_nontrivial after the nullchecks are done.
static void cg_set_nullable(charbuf *out, CSTR var, CSTR is_null, CSTR value) {
  cg_combine_nullables(out, var, is_null, "0", value);
}

// Set nullable output type to null.  The only trick here is that reference
// types need the ref counting stuff.
// NOTE: there are lots of cases where even not-nullable ref types have to be
// set to null. These correspond to cases where the value is known to be
// uninitialized and we need to get something sane in there so that there isn't
// junk.  Or likewise where the value must become uninitialized because it's
// logically not readable anymore (e.g. in a cursor with no data). We have to
// free the data... so we have to set it to null... This is a bit weird but the
// alternative is some not-null sentinel constant string like the empty string
// which seems worse...
static void cg_set_null(charbuf *output, CSTR name, sem_t sem_type) {
  if (is_blob(sem_type)) {
    bprintf(output, "cql_set_blob_ref(&%s, NULL);\n", name);
  }
  else if (is_object(sem_type)) {
    bprintf(output, "cql_set_object_ref(&%s, NULL);\n", name);
  }
  else if (is_text(sem_type)) {
    bprintf(output, "cql_set_string_ref(&%s, NULL);\n", name);
  }
  else if (is_nullable(sem_type)) {
    bprintf(output, "cql_set_null(%s);\n", name);
  }
}

// Once we've done any type conversions for the basic types we can do pretty
// simple assignments The nullable non-reference types typically need of the
// helper macros unless it's an exact-type copy operation.  This function is
// used by cg_store near the finish line.
static void cg_copy(charbuf *output, CSTR var, sem_t sem_type_var, CSTR value) {
  if (is_ref_type(sem_type_var)) {
    // we will use one of the ref setters

    CSTR prefix = "&";
    if (var[0] == '*') {
      // this is just to avoid weird looking &*foo in the output which happens
      // when the target is an output variable
      var++;
      prefix = "";
    }

    if (is_text(sem_type_var)) {
      bprintf(output, "cql_set_string_ref(%s%s, %s);\n", prefix, var, value);
    }
    else if (is_blob(sem_type_var)) {
      bprintf(output, "cql_set_blob_ref(%s%s, %s);\n", prefix, var, value);
    }
    else if (is_object(sem_type_var)) {
      bprintf(output, "cql_set_object_ref(%s%s, %s);\n", prefix, var, value);
    }
  }
  else {
    bprintf(output, "%s = %s;\n", var, value);
  }
}

// Functions are a little special in that they can return reference types that
// come with a +1 reference.  To handle those you do not want to upcount the
// target. We release whatever we're holding and then hammer it with the new
// value with no upcount using the +1 we were given. These special set_created_*
// helper functions do exactly that.  Previously we tried it with ad hoc code
// which was all wrong.  It's important to not release the target of the copy
// early as the target may be needed in the call that did the create.
static void cg_copy_for_create(charbuf *output, CSTR var, sem_t sem_type_var, CSTR value) {
  CSTR prefix = "&";
  if (var[0] == '*') {
    // this is just to avoid weird looking &*foo in the output which happens
    // when the target is an output variable
    var++;
    prefix = "";
  }

  if (is_text(sem_type_var)) {
    bprintf(output, "cql_set_created_string_ref(%s%s, %s);\n", prefix, var, value);
  }
  else if (is_blob(sem_type_var)) {
    bprintf(output, "cql_set_created_blob_ref(%s%s, %s);\n", prefix, var, value);
  }
  else if (is_object(sem_type_var)) {
    bprintf(output, "cql_set_created_object_ref(%s%s, %s);\n", prefix, var, value);
  }
}

// This is most general store function.  Given the type of the destination and
// the type of the source plus the is_null and value of the source it generates
// the correct operation to set it.
// * if storing to a boolean from non-boolean first normalize the result to a 0 or 1
// * for text, emit cql_set_string_ref to do the job
// * for nullables use cg_set_nullable (see above) to do the job
// * for not-nullables x = y is all you need.
static void cg_store(charbuf *output, CSTR var, sem_t sem_type_var, sem_t sem_type_expr, CSTR is_null, CSTR value) {
  CHARBUF_OPEN(adjusted_value);
  CG_BEGIN_ADJUST_FOR_OUTARG(var, sem_type_var);

  // Normalize floats and bools for storage
  if (is_real(sem_type_var) && !is_real(sem_type_expr)) {
    bprintf(&adjusted_value, "(cql_double)(%s)", value);
    value = adjusted_value.ptr;
  }

  // Normalize bools for storage
  if (is_bool(sem_type_var) && !is_bool(sem_type_expr)) {
    // exclude some things that are already normalized
    if (strcmp("0", value) && strcmp("1", value) && value[0] != '!') {
      bprintf(&adjusted_value, "!!(%s)", value);
      value = adjusted_value.ptr;
    }
  }

  bool_t handled = false;

  // Check to see if we are trying to store a variable back on itself.
  // This happens when is_assignment_target_reusable let us use the target
  // of the assignment as the scratch variable.  When it comes time to
  // do the assignment we find there is now nothing to do.
  if (!is_nullable(sem_type_var) || is_ref_type(sem_type_var)) {
    // dead store -- source = target
    handled = !strcmp(var, value);
  }
  else {
    // In the nullable case the comparison is a bit trickier, we have to be
    // storing from var.value and var.is_null right back into var.value
    // and var.isnull.
    CHARBUF_OPEN(val);
    CHARBUF_OPEN(nul);
    bprintf(&val, "%s.value", var);
    bprintf(&nul, "%s.is_null", var);
    handled = !strcmp(val.ptr, value) && !strcmp(nul.ptr, is_null);
    CHARBUF_CLOSE(nul);
    CHARBUF_CLOSE(val);
  }

  if (handled) {
    // nothing left to do, assignment already happened
  }
  else if (is_ref_type(sem_type_var) || !is_nullable(sem_type_var)) {
    cg_copy(output, var, sem_type_var, value);
  }
  else {
    cg_set_nullable(output, var, is_null, value);
  }

  CG_END_ADJUST_FOR_OUTARG();
  CHARBUF_CLOSE(adjusted_value);
}

// This is a simple helper for store where we know that the type of the thing
// being stored is exactly the same as the type of the thing we are storing.
// This is used when we just made a temporary of exactly the correct type to
// hold an expression.  cg_store handles this all but this helper lets you
// specify only one type.
static void cg_store_same_type(charbuf *output, CSTR var, sem_t sem_type, CSTR is_null, CSTR value) {
  cg_store(output, var, sem_type, sem_type, is_null, value);
}

// This is the general helper for some kind of comparison.  In fact comparison
// for the numeric types is exactly like all the other binary operators so
// really this is here only to special case the code gen for text comparison.
// The passed in "op" is the operator between the left and right, so "<=", "<",
// etc.  String comparisons use the cql_string_compare helper to do the compare
// and the comparison is changed to be relative to zero.  So x <= y turns into
// cql_string_compare(x, y) <= 0.  If the arguments are not nullable, the
// comparison expression goes directly into value.  If the the result is
// nullable, it goes into a scratch var using the "combine" rules, see above.
static void cg_binary_compare(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_left = ast->left->sem->sem_type;
  sem_t sem_type_right = ast->right->sem->sem_type;

  bool_t is_text_op = is_text(sem_type_left) && is_text(sem_type_right);
  bool_t is_blob_op = is_blob(sem_type_left) && is_blob(sem_type_right);

  if (is_blob_op) {
    // we want to make sure blob is only supported for certain operation
    // even though we already have the semantic analysis for this.
    Invariant(is_ast_eq(ast) || is_ast_ne(ast));
  }

  if (!is_text_op && !is_blob_op) {
   // for numeric, the usual binary processing works
   cg_binary(ast, op, is_null, value, pri, pri_new);
   return;
  }

  // Both sides are text/blob or null; already verified compatible in semantic
  // phase.

  CHARBUF_OPEN(comparison);

  if (needs_paren(ast, pri_new, pri)) {
    bprintf(&comparison, "(");
  }

  ast_node *l = ast->left;
  ast_node *r = ast->right;

  CG_RESERVE_RESULT_VAR(ast, sem_type_result);
  CG_PUSH_EVAL(l, pri_new);
  CG_PUSH_EVAL(r, pri_new);

  if (is_ast_like(ast)) {
    // like not allowed semantically for blob type
    Invariant(!is_blob_op);
    bprintf(&comparison, "cql_string_like(%s, %s) == 0", l_value.ptr, r_value.ptr);
  }
  else if (is_ast_not_like(ast)) {
    // like not allowed semantically for blob type
    Invariant(!is_blob_op);
    bprintf(&comparison, "cql_string_like(%s, %s) != 0", l_value.ptr, r_value.ptr);
  }
  else if (is_blob_op) {
    bool_t logical_not = is_ast_ne(ast) || is_ast_is_not(ast);
    if (logical_not) {
      bprintf(&comparison, "%s", "!");
    }
    bprintf(&comparison, "cql_blob_equal(%s, %s)", l_value.ptr, r_value.ptr);
  }
  else {
    // otherwise other string comparisons
    bprintf(&comparison, "cql_string_compare(%s, %s) %s 0", l_value.ptr, r_value.ptr, op);
  }

  if (needs_paren(ast, pri_new, pri)) {
    bprintf(&comparison, ")");
  }

  if (is_not_nullable(sem_type_left) && is_not_nullable(sem_type_right)) {
    bprintf(value, "%s", comparison.ptr);
    bprintf(is_null, "0");
  }
  else {
    CG_USE_RESULT_VAR();
    cg_combine_nullables(cg_main_output, result_var.ptr, l_is_null.ptr, r_is_null.ptr, comparison.ptr);
  }

  CG_POP_EVAL(r);
  CG_POP_EVAL(l);
  CG_CLEANUP_RESULT_VAR();

  CHARBUF_CLOSE(comparison);
}

// Other than string comparison, all the normal (no short-circuit) binary operators
// can be handled the same way.
//   * op is the operator text
//   * is_null and value are the usual outputs
//   * pri is the strength of the caller
//   * pri_new is the strength of "op"
//
// The helper needs_paren() tells us if we should wrap this subtree in parens
// (see above) If the inputs are not nullable then we can make the easy case of
// returning the result in the value string (and 0 for is null).  Otherwise,
// cg_combine_nullables does the job.
static void cg_binary(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  // left op right

  ast_node *l = ast->left;
  ast_node *r = ast->right;

  sem_t sem_type_result = ast->sem->sem_type;

  if (sem_type_result == SEM_TYPE_NULL) {
    bprintf(value, "0");
    bprintf(is_null, "1");
    return;
  }

  sem_t sem_type_left = l->sem->sem_type;
  sem_t sem_type_right = r->sem->sem_type;

  // this hold the formula for the answer
  CHARBUF_OPEN(result);

  CG_RESERVE_RESULT_VAR(ast, sem_type_result);
  CG_PUSH_EVAL(l, pri_new);
  CG_PUSH_EVAL(r, pri_new);

  bprintf(&result, "%s %s %s", l_value.ptr, op, r_value.ptr);

  if (is_not_nullable(sem_type_left) && is_not_nullable(sem_type_right)) {
    if (needs_paren(ast, pri_new, pri)) {
      bprintf(value, "(%s)", result.ptr);
    }
    else {
      bprintf(value, "%s", result.ptr);
    }
    bprintf(is_null, "0");
  }
  else {
    // put result into result_var
    CG_USE_RESULT_VAR();
    cg_combine_nullables(cg_main_output, result_var.ptr, l_is_null.ptr, r_is_null.ptr, result.ptr);
  }

  CG_POP_EVAL(r);
  CG_POP_EVAL(l);
  CG_CLEANUP_RESULT_VAR();

  CHARBUF_CLOSE(result);
}

// This is the code gen for <expr> IS FALSE
// The operands are already known to be of the correct type so all we have to do is
// check for nullable or not nullable and generate the appropriate code using
// either the helper or just looking at the value.
static void cg_expr_is_false(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_false(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  sem_t sem_type_is_expr = expr->sem->sem_type;

  // expr IS FALSE
  bprintf(is_null, "0"); // the result of is false is never null

  // we always put parens because ! is the highest binding, so we can use ROOT,
  // the callee never needs parens
  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  if (is_nullable(sem_type_is_expr)) {
    bprintf(value, "cql_is_nullable_false(%s, %s)", expr_is_null.ptr, expr_value.ptr);
  }
  else {
    bprintf(value, "!(%s)", expr_value.ptr);
  }

  CG_POP_EVAL(expr);
}

// This is the code gen for <expr> IS NOT FALSE
// The operands are already known to be of the correct type so all we have to do is
// check for nullable or not nullable and generate the appropriate code using
// either the helper or just looking at the value.
static void cg_expr_is_not_false(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_not_false(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  sem_t sem_type_is_expr = expr->sem->sem_type;

  // expr IS NOT FALSE
  bprintf(is_null, "0"); // the result of is false is never null

  // we always put parens because ! is the highest binding, so we can use ROOT,
  // the callee never needs parens
  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  if (is_nullable(sem_type_is_expr)) {
    bprintf(value, "!cql_is_nullable_false(%s, %s)", expr_is_null.ptr, expr_value.ptr);
  }
  else {
    bprintf(value, "!!(%s)", expr_value.ptr);
  }

  CG_POP_EVAL(expr);
}

// This is th ecode gen for <expr> IS TRUE
// The operands already known to be of the correct type so all we have to do is
// check for nullable or not nullable and generate the appropriate code using
// either the helper or just looking at the value.
static void cg_expr_is_true(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_true(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  sem_t sem_type_is_expr = expr->sem->sem_type;

  // expr IS TRUE
  bprintf(is_null, "0"); // the result of is true is never null

  // we always put parens because ! is the highest binding, so we can use ROOT,
  // the callee never needs parens
  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  if (is_nullable(sem_type_is_expr)) {
    bprintf(value, "cql_is_nullable_true(%s, %s)", expr_is_null.ptr, expr_value.ptr);
  }
  else {
    bprintf(value, "!!(%s)", expr_value.ptr);
  }

  CG_POP_EVAL(expr);
}

// This is the code gen for <expr> IS NOT TRUE
// The operands already known to be of the correct type so all we have to do is
// check for nullable or not nullable and generate the appropriate code using
// either the helper or just looking at the value.
static void cg_expr_is_not_true(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_not_true(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  sem_t sem_type_is_expr = expr->sem->sem_type;

  // expr IS NOT TRUE
  bprintf(is_null, "0"); // the result of is not true is never null

  // we always put parens because ! is the highest binding, so we can use ROOT,
  // the callee never needs parens
  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  if (is_nullable(sem_type_is_expr)) {
    bprintf(value, "!cql_is_nullable_true(%s, %s)", expr_is_null.ptr, expr_value.ptr);
  }
  else {
    bprintf(value, "!(%s)", expr_value.ptr);
  }

  CG_POP_EVAL(expr);
}

// The code-gen for is_null is one of the easiest.  The recursive call
// produces is_null as one of the outputs.  Use that.  Our is_null result
// is always zero because IS NULL is never, itself, null.
static void cg_expr_is_null(ast_node *expr, charbuf *is_null, charbuf *value) {
  sem_t sem_type_expr = expr->sem->sem_type;

  // expr IS NULL
  bprintf(is_null, "0"); // the result of is null is never null

  // The fact that this is not constant not null for not null reference types reflects
  // the weird state of affairs with uninitialized reference variables which
  // must be null even if they are typed not null.

  if (is_not_nullable(sem_type_expr) && !is_ref_type(sem_type_expr)) {
    // Note, sql has no side-effects so we can fold this away.
    bprintf(value, "0");
  }
  else {
    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);
    bprintf(value, "%s", expr_is_null.ptr);
    CG_POP_EVAL(expr);
  }
}

// The code-gen for is_not_null is one of the easiest.  The recursive call
// produces is_null as one of the outputs.  Invert that.  Our is_null result
// is always zero because IS NOT NULL is never, itself, null.
static void cg_expr_is_not_null(ast_node *expr, charbuf *is_null, charbuf *value) {
  sem_t sem_type_expr = expr->sem->sem_type;

  // expr IS NOT NULL
  bprintf(is_null, "0"); // the result of is not null is never null

  // The fact that this is not constant not null for not null reference types reflects
  // the weird state of affairs with uninitialized reference variables which
  // must be null even if they are typed not null.

  if (is_not_nullable(sem_type_expr) && !is_ref_type(sem_type_expr)) {
    // Note, sql has no side-effects so we can fold this away.
    bprintf(value, "1");
  }
  else {
    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);
    bprintf(value, "!%s", expr_is_null.ptr);
    CG_POP_EVAL(expr);
  }
}

// This is the general IS pattern, there are several case:
//  * if the right hand side is NULL then use the special helper for IS NULL
//    * that helper makes better code for this special case (the 99% case)
//  * if the args are text, use the text comparor runtime helper
//  * if the args are non-nullable or reference types (not text) equality works
//  * otherwise use the messy formula
//    * both are either null or both not null AND
//    * either they are null or their values are equal
static void cg_expr_is(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is(ast));
  EXTRACT_ANY_NOTNULL(l, ast->left);
  EXTRACT_ANY_NOTNULL(r, ast->right);

  // left IS right

  if (is_ast_null(l)) {
    cg_expr_is_null(r, is_null, value);
    return;
  }
  else if (is_ast_null(r)) {
    cg_expr_is_null(l, is_null, value);
    return;
  }

  sem_t sem_type_left = l->sem->sem_type;
  sem_t sem_type_right = r->sem->sem_type;

  // the result of IS, will not be null, no cases.
  bprintf(is_null, "0");

  bool_t is_text_op = is_text(sem_type_left) || is_text(sem_type_right);
  bool_t is_blob_op = is_blob(sem_type_left) || is_blob(sem_type_right);
  if (is_text_op || is_blob_op) {
    // Both sides are text already verified compatible in semantic phase.

    CG_PUSH_EVAL(l, pri_new);
    CG_PUSH_EVAL(r, pri_new);

    CSTR equal_func = is_text_op ? "cql_string_equal" : "cql_blob_equal";
    bprintf(value, "%s(%s, %s)", equal_func, l_value.ptr, r_value.ptr);

    CG_POP_EVAL(r);
    CG_POP_EVAL(l);
    return;
  }

  CG_PUSH_EVAL(l, pri_new);
  CG_PUSH_EVAL(r, pri_new);

  bool_t refs = is_ref_type(sem_type_left) || is_ref_type(sem_type_right);
  bool_t notnull = is_not_nullable(sem_type_left) && is_not_nullable(sem_type_right);

  if (notnull || refs) {
    if (needs_paren(ast, pri_new, pri)) {
      bprintf(value, "(%s == %s)", l_value.ptr, r_value.ptr);
    }
    else {
      bprintf(value, "%s == %s", l_value.ptr, r_value.ptr);
    }
  }
  else {
    bprintf(value, "((%s == %s) && (%s || %s == %s))",
      l_is_null.ptr, r_is_null.ptr, r_is_null.ptr,
      l_value.ptr, r_value.ptr);
  }

  CG_POP_EVAL(r);
  CG_POP_EVAL(l);
}

// This is the general IS NOT pattern, there are several case:
//  * if the right hand side is NULL then use the special helper for IS NOT NULL
//    * that helper makes better code for this special case (the 99% case)
//  * if the args are text, use the text comparor runtime helper (with !)
//  * if the args are non-nullable or reference types (not text) inequality works
//  * otherwise use the messy IS formula (qv), but invert the result
static void cg_expr_is_not(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_not(ast));
  EXTRACT_ANY_NOTNULL(l, ast->left);
  EXTRACT_ANY_NOTNULL(r, ast->right);

  // left IS NOT right

  if (is_ast_null(r)) {
    cg_expr_is_not_null(l, is_null, value);
    return;
  }
  else if (is_ast_null(l)) {
    cg_expr_is_not_null(r, is_null, value);
    return;
  }

  sem_t sem_type_left = l->sem->sem_type;
  sem_t sem_type_right = r->sem->sem_type;

  // the resut of IS NOT, will not be null, no cases.
  bprintf(is_null, "0");

  bool_t is_text_exp = is_text(sem_type_left) || is_text(sem_type_right);
  bool_t is_blob_exp = is_blob(sem_type_left) || is_blob(sem_type_right);
  if (is_text_exp || is_blob_exp) {
    // Both sides are text already verified compatible in semantic phase.

    CG_PUSH_EVAL(l, pri_new);
    CG_PUSH_EVAL(r, pri_new);

    CSTR equal_func = is_text_exp ? "cql_string_equal" : "cql_blob_equal";
    bprintf(value, "!%s(%s, %s)", equal_func, l_value.ptr, r_value.ptr);

    CG_POP_EVAL(r);
    CG_POP_EVAL(l);
    return;
  }

  CG_PUSH_EVAL(l, pri_new);
  CG_PUSH_EVAL(r, pri_new);

  bprintf(is_null, "0");

  bool_t refs = is_ref_type(sem_type_left) || is_ref_type(sem_type_right);
  bool_t notnull = is_not_nullable(sem_type_left) && is_not_nullable(sem_type_right);

  if (notnull || refs) {
    if (needs_paren(ast, pri_new, pri)) {
      bprintf(value, "(%s != %s)", l_value.ptr, r_value.ptr);
    }
    else {
      bprintf(value, "%s != %s", l_value.ptr, r_value.ptr);
    }
  }
  else {
    bprintf(value, "!((%s == %s) && (%s || %s == %s))",
      l_is_null.ptr, r_is_null.ptr, r_is_null.ptr,
      l_value.ptr, r_value.ptr);
  }

  CG_POP_EVAL(r);
  CG_POP_EVAL(l);
}

// Helper to emit an "if false" condition.
// There are lots of cases where the object is not nullable and we'd like nicer
// code for those cases, hence this helper.
static void cg_if_false(charbuf *output, CSTR is_null, CSTR value) {
  if (!strcmp(is_null, "0")) {
    bprintf(output, "if (!(%s)) {\n", value);
  }
  else if (!strcmp(is_null, "1")) {
    // null is not false
    bprintf(output, "if (0) {\n");
  }
  else {
   bprintf(output, "if (cql_is_nullable_false(%s, %s)) {\n", is_null, value);
  }
}

// Helper to emit an "if true" condition
// There are lots of cases where the object is not nullable and we'd like nicer
// code for those cases, hence this helper.
static void cg_if_true(charbuf *output, CSTR is_null, CSTR value) {
  if (!strcmp(is_null, "0")) {
    bprintf(output, "if (%s) {\n", value);
  }
  else if (!strcmp(is_null, "1")) {
    // null is not true
    bprintf(output, "if (0) {\n");
  }
  else {
   bprintf(output, "if (cql_is_nullable_true(%s, %s)) {\n", is_null, value);
  }
}

// The logical operations are fairly tricky, the code generators for
// each of them are very similar.  Basically x OR y has to be this:
//   * if x is true the answer is true and don't evaluate y (null is not true)
//   * if x is not true and y is true the answer is true (and both were evaluated)
//   * if neither is true and either is null the answer is null
//   * if both are false (only) the answer is false.  See the truth table.
// To get this code generation we need some if statements...  This is another
// of the cases where an expression-looking thing actually has statements in the C.
// There is easy case code if both are known to to be nullable, where the result
// is directly computed with ||.
static void cg_expr_or(ast_node *ast, CSTR str, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_or(ast));
  Contract(pri_new == C_EXPR_PRI_LOR);

  EXTRACT_ANY_NOTNULL(l, ast->left);
  EXTRACT_ANY_NOTNULL(r, ast->right);

  // [left] OR [right]

  // Logical OR truth table and short circuit rules:
  //
  // left right   result evalaute
  //----- -----   ------ --------
  // null null    null   both
  // null 0       null   both
  // null 1       1      both
  // 0    null    null   both
  // 0    0       0      both
  // 0    1       1      both
  // 1    null    1      left only
  // 1    0       1      left only
  // 1    1       1      left only

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_right = r->sem->sem_type;

  CG_RESERVE_RESULT_VAR(ast, sem_type_result);
  CG_PUSH_EVAL(l, pri_new);
  CHARBUF_OPEN(right_eval);

  charbuf *saved_main = cg_main_output;
  cg_main_output = &right_eval;
  CG_PUSH_EVAL(r, pri_new);
  cg_main_output = saved_main;

  // Easiest case of all, we can use the logical || operator
  // we can only do this if everything is non-null and no-statement generation is needed for the right expression
  // it's ok if statement generation is needed for the left because that never needs to short circuit (left
  // is always evaluated).
  if (!is_nullable(sem_type_result) && right_eval.used == 1) {
    if (needs_paren(ast, pri_new, pri)) {
      bprintf(value, "(");
    }

    bprintf(is_null, "0");
    bprintf(value, "%s || %s", l_value.ptr, r_value.ptr);

    if (needs_paren(ast, pri_new, pri)) {
      bprintf(value, ")");
    }
  }
  else {
    // Possibly nullable result...
    CG_USE_RESULT_VAR();

    // More special cases, both null is just null.
    if (is_ast_null(l) && is_ast_null(r)) {
      bprintf(cg_main_output, "cql_set_null(%s);\n", result_var.ptr);
    }
    else {
      cg_if_true(cg_main_output, l_is_null.ptr, l_value.ptr); // if (left...) {
      // if left is true the result is true and don't evaluate the right
      bprintf(cg_main_output, "  ");
      cg_store_same_type(cg_main_output, result_var.ptr, sem_type_result, "0", "1");
      bprintf(cg_main_output, "}\n");
      bprintf(cg_main_output, "else {\n");
      // Left is not true, it's null or false.  We need the right.
      // We already stored the statements right needs (if any).  Spit those out now.
      CG_PUSH_MAIN_INDENT(r, 2);
      bprintf(cg_main_output, "%s", right_eval.ptr);

      if (!is_nullable(sem_type_result)) {
        // If the result is not null then neither of the inputs are null
        // In this branch the left was not true, so it must have been false.
        // Therefore the result is whatever is on the right.  And it's not null.
        cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_right, "0", r_value.ptr);
      }
      else {
        // One was nullable so we have to do the nullable logic
        cg_if_true(cg_main_output, r_is_null.ptr, r_value.ptr); // if (right..) {
        bprintf(cg_main_output, "  ");
        // The right was true, the result is therefore true.
        cg_store_same_type(cg_main_output, result_var.ptr, sem_type_result, "0", "1");
        bprintf(cg_main_output, "}\n");
        bprintf(cg_main_output, "else {\n  ");
        // Neither was true, so the result is null or false.  Null if either are null.
        cg_combine_nullables(cg_main_output, result_var.ptr, l_is_null.ptr, r_is_null.ptr, "0");
        bprintf(cg_main_output, "}\n");
      }

      CG_POP_MAIN_INDENT(r);

      bprintf(cg_main_output, "}\n");
    }
  }

  CG_POP_EVAL(r);
  CHARBUF_CLOSE(right_eval);
  CG_POP_EVAL(l);
  CG_CLEANUP_RESULT_VAR();
}

// The logical operations are fairly tricky, the code generators for each of
// them are very similar.  Basically x AND y has to be this:
//   * if x is false the answer is false and don't evaluate y (null is not
//     false)
//   * if x is not false and y is false the answer is false (and both were
//     evaluated)
//   * if neither is false and either is null the answer is null
//   * if both are true (only) the answer is true.  See the truth table. To get
//     this code generation we need some if statements...  This is another of
//     the cases where an expression-looking thing actually has statements in
//     the C. There is easy case code if both are known to to be nullable, where
//     the result is directly computed with &&.
static void cg_expr_and(ast_node *ast, CSTR str, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_and(ast));
  Contract(pri_new == C_EXPR_PRI_LAND);

  EXTRACT_ANY_NOTNULL(l, ast->left);
  EXTRACT_ANY_NOTNULL(r, ast->right);

  // [left] AND [right]

  // Logical AND truth table and short circuit rules:
  //
  // left right   result evalaute
  //----- -----   ------ --------
  // null null    null   both
  // null 0       0      both
  // null 1       null   both
  // 0    null    0      left only
  // 0    0       0      left only
  // 0    1       0      left only
  // 1    null    null   both
  // 1    0       0      both
  // 1    1       1      both

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_right = r->sem->sem_type;

  CG_RESERVE_RESULT_VAR(ast, sem_type_result);
  CG_PUSH_EVAL(l, pri_new);

  CHARBUF_OPEN(right_eval);

  charbuf *saved_main = cg_main_output;
  cg_main_output = &right_eval;
  CG_PUSH_EVAL(r, pri_new);
  cg_main_output = saved_main;

  // Easiest case of all, we can use the logical && operator
  // we can only do this if everything is non-null and no-statement generation
  // is needed for the right expression it's ok if statement generation is
  // needed for the left because that never needs to short circuit (left is
  // always evaluated).
  if (!is_nullable(sem_type_result) && right_eval.used == 1) {
    if (needs_paren(ast, pri_new, pri)) {
      bprintf(value, "(");
    }

    bprintf(is_null, "0");
    bprintf(value, "%s && %s", l_value.ptr, r_value.ptr);

    if (needs_paren(ast, pri_new, pri)) {
      bprintf(value, ")");
    }
  }
  else {
    // We're doing the longish form, so there is a result variable for the answer.
    CG_USE_RESULT_VAR();

    // More special cases, both null is just null.
    if (is_ast_null(l) && is_ast_null(r)) {
      bprintf(cg_main_output, "cql_set_null(%s);\n", result_var.ptr);
    }
    else {
      cg_if_false(cg_main_output, l_is_null.ptr, l_value.ptr); // if (!left...) {
      bprintf(cg_main_output, "  ");
      cg_store_same_type(cg_main_output, result_var.ptr, sem_type_result, "0", "0");
      bprintf(cg_main_output, "}\n");
      bprintf(cg_main_output, "else {\n");
      // Left is not false, it's null or true.  We need the right.
      // We already stored the statements right needs (if any).  Spit those out now.
      CG_PUSH_MAIN_INDENT(r, 2);
      bprintf(cg_main_output, "%s", right_eval.ptr);

      if (!is_nullable(sem_type_result)) {
        // If the result is not null then neither of the inputs are null. In
        // this branch the left was not false, so it must have been true.
        // Therefore the result is whatever is on the right.  And it's not null.
        cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_right, "0", r_value.ptr);
      }
      else {
        // One was nullable so we have to do the nullable logic
        cg_if_false(cg_main_output, r_is_null.ptr, r_value.ptr); // if (!right..) {
        bprintf(cg_main_output, "  ");
        // The right is false, the result is therefore false.
        cg_store_same_type(cg_main_output, result_var.ptr, sem_type_result, "0", "0");
        bprintf(cg_main_output, "}\n");
        bprintf(cg_main_output, "else {\n  ");
        // Neither was false, so the result is null or true.  Null if either are null.
        cg_combine_nullables(cg_main_output, result_var.ptr, l_is_null.ptr, r_is_null.ptr, "1");
        bprintf(cg_main_output, "}\n");
      }

      CG_POP_MAIN_INDENT(r);

      bprintf(cg_main_output, "}\n");
    }
  }

  CG_POP_EVAL(r);
  CHARBUF_CLOSE(right_eval);
  CG_POP_EVAL(l);
  CG_CLEANUP_RESULT_VAR();
}

// The unary operators are handled just like the binary operators.  All of the C
// outputs have the form (op arg).  We just have to decide if we need parens. We
// use the same rules for parens here as in other places.  "pri" tells us the
// context of the caller, if it is stronger than our operator then we need
// parens. As usual, there is the easy case for not-nullables and the "use a
// temporary" case for nullables.
static void cg_unary(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  // op [left]

  EXTRACT_ANY_NOTNULL(expr, ast->left);
  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;

  if (!strcmp(op, "-") && is_ast_num(expr)) {
    // We have to do special code gen for -9223372036854775808 to avoid compiler
    // warnings...  This is how the literal gets handled in limits.h as well...
    EXTRACT_NUM_TYPE(num_type, expr);
    EXTRACT_NUM_VALUE(lit, expr);

    if (num_type == NUM_LONG && !strcmp("9223372036854775808", lit)) {
      // emit MIN_LONG in a way that the C compiler can accept
      bprintf(value, "(_64(-9223372036854775807) - 1)");
      bprintf(is_null, "0");
      return;
    }
  }

  CHARBUF_OPEN(result);
  CG_RESERVE_RESULT_VAR(ast, sem_type_result);
  CG_PUSH_EVAL(expr, pri_new)

  if (needs_paren(ast, pri_new, pri)) {
    bprintf(&result, "(%s%s)", op, expr_value.ptr);
  }
  else {
    // We always add a space to avoid creating "--" or "++"
    // expr_value might be -1 or -x or some such.  This way we're
    // always safe at the cost of a space.
    bprintf(&result, "%s %s", op, expr_value.ptr);
  }

  if (is_not_nullable(sem_type_expr)) {
    bprintf(is_null, "0");
    bprintf(value, "%s", result.ptr);
  }
  else {
    CG_USE_RESULT_VAR();
    cg_set_nullable(cg_main_output, result_var.ptr, expr_is_null.ptr, result.ptr);
  }

  CG_POP_EVAL(expr);
  CG_CLEANUP_RESULT_VAR();
  CHARBUF_CLOSE(result);
}

// The sign function is present in later versions of Sqlite so we want to The
// strategy is to compute the value of the argument, store it in a temporary and
// then use the expression (x > 0) - (x < 0) to compute the sign.  The temporary
// is needed because 'x' appears twice and we do not want to evaluate the
// expression twice.
static void cg_func_sign(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  sem_t sem_type_result = call_ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;

  CHARBUF_OPEN(sign_value);
  CG_SETUP_RESULT_VAR(call_ast, sem_type_result);

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);
  CG_PUSH_TEMP(temp, sem_type_expr);

  cg_store_same_type(cg_main_output, temp.ptr, sem_type_result, expr_is_null.ptr, expr_value.ptr);

  bprintf(&sign_value, "((%s > 0) - (%s < 0))", temp_value.ptr, temp_value.ptr);

  cg_store_same_type(cg_main_output, result_var.ptr, sem_type_result, temp_is_null.ptr, sign_value.ptr);

  CG_POP_TEMP(temp);
  CG_POP_EVAL(expr);
  CG_CLEANUP_RESULT_VAR();
  CHARBUF_CLOSE(sign_value);
}

// To do `abs` we have to evaluate the argument and store it somewhere we use
// the result variable for this.  We don't want to evaluate that expression more
// than once, hence the temporary storage.  Once we have the value in a result
// variable, we can test it against zero safely and alter it as needed.
static void cg_func_abs(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_ANY_NOTNULL(expr, arg_list->left); // first arg

  // abs ( expr )

  sem_t sem_type_result = call_ast->sem->sem_type;
  sem_t core_type_result = core_type_of(sem_type_result);

  // null literal is an error
  Invariant(core_type_result != SEM_TYPE_NULL);

  CHARBUF_OPEN(abs_value);
  CG_SETUP_RESULT_VAR(call_ast, sem_type_result);

  // Evaluate the expression and stow it in a temporary.
  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);
  CG_PUSH_TEMP(temp, sem_type_result);

  // Copy the expression, we can't evaluate it more than once, so stow it.
  cg_store_same_type(cg_main_output, temp.ptr, sem_type_result, expr_is_null.ptr, expr_value.ptr);

  // this is ruled out by semanttic analysis
  Invariant(core_type_result != SEM_TYPE_BOOL);

  switch (core_type_result) {
    case SEM_TYPE_INTEGER:
      bprintf(&abs_value, "abs(%s)", temp_value.ptr);
      break;

    case SEM_TYPE_LONG_INTEGER:
      bprintf(&abs_value, "labs(%s)", temp_value.ptr);
      break;

    case SEM_TYPE_REAL:
      bprintf(&abs_value, "fabs(%s)", temp_value.ptr);
      break;
  }

  cg_store_same_type(cg_main_output, result_var.ptr, sem_type_result, temp_is_null.ptr, abs_value.ptr);

  CG_POP_TEMP(temp);
  CG_POP_EVAL(expr);
  CG_CLEANUP_RESULT_VAR();
  CHARBUF_CLOSE(abs_value);
}

// This helper generates the tests for each entry in the IN list.
// we generate the appropriate equality test -- one for strings
// one for nullables and one for not nullables.  Note expr is already known
// to be not null here.  There was previous codegen for that case.  The result
// is either bool or nullable bool.
static void cg_in_or_not_in_expr_list(ast_node *head, CSTR expr, CSTR result, sem_t sem_type_result, bool_t is_not_in) {
  Contract(is_bool(sem_type_result));
  CSTR found_value = is_not_in ? "0" : "1";
  CSTR not_found_value = is_not_in ? "1" : "0";

  cg_store_same_type(cg_main_output, result, sem_type_result, "0", found_value);

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_ANY_NOTNULL(in_expr, ast->left)

    // null can't ever match anything, waste of time.
    if (is_ast_null(in_expr)) {
      continue;
    }

    cg_line_directive_min(in_expr, cg_main_output);

    int32_t stack_level_saved = stack_level;
    CG_PUSH_EVAL(in_expr, C_EXPR_PRI_EQ_NE);
    sem_t sem_type_in_expr = in_expr->sem->sem_type;

    if (is_text(sem_type_in_expr)) {
      bprintf(cg_main_output, "if (cql_string_compare(%s, %s) == 0)", expr, in_expr_value.ptr);
    }
    else if (is_blob(sem_type_in_expr)) {
      bprintf(cg_main_output, "if (cql_blob_equal(%s, %s))", expr, in_expr_value.ptr);
    }
    else if (is_nullable(sem_type_in_expr)) {
      bprintf(cg_main_output,
              "if (cql_is_nullable_true(%s, %s == %s))",
              in_expr_is_null.ptr,
              expr,
              in_expr_value.ptr);
    }
    else {
      bprintf(cg_main_output, "if (%s == %s)", expr, in_expr_value.ptr);
    }

    bprintf(cg_main_output, " break;\n");
    CG_POP_EVAL(in_expr);

    // This comparison clause fully used any temporaries associated with expr
    // this is kind of like the result variable case, except we didn't store the
    // result we used it in the "if" test, but we're done with it.
    stack_level = stack_level_saved;
  }

  cg_store_same_type(cg_main_output, result, sem_type_result, "0", not_found_value);
}

// Helper to generate a null result.  For consistency with other nullable
// results we store it in a scratch variable.  Note that this is a "typed" null.
// That is we know the kind of null we are making, a null int, null long, etc.
// Again this lets the normal nullability path just work.
static void cg_null_result(ast_node *ast, charbuf *is_null, charbuf *value) {
  sem_t sem_type_result = ast->sem->sem_type;
  CG_SETUP_RESULT_VAR(ast, sem_type_result);
  cg_set_null(cg_main_output, result_var.ptr, sem_type_result);
  CG_CLEANUP_RESULT_VAR();
}

// The [NOT] IN structure is the simplest of the multi-test forms. It's actually
// a special case of case/when if you like. Each item in the [NOT] IN needs to
// be evaluated because there is no rule that says they are constants.
// NOT IN is just a similar reversed check compare IN starting with opposite result value.
// The general pattern for  X IN (U, V) looks like this
//
//  int result;
//  do {
//    prep statements for X;
//    temp = X;
//    if (temp is null) { result = null; break; } [only needed if X is nullable]
//
//    result = 1;  /* cg_in_or_not_in_expr_list generates the alternatives */
//    (result = 0; if NOT IN case)
//
//    prep statements for U;
//    compute U;
//    if (temp == U) break;
//
//    prep statements for V;
//    compute V;
//    if (temp == V) break;
//
//    result = 0;
//    (result = 1; if NOT IN case)
//   } while (0);
//
// The result ends up in the is_null and value fields as usual.
static void cg_expr_in_pred_or_not_in(
  ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_in_pred(ast) || is_ast_not_in(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left)
  EXTRACT(expr_list, ast->right);

  // [expr] [NOT] IN ( [expr_list] )

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;

  if (is_null_type(sem_type_expr)) {
    cg_null_result(ast, is_null, value);
    return;
  }

  // The answer will be stored in this scratch variable. note: we do not allow
  // the assignment variable to be used because it might be in the candidate
  // list. Since we write to it before we're done the early
  // "result = 1" would kill something like  r := x in (r, b);
  CG_SETUP_RESULT_VAR(NULL, sem_type_result);

  bprintf(cg_main_output, "do {\n");

  CG_PUSH_MAIN_INDENT(do, 2);

  cg_line_directive_min(expr, cg_main_output);

  // Evaluate the expression and stow it in a temporary.
  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);
  CG_PUSH_TEMP(temp, sem_type_expr);

  // Copy the expression, we can't evaluate it more than once, so stow it.
  cg_store_same_type(cg_main_output, temp.ptr, sem_type_expr, expr_is_null.ptr, expr_value.ptr);

  // If the expression is null the result is null
  if (is_nullable(sem_type_expr)) {
    bprintf(cg_main_output, "if (%s) {    \n", temp_is_null.ptr);
    bprintf(cg_main_output, "  ");
    cg_set_null(cg_main_output, result_var.ptr, sem_type_result);
    bprintf(cg_main_output, "  break;\n");
    bprintf(cg_main_output, "}\n");
  }

  // Now generate the list
  cg_in_or_not_in_expr_list(expr_list, temp_value.ptr, result_var.ptr, sem_type_result, is_ast_not_in(ast));

  CG_POP_TEMP(temp);
  CG_POP_EVAL(expr);
  CG_POP_MAIN_INDENT(do);
  CG_CLEANUP_RESULT_VAR();

  cg_line_directive_max(ast, cg_main_output);
  bprintf(cg_main_output, "} while (0);\n");
}

// This helper method emits the alternatives for the case.  If there was an
// expression the temporary holding the expression is in expr.  Expr has already
// been tested for null if that was a possibility so we only need its value at
// this point.
static void cg_case_list(ast_node *head, CSTR expr, CSTR result, sem_t sem_type_result) {
  Contract(is_ast_case_list(head));

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_NOTNULL(when, ast->left);
    EXTRACT_ANY_NOTNULL(case_expr, when->left);
    EXTRACT_ANY_NOTNULL(then_expr, when->right);

    // WHEN [case_expr] THEN [then_expr]

    sem_t sem_type_case_expr = case_expr->sem->sem_type;
    sem_t sem_type_then_expr = then_expr->sem->sem_type;

    cg_line_directive_min(case_expr, cg_main_output);

    int32_t stack_level_saved = stack_level;
    CG_PUSH_EVAL(case_expr, C_EXPR_PRI_EQ_NE);

    if (expr) {
      // Generate a comparison for the appropriate data type (expr known to be not null)
      if (is_text(sem_type_case_expr)) {
        bprintf(cg_main_output, "if (cql_string_compare(%s, %s) == 0) {\n",
                expr,
                case_expr_value.ptr);
      }
      else if (is_nullable(sem_type_case_expr)) {
        bprintf(cg_main_output, "if (cql_is_nullable_true(%s, %s == %s)) {\n",
                case_expr_is_null.ptr,
                expr,
                case_expr_value.ptr);
      }
      else {
        bprintf(cg_main_output, "if (%s == %s) {\n", expr, case_expr_value.ptr);
      }
    }
    else {
      // No temporary, generate a test for a boolean expression (which may or may not be null)
      if (is_nullable(sem_type_case_expr)) {
        bprintf(cg_main_output, "if (cql_is_nullable_true(%s, %s)) {\n",
                case_expr_is_null.ptr,
                case_expr_value.ptr);
      }
      else {
        bprintf(cg_main_output, "if (%s) {\n", case_expr_value.ptr);
      }
    }
    cg_line_directive_min(then_expr, cg_main_output);
    CG_POP_EVAL(case_expr);

    // The comparison above clause fully used any temporaries associated with expr
    stack_level = stack_level_saved;

    CG_PUSH_MAIN_INDENT(then, 2);
    CG_PUSH_EVAL(then_expr, C_EXPR_PRI_ROOT);

    cg_store(cg_main_output, result, sem_type_result, sem_type_then_expr, then_expr_is_null.ptr, then_expr_value.ptr);
    bprintf(cg_main_output, "break;\n");

    CG_POP_EVAL(then_expr);
    CG_POP_MAIN_INDENT(then);
    bprintf(cg_main_output, "}\n");

    // This 'then' clause stored its result, temporaries no longer needed
    // This is just like the result variable case
    stack_level = stack_level_saved;
  }
}

// Case looks a lot like IN except the net result is computed at each step
// and the test is different at each step.  It's a straight generalization.
//
// Case X when U then R1 when V then R2 else R3 end;
//
//   declare result (whatever type holds R1, R2, and R3)
//
//   do {
//     statements to evaluate X;
//     temp = X;
//     [ if temp is null goto case_else; ] optional if temp is nullable
//
//     statements to evaluate U
//     if (temp == U) {
//       statements to evaluate R1;
//       result = R1;
//       break;
//     }
//
//     statements to evaluate V
//     if (temp == V) {
//       statements to evaluate R2;
//       result = R2;
//       break;
//     }
//   case_else:
//     statements to evaluate R3;
//     result = R3;
//   } while (0);
//
// If the X is omitted then U and V are normal boolean expressions and
// the code becomes if (U) etc  if (V) etc. with no temp.
static void cg_expr_case(ast_node *case_expr, CSTR str, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_case_expr(case_expr));
  EXTRACT_ANY(expr, case_expr->left);
  EXTRACT_NOTNULL(connector, case_expr->right);
  EXTRACT_NOTNULL(case_list, connector->left);
  EXTRACT_ANY(else_expr, connector->right);

  // if we need an else label, this will hold the value.
  int32_t else_label_number = -1;

  sem_t sem_type_result = case_expr->sem->sem_type;

  // CASE [expr]? [case_list] ELSE [else_expr] END

  // The answer will be stored in this scratch variable, any type is possible
  CG_SETUP_RESULT_VAR(case_expr, sem_type_result);

  cg_line_directive_min(case_expr, cg_main_output);
  bprintf(cg_main_output, "do {\n");

  CG_PUSH_MAIN_INDENT(do, 2);

  // if the form is case expr when ... then save the expr in a temporary
  if (expr) {
    cg_line_directive_min(expr, cg_main_output);

    sem_t sem_type_expr = expr->sem->sem_type;
    CG_PUSH_TEMP(temp, sem_type_expr);

    int32_t stack_level_saved = stack_level;

    // Compute the value of the expression.
    CG_PUSH_EVAL(expr, C_EXPR_PRI_EQ_NE);

    // Store it in the temporary we just made, which has the exact correct type (we just made it)
    bprintf(cg_main_output, "  ");
    cg_store_same_type(cg_main_output, temp.ptr, sem_type_expr, expr_is_null.ptr, expr_value.ptr);

    // here "temp" is like a mini-result variable... anything from expr can be
    // released we only need temp now, so restore to that level.
    stack_level = stack_level_saved;

    // If the expression is null, then we go to the else logic.  Note: there is always else logic
    // either the user provides it or we do (to use null as the default).
    if (is_nullable(sem_type_expr)) {
      else_label_number = ++case_statement_count;
      bprintf(cg_main_output, "  if (%s) ", temp_is_null.ptr);
      bprintf(cg_main_output, "goto case_else_%d;\n", else_label_number);
    }

    cg_case_list(case_list, temp_value.ptr, result_var.ptr, sem_type_result);

    CG_POP_EVAL(expr);
    CG_POP_TEMP(temp);
  }
  else {
    // Otherwise do the case list with no expression...
    cg_case_list(case_list, NULL, result_var.ptr, sem_type_result);
  }

  if (else_label_number >= 0) {
    bprintf(cg_main_output, "case_else_%d:\n", else_label_number);
  }

  // If there is an else clause, spit out the result for that now. Note that
  // lack of an else is by-construction a nullable outcome because the semantics
  // of case say that if you miss all the cases you get null.
  if (else_expr) {
    cg_line_directive_min(else_expr, cg_main_output);

    sem_t sem_type_else = else_expr->sem->sem_type;

    CG_PUSH_EVAL(else_expr, C_EXPR_PRI_ROOT);

    cg_line_directive_max(case_expr, cg_main_output);
    cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_else, else_expr_is_null.ptr, else_expr_value.ptr);

    CG_POP_EVAL(else_expr);
  }
  else {
    // No else, result must be nullable. (enforced by cg_set_null)
    cg_line_directive_max(case_expr, cg_main_output);
    cg_set_null(cg_main_output, result_var.ptr, sem_type_result);
  }

  CG_POP_MAIN_INDENT(do);
  CG_CLEANUP_RESULT_VAR();

  bprintf(cg_main_output, "} while (0);\n");
}

// We have built-in support for numeric casts only, the SQL string cast
// operations are highly complex with interesting parsing rules and so forth.
// We don't try to do those at all but there's no reason we can't do the simple
// numeric conversions in the non-SQL path
static void cg_expr_cast(ast_node *cast_expr, CSTR str, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_cast_expr(cast_expr));

  sem_t sem_type_result = cast_expr->sem->sem_type;
  sem_t core_type_result = core_type_of(sem_type_result);

  ast_node *expr = cast_expr->left;
  sem_t core_type_expr = core_type_of(expr->sem->sem_type);

  CSTR type_text = NULL;
  CSTR bool_norm = "";

  if (core_type_expr == SEM_TYPE_BOOL) {
    // convert bool to 0/1
    bool_norm = "!!";
  }

  switch (core_type_result) {
    case SEM_TYPE_INTEGER:
      type_text = "cql_int32";
      break;

    case SEM_TYPE_LONG_INTEGER:
      type_text = "cql_int64";
      break;

    case SEM_TYPE_REAL:
      type_text = "cql_double";
      break;

    case SEM_TYPE_BOOL:
      // convert to 0/1 as part of conversion
      bool_norm = "!!";
      type_text = "cql_bool";
      break;

    default:
      // all other types forbidden by semantic analysis
      Invariant(core_type_expr == SEM_TYPE_NULL || core_type_expr == core_type_result);
      break;
  }

  CG_RESERVE_RESULT_VAR(cast_expr, sem_type_result);
  CG_PUSH_EVAL(expr, pri_new);
  CHARBUF_OPEN(result);

  if (core_type_expr == SEM_TYPE_NULL) {
    bprintf(value, "0");
    bprintf(is_null, "1");
  }
  else if (core_type_expr == core_type_result) {
    // no-op cast, just pass through
    bprintf(is_null, "%s", expr_is_null.ptr);
    bprintf(value, "%s", expr_value.ptr);
  }
  else  {
    bprintf(&result, "((%s)%s(%s))", type_text, bool_norm, expr_value.ptr);
    if (is_not_nullable(sem_type_result)) {
      // simple cast, use the result with no temporary
      bprintf(value, "%s", result.ptr);
      bprintf(is_null, "0");
    }
    else {
      // nullable form, make a result variable and store
      CG_USE_RESULT_VAR();
      cg_set_nullable(cg_main_output, result_var.ptr, expr_is_null.ptr, result.ptr);
    }
  }

  CHARBUF_CLOSE(result);
  CG_POP_EVAL(expr);
  CG_CLEANUP_RESULT_VAR();
}

// We have built-in type_check fun which use to check an expr strictly match a
// type. during semantic analysis otherwise error. At the codegen phase we just
// emit the expr since the type check already succeeded.
static void cg_expr_type_check(ast_node *type_check_expr, CSTR str, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_type_check_expr(type_check_expr));
  EXTRACT_ANY_NOTNULL(expr, type_check_expr->left);

  CG_PUSH_EVAL(expr, pri_new);

  // Type checking of the expression already happened during semantic analysis.
  // It's safe to just output it
  bprintf(is_null, "0");
  bprintf(value, "%s", expr_value.ptr);

  CG_POP_EVAL(expr);
}

// A CQL string literal needs to be stored somewhere so it looks like a
// string_ref. Here is a helper method for creating the name of the literal.  We
// use some letters from the text of the literal in the variable name to make it
// easier to find and recognize.
static bool_t cg_make_nice_literal_name(CSTR str, charbuf *output) {
  // empty buffer (just the null terminator)
  Contract(output->used == 1);

  CSTR existing_name = find_literal(str);
  if (existing_name) {
    bprintf(output, "%s", existing_name);
    return false;
  }

  bprintf(output, "_literal_%d", ++string_literals_count);
  bool_t underscore = false;

  for (int32_t i = 0; str[i] && i < CQL_NICE_LITERAL_NAME_LIMIT; i++) {
    char ch = str[i];
    if (IsAlpha(ch)) {
      bputc(output, ch);
      underscore = false;
    }
    else if (ch == '\\') {
     if (str[i+1]) i++;  // don't fall off the end
    }
    else if (!underscore) {
      bputc(output, '_');
      underscore = true;
    }
  }

  if (current_proc) {
    EXTRACT_STRING(name, current_proc->left);
    bprintf(output, "%s", name);
  }

  symtab_add(string_literals, str, Strdup(output->ptr));
  return true;
}

// This converts from SQL string literal format to C literal format.
//  * the single quotes around the string become double quotes
//  * escaped single quote becomes just single quote
//  * backslash escapes are preserved
static void cg_requote_literal(CSTR str, charbuf *output) {
  CHARBUF_OPEN(plaintext);
  cg_decode_string_literal(str, &plaintext);
  cg_encode_c_string_literal(plaintext.ptr, output);
  CHARBUF_CLOSE(plaintext);
}

// Here we use the helper above to create a variable name for the literal then
// we declare that variable and emit the initializer.  The macro
// cql_string_literal does the job for us while allowing the different string
// implementations.  These go into the constants section.
static void cg_string_literal(CSTR str, charbuf *output) {
  Contract(str);
  Contract(str[0] == '\'');

  CHARBUF_OPEN(name);
  bool_t is_new = cg_make_nice_literal_name(str, &name);

  // Emit reference to a new shared string.
  bprintf(output, "%s", name.ptr);

  if (is_new) {
    // The shared string itself must live forever so it goes in global constants.
    bprintf(cg_constants_output, "cql_string_literal(%s, ", name.ptr);
    cg_requote_literal(str, cg_constants_output);
    bprintf(cg_constants_output, ");\n");
  }

  CHARBUF_CLOSE(name);
}

// The rewritten between expression is designed to be super easy to code gen.
// The semantic analyzer has already turned the between or not beween into a
// normal combination of and/or so all we have to do is load up the temporary
// with the test value and then evaluate the test expression. Between and not
// between look the same to the codgen (they will have different expressions).
// This lets us get all that weird short circuit behavior super easy.  It's
// literally the AND/OR code running.
static void cg_expr_between_rewrite(
  ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_between_rewrite(ast));
  EXTRACT_NOTNULL(range, ast->right);
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_ANY_NOTNULL(test, range->right);

  // BETWEEN REWRITE [var := expr] CHECK [test]

  sem_t sem_type_var = expr->sem->sem_type;

  if (is_ast_null(expr)) {
    bprintf(is_null, "1");
    bprintf(value, "0");
    return;
  }

  // we have to do this after we have checked the expression for the null case
  // if it is the null case the variable we generated for temporary storage
  // would be rewritten to the null constant and this next extract fails
  // the early out handles that case so we're now in the normal invariant.
  EXTRACT_STRING(var, range->left);

  cg_var_decl(cg_declarations_output, sem_type_var, var, CG_VAR_DECL_FULL);

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ASSIGN);
  cg_store_same_type(cg_main_output, var, sem_type_var, expr_is_null.ptr, expr_value.ptr);
  CG_POP_EVAL(expr);

  cg_expr(test, is_null, value, pri);
}

// This is the first of the key primitives in codegen -- it generates the
// output buffers for an identifier.  There are a few interesting cases.
//   * if it's an out variable we refer to it as *foo
//   * nullable strings use "id" for .value and "!id" for .is_null
//   * nullable other use the variables .is_null and .value
//   * non-nullables use the variable for the value and "0" for is_null
//   * we have special case code for the @RC identifier for the most recent result code
//   * we have to undo the cursor transform _C_has_row_ into C._has_row_ because
//     cursors are uniform in LUA, this is goofy but works for now
//   * when processing shared fragments we might need to alias local variables
//     to their computed value
//
// Note: It's important to use the semantic name sem->name rather than the text
// of the ast because the user might refer case insensitively to the variable FoO
// and we need to emit the canonical name (e.g. foo, or Foo, or whatever it was).
static void cg_id(ast_node *expr, charbuf *is_null, charbuf *value) {
  sem_t sem_type = expr->sem->sem_type;
  Invariant(is_variable(sem_type));

  // Crucial, we want the canonical version of the name, not any MixED case version
  // the user might have typed.
  CSTR name = expr->sem->name;

  // map the logical @rc variable to the correct saved version
  if (!strcmp(name, "@rc")) {
    bprintf(value, "%s", rcthrown_current);
    bprintf(is_null, "0");
    rcthrown_used = true;
    return;
  }

  // While generating expressions for the CTE assignments we might have to
  // rename the proc args to the name in the outermost context.
  if (proc_arg_aliases) {
    symtab_entry *entry = symtab_find(proc_arg_aliases, name);
    if (entry) {
      EXTRACT_ANY_NOTNULL(var, entry->val);
      name = var->sem->name;
    }
  }

  CHARBUF_OPEN(name_buff);

  if (is_out_parameter(sem_type)) {
    bprintf(&name_buff, "(*%s)", name);
    name = name_buff.ptr;
  }

  if (is_ref_type(sem_type)) {
    // Note that reference type identifiers can't be assumed to be not null
    // even if declared so, because they begin uninitialized.  Yes this is weird.
    // C has the same problem...
    bprintf(value, "%s", name);
    bprintf(is_null, "!%s", name);
  }
  else {
    if (is_nullable(sem_type)) {
      bprintf(value, "%s.value", name);
      bprintf(is_null, "%s.is_null", name);
    }
    else {
      bprintf(value, "%s", name);
      bprintf(is_null, "0");
    }
  }

  CHARBUF_CLOSE(name_buff);
}

// Recall that coalesce returns the first non-null arg from the list of arguments.
// The arguments must be type compatible, this was previously verified.  To do
// the codgen for coalesce(X,Y) we use a pattern like this:
//   declare result of the appropriate type;
//   do {
//     evaluate X;
//     if (x is not null) {
//       result = X;  // we can use the form where  X is known to be not null
//       break;       // we're done...
//     }
//     ... other cases just like the above...
//     ... the final case has no test, use it even if null
//     evaluate Y;
//     result = Y;
//   } while (0);
static void cg_func_coalesce(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // ifnull ( [arg_list] )
  // coalesce ( [arg_list] )

  sem_t sem_type_result = call_ast->sem->sem_type;

  // the answer will be stored in this scratch variable
  CG_SETUP_RESULT_VAR(call_ast, sem_type_result);

  cg_line_directive_min(call_ast, cg_main_output);
  bprintf(cg_main_output, "do {\n");
  CG_PUSH_MAIN_INDENT(do, 2);
  for (ast_node *ast = arg_list; ast; ast = ast->right) {
    EXTRACT_ANY_NOTNULL(expr, ast->left);

    sem_t sem_type_expr = expr->sem->sem_type;

    cg_line_directive_max(expr, cg_main_output);
    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

    // Generate the test for all but the last choice.
    if (ast->right) {
      bprintf(cg_main_output, "if (!%s) {\n  ", expr_is_null.ptr);

      // We can generate the store for a known not null value
      // because we just tested for not null, cg_store will pick the best
      // assignment macro for that case based on type.
      bclear(&expr_is_null);
      bputc(&expr_is_null, '0');
      sem_type_expr |= SEM_TYPE_NOTNULL;
    }

    cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_expr, expr_is_null.ptr, expr_value.ptr);

    if (ast->right) {
      bprintf(cg_main_output, "  break;\n");
      bprintf(cg_main_output, "}\n");
    }

    CG_POP_EVAL(expr);
  }
  CG_POP_MAIN_INDENT(do);
  bprintf(cg_main_output, "} while (0);\n");
  CG_CLEANUP_RESULT_VAR();
}

// Ifnull is an alias for coalesce, with only two args.
static void cg_func_ifnull(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  cg_func_coalesce(call_ast, is_null, value);
}

// The sensitive wrapper does nothing at codegen time, we just foward evaluation
// down into its one and only argument.
static void cg_func_sensitive(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // sensitive ( any expression ) -- at run time this function is a no-op
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  // we just evaluate the inner expression
  // we have to fake a high binding strength so that it will for sure emit parens
  // as the nullable() construct looks like has parens and we don't know our context
  // oh well, extra parens is better than the temporaries of doing this with PUSH_EVAL etc.
  cg_expr(expr, is_null, value, C_EXPR_PRI_HIGHEST);
}

// The nullable wrapper does nothing at codegen time, we just foward evaluation
// down into its one and only argument.
static void cg_func_nullable(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // nullable ( any expression ) -- at run time this function is a no-op
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  // we just evaluate the inner expression
  // we have to fake a high binding strength so that it will for sure emit parens
  // as the nullable() construct looks like has parens and we don't know our context
  // oh well, extra parens is better than the temporaries of doing this with PUSH_EVAL etc.
  cg_expr(expr, is_null, value, C_EXPR_PRI_HIGHEST);
}

typedef enum {
  ATTEST_NOTNULL_VARIANT_CRASH,
  ATTEST_NOTNULL_VARIANT_INFERRED,
  ATTEST_NOTNULL_VARIANT_THROW,
} attest_notnull_variant;

// Generates code for all functions of the attest_notnull family.
static void cg_func_attest_notnull(ast_node *call_ast, charbuf *is_null, charbuf *value, attest_notnull_variant variant) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // notnull ( a_nullable_expression )

  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  // result known to be not null so easy codegen

  sem_t sem_type_expr = expr->sem->sem_type;
  Invariant(is_nullable(sem_type_expr));  // expression must already be in a temp

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

    switch (variant) {
      case ATTEST_NOTNULL_VARIANT_CRASH:
        bprintf(cg_main_output, "cql_invariant(!%s);\n", expr_is_null.ptr);
        break;
      case ATTEST_NOTNULL_VARIANT_INFERRED:
        // Semantic analysis has guaranteed that the input is not going to be
        // NULL so we don't need to check anything here.
        break;
      case ATTEST_NOTNULL_VARIANT_THROW:
        bprintf(cg_main_output, "if (%s) {\n", expr_is_null.ptr);
        bprintf(cg_main_output, "  _rc_ = SQLITE_ERROR;\n");
        bprintf(cg_main_output, "  cql_error_trace();\n");
        bprintf(cg_main_output, "  goto %s;\n", error_target);
        bprintf(cg_main_output, "}\n");
        error_target_used = true;
        break;
    }

    bprintf(is_null, "0");
    bprintf(value, "%s", expr_value.ptr);

  CG_POP_EVAL(expr);
}

// As the name suggests, we yield a not null result but throw if the argument was null
static void cg_func_ifnull_throw(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  cg_func_attest_notnull(call_ast, is_null, value, ATTEST_NOTNULL_VARIANT_THROW);
}

// As the name suggests, we yield a not null result but crash/assert if the argument was null
static void cg_func_ifnull_crash(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  cg_func_attest_notnull(call_ast, is_null, value, ATTEST_NOTNULL_VARIANT_CRASH);
}

// The point of this psuedo function is to make it possible to have CQL users
// opt-in to the compressed string pieces mode if they have highly duplicated strings
// this is really the most useful in the schema generator -- more kinds of strings
// can participate in the pieces plan.
static void cg_func_cql_compressed(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);
  EXTRACT_STRING(str, expr);

  // we never try to compress the empty string, that's dumb
  if (!options.compress || !strcmp(str, "''")) {
    // Note str is the lexeme, so it is still quoted and escaped.
    bprintf(is_null, "0");
    cg_string_literal(str, value);
  }
  else {
    CG_SETUP_RESULT_VAR(expr, SEM_TYPE_TEXT | SEM_TYPE_NOTNULL);
    CHARBUF_OPEN(call);
    CHARBUF_OPEN(unquoted);
    cg_decode_string_literal(str, &unquoted);
    bprintf(&call, "cql_uncompress(_pieces_, ");
    cg_statement_pieces(unquoted.ptr, &call);
    bprintf(&call, ")");
    cg_copy_for_create(cg_main_output, result_var.ptr, SEM_TYPE_TEXT, call.ptr);
    CHARBUF_CLOSE(unquoted);
    CHARBUF_CLOSE(call);
    CG_CLEANUP_RESULT_VAR();
  }
}

// The `cql_inferred_notnull` function is not used by the programmer directly,
// but rather inserted via a rewrite during semantic analysis to coerce a value
// of a nullable type to be nonnull. The reason for this approach, as opposed to
// just changing the type directly, is that there are also representational
// differences between values of nullable and nonnull types; some conversion is
// required.
static void cg_func_cql_inferred_notnull(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  cg_func_attest_notnull(call_ast, is_null, value, ATTEST_NOTNULL_VARIANT_INFERRED);
}

// There's a helper for this method, just call it.  Super easy.
static void cg_func_changes(ast_node *ast, charbuf *is_null, charbuf *value) {
  bprintf(is_null, "0");
  bprintf(value, "sqlite3_changes(_db_)");
}

// There's a helper for this method, just call it.  Super easy.
static void cg_func_last_insert_rowid(ast_node *ast, charbuf *is_null, charbuf *value) {
  bprintf(is_null, "0");
  bprintf(value, "sqlite3_last_insert_rowid(_db_)");
}

// Printf also has a helper, we just call it.  There are other helpers to emit
// a call to an external (not stored proc) function.  Use that.
static void cg_func_printf(ast_node *call_ast, charbuf *is_null, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  CG_SETUP_RESULT_VAR(call_ast, SEM_TYPE_TEXT | SEM_TYPE_NOTNULL);
  bprintf(cg_main_output, "{\n");
  cg_call_named_external("  char *_printf_result = sqlite3_mprintf", arg_list);
  bprintf(cg_main_output, "  cql_string_release(%s);\n", result_var.ptr);
  bprintf(cg_main_output, "  %s = cql_string_ref_new(_printf_result);\n", result_var.ptr);
  bprintf(cg_main_output, "  sqlite3_free(_printf_result);\n");
  bprintf(cg_main_output, "}\n");
  CG_CLEANUP_RESULT_VAR();
}

// wrapper function for the builtin cql_get_blob_size
// all we have to do is figure out if we need a temporary or not to hold the answer
static void cg_func_cql_get_blob_size(ast_node *ast, charbuf*is_null, charbuf *value) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  // The result is known to be not nullable therefore we can store directly the value to the result buff
  bprintf(is_null, "0");
  bprintf(value, "cql_get_blob_size(%s)", expr_value.ptr);

  CG_POP_EVAL(expr);
}

// This is some kind of function call in an expression context.  Look up the method
// and call one of the cg_func_* workers above.  All arg combos are known to be good
// because semantic analysis verified them already.
static void cg_expr_call(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);

  // name( [arg_list] )

  if (find_func(name) || find_proc(name) || find_unchecked_func(name)) {
    cg_user_func(ast, is_null, value);
  }
  else {
    symtab_entry *entry = symtab_find(cg_funcs, name);
    Invariant(entry);  // names have already been verified!
    ((void (*)(ast_node *, charbuf *, charbuf *))entry->val)(ast, is_null, value);
  }
}

// Numeric literal, spit it out.
static void cg_expr_num(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_num(expr));
  EXTRACT_NUM_TYPE(num_type, expr);
  EXTRACT_NUM_VALUE(lit, expr);
  // a numeric literal
  bprintf(is_null, "0");

  if (num_type == NUM_LONG) {
    // add long suffix if needed
    bprintf(value, "_64(%s)", lit);
  }
  else {
    bprintf(value, "%s", lit);
  }
}

// we generate a simple string literal or an identifier here, both use the "str" node
static void cg_expr_str(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  // String could be an id, or a literal -- literals start with single quote.
  Contract(is_ast_str(expr));
  EXTRACT_STRING(str, expr);
  if (is_strlit(expr)) {
    // Note str is the lexeme, so it is still quoted and escaped.
    cg_string_literal(str, value);
    bprintf(is_null, "0");
  }
  else {
    cg_id(expr, is_null, value);
  }
}

// the "dot" operator (e.g. C.x) is handled on the ID path
static void cg_expr_dot(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  // X.Y has a net local name computed by semantic analysis.  Use it like any other id.
  Contract(is_ast_dot(expr));
  cg_id(expr, is_null, value);
}

// the null constant
static void cg_expr_null(ast_node *expr, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_null(expr));
  // null literal
  bprintf(value, "NULL");
  bprintf(is_null, "1");
}

// This is the main entry point for codegen of an expression.  It dispatches to
// one of the above workers for all the complex types and handles a few
// primitives in place. See the introductory notes to understand is_null and
// value.
static void cg_expr(ast_node *expr, charbuf *is_null, charbuf *value, int32_t pri) {
  Contract(is_null);
  Contract(value);
  Contract(value->used == 1);  // just the null (i.e. empty buffer)
  Contract(is_null->used == 1); // just the null (i.e. empty buffer)

  // These are all the expressions there are, we have to find it in this table
  // or else someone added a new expression type and it isn't supported yet.
  symtab_entry *entry = symtab_find(cg_exprs, expr->type);
  Invariant(entry);
  cg_expr_dispatch *disp = (cg_expr_dispatch*)entry->val;
  disp->func(expr, disp->str, is_null, value, pri, disp->pri_new);
}

// Generates the necessary cleanup call for the given temporary statement
// Normally we use statement 0 for all our temp statements, but, if we are in a
// loop, we recognize that the temp statement might be used again in the next
// iteration.  So instead of eagerly finalizing it, we simply reset it so that
// we can avoid an expensive prepare in the next iteration. All such "in a loop"
// statements have an index greater than 0 to ensure they get a unique name.
static void cg_temp_stmt_cleanup(int32_t stmt_index, charbuf *output) {
  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);
  // if statement index 0 then we're not re-using this statement in a loop
  if (stmt_index == 0) {
    bprintf(output, "cql_finalize_stmt(&%s);\n", temp_stmt.ptr);
  }
  else {
    bprintf(output, "sqlite3_reset(%s);\n", temp_stmt.ptr);
  }
  CHARBUF_CLOSE(temp_stmt);
}

// This is a nested select expression.  To evaluate we will
//  * prepare a temporary to hold the result
//  * generate the bound SQL statement
//  * extract the exactly one argument into the result variable
//    which is of exactly the right type
//  * use that variable as the result.
// The helper methods take care of sqlite error management.
static void cg_expr_select(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_select_variant(ast));

  // SELECT [select_opts] [select_expr_list_con]

  sem_t sem_type_result = ast->sem->sem_type;

  CG_SETUP_RESULT_VAR(ast, sem_type_result);

  int32_t stmt_index = cg_bound_sql_statement(NULL, ast, CG_PREPARE | CG_MINIFY_ALIASES);

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  // exactly one column is allowed, already checked in semantic analysis, fetch it
  bprintf(cg_main_output, "_rc_ = sqlite3_step(%s);\n", temp_stmt.ptr);
  cg_error_on_rc_notequal("SQLITE_ROW");
  cg_get_column(sem_type_result, temp_stmt.ptr, 0, result_var.ptr, cg_main_output);
  cg_temp_stmt_cleanup(stmt_index, cg_main_output);

  CHARBUF_CLOSE(temp_stmt);
  CG_CLEANUP_RESULT_VAR();
}

// "Select ... if nothing throw" is exactly the same codegen as regular select. The throwing
// that is done by default is simply made explcit.  The normal codegen already does
// the "throw" (i.e. goto the current error target).
static void cg_expr_select_if_nothing_throw(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_throw_expr(ast));
  EXTRACT_ANY_NOTNULL(select_expr, ast->left);
  cg_expr_select(select_expr, op, is_null, value, pri, pri_new);
}

// This helper does the evaluation of the select statement portion of the
// (SELECT ... IF NOTHING ...) forms.  Importantly the result type of the select
// might not exactly match the result type of expression because the default
// value could be of a different type and it might cause the overall expression
// to be not null.  So here we have to fetch just the select statement part into
// its own result variable of the exact correct type later we will safely assign
// that result to the final type if it held a value
static int32_t cg_expr_select_frag(ast_node *ast, charbuf *is_null, charbuf *value) {
  sem_t sem_type_result = ast->sem->sem_type;

  CG_SETUP_RESULT_VAR(ast, sem_type_result);

  int32_t stmt_index = cg_bound_sql_statement(NULL, ast, CG_PREPARE | CG_MINIFY_ALIASES);

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  // exactly one column is allowed, already checked in semantic analysis, fetch it
  bprintf(cg_main_output, "_rc_ = sqlite3_step(%s);\n", temp_stmt.ptr);
  cg_error_on_expr("_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE");
  bprintf(cg_main_output, "if (_rc_ == SQLITE_ROW) {\n");
  cg_get_column(sem_type_result, temp_stmt.ptr, 0, result_var.ptr, cg_main_output);

  CHARBUF_CLOSE(temp_stmt);
  CG_CLEANUP_RESULT_VAR();

  // note that callers are expected to check the remaining error codes and clean up
  // the temp statement.
  return stmt_index;
}

// This is a nested select expression.  To evaluate we will
//  * prepare a temporary to hold the result
//  * generate the bound SQL statement
//  * extract the exactly one argument into the result variable
//    which is of exactly the right type
//  * use that variable as the result.
//  * if there is no row, we use the default expression
// The helper methods takes care of sqlite error management.
static void cg_expr_select_if_nothing(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_expr(ast));

  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  // SELECT [select_opts] [select_expr_list_con] IF NOTHING expr

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;
  sem_t sem_type_select = select_stmt->sem->sem_type;

  // this is the overall result
  CG_SETUP_RESULT_VAR(ast, sem_type_result);

  CHARBUF_OPEN(select_is_null);
  CHARBUF_OPEN(select_value);

  // The select statement might have a different result type than overall.
  // e.g. (select an_int from somewhere if nothing 2.5), the overall result is real.
  int32_t stmt_index = cg_expr_select_frag(select_stmt, &select_is_null, &select_value);

  // We're inside of the "if (__rc__ == SQLITE_ROW) {" case. We need to store the
  // result of the select in our output variable note that these are known to be
  // compatible (already verified) but they might not be the exact same type,
  // hence the copy.  In this case we're definitely using the value.
  bprintf(cg_main_output, "  ");
  cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_select, select_is_null.ptr, select_value.ptr);

  bprintf(cg_main_output, "}\n");
  bprintf(cg_main_output, "else {\n  ");

  // if no row found, then evaluate and use the default
  CG_PUSH_EVAL(expr, C_EXPR_PRI_ASSIGN);
  cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_expr, expr_is_null.ptr, expr_value.ptr);
  CG_POP_EVAL(expr);

  bprintf(cg_main_output, "}\n");
  cg_temp_stmt_cleanup(stmt_index, cg_main_output);

  CHARBUF_CLOSE(select_value);
  CHARBUF_CLOSE(select_is_null);

  CG_CLEANUP_RESULT_VAR();
}

// This is a nested select expression.  To evaluate we will
//  * prepare a temporary to hold the result
//  * generate the bound SQL statement
//  * extract the exactly one argument into the result variable
//    which is of exactly the right type
//  * use that variable as the result.
//  * if there is no row, or the returned value is null we use the default expression
// The helper methods take care of sqlite error management.
static void cg_expr_select_if_nothing_or_null(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_or_null_expr(ast));

  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  // SELECT [select_opts] [select_expr_list_con] IF NOTHING expr

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;
  sem_t sem_type_select = select_stmt->sem->sem_type;

  CG_SETUP_RESULT_VAR(ast, sem_type_result);

  CHARBUF_OPEN(select_is_null);
  CHARBUF_OPEN(select_value);

  // the select statement might have a different result type than overall
  // e.g. (select an_int from somewhere if nothing 2.5), the overall result is real
  int32_t stmt_index = cg_expr_select_frag(select_stmt, &select_is_null, &select_value);

  // we're inside of the "if (__rc__ == SQLITE_ROW) {" case
  // in this variation we have to first see if the result is null before we use it
  bprintf(cg_main_output, "}\n");
  bprintf(cg_main_output, "if (_rc_ == SQLITE_DONE || %s) {\n  ", select_is_null.ptr);

  // now row or null result, evaluate the default
  CG_PUSH_EVAL(expr, C_EXPR_PRI_ASSIGN);
  cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_expr, expr_is_null.ptr, expr_value.ptr);
  CG_POP_EVAL(expr);

  bprintf(cg_main_output, "} else { \n  ");
  // ok to use the value we fetched, go ahead an copy it to its final destination
  // note this may change the type but only in a compatible way
  cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_select, select_is_null.ptr, select_value.ptr);
  bprintf(cg_main_output, "}\n");
  bprintf(cg_main_output, "_rc_ = SQLITE_OK;\n");
  cg_temp_stmt_cleanup(stmt_index, cg_main_output);

  CHARBUF_CLOSE(select_value);
  CHARBUF_CLOSE(select_is_null);

  CG_CLEANUP_RESULT_VAR();
}

// This is a nested select expression.  To evaluate we will
//  * prepare a temporary to hold the result
//  * generate the bound SQL statement
//  * extract the exactly one argument into the result variable
//    which is of exactly the right type
//  * use that variable as the result.
//  * if there is no row, or the returned value is null then we throw
// The helper methods take care of sqlite error management.
static void cg_expr_select_if_nothing_or_null_throw(ast_node *ast, CSTR op, charbuf *is_null, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_or_null_throw_expr(ast));

  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);

  // SELECT [select_opts] [select_expr_list_con] IF NOTHING OR NULL THROW

  sem_t sem_type_result = ast->sem->sem_type;

  CG_SETUP_RESULT_VAR(ast, sem_type_result);

  CHARBUF_OPEN(select_is_null);
  CHARBUF_OPEN(select_value);

  // the select statement might have a different result type than overall
  // e.g. (select an_int from somewhere if nothing 2.5), the overall result is real
  int32_t stmt_index = cg_expr_select_frag(select_stmt, &select_is_null, &select_value);

  // we're inside of the "if (__rc__ == SQLITE_ROW) {" case
  // in this variation we have to first see if the result is null before we use it
  bprintf(cg_main_output, "}\n");
  bprintf(cg_main_output, "if (_rc_ == SQLITE_DONE || %s) {\n  ", select_is_null.ptr);
  bprintf(cg_main_output, "  cql_error_trace();\n");
  bprintf(cg_main_output, "  goto %s;\n", error_target);
  bprintf(cg_main_output, "} else { \n  ");
  // ok to use the value we fetched, go ahead an copy it to its final destination
  // note this may change the type but only in a compatible way
  cg_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_result, select_is_null.ptr, select_value.ptr);
  bprintf(cg_main_output, "}\n");
  bprintf(cg_main_output, "_rc_ = SQLITE_OK;\n");
  cg_temp_stmt_cleanup(stmt_index, cg_main_output);

  CHARBUF_CLOSE(select_value);
  CHARBUF_CLOSE(select_is_null);

  CG_CLEANUP_RESULT_VAR();
}

// This is the elementary piece of the if-then construct, it's one condition
// and one statement list.  It can happen in the context of the top level
// if or any else-if.  The conditional generated requires either simple true
// for not nulls or nullable true (i.e. null is false, false is false).
static void cg_cond_action(ast_node *ast) {
  Contract(is_ast_cond_action(ast));
  EXTRACT(stmt_list, ast->right);
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  // [expr ast->left] THEN stmt_list

  sem_t sem_type_expr = expr->sem->sem_type;

  cg_line_directive_max(expr, cg_main_output);

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  if (is_ast_null(expr) || is_not_nullable(sem_type_expr)) {
    bprintf(cg_main_output, "if (%s) {\n", expr_value.ptr);
  }
  else {
    bprintf(cg_main_output, "if (cql_is_nullable_true(%s, %s)) {\n", expr_is_null.ptr, expr_value.ptr);
  }

  CG_POP_EVAL(expr);

  if (stmt_list) {
    cg_stmt_list(stmt_list);
    cg_line_directive_max(stmt_list, cg_main_output);
  }

  bprintf(cg_main_output, "}\n");
}

// Recursively emits the else-if chain.  These have to nest to allow for
// expressions to generate statements.
static void cg_elseif_list(ast_node *ast, ast_node *elsenode) {
  if (ast) {
    Contract(is_ast_elseif(ast));
    EXTRACT(cond_action, ast->left);

    // ELSE IF [cond_action]
    bprintf(cg_main_output, "else {\n");
      CG_PUSH_MAIN_INDENT(else, 2);
      cg_cond_action(cond_action);
      cg_elseif_list(ast->right, elsenode);
      CG_POP_MAIN_INDENT(else);
    bprintf(cg_main_output, "}\n");
  }
  else if (elsenode) {
    Contract(is_ast_else(elsenode));
    // ELSE [stmt_list]
    cg_line_directive_min(elsenode, cg_main_output);
    EXTRACT(stmt_list, elsenode->left);
    bprintf(cg_main_output, "else {\n");
    cg_stmt_list(stmt_list);
    bprintf(cg_main_output, "}\n");
  }
}

// This evaluates an expression and discards the result
// We could optimize this more by looking to see if
// the expression could possibly have side effects
// and not emitting it if it is side-effect free.
static void cg_expr_stmt(ast_node *ast) {
  Contract(is_ast_expr_stmt(ast));

  EXTRACT_ANY_NOTNULL(expr, ast->left);

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  bprintf(cg_main_output, "(void)(%s);\n", expr_value.ptr);

  CG_POP_EVAL(expr);
}

static void cg_ifdef_stmt(ast_node *ast) {
  Contract(is_ast_ifdef_stmt(ast) || is_ast_ifndef_stmt(ast));
  EXTRACT_ANY_NOTNULL(evaluation, ast->left);
  EXTRACT_NOTNULL(pre, ast->right);
  bool_t is_true = is_ast_is_true(evaluation);

  // We don't want to count these statements as nested, we're still global
  // If were were global before.
  stmt_nesting_level--;

  if (is_true) {
    EXTRACT(stmt_list, pre->left);
    if (stmt_list) {
      cg_stmt_list(stmt_list);
    }
  }
  else {
    EXTRACT(stmt_list, pre->right);
    if (stmt_list) {
      cg_stmt_list(stmt_list);
    }
  }

  // Put back the statement level
  stmt_nesting_level++;
}

static void cg_ifndef_stmt(ast_node *ast) {
  // the true/false evaluation has already been done and we are is_true if
  // we take the true branch
  cg_ifdef_stmt(ast);
}

// As with the other cases the fact that expressions might require statements
// complicates the codegen. If there is an else-if (expression) that expression
// might itself require statements to compute the expression.  Even a logical
// AND might require statements if there is nullability involved. That means the
// overall pattern has to look like this, with nesting.
//
// prep statements;
//   result = final expression;
//   if (result) {
//     statements;
//   }
//   else {
//     prep statements;
//     result = final expression;
//     if (result) {
//       statements;
//     }
//     else {
//      statements;
//     }
//   }
static void cg_if_stmt(ast_node *ast) {
  Contract(is_ast_if_stmt(ast));

  EXTRACT_NOTNULL(cond_action, ast->left);
  EXTRACT_NOTNULL(if_alt, ast->right);

  // IF [cond_action] [if_alt]
  cg_cond_action(cond_action);

  EXTRACT(elseif, if_alt->left);
  EXTRACT_NAMED(elsenode, else, if_alt->right);
  cg_elseif_list(elseif, elsenode);

  // END IF
}

// This code uses the same cg_store helper method to do an assignment as is used
// all over the place for assigning to scratch variables.  All we have to do
// here is pull the name and types out of the ast.
static void cg_assign(ast_node *ast) {
  Contract(is_ast_assign(ast) || is_ast_let_stmt(ast) || is_ast_const_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  CSTR name = name_ast->sem->name;  // crucial: use the canonical name not the specified name

  Contract(stack_level == 0);

  // SET [name] := [expr]

  sem_t sem_type_var = name_ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ASSIGN);
  cg_store(cg_main_output, name, sem_type_var, sem_type_expr, expr_is_null.ptr, expr_value.ptr);
  CG_POP_EVAL(expr);
}

// In the LET statement, we declare the variable based on type, emit that
// then do the usual SET codegen.
static void cg_let_stmt(ast_node *ast) {
  Contract(is_ast_let_stmt(ast) || is_ast_const_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);

  // null type variables are null aliases, they are rewritten away
  if (is_null_type(name_ast->sem->sem_type)) {
    return;
  }

  cg_declare_simple_var(name_ast->sem->sem_type, name);
  cg_assign(ast);
}

// In the CONST statement, emit the same codegen as LET statement.
// Immutability enforcement is done during semantic analysis.
static void cg_const_stmt(ast_node *ast) {
  Contract(is_ast_const_stmt(ast));
  cg_let_stmt(ast);
}

// This is the processing for a single parameter in a stored proc declaration.
// All we have to do is emit the type signature of that parameter.  This is
// precisely what cg_var_decl with CG_VAR_DECL_PROTO is for...
static void cg_param(ast_node *ast, charbuf *decls, bool_t alias_in_ref) {
  Contract(is_ast_param(ast));
  EXTRACT_NOTNULL(param_detail, ast->right);
  EXTRACT_NAME_AST(name_ast, param_detail->left)
  EXTRACT_STRING(name, name_ast);

  // [in out] name [datatype]

  sem_t sem_type = name_ast->sem->sem_type;

  // If this parameter will be mutated we have to own the reference, so we make
  // an alias We'll initialize the alias from the argument during param init.

  if (alias_in_ref && !is_out_parameter(sem_type) && was_set_variable(sem_type) && is_ref_type(sem_type)) {
    CHARBUF_OPEN(alias);
    bprintf(&alias, "_in__%s", name);
    cg_var_decl(decls, sem_type, alias.ptr, CG_VAR_DECL_PROTO);
    CHARBUF_CLOSE(alias);
  }
  else {
    cg_var_decl(decls, sem_type, name, CG_VAR_DECL_PROTO);
  }
}

// Walk all the params of a stored proc and emit each one with a comma where needed.
// cg_param does all the hard work.
static void cg_params(ast_node *ast, charbuf *decls, bool_t alias_in_ref) {
  Contract(is_ast_params(ast));

  while (ast) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left);

    cg_param(param, decls, alias_in_ref);

    if (ast->right) {
      bprintf(decls, ", ");
    }

    ast = ast->right;
  }
}

// Emit any initialization code needed for the parameters. In particular out
// parameters assume that there is garbage in the out location, so they hammer a
// NULL or 0 into that slot.
static void cg_param_init(ast_node *ast, charbuf *body) {
  Contract(is_ast_param(ast));
  EXTRACT_NOTNULL(param_detail, ast->right);
  EXTRACT_NAME_AST(name_ast, param_detail->left)
  EXTRACT_STRING(name, name_ast);

  // [in out] name [datatype]

  sem_t sem_type = name_ast->sem->sem_type;

  // In a proc decl the out arg initialized to null, this avoids attempting
  // to release any incoming garbage value and ensures some sanity in the event
  // the the return code is ignored...  Nobody ignores return codes, right?
  if (is_out_parameter(sem_type) && !is_in_parameter(sem_type)) {
    if (is_ref_type(sem_type)) {
      bprintf(body, "  *(void **)%s = NULL; // set out arg to non-garbage\n", name);
    }
    else if (is_nullable(sem_type)) {
      bprintf(body, "  cql_set_null(*%s); // set out arg to non-garbage\n", name);
    }
    else {
      bprintf(body, "  *%s = 0; // set out arg to non-garbage\n", name);
    }
  }

  // If this parameter will be mutated we have to own the reference, so we make
  // an alias. Here we initialize the alias from the in parameter.  The variable
  // now has normal lifetime.

  // Example:  proc foo(x text) begin x := 'foo'; end;
  //
  // The 'x' argument is borrowed, so we don't normally release 'x' however we
  // put 'foo' in it The caller isn't going to release the string 'foo', we
  // aren't because we donm't release 'x' becaues it's borrowed.  To fix this
  // instead we generate effectively:
  //
  // proc foo(_in__x text) begin let x := _in__x;  x := 'foo'; end;
  //
  // That pattern works as usual and of course _in__x is not mutated so it
  // doesn't have to be released.  FWIW: Lua codegen doesn't have this problem
  // because Lua manages the refs.

  if (!is_out_parameter(sem_type) && was_set_variable(sem_type) && is_ref_type(sem_type)) {
    cg_declare_simple_var(sem_type, name);

    CHARBUF_OPEN(alias);
    bprintf(&alias, "_in__%s", name);
    bprintf(body, "  ");
    cg_copy(body, name, sem_type, alias.ptr);
    CHARBUF_CLOSE(alias);
  }
}

// Walk all the params of a stored proc, if any of them require initialization
// code in the body, emit that here.
static void cg_params_init(ast_node *ast, charbuf *body) {
  Contract(is_ast_params(ast));

  while (ast) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left);

    cg_param_init(param, body);

    ast = ast->right;
  }
}

// This is used when we are making a call to a known stored proc.  This is
// usable only in limited cases where we have previously set up local variables
// whose names exactly match the formal names of the function we are attempting
// to call. In particular the function that generates a rowset knows how to call
// the corresponding function that generates a statement because their
// signatures exactly match.
static void cg_param_name(ast_node *ast, charbuf *output) {
  Contract(is_ast_param(ast));
  EXTRACT_NOTNULL(param_detail, ast->right);
  EXTRACT_NAME_AST(name_ast, param_detail->left)
  EXTRACT_STRING(name, name_ast);

  bprintf(output, "%s", name);
}

// This loops through the parameters and emits each one as part of a call where
// we have a local for each parameter.  See above.
static void cg_param_names(ast_node *ast, charbuf *output) {
  Contract(is_ast_params(ast));

  while (ast) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left);

    cg_param_name(param, output);

    if (ast->right) {
      bprintf(output, ", ");
    }

    ast = ast->right;
  }
}

// Row types are emitted in a canonical order to make comparison, hashing and
// other operations easier.  For now that order is simply primitive types and
// then reference types.  This will become more strict over time as other areas
// take advantage of ordering to generate more compact code.
static void cg_fields_in_canonical_order(charbuf *output, sem_struct *sptr) {
  uint32_t count = sptr->count;

  // first primitive types
  for (uint32_t i = 0; i < count; i++) {
    sem_t sem_type = sptr->semtypes[i];
    if (is_ref_type(sem_type)) {
      continue;
    }
    CSTR col = sptr->names[i];
    bprintf(output, "  ");
    cg_var_decl(output, sem_type, col, CG_VAR_DECL_PROTO);
    bprintf(output, ";\n");
  }

  // then reference types
  for (uint32_t i = 0; i < count; i++) {
    sem_t sem_type = sptr->semtypes[i];
    if (!is_ref_type(sem_type)) {
      continue;
    }

    CSTR col = sptr->names[i];
    bprintf(output, "  ");
    cg_var_decl(output, sem_type, col, CG_VAR_DECL_PROTO);
    bprintf(output, ";\n");
  }
}

// This function generates a struct definition into the indicated output. If
// `cursor_name` is NULL, as is the case for the result type of procs with the
// OUT keyword, the struct will be named with the current proc name. If
// `cursor_name` is not NULL, the struct will be named with both the current
// proc name and the cursor name. The struct includes the _has_row_ boolean plus
// the fields of the sem_struct provided.
static void cg_c_struct_for_sptr(charbuf *output, sem_struct *sptr, CSTR cursor_name) {
  Invariant(sptr);

  CSTR scope = current_proc_name();
  Contract(scope || cursor_name);  // no scope and no name makes no sense
  bool_t is_out_proc = !cursor_name;
  CSTR suffix = (cursor_name && scope) ? "_" : "";
  scope = scope ? scope : "";
  cursor_name = cursor_name ? cursor_name : "";

  CG_CHARBUF_OPEN_SYM(row_type, scope, suffix, cursor_name, "_row");

  bprintf(output, "\n");

  if (is_out_proc) {
    // Since we emit this for each DECLARE PROC as well as CREATE PROC, we need
    // a guard to avoid duplicate definitions
    bprintf(output, "#ifndef row_type_decl_%s\n", row_type.ptr);
    bprintf(output, "#define row_type_decl_%s 1\n", row_type.ptr);
  }

  bprintf(output, "typedef struct %s {\n", row_type.ptr);

  // emit the two standard fields, _has_row_, _refs_count_, and _refs_offset_
  bprintf(output, "  cql_bool _has_row_;\n");
  bprintf(output, "  cql_uint16 _refs_count_;\n");
  bprintf(output, "  cql_uint16 _refs_offset_;\n");

  cg_fields_in_canonical_order(output, sptr);

  bprintf(output, "} %s;\n", row_type.ptr);

  if (is_out_proc) {
    bprintf(output, "#endif\n");
  }

  CHARBUF_CLOSE(row_type);
}

// We often need the count of reference types in a struct type
static int32_t refs_count_sptr(sem_struct *sptr) {
  int32_t refs_count = 0;

  for (uint32_t i = 0; i < sptr->count; i++) {
    if (is_ref_type(sptr->semtypes[i])) {
      refs_count++;
    }
  }

  return refs_count;
}

// Emit the offsets for the given struct type into the output with the given name
static void cg_col_offsets(charbuf *output, sem_struct *sptr, CSTR sym_name, CSTR struct_name) {
  uint32_t count = sptr->count;

  CSTR prefix = in_var_group_emit ? "" : "static ";

  bprintf(output, "\n%scql_uint16 %s[] = { %d", prefix, sym_name, count);

  for (uint32_t i = 0; i < sptr->count; i++) {
    bprintf(output, ",\n");
    bprintf(output, "  cql_offsetof(%s, %s)", struct_name,  sptr->names[i]);
  }

  bprintf(output, "\n};\n");
}

static void cg_data_types(charbuf *output, sem_struct *sptr, CSTR sym_name) {
  CSTR prefix = in_var_group_emit ? "" : "static ";

  bprintf(output, "\n%suint8_t %s[] = {\n", prefix, sym_name);

  for (uint32_t i = 0; i < sptr->count; i++) {
    if (i != 0) {
      bprintf(output, ",\n");
    }
    bprintf(output, "  ");
    cg_data_type(output, sptr->semtypes[i]);
  }

  bprintf(output, "\n};\n");
}

// This is the codegen for a dynamic cursor.  When a function has an arg that is
// of type CURSOR this means that it accepts any kind of cursor.  So, the cursor
// argument is replaced with a so-called "dynamic cursor".  This is a bunch of
// metadata about the cursor such as the names of its fields as well as their
// types and offsets.  The function can use this information to do its job.
// Normally such functions are pretty generic, like format the cursor as a
// string, or hash the cursor.  But in principle it can be anyuthing. This code
// generates the necessary variables for a dynamic cursor so that when a call
// happens later &cursor_name_dyn can be passed for the arg and it's ready to go.
static void cg_dynamic_cursor(charbuf *output, sem_struct *sptr, CSTR sym_name, CSTR cols_name, CSTR types_name) {
  CSTR scope = current_proc_name();
  CSTR suffix = (sym_name && scope) ? "_" : "";
  scope = scope ? scope : "";

  CG_CHARBUF_OPEN_SYM(refs_offset, scope, suffix, sym_name, "_refs_offset");
  CG_CHARBUF_OPEN_SYM(fields, scope, suffix, sym_name, "_fields");
  int32_t refs_count = refs_count_sptr(sptr);

  // NOTE: that cursor field strings are highly duplicative but the
  // compiler/linker will fold these anyway
  bprintf(output, "const char *%s[] = {\n", fields.ptr);
  for (uint32_t i = 0; i < sptr->count; i++) {
    // for consistency with debug info and Lua we use the actual encoded field
    // name for the dynamic cursor.  The other option (using names like `an id`)
    // is problematic.  Any particular call may decode the names if it wants to.
    bprintf(output, "  \"%s\",\n", sptr->names[i]);
  }
  bprintf(output, "};\n");

  bprintf(output, "cql_dynamic_cursor %s_dyn = {\n", sym_name);
  bprintf(output, "  .cursor_data = (void *)&%s,\n", sym_name);
  bprintf(output, "  .cursor_has_row = (void *)&%s._has_row_,\n", sym_name);
  bprintf(output, "  .cursor_data_types = %s,\n", types_name);
  bprintf(output, "  .cursor_col_offsets = %s,\n", cols_name);
  bprintf(output, "  .cursor_size = sizeof(%s),\n", sym_name);
  bprintf(output, "  .cursor_fields = %s,\n", fields.ptr);
  if (refs_count) {
    bprintf(output, "  .cursor_refs_count = %d,\n", refs_count);
    bprintf(output, "  .cursor_refs_offset = %s,\n", refs_offset.ptr);
  }
  bprintf(output, "};\n");

  CHARBUF_CLOSE(fields);
  CHARBUF_CLOSE(refs_offset);
}

// Emit the offsets for the reference types in the given struct type into the output
static void cg_refs_offset(charbuf *output, sem_struct *sptr, CSTR offset_sym, CSTR struct_name) {
  int32_t refs_count = refs_count_sptr(sptr);

  bprintf(output, "\n#define %s ", offset_sym);

  for (uint32_t i = 0; i < sptr->count; i++) {
    if (is_ref_type(sptr->semtypes[i])) {
      bprintf(output, "cql_offsetof(%s, %s) // count = %d\n", struct_name,  sptr->names[i], refs_count);
      break;
    }
  }
}

static void find_identity_columns_callback(CSTR _Nonnull name, ast_node *_Nonnull found_ast, void *_Nullable context) {
  Invariant(context);
  charbuf *output = (charbuf*)context;

  Invariant(current_proc);
  Invariant(current_proc->sem);
  Invariant(current_proc->sem->sptr);

  sem_struct *sptr = current_proc->sem->sptr;

  // already checked in semantic analysis
  int32_t col_index = sem_column_index(sptr, name);
  Invariant(col_index >= 0);

  bprintf(output, "  %d, // %s\n", col_index, name);
}

// Emit the array of identity columns (used by cql_rows_same to determine which columns identify the "same" record)
// Return 1 if any identity columns were found; otherwise 0
static bool_t cg_identity_columns(
  charbuf *headers_output,
  charbuf *defs_output,
  CSTR proc_name,
  ast_node *_Nullable misc_attrs,
  CSTR identity_columns_sym)
{
  if (!misc_attrs) {
    return false;
  }

  CHARBUF_OPEN(cols);
  uint32_t count = find_identity_columns(misc_attrs, &find_identity_columns_callback, &cols);
  if (count > 0) {
    bprintf(headers_output, "%scql_uint16 %s[];\n\n", rt->symbol_visibility, identity_columns_sym);
    bprintf(defs_output, "\ncql_uint16 %s[] = { %d,\n%s};\n", identity_columns_sym, count, cols.ptr);
  }
  CHARBUF_CLOSE(cols);
  return count > 0;
}

// Emit the teardown information for use in in a rowset row or cursor row
// this is just the count of references and the offset of the first reference
// in the row structure. Since the references are stored together and are
// at the end of the row you can alway clean up a row using just the offset
// and the count.
static void cg_struct_teardown_info(charbuf *output, sem_struct *sptr, CSTR name) {
  Invariant(sptr);

  int32_t refs_count = refs_count_sptr(sptr);
  if (!refs_count) {
    return;
  }

  CSTR scope = current_proc_name();
  Contract(scope || name);  // no scope and no name makes no sense
  CSTR suffix = (name && scope) ? "_" : "";
  scope = scope ? scope : "";
  name = name ? name : "";

  CG_CHARBUF_OPEN_SYM(count_sym, scope, suffix, name, "_refs_count");
  CG_CHARBUF_OPEN_SYM(offset_sym, scope, suffix, name, "_refs_offset");
  CG_CHARBUF_OPEN_SYM(row_type, scope, suffix, name, "_row");

  cg_refs_offset(output, sptr, offset_sym.ptr, row_type.ptr);

  CHARBUF_CLOSE(row_type);
  CHARBUF_CLOSE(offset_sym);
  CHARBUF_CLOSE(count_sym);
}

// Emit the return code variables for the procedure
// if the procedure uses throw then it needs the saved RC as well so we can re-throw it
static void cg_emit_rc_vars(charbuf *output) {
  bprintf(output, "  cql_code _rc_ = SQLITE_OK;\n");
}

// For each parameter, emit a contract that enforces nullability as follows:
//
// * In the case of an IN NOT NULL parameter, enforce that the caller has not
//   passed NULL.
// * Similarly, in the case of an OUT or INOUT parameter, again enforce that the
//   caller has not passed NULL.
// * In addition to the previous case, in the case of an INOUT NOT NULL
//   parameter, enforce that the pointer provided by the caller does not point
//   to NULL.
//
// The contracts emitted always match the _Notnull parameter attributes in the
// declaration of the procedure.
static void cg_emit_contracts(ast_node *ast, charbuf *b) {
  Contract(is_ast_params(ast));
  Contract(b);

  CHARBUF_OPEN(alias);

  bool_t did_emit_contract = false;

  int32_t position = 1;
  for (ast_node *params = ast; params; params = params->right, position++) {
    Contract(is_ast_params(params));
    EXTRACT_NOTNULL(param, params->left);
    EXTRACT_NOTNULL(param_detail, param->right);
    EXTRACT_NAME_AST(name_ast, param_detail->left);
    EXTRACT_STRING(name, name_ast);

    sem_t sem_type = name_ast->sem->sem_type;

    // if the in_arg has been renamed, we use its alias here
    if (!is_out_parameter(sem_type) && was_set_variable(sem_type) && is_ref_type(sem_type)) {
      bclear(&alias);
      bprintf(&alias, "_in__%s", name);
      name = alias.ptr;
    }

    bool_t is_nonnull_ref_type = is_not_nullable(sem_type) && is_ref_type(sem_type);
    if (is_inout_parameter(sem_type) && is_nonnull_ref_type) {
      // This is the special case of `INOUT arg R NOT NULL`, where `R` is a
      // reference type. This case is special because both the argument and what
      // it points to must not be null; the former because we'll write to it,
      // and the latter because we'll read it and expect it to not be NULL.
      bprintf(b, "  cql_contract_argument_notnull_when_dereferenced((void *)%s, %d);\n", name, position);
      did_emit_contract = true;
    }
    else if (is_out_parameter(sem_type) || is_nonnull_ref_type) {
      // Here, only the argument itself must not be null. This is either because
      // we have an OUT argument and thus only need to be able to write to the
      // address given, or because we have an `IN arg R NOT NULL` (where `R` is
      // some reference type) that we'll read and expect to not be NULL.
      bprintf(b, "  cql_contract_argument_notnull((void *)%s, %d);\n", name, position);
      did_emit_contract = true;
    }
  }

  if (did_emit_contract) {
    bprintf(b, "\n");
  }

  CHARBUF_CLOSE(alias);
}

#define EMIT_DML_PROC 1

// Emit a prototype for the fetch results function into the indicated buffer we
// need some context such as "is it a dml proc" to do this correctly but
// otherwise this is just using some of our standard helpers
static void cg_emit_fetch_results_prototype(
  bool_t dml_proc,
  ast_node *params,
  CSTR proc_name,
  CSTR result_set_name,
  charbuf *decl)
{
  CG_CHARBUF_OPEN_SYM(fetch_results_sym, proc_name, "_fetch_results");
  CG_CHARBUF_OPEN_SYM(result_set_ref, result_set_name, "_result_set_ref");

  // either return code or void
  if (dml_proc) {
    bprintf(decl, "CQL_WARN_UNUSED cql_code ");
  }
  else {
    bprintf(decl, "void ");
  }

  // proc name
  bprintf(decl, "%s(", fetch_results_sym.ptr);

  // optional db reference
  if (dml_proc) {
    bprintf(decl, "sqlite3 *_Nonnull _db_,");
  }

  // result set type
  bprintf(decl, " %s _Nullable *_Nonnull result_set", result_set_ref.ptr);

  // args to forward
  if (params) {
    bprintf(decl, ", ");
    cg_params(params, decl, CG_PROC_PARAMS_NO_ALIAS);
  }

  CHARBUF_CLOSE(result_set_ref);
  CHARBUF_CLOSE(fetch_results_sym);
}

// The prototype for the given procedure goes into the given buffer.  This is a
// naked prototype, so additional arguments could be added -- it will be missing
// the trailing ")" and it will not have EXPORT or anything like that on it.
static void cg_emit_proc_prototype(ast_node *ast, charbuf *proc_decl, bool_t force_fetch_results) {
  Contract(is_ast_create_proc_stmt(ast) || is_ast_declare_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  CSTR name = NULL;

  if (is_ast_create_proc_stmt(ast)) {
    EXTRACT_STRING(n, ast->left);
    name = n;
  }
  else {
    EXTRACT_NOTNULL(proc_name_type, ast->left);
    EXTRACT_STRING(n, proc_name_type->left);
    name = n;
  }

  bool_t private_proc = is_proc_private(ast);
  bool_t dml_proc = is_dml_proc(ast->sem->sem_type);
  bool_t result_set_proc = has_result_set(ast);
  bool_t out_stmt_proc = has_out_stmt_result(ast);
  bool_t out_union_proc = has_out_union_stmt_result(ast) || force_fetch_results;

  // if you're doing out_union then the row fetcher is all there is
  CSTR suffix = out_union_proc ? "_fetch_results" : "";

  // use alternative prefix if there is one.
  CSTR prefix = rt->symbol_prefix;
  if (misc_attrs){
    CSTR alt_prefix = get_named_string_attribute_value(misc_attrs, "alt_prefix");
    if (alt_prefix) {
      prefix = alt_prefix;
    }
  }
  CG_CHARBUF_OPEN_SYM_WITH_PREFIX(proc_sym, prefix, name, suffix);

  if (private_proc) {
    bprintf(proc_decl, "static ");
  }

  bool_t need_comma = false;
  if (dml_proc) {
    bprintf(proc_decl, "CQL_WARN_UNUSED cql_code %s(sqlite3 *_Nonnull _db_", proc_sym.ptr);
    if (result_set_proc && !force_fetch_results) {
      bprintf(proc_decl, ", sqlite3_stmt *_Nullable *_Nonnull _result_stmt");
    }
    need_comma = true;
  }
  else {
    bprintf(proc_decl, "void %s(", proc_sym.ptr);
  }

  if (out_union_proc) {
    CG_CHARBUF_OPEN_SYM(result_set_ref, name, "_result_set_ref");

    if (need_comma) {
      bprintf(proc_decl, ", ");
    }

    // result set type
    bprintf(proc_decl, "%s _Nullable *_Nonnull _result_set_", result_set_ref.ptr);

    need_comma = true;
    CHARBUF_CLOSE(result_set_ref);
  }

  // CREATE PROC [name] ( [params] )
  if (params) {
    if (need_comma) {
      bprintf(proc_decl, ", ");
    }
    cg_params(params, proc_decl, CG_PROC_PARAMS_IN_ALIAS);
  }

  if (out_stmt_proc && !force_fetch_results) {
    if (dml_proc || params) {
      bprintf(proc_decl, ", ");
    }

    CG_CHARBUF_OPEN_SYM(result_type, name, "_row");
    bprintf(proc_decl, "%s *_Nonnull _result_", result_type.ptr);
    CHARBUF_CLOSE(result_type);
  }

  if (!params && !out_stmt_proc && !out_union_proc && !dml_proc) {
    bprintf(proc_decl, "void");  // make foo(void) rather than foo()
  }

  CHARBUF_CLOSE(proc_sym);
}

// Emitting a stored proc is mostly setup.  We have a bunch of housekeeping to do:
//  * create new scratch buffers for the body and the locals and the cleanup section
//  * save the current output globals
//  * set the globals to point to those buffers
//  * save the old scratch masks and create new ones
//  * emit the prototype of the C function for this proc into two streams:
//      * the .h file (in prototype form)
//      * the current main_output (in function definition form)
//      * use the helper method above to emit the parameters
//  * recursively spit out the statements
//  * when this is all done assemble the pieces into the original output streams
//  * procedures that use SQL will get a hidden _db_ argument
//  * procedures that return a result set will get a statement output
//    * and the additional procedures for creating the result set and accessing it are emitted
static void cg_create_proc_stmt(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  bool_t private_proc = is_proc_private(ast);
  bool_t dml_proc = is_dml_proc(ast->sem->sem_type);
  bool_t result_set_proc = has_result_set(ast);
  bool_t out_stmt_proc = has_out_stmt_result(ast);
  bool_t out_union_proc = has_out_union_stmt_result(ast);
  bool_t calls_out_union = has_out_union_call(ast);
  proc_cte_index = 0;
  cur_bound_statement = 0;
  int32_t c_prepared_statement_index_saved = c_prepared_statement_index;
  c_prepared_statement_index = 0;

  if (is_proc_shared_fragment(ast)) {
    // shared fragments produce no code at all, no header, nothing
    // extension fragments, same story
    // put a line marker in the header file in case we want a test suite that verifies that

    if (options.test) {
      bprintf(cg_header_output, "\n// The statement ending at line %d\n//\n", ast->lineno);
    }

    return;
  }

  CHARBUF_OPEN(proc_fwd_ref);
  CHARBUF_OPEN(proc_contracts);
  CHARBUF_OPEN(proc_body);
  CHARBUF_OPEN(proc_locals);
  CHARBUF_OPEN(proc_cleanup);

  bool_t saved_error_target_used = error_target_used;
  error_target_used = false;
  return_used = false;

  int32_t saved_rcthrown_index = rcthrown_index;
  rcthrown_index = 0;

  bool_t saved_rcthrown_used = rcthrown_used;
  rcthrown_used = false;

  bool_t saved_temp_emitted = temp_statement_emitted;
  bool_t saved_seed_declared = seed_declared;
  charbuf *saved_main = cg_main_output;
  charbuf *saved_decls = cg_declarations_output;
  charbuf *saved_scratch = cg_scratch_vars_output;
  charbuf *saved_cleanup = cg_cleanup_output;
  charbuf *saved_fwd_ref = cg_fwd_ref_output;
  cg_scratch_masks *saved_masks = cg_current_masks;
  cg_scratch_masks masks;
  cg_current_masks = &masks;
  cg_zero_masks(cg_current_masks);
  temp_statement_emitted = false;
  in_proc = true;
  current_proc = ast;
  seed_declared = false;

  bprintf(cg_declarations_output, "\n");

  // if you're doing out_union then the row fetcher is all there is
  CSTR suffix = out_union_proc ? "_fetch_results" : "";

  CG_CHARBUF_OPEN_SYM(proc_name_base, name);
  CG_CHARBUF_OPEN_SYM(proc_sym, name, suffix);

  bprintf(cg_declarations_output, "#define _PROC_ \"%s\"\n", proc_sym.ptr);

  if (out_stmt_proc || out_union_proc) {
    cg_c_struct_for_sptr(cg_fwd_ref_output, ast->sem->sptr, NULL);
    cg_struct_teardown_info(cg_declarations_output, ast->sem->sptr, NULL);
  }

  if (out_stmt_proc || out_union_proc || result_set_proc) {
    cg_proc_result_set(ast);
  }

  if (options.test) {
    // echo the export where it can be sanity checked
    bprintf(cg_declarations_output, "/*\n");
    if (private_proc) {
      bprintf(cg_declarations_output, "private:\n");
    }
    else {
      bprintf(cg_declarations_output, "export:\n");
    }

    gen_set_output_buffer(cg_declarations_output);
    gen_declare_proc_closure(ast, NULL);
    bprintf(cg_declarations_output, "*/\n");
  }

  cg_main_output = &proc_body;
  cg_declarations_output = &proc_locals;
  cg_scratch_vars_output = &proc_locals;
  cg_cleanup_output = &proc_cleanup;

  CHARBUF_OPEN(proc_decl);
  cg_emit_proc_prototype(ast, &proc_decl, CQL_PROTO_NORMAL);

  if (out_union_proc) {
    CG_CHARBUF_OPEN_SYM(result_set_ref, name, "_result_set_ref");

    if (!calls_out_union) {
      CSTR rc = dml_proc ? "_rc_" : "SQLITE_OK";
      if (dml_proc) {
        bprintf(&proc_cleanup, "  %s_info.db = _db_;\n", proc_name_base.ptr);
      }
      bprintf(
        &proc_cleanup,
        "  cql_results_from_data(%s, &_rows_, &%s_info, (cql_result_set_ref *)_result_set_);\n",
        rc,
        proc_name_base.ptr);
      if (dml_proc) {
        bprintf(&proc_cleanup, "  %s_info.db = NULL;\n", proc_name_base.ptr);
      }

      CG_CHARBUF_OPEN_SYM(perf_index, name, "_perf_index");
        // emit profiling start signal
        bprintf(&proc_body, "  cql_profile_start(CRC_%s, &%s);\n", proc_name_base.ptr, perf_index.ptr);
      CHARBUF_CLOSE(perf_index);
    }
    else {
      // If this is a forwarding procedure then we have to ensure that we produce at least an empty
      // result even if the procedure didn't actually make the call to the forwarder.

      if (dml_proc) {
        bprintf(&proc_cleanup, "  if (_rc_ == SQLITE_OK && !*_result_set_) ");
      }
      else {
        bprintf(&proc_cleanup, "  if (!*_result_set_) ");
      }

      bprintf(&proc_cleanup, "*_result_set_ = (%s)cql_no_rows_result_set();\n", result_set_ref.ptr);
    }
    CHARBUF_CLOSE(result_set_ref);
  }

  // CREATE PROC [name] ( [params] )
  if (params) {
    cg_params_init(params, &proc_body);
    if (!private_proc) {
      cg_emit_contracts(params, &proc_contracts);
    }
  }

  if (dml_proc) {
    // Your cqlrt can define cql_error_prepare to be whatever it wants. Maybe something
    // that declares some local variables that your tracing will use.  Or something
    // that pushes an error context onto a stack.  Any kind of tracing can be constructed
    // like this -- entirely up to your cqlrt.  The default version expands to nothing.
    bprintf(&proc_locals, "cql_error_prepare();\n");
  }

  if (out_stmt_proc) {
    bprintf(&proc_locals, "memset(_result_, 0, sizeof(*_result_));\n");
  }

  // If the proc has a result, don't expose a function with the proc name.
  // Consumers should use the _fetch_results function to execute the proc.
  // We don't make it "static" so that CQL-based tests can access it.  However
  // you would have to import it yourself to get access to the symbol (--generate_exports)
  charbuf *decl = (result_set_proc || out_stmt_proc) ? cg_fwd_ref_output : cg_header_output;

  if (private_proc)  {
    bprintf(decl, "// %s);\n", proc_decl.ptr);
  }
  else {
    bprintf(decl, "%s%s);\n", rt->symbol_visibility, proc_decl.ptr);
  }

  if (options.generate_exports && !private_proc) {
    gen_set_output_buffer(exports_output);
    // the declare proc and any other procs it needs due to types with kind object<x SET>
    gen_declare_proc_closure(ast, emitted_proc_decls);
  }

  if (out_union_proc) {
    // clobber the out arg, it is assumed to be trash by convention
    bprintf(&proc_locals, "*_result_set_ = NULL;\n");
  }

  cg_fwd_ref_output = &proc_fwd_ref;
  // BEGIN [stmt_list] END
  cg_stmt_list(stmt_list);

  cg_fwd_ref_output = saved_fwd_ref;
  cg_main_output = saved_main;
  cg_declarations_output = saved_decls;
  cg_scratch_vars_output = saved_scratch;
  cg_cleanup_output = saved_cleanup;
  cg_current_masks = saved_masks;
  temp_statement_emitted = saved_temp_emitted;
  seed_declared = saved_seed_declared;

  bprintf(cg_declarations_output, "%s", proc_fwd_ref.ptr);
  bprintf(cg_declarations_output, "%s) {\n", proc_decl.ptr);
  bprintf(cg_declarations_output, "%s", proc_contracts.ptr);

  if (dml_proc) {
    cg_emit_rc_vars(cg_declarations_output);
    if (result_set_proc) {
      bprintf(cg_declarations_output, "  *_result_stmt = NULL;\n");
    }
  }

  if (out_union_proc && !calls_out_union) {
    bprintf(cg_declarations_output, "  cql_bytebuf _rows_;\n");
    bprintf(cg_declarations_output, "  cql_bytebuf_open(&_rows_);\n");
  }

  bindent(cg_declarations_output, &proc_locals, 2);
  if (proc_locals.used > 1) {
    bprintf(cg_declarations_output, "\n");
  }

  bprintf(cg_declarations_output, "%s", proc_body.ptr);

  cg_line_directive_max(ast, cg_declarations_output);

  if (dml_proc) {
    bprintf(cg_declarations_output, "  _rc_ = SQLITE_OK;\n");
  }

  bool_t empty_statement_needed = false;

  if (error_target_used || return_used) {
    bprintf(cg_declarations_output, "\n%s:", error_target);
    empty_statement_needed = true;
  }

  bprintf(cg_declarations_output, "\n");

  if (dml_proc) {
    // Your cqlrt can define cql_error_report to be whatever it wants. Maybe
    // something that calls a logging function if _rc_ is not zero.  Maybe it
    // reports if it's the last thing on the error stack otherwise it just
    // appends a new thing.  Any kind of tracing can be constructed like this
    // it is entirely up to your cqlrt. The default version expands to nothing.
    bprintf(cg_declarations_output, "  cql_error_report();\n");
    empty_statement_needed = false;
  }

  if (proc_cleanup.used > 1) {
    bprintf(cg_declarations_output, "%s", proc_cleanup.ptr);
    empty_statement_needed = false;
  }

  if (result_set_proc) {
    // Because of control flow it's possible that we never actually ran a select
    // statement even if there were no errors.  Or maybe we caught the error.
    // In any case if we are not producing an error then we have to produce an
    // empty result set to go with it.
    bprintf(cg_declarations_output, "  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);\n");
    empty_statement_needed = false;
  }

  if (dml_proc) {
    bprintf(cg_declarations_output, "  return _rc_;\n");
    empty_statement_needed = false;
  }

  if (empty_statement_needed) {
    bprintf(cg_declarations_output, "  ; // label requires some statement\n");
  }

  bprintf(cg_declarations_output, "}\n");
  bprintf(cg_declarations_output, "#undef _PROC_\n");

  CHARBUF_CLOSE(proc_decl);
  CHARBUF_CLOSE(proc_sym);
  CHARBUF_CLOSE(proc_name_base);
  CHARBUF_CLOSE(proc_cleanup);
  CHARBUF_CLOSE(proc_locals);
  CHARBUF_CLOSE(proc_body);
  CHARBUF_CLOSE(proc_contracts);
  CHARBUF_CLOSE(proc_fwd_ref);

  in_var_group_decl = false;
  in_var_group_emit = false;
  in_proc = false;
  current_proc = NULL;

  error_target_used = saved_error_target_used;
  rcthrown_index = saved_rcthrown_index;
  rcthrown_used = saved_rcthrown_used;
  Invariant(!strcmp(error_target, CQL_CLEANUP_DEFAULT_LABEL));
  Invariant(!strcmp(rcthrown_current, CQL_RCTHROWN_DEFAULT));
  c_prepared_statement_index = c_prepared_statement_index_saved;
}

static void cg_alias_of_callback(
  CSTR _Nonnull func_name, // underlying name of function this alias is of
  ast_node* _Nonnull misc_attr_value,
  void* _Nullable context // func ast
) {
  CSTR alias_name = (CSTR) context;

  CG_CHARBUF_OPEN_SYM(alias_sym, alias_name);
  CG_CHARBUF_OPEN_SYM(func_sym, func_name);

  bprintf(cg_fwd_ref_output, "#define %s %s\n", alias_sym.ptr, func_sym.ptr);

  CHARBUF_CLOSE(func_sym);
  CHARBUF_CLOSE(alias_sym);
}

// Here we have to emit the prototype for the declared function as a C prototype
// this is just like our stored procs but we also have a return type.  See
// cg_declare_proc_stmt for a comparison.
static void cg_declare_func_stmt(ast_node *ast) {
  Contract(is_ast_declare_func_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT(params, func_params_return->left);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  sem_t sem_type_return = func_params_return->right->sem->sem_type;

  CHARBUF_OPEN(func_decl);
  CG_CHARBUF_OPEN_SYM(func_sym, name);

  cg_var_decl(&func_decl, sem_type_return, func_sym.ptr, 0);
  bprintf(&func_decl, "(");

  // DECLARE FUNC [name] ( [params] ) returntype
  if (params) {
    cg_params(params, &func_decl, CG_PROC_PARAMS_NO_ALIAS);
  }
  else {
    bprintf(&func_decl, "void");
  }

  bprintf(cg_fwd_ref_output, "%s%s);\n", rt->symbol_visibility, func_decl.ptr);

  // Find existing cql:alias_of attribute and print appropriate #define macro.
  if (misc_attrs) {
    find_cql_alias_of(misc_attrs, cg_alias_of_callback, (void *) name);
  }

  CHARBUF_CLOSE(func_sym);
  CHARBUF_CLOSE(func_decl);
}

// emit the proc with the appropriate invocation prefix
static void cg_emit_proc_decl_from_invocation(bool_t private_proc, CSTR invocation) {
  if (private_proc) {
    bprintf(cg_declarations_output, "%s);\n\n", invocation);
  }
  else {
    bprintf(cg_fwd_ref_output, "%s%s);\n\n", rt->symbol_visibility, invocation);
  }
}

// Emit the prototype for the declared method, but no body.
static void cg_declare_proc_stmt(ast_node *ast) {
  Contract(is_ast_declare_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_name_type, ast->left);
  EXTRACT_NAME_AST(name_ast, proc_name_type->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  Contract(!current_proc);

  current_proc = ast;

  bool_t private_proc = is_proc_private(ast);
  bool_t out_stmt_proc = has_out_stmt_result(ast);
  bool_t out_union_proc = has_out_union_stmt_result(ast);
  bool_t has_result_proc = has_result_set(ast) ;

  CHARBUF_OPEN(proc_decl);

  cg_emit_proc_prototype(ast, &proc_decl, CQL_PROTO_NORMAL);

  if (out_stmt_proc || out_union_proc || has_result_proc) {

    CG_CHARBUF_OPEN_SYM(result_set_ref, name, "_result_set_ref");
    CG_CHARBUF_OPEN_SYM(result_set, name, "_result_set");

    cg_result_set_type_decl(cg_header_output, result_set.ptr, result_set_ref.ptr);

    CHARBUF_CLOSE(result_set);
    CHARBUF_CLOSE(result_set_ref);

    if (out_stmt_proc || has_result_proc) {
      // force fetch results prototype
      CHARBUF_OPEN(fetch_results_decl);
        cg_emit_proc_prototype(ast, &fetch_results_decl, CQL_FORCE_FETCH_RESULTS);
        cg_emit_proc_decl_from_invocation(private_proc, fetch_results_decl.ptr);
      CHARBUF_CLOSE(fetch_results_decl);
    }
  }

  if (out_stmt_proc) {
    cg_c_struct_for_sptr(cg_fwd_ref_output, ast->sem->sptr, NULL);
  }

  cg_emit_proc_decl_from_invocation(private_proc, proc_decl.ptr);

  // Find existing cql:alias_of attribute and print appropriate #define macro.
  if (misc_attrs) {
    find_cql_alias_of(misc_attrs, cg_alias_of_callback, (void *) name);
  }

  current_proc = NULL;

  CHARBUF_CLOSE(proc_decl);
}

static void cg_declare_simple_var(sem_t sem_type, CSTR name) {
  // if in a variable group we only emit the header part of the declarations
  if (!in_var_group_decl) {
    cg_var_decl(cg_declarations_output, sem_type, name, CG_VAR_DECL_FULL);
  }
  if (!in_proc && !in_var_group_emit) {
    bprintf(cg_header_output, "%s", rt->symbol_visibility);
    cg_var_decl(cg_header_output, sem_type, name, CG_VAR_DECL_PROTO);
    bprintf(cg_header_output, ";\n");
  }
}

// Emit a bunch of variable declarations for normal variables.
// cg_var_decl does exactly this job for us.  Add any global variables to
// the header file output.
static void cg_declare_vars_type(ast_node *declare_vars_type) {
  Contract(is_ast_declare_vars_type(declare_vars_type));
  EXTRACT_NOTNULL(name_list, declare_vars_type->left);

  // DECLARE [name_list] [data_type]

  for (ast_node *ast = name_list; ast; ast = ast->right) {
    EXTRACT_NAME_AST(name_ast, ast->left);
    EXTRACT_STRING(name, name_ast);

    cg_declare_simple_var(name_ast->sem->sem_type, name);
  }
}

// This is a callback method handed to the gen_ method that creates SQL for us
// it will call us every time it finds a variable that needs to be bound.  That
// variable is replaced by ? in the SQL output.  We end up with a list of
// variables to bind on a silver platter (but in reverse order).
static bool_t cg_capture_variables(ast_node *ast, void *context, charbuf *buffer) {
  // all variables have a name
  Contract(ast->sem->name);

  // If the current context is inline function expansion then arg variables are
  // emitted as is -- we rewrite these so that they come from an inline table
  // e.g.
  //   'select x + y'
  // becomes
  //   '(select x + y from (select arg1 x, arg2 y))'
  //
  // as a result x, y are not bound variables
  if (in_inline_function_fragment) {
    return false;
  }

  cur_variable_count++;

  symtab_entry *entry = symtab_find(proc_arg_aliases, ast->sem->name);
  if (entry) {
    // this variable has been rewritten to a new name, use the alias
    ast = entry->val;
  }

  list_item **head = (list_item**)context;
  add_item_to_list(head, ast);

  gen_printf("?");
  return true;
}

// This is a callback method handed to the gen_ method that creates SQL for us
// it will call us every time it finds a cte table that needs to be generated.
// If this is one of the tables that is supposed to be an "argument" then we
// will remove the stub definition of the CTE.  References to this name will be
// changed to required table in another callback
static bool_t cg_suppress_cte(ast_node *ast, void *context, charbuf *buffer) {
  Contract(is_ast_cte_table(ast));
  EXTRACT(cte_decl, ast->left);
  EXTRACT_STRING(name, cte_decl->left);

  // if we have an alias we suppress the name
  symtab_entry *entry = symtab_find(proc_cte_aliases, name);
  return !!entry;
}

// This a callback method handed to the gen_ method that creates SQL for us it
// will call us every time it finds a table reference that needs to be
// generated. If this is one of the tables that is supposed to be an "argument"
// then we will emit the desired value instead of the stub name.   Note that
// this is always the name of a CTE and CTE of the old name was suppressed using
// the callback above cg_suppress_cte
static bool_t cg_table_rename(ast_node *ast, void *context, charbuf *buffer) {
  // this is a simple table factor, so an actual name...
  EXTRACT_STRING(name, ast);
  bool_t handled = false;

  // if we have an alias we suppress the name
  symtab_entry *entry = symtab_find(proc_cte_aliases, name);
  if (entry) {
    EXTRACT(cte_binding, entry->val);
    EXTRACT_STRING(actual, cte_binding->left);
    gen_printf("%s", actual);
    handled = true;
  }

  return handled;
}

// This helper method fetchs a single column from a select statement.  The
// result is to be stored in the local variable "var" which will be in the
// correct state including nullability.  There are helpers for most cases,
// otherwise we can use normal sqlite accessors.  Strings of course create a
// cql_string_ref and blobs create a cql_blog_ref.
static void cg_get_column(sem_t sem_type, CSTR cursor, int32_t index, CSTR var, charbuf *output) {
  sem_t core_type = core_type_of(sem_type);

  bprintf(output, "  ");

  if (is_nullable(sem_type)) {
    switch (core_type) {
      case SEM_TYPE_BOOL:
        bprintf(output, "cql_column_nullable_bool(%s, %d, &%s);\n", cursor, index, var);
        break;
      case SEM_TYPE_INTEGER:
        bprintf(output, "cql_column_nullable_int32(%s, %d, &%s);\n", cursor, index, var);
        break;
      case SEM_TYPE_REAL:
        bprintf(output, "cql_column_nullable_double(%s, %d, &%s);\n", cursor, index, var);
        break;
      case SEM_TYPE_LONG_INTEGER:
        bprintf(output, "cql_column_nullable_int64(%s, %d, &%s);\n", cursor, index, var);
        break;
      case SEM_TYPE_TEXT:
        bprintf(output, "cql_column_nullable_string_ref(%s, %d, &%s);\n", cursor, index, var);
        break;
      case SEM_TYPE_BLOB:
        bprintf(output, "cql_column_nullable_blob_ref(%s, %d, &%s);\n", cursor, index, var);
        break;
    }
  }
  else {
    switch (core_type) {
      case SEM_TYPE_BOOL:
        bprintf(output, "%s = sqlite3_column_int(%s, %d) != 0;\n", var, cursor, index);
        break;
      case SEM_TYPE_INTEGER:
        bprintf(output, "%s = sqlite3_column_int(%s, %d);\n", var, cursor, index);
        break;
      case SEM_TYPE_REAL:
        bprintf(output, "%s = sqlite3_column_double(%s, %d);\n", var, cursor, index);
        break;
      case SEM_TYPE_LONG_INTEGER:
        bprintf(output, "%s = sqlite3_column_int64(%s, %d);\n", var, cursor, index);
        break;
      case SEM_TYPE_TEXT:
        bprintf(output, "cql_column_string_ref(%s, %d, &%s);\n", cursor, index, var);
        break;
      case SEM_TYPE_BLOB:
        bprintf(output, "cql_column_blob_ref(%s, %d, &%s);\n", cursor, index, var);
        break;
    }
  }
}

static void cg_cql_datatype(sem_t sem_type, charbuf *output) {
  if (!is_nullable(sem_type)) {
    bprintf(output, "CQL_DATA_TYPE_NOT_NULL | ");
  }

  switch (core_type_of(sem_type)) {
    case SEM_TYPE_BOOL:
        bprintf(output, "CQL_DATA_TYPE_BOOL");
        break;
      case SEM_TYPE_INTEGER:
        bprintf(output, "CQL_DATA_TYPE_INT32");
        break;
      case SEM_TYPE_REAL:
      bprintf(output, "CQL_DATA_TYPE_DOUBLE");
        break;
      case SEM_TYPE_LONG_INTEGER:
        bprintf(output, "CQL_DATA_TYPE_INT64");
        break;
      case SEM_TYPE_TEXT:
        bprintf(output, "CQL_DATA_TYPE_STRING");
        break;
      case SEM_TYPE_OBJECT:
        bprintf(output, "CQL_DATA_TYPE_OBJECT");
        break;
      default:
        // nothing else left
        Contract(is_blob(sem_type));
        bprintf(output, "CQL_DATA_TYPE_BLOB");
        break;
    }
}

// CQL uses the helper method cql_multifetch to get all the columns from a
// statement This helper generates the correct CQL_DATA_TYPE_* data info and
// emits the correct argument.
static void cg_fetch_column(sem_t sem_type, CSTR var) {
  cg_cql_datatype(sem_type, cg_main_output);

  bprintf(cg_main_output, ", ");

  if (!is_out_parameter(sem_type)) {
    bprintf(cg_main_output, "&");
  }

  bprintf(cg_main_output, "%s", var);
}

// CQL uses the helper method cql_multibind to bind all the columns to a
// statement This helper generates the correct CQL_DATA_TYPE_* data info and
// emits the arg in the expected format (pointers for nullable primitives) the
// value for all ref types plus all non nullables.
static void cg_bind_column(sem_t sem_type, CSTR var) {
  cg_cql_datatype(sem_type, cg_main_output);

  bprintf(cg_main_output, ", ");

  bool_t needs_address = is_nullable(sem_type) && !is_ref_type(sem_type);

  CSTR prefix = "";

  if (needs_address) {
    // out parameter is already an address
    if (!is_out_parameter(sem_type)) {
      prefix = "&";
    }
  }
  else {
    // don't want address use * prefix on out args
    if (is_out_parameter(sem_type)) {
      prefix = "*";
    }
  }

  bprintf(cg_main_output, "%s%s", prefix, var);
}

// Emit a declaration for the temporary statement _temp_stmt_ if we haven't
// already done so.  Also emit the cleanup once.
static void ensure_temp_statement(int32_t stmt_index) {
  // index 0 is the shared temp statement, all others are unique and are emitted every time
  if (temp_statement_emitted && stmt_index == 0) {
    return;
  }

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  bprintf(cg_declarations_output, "sqlite3_stmt *%s = NULL;\n", temp_stmt.ptr);
  bprintf(cg_cleanup_output, "  cql_finalize_stmt(&%s);\n", temp_stmt.ptr);

  CHARBUF_CLOSE(temp_stmt);

  if (stmt_index == 0) {
    temp_statement_emitted = true;
  }
}

// Now we either find the piece already and get its number or else we can make a
// new piece.  This is all about creating the shared identifiers.  Note that we
// use character offsets in the main string as the identifiers so that we can
// easily offset from the base.  This saves us from having yet another array.
// Note also that we might want to encode these ids in a variable length
// encoding so that we can have more than 64k of them...
static int32_t cg_intern_piece(CSTR str, int32_t len) {
  symtab_entry *entry = symtab_find(text_pieces, str);
  if (entry) {
    return (int32_t)(int64_t)(entry->val);
  }

  int32_t result = piece_last_offset;
  symtab_add(text_pieces, Strdup(str), piece_last_offset + (char *)NULL);
  piece_last_offset += len + 1;  // include space for the nil
  bprintf(cg_pieces_output, "  \"%s\\0\" // %d\n", str, result);
  return result;
}

// Variable length integer encoding: any byte that starts with the high bit set
// indicates that there are more bytes.  The last byte does not have the high
// bit set. So the one-byte encoding is just the simple integer as one byte.
static void cg_varinteger(int32_t val, charbuf *output) {
  do {
    // strip 7 bits
    uint32_t byte = val & 0x7f;
    if (val > 0x7f) {
      byte |= 0x80; // variable length encoding, if the high bit is set, then read another byte
    }
    val >>= 7;  // peel off another 7 bits
    val &= 0x01ffffff; // mask off the any sign extension
    bprintf(output, "\\x%02x", byte); // this is the byte in hex form for a C string
  } while (val);
}

// We found a shareable fragment, encode it for emission into the literal.
// Importantly these ids are 32 bits but we store them in a variable length
// encoding because 32 bits everywhere eats the savings
static void cg_flush_piece(CSTR start, CSTR cur, charbuf *output) {
  CHARBUF_OPEN(temp);
  int32_t len = (int32_t)(cur - start);

  while (start < cur) {
    cg_encode_char_as_c_string_literal(*start, &temp);
    start++;
  }

  int32_t offset = cg_intern_piece(temp.ptr, len);
  CHARBUF_CLOSE(temp);

  cg_varinteger(offset + 1, output);
}

// Break the input string into pieces that are likely to be shared, assign each
// a number and then emit the array of those numbers instead of the original
// string. We're doing this because there is a lot of redundancy in typically
// generated SQL (e.g. the words SELECT, DROP, EXISTS appear a lot) and we can
// encode this much more economically.  Note also column names like
// system_function_name are broken because the system_ part is often shared.
cql_noexport uint32_t cg_statement_pieces(CSTR in, charbuf *output) {
  Contract(in);
  int32_t len = (int32_t)strlen(in);
  Contract(len);

  uint32_t count = 0;

  CSTR start = in;
  CSTR cur = in;

  int32_t prev_state = 0;
  int32_t cur_state = 0;

  bputc(output, '"');
  cg_varinteger(len + 1, output);

  for (; *cur ; cur++, prev_state = cur_state) {
    char ch = *cur;
    if (ch == ' ' || ch == '\n') {
      cur_state = 0;  // state 0 is a run of whitespace
    }
    else if ((ch >= 'a' && ch <= 'z') || (ch >= '@' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
      cur_state = 1; // state 1 is a run of alpha-ish charcters
    }
    else {
      cur_state = 2; // state 2 is a run of misc characters like operators or whatever
    }

    if (prev_state == cur_state) {
      continue;  // keep going as long as we're on the same kind of run
    }

    if (cur - start <= 4 && cur_state == 0) {
      continue;  // if we found whitespace keep going if we haven't seen at least 4 characters
    }

    // Ok we have something worthy of flushing: one last chance to grow it some.
    // We dont want single spaces to go into the output by themselves because
    // it's costly.  Include this space in the token.  Note that this is already
    // normalized output so multiple spaces are not a possibility. Space and
    // then newline is also shunned (it'll work but it doesn't happen because
    // gen_sql never creates that stuff).

    if (cur_state == 0) {
      // use the space/newline
      cur++;
      // put ourselves into the correct state, here we let _ start an alpha-ish sttate after a break
      ch = *cur;
      if ((ch >= 'a' && ch <= 'z') || (ch >= '@' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_') {
        // back to run of alpha
        cur_state = 1;
      }
      // note cur has been advanced now and it might be null (!)
    }

    // if we've anything to flush at this point the run is over, flush it.
    if (start < cur) {
      cg_flush_piece(start, cur, output);
      start = cur;
      count++;

      // if we advanced off the end above when we skipped over the space, we can
      // exit now we don't want to advance again off the end of the string.
      if (!*cur) {
        break;
      }
    }
  }

  // if there's anything left pending when we hit the end, flush it.
  if (start < cur) {
    cg_flush_piece(start, cur, output);
    count++;
  }

  bputc(output, '"');

  return count;
}

// This tells us how many fragments we emitted using some size math
static uint32_t cg_fragment_count() {
  return (uint32_t)(shared_fragment_strings.used / sizeof(CSTR));
}

// When we complete a chunk of fragment text we have to emit the predicates for
// the variables that were in that chunk.  We do this in the same context as the
// conditional for that string.
static void cg_flush_variable_predicates() {
  if (!has_conditional_fragments) {
    return;
  }

  while (prev_variable_count < cur_variable_count) {
    if (cur_fragment_predicate == 0 || cur_fragment_predicate + 1 == max_fragment_predicate) {
      bprintf(cg_main_output, "_vpreds_%d[%d] = 1; // pred %d known to be 1\n",
      cur_bound_statement,
      prev_variable_count++,
      cur_fragment_predicate);
    }
    else {
      // If we're back in previous context we can always just use the predicate
      // value for that context which was set in an earlier block.
      // TODO: I think we can prove that it's always true in the code block we
      // are in so this could be = 1 and hence is the same as the above.
      bprintf(cg_main_output, "_vpreds_%d[%d] = _preds_%d[%d];\n",
        cur_bound_statement,
        prev_variable_count++,
        cur_bound_statement,
        cur_fragment_predicate);
    }
  }
}

// If we have set up the predicate for this chunk of text we can just use it we
// see that by looking at how many predicates we set up and if we are past that
// point. If we need a predicate for the current line we use the predicate value
// for the "current" predicate scope, which nests.  Whatever the current
// predicate is we use that and make an entry in the array.  So that way there
// is always one computed predicate for each chunk of text we plan to emit.
static void cg_fragment_copy_pred() {
  if (!has_conditional_fragments) {
    return;
  }

  uint32_t count = cg_fragment_count();
  if (count + 1 == max_fragment_predicate) {
    return;
  }

  if (cur_fragment_predicate == 0) {
    bprintf(cg_main_output, "_preds_%d[%d] = 1;\n",
      cur_bound_statement,
      max_fragment_predicate++);
  }
  else {
    // TODO: I think we can prove that it's always true in the code block we are
    // in so this could be = 1 and hence is the same as the above.
    bprintf(cg_main_output, "_preds_%d[%d] = _preds_%d[%d];\n",
      cur_bound_statement,
      max_fragment_predicate++,
      cur_bound_statement,
      cur_fragment_predicate);
  }

  cg_flush_variable_predicates();
}

// First we make sure we have a predicate row and then we emit the line assuming
// there is anything to emit...
static void cg_emit_one_frag(charbuf *buffer) {
  // TODO: can we make this an invariant?
  if (buffer->used > 1) {
    cg_fragment_copy_pred();
    CSTR str = Strdup(buffer->ptr);
    bytebuf_append_var(&shared_fragment_strings, str);
    bclear(buffer);
  }
}

// Emit a fragment from a statement, note that this can nest
static void cg_fragment_stmt(ast_node *stmt, charbuf *buffer) {
  gen_one_stmt(stmt);
  cg_emit_one_frag(buffer);
  cg_flush_variable_predicates();
}

// A new block in a conditional, this is the "it's true" case for it assign it a
// number and move on.  Note the code is always inside of
// if (the_expression_was_true) {...}
static void cg_fragment_setpred() {
  cur_fragment_predicate = max_fragment_predicate;
  if (has_conditional_fragments) {
    bprintf(cg_main_output, "_preds_%d[%d] = 1;\n",
      cur_bound_statement,
      max_fragment_predicate++);
  }
}

// Emit the if condition for the conditional fragment and then generate the
// predicate setting as well as the SQL for that part of the fragment.
static void cg_fragment_cond_action(ast_node *ast, charbuf *buffer) {
  Contract(is_ast_cond_action(ast));
  EXTRACT_NOTNULL(stmt_list, ast->right);
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  // [expr ast->left] THEN stmt_list

  sem_t sem_type_expr = expr->sem->sem_type;

  cg_line_directive_max(expr, cg_main_output);

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  if (is_ast_null(expr) || is_not_nullable(sem_type_expr)) {
    bprintf(cg_main_output, "if (%s) {\n", expr_value.ptr);
  }
  else {
    bprintf(cg_main_output, "if (cql_is_nullable_true(%s, %s)) {\n", expr_is_null.ptr, expr_value.ptr);
  }

  CG_POP_EVAL(expr);

  int32_t cur_fragment_predicate_saved = cur_fragment_predicate;

  CG_PUSH_MAIN_INDENT(ifbody, 2);
  cg_fragment_setpred();

  // and we emit the next statement string fragment
  cg_fragment_stmt(stmt_list->left, buffer);

  cur_fragment_predicate = cur_fragment_predicate_saved;

  CG_POP_MAIN_INDENT(ifbody);
  bprintf(cg_main_output, "}\n");
}

// Here we're just walking the elseif list, as with normal codegen when we get
// to the end we deal with the elsenode.  We can't do the else node in the caller
// because we need to emit it inside the deepest matching parens.  So we just
// push the elsenode down the recursion until its needed.
static void cg_fragment_elseif_list(ast_node *ast, ast_node *elsenode, charbuf *buffer) {
  if (ast) {
    Contract(is_ast_elseif(ast));
    EXTRACT(cond_action, ast->left);

    // ELSE IF [cond_action]
    bprintf(cg_main_output, "else {\n");
      CG_PUSH_MAIN_INDENT(else, 2);
      cg_fragment_cond_action(cond_action, buffer);
      cg_fragment_elseif_list(ast->right, elsenode, buffer);
      CG_POP_MAIN_INDENT(else);
    bprintf(cg_main_output, "}\n");
  }
  else if (elsenode) {
    Contract(is_ast_else(elsenode));
    // ELSE [stmt_list]
    cg_line_directive_min(elsenode, cg_main_output);
    EXTRACT(stmt_list, elsenode->left);

    bprintf(cg_main_output, "else {\n");
      CG_PUSH_MAIN_INDENT(else, 2);

      int32_t cur_fragment_predicate_saved = cur_fragment_predicate;
      cg_fragment_setpred();

      // this is the next string fragment
      cg_fragment_stmt(stmt_list->left, buffer);

      cur_fragment_predicate = cur_fragment_predicate_saved;
      CG_POP_MAIN_INDENT(else);
    bprintf(cg_main_output, "}\n");
  }
}

// This handles the expression fragment case, this is rewritten so that the
// arguments of the expression fragment become columns of one row of table
//
// e.g.
// [[shared_fragment]]
// create proc ex_frag(x integer)
// begin
//    select x + 2 * x as result;
// end
//
// this becomes
//
// "SELECT x + 2 * x from (select ? as x)"
//
// The expression fragment is not allowed to have its own from clause which
// means we can use the from clause for our own purposes (local binding).  The
// is very helpful if the fragment happens often or if the argument would
// otherwise have to be evaluated many times.  But it comes at the cost of a
// one-row query.
static bool_t cg_inline_func(ast_node *call_ast, void *context, charbuf *buffer) {
  Contract(is_ast_call(call_ast));
  EXTRACT_STRING(proc_name, call_ast->left);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!is_inline_func_call(call_ast)) {
    return false;
  }

  // flush what we have so far
  cg_emit_one_frag(buffer);

  ast_node *ast = find_proc(proc_name);

  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  bool_t saved_in_inline_function_fragment = in_inline_function_fragment;
  symtab *saved_proc_arg_aliases = proc_arg_aliases;
  symtab *saved_proc_cte_aliases = proc_cte_aliases;
  in_inline_function_fragment = true;

  proc_arg_aliases = NULL;
  proc_cte_aliases = NULL;

  gen_printf("(");

  // Emit a fragment from a statement, note that this can nest
  cg_fragment_stmt(stmt, buffer);

  proc_arg_aliases = saved_proc_arg_aliases;
  proc_cte_aliases = saved_proc_cte_aliases;
  in_inline_function_fragment = saved_in_inline_function_fragment;

  if (params) {
    // If there are any args we create a nested select expression to bind them
    // to the variable names.  Note that this means args are evaluated once
    // which could be important if there are SQL functions with side-effects
    // being used (highly rare) or expensive functions.
    gen_printf(" FROM (SELECT ");

    while (params) {
      Invariant(is_ast_params(params));
      Invariant(arg_list); // expressions match the args

      EXTRACT_NOTNULL(param, params->left);
      EXTRACT_ANY_NOTNULL(expr, arg_list->left);

      EXTRACT_NOTNULL(param_detail, param->right);
      EXTRACT_NAME_AST(param_name_ast, param_detail->left)
      EXTRACT_STRING(param_name, param_name_ast);

      gen_root_expr(expr);
      gen_printf(" %s", param_name);
      if (params->right) {
        gen_printf(", ");
      }

      // guaranteed to stay in lock step
      params = params->right;
      arg_list = arg_list->right;
    }
    gen_printf(")");
  }

  gen_printf(")");
  cg_emit_one_frag(buffer);

  return true;
}

// Here we've found a call expression where a CTE should be so like
// with
//  X(*) as (call foo(1,2,3))
// select * from X;
//
// or
//
// with
//  X(*) as (call foo(1,2,3) USING foo as source1, bar = source2)
// select * from X;
//
// What we're going to do is replace the call with the body of the procedure
// that is being called. We have to do a few things to make this work:
//  * the args to the procedure have to be evaluated and put into locals
//  * any use of those arguments has to be redirected to said locals (so rename
//    the locals)
//  * naturally any of those arguments can't be database things (wrong context)
//    so we can evaluate them all in advance
//  * if the call has the "USING" form then we have to alias all instances of
//    the mentioned tables in the target procedure to be the values that were
//    provided
//  * any such args/aliases have been pre-validated during semantic analysis
//  * code gen is designed to keep as many string literals identical as possible
//    so that they can be folded
static bool_t cg_call_in_cte(ast_node *cte_body, void *context, charbuf *buffer) {
  EXTRACT_NOTNULL(call_stmt, cte_body->left);
  EXTRACT(cte_binding_list, cte_body->right);

  EXTRACT_STRING(name, call_stmt->left);
  EXTRACT_ANY(expr_list, call_stmt->right);

  ast_node *ast = find_proc(name);

  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);

  bool_t saved_in_inline_function_fragment = in_inline_function_fragment;
  symtab *saved_proc_arg_aliases = proc_arg_aliases;
  symtab *saved_proc_cte_aliases = proc_cte_aliases;
  in_inline_function_fragment = false;

  symtab *new_arg_aliases = symtab_new();
  proc_cte_aliases = symtab_new();

  while (cte_binding_list) {
    EXTRACT_NOTNULL(cte_binding, cte_binding_list->left);
    EXTRACT_STRING(formal, cte_binding->right);
    EXTRACT_STRING(actual, cte_binding->left);

    // The "actual" might itself be an alias from the outer scope be sure to
    // push that down if that's the case.  One level is always enough because
    // each level does its own push if needed.
    bool_t handled = false;

    if (saved_proc_cte_aliases) {
      symtab_entry *entry = symtab_find(saved_proc_cte_aliases, actual);
      if (entry) {
        symtab_add(proc_cte_aliases, formal, entry->val);
        handled = true;
      }
    }

    if (!handled) {
      // normal case, the first time a name is aliased
      symtab_add(proc_cte_aliases, formal, cte_binding);
    }

    cte_binding_list = cte_binding_list->right;
  }

  if (params) {
    // move to the next index if we need to alias anything
    proc_cte_index++;
  }

  while (params) {
    Invariant(is_ast_params(params));
    Invariant(expr_list); // expressions match the args

    EXTRACT_NOTNULL(param, params->left);
    EXTRACT_ANY_NOTNULL(expr, expr_list->left);

    EXTRACT_NOTNULL(param_detail, param->right);
    EXTRACT_NAME_AST(param_name_ast, param_detail->left)
    EXTRACT_STRING(param_name, param_name_ast);

    sem_t sem_type_var = param_name_ast->sem->sem_type;

    CSTR alias_name = dup_printf("_p%d_%s_", proc_cte_index, param_name);

    AST_REWRITE_INFO_SET(param->lineno, param->filename);

    ast_node *alias  = new_ast_str(alias_name);
    symtab_add(new_arg_aliases, param_name, alias);
    alias->sem = new_sem(sem_type_var);
    alias->sem->name = alias_name;
    alias->sem->kind = param_name_ast->sem->kind;

    AST_REWRITE_INFO_RESET();

    // emit the declaration
    cg_var_decl(cg_declarations_output, sem_type_var, alias_name, CG_VAR_DECL_FULL);

    sem_t sem_type_expr = expr->sem->sem_type;

    // evaluate the expression and assign
    // note that any arg aliases here are in the context of the caller not the
    // callee we're setting up the aliases for the callee right now and they
    // aren't ready yet even but that's ok because the expressions are in the
    // context of the caller.

    // todo: if the evaluation has a nested select statement then we will have
    // to re-enter all of this.  We can either ban that (which isn't insane
    // really) or else we can save the codegen state like callbacks and such so
    // that it can re-enter.  That's the desired path.

    CG_PUSH_EVAL(expr, C_EXPR_PRI_ASSIGN);
    cg_store(cg_main_output, alias_name, sem_type_var, sem_type_expr, expr_is_null.ptr, expr_value.ptr);
    CG_POP_EVAL(expr);

    // guaranteed to stay in lock step
    params = params->right;
    expr_list = expr_list->right;
  }

  // exactly one statment
  Invariant(!stmt_list->right);

  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  // now replace the aliases for just this one bit
  proc_arg_aliases = new_arg_aliases;

  cg_emit_one_frag(buffer);

  bool_t is_nested_select = is_ast_table_or_subquery(cte_body->parent);
  cte_proc_call_info* info = (cte_proc_call_info*)context;
  bool_t saved_minify_aliases = info->callbacks->minify_aliases;

  CHARBUF_OPEN(wrapper);
  if (is_nested_select) {
    // We need to keep column names of the generated SELECT
    // when generating shared fragments as a subquery.
    info->callbacks->minify_aliases = false;

    bprintf(&wrapper, "(");
    cg_emit_one_frag(&wrapper);
  }
  else {
    // Use the original global setting
    // (subcalls inside a CTE of a fragment in a nested select can use original setting)
    info->callbacks->minify_aliases = info->minify_aliases;
  }

  if (is_ast_if_stmt(stmt)) {
    EXTRACT_NOTNULL(cond_action, stmt->left);
    EXTRACT_NOTNULL(if_alt, stmt->right);
    EXTRACT(elseif, if_alt->left);
    EXTRACT_NAMED_NOTNULL(elsenode, else, if_alt->right);

    cg_fragment_cond_action(cond_action, buffer);
    cg_fragment_elseif_list(elseif, elsenode, buffer);
  }
  else {
    cg_fragment_stmt(stmt, buffer);
  }

  if (is_nested_select) {
    bprintf(&wrapper, ")");
    cg_emit_one_frag(&wrapper);
  }

  info->callbacks->minify_aliases = saved_minify_aliases;
  CHARBUF_CLOSE(wrapper);

  symtab_delete(proc_arg_aliases);
  symtab_delete(proc_cte_aliases);
  proc_arg_aliases = saved_proc_arg_aliases;
  proc_cte_aliases = saved_proc_cte_aliases;
  in_inline_function_fragment = saved_in_inline_function_fragment;

  return true;
}

// We're looking for the presence of any shared fragments and in particular
// the presence of conditionals within them.  We don't have to do much for
// this check but we do have to recurse the search as the normal walk doesn't
// go into the body of shared fragments and the conditionals might be deeper
// in the tree.
static bool_t cg_search_conditionals_call_in_cte(ast_node *cte_body, void *context, charbuf *buffer) {
  EXTRACT_NOTNULL(call_stmt, cte_body->left);
  EXTRACT_STRING(name, call_stmt->left);

  ast_node *ast = find_proc(name);

  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  has_conditional_fragments |= is_ast_if_stmt(stmt);
  has_shared_fragments = true;

  // recurse the fragment contents, we might find more stuff, like variables and
  // such deeper in the tree
  gen_one_stmt(stmt);

  return false;
}

// We simply record that we found some variables, any variables
static bool_t cg_note_variable_exists(ast_node *cte_body, void *context, charbuf *buffer) {
  has_variables = true;
  return false;
}

// The inline function counts as a shared fragment and we recurse to find any
// internal shared fragments or conditional fragments inside of the inline
// function. Note that even though it has no FROM clause the inline function
// could have a nested select inside of its select list and therefore all
// fragment types can appear inside of an inline function fragment.
static bool_t cg_note_inline_func(ast_node *call_ast, void *context, charbuf *buffer) {
  Contract(is_ast_call(call_ast));
  EXTRACT_STRING(proc_name, call_ast->left);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);

  if (!is_inline_func_call(call_ast)) {
    return false;
  }

  ast_node *ast = find_proc(proc_name);

  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  // recurse the fragment contents, we might find more stuff, like variables and
  // such deeper in the tree
  gen_one_stmt(stmt);

  has_shared_fragments = true;
  return false;
}

// We set up a walk of the tree using the echo functions but we are going to
// note what kinds of things we spotted while doing the walk.  We need to know
// in advance what style of codegen we'll be doing.
static void cg_classify_fragments(ast_node *stmt) {
  has_shared_fragments = false;
  has_conditional_fragments = false;
  has_variables = false;

  CHARBUF_OPEN(sql);
  gen_set_output_buffer(&sql);
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.cte_proc_callback = cg_search_conditionals_call_in_cte;
  callbacks.variables_callback = cg_note_variable_exists;
  callbacks.func_callback = cg_note_inline_func;
  gen_statement_with_callbacks(stmt, &callbacks);
  CHARBUF_CLOSE(sql);
}

// This is the most important function for sqlite access;  it does the heavy
// lifting of generating the C code to prepare and bind a SQL statement. If
// cg_exec is true (CG_EXEC) then the statement is executed immediately and
// finalized.  No results are expected.  To accomplish this we do the following:
//   * figure out the name of the statement, either it's given to us or we're
//     using the temp statement
//   * call get_statement_with_callback to get the text of the SQL from the AST
//     * the callback will give us all the variables to bind
//     * count the variables so we know what column numbers to use (the list is
//       backwards!)
//   * if CG_EXEC and no variables we can use the simpler sqlite3_exec form
//   * bind any variables
//   * if there are variables CG_EXEC will step and finalize
static int32_t cg_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_flags) {
  list_item *vars = NULL;
  CSTR amp = "&";

  cur_bound_statement++;
  cur_fragment_predicate = 0;
  max_fragment_predicate = 0;
  prev_variable_count = 0;
  cur_variable_count = 0;
  int32_t stmt_index = 0;

  bytebuf_open(&shared_fragment_strings);

  if (stmt_name && !strcmp("_result", stmt_name)) {
    // predefined out argument
    amp = "";
  }

  cg_classify_fragments(stmt);

  if (has_conditional_fragments) {
    bprintf(cg_main_output, "memset(&_preds_%d[0], 0, sizeof(_preds_%d));\n",
      cur_bound_statement,
      cur_bound_statement);
    if (has_variables) {
      bprintf(cg_main_output, "memset(&_vpreds_%d[0], 0, sizeof(_vpreds_%d));\n",
        cur_bound_statement,
        cur_bound_statement);
    }
  }

  bool_t may_reuse_statement = !has_conditional_fragments && cg_in_loop;
  bool_t reusing_statement = false;

  bool_t minify_aliases = !!(cg_flags & CG_MINIFY_ALIASES);
  bool_t exec_only = !!(cg_flags & CG_EXEC);

  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.variables_callback = cg_capture_variables;
  callbacks.variables_context = &vars;
  callbacks.minify_casts = true;
  callbacks.minify_aliases = minify_aliases;
  callbacks.long_to_int_conv = true;
  callbacks.cte_proc_callback = cg_call_in_cte;
  callbacks.cte_suppress_callback = cg_suppress_cte;
  callbacks.table_rename_callback = cg_table_rename;
  callbacks.func_callback = cg_inline_func;

  cte_proc_call_info cte_proc_context;
  callbacks.cte_proc_context = &cte_proc_context;
  cte_proc_context.callbacks = &callbacks;
  cte_proc_context.minify_aliases = minify_aliases;

  CHARBUF_OPEN(sql);
  gen_set_output_buffer(&sql);
  gen_statement_with_callbacks(stmt, &callbacks);

  // whether or not there is a prepare statement
  bool_t has_prepare_stmt = !exec_only || vars;

  uint32_t count = 0;
  for (list_item *item = vars; item; item = item->next, count++) ;

  CHARBUF_OPEN(temp_stmt);

  if (stmt_name == NULL && has_prepare_stmt) {
    if (may_reuse_statement) {
      stmt_index = ++c_prepared_statement_index;
      reusing_statement = true;
    }
    ensure_temp_statement(stmt_index);
    CG_TEMP_STMT_BASE_NAME(stmt_index, &temp_stmt);
    stmt_name = temp_stmt.ptr;
  }

  // take care of what's left in the buffer after the other fragments have been emitted
  if (has_shared_fragments) {
    cg_emit_one_frag(&sql);
  }

  if (!has_shared_fragments && options.compress) {
    bprintf(cg_main_output, "/*  ");
    CHARBUF_OPEN(t2);
      cg_pretty_quote_plaintext(sql.ptr, &t2, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);
      cg_remove_slash_star_and_star_slash(&t2); // internal "*/" is fatal. "/*" can also be under certain compilation flags
      bprintf(cg_main_output, "%s", t2.ptr);
    CHARBUF_CLOSE(t2);
    bprintf(cg_main_output, " */\n");

    if (!has_prepare_stmt) {
      bprintf(cg_main_output, "_rc_ = cql_exec_frags(_db_,\n");
    }
    else {
      if (reusing_statement) {
        bprintf(cg_main_output, "if (!%s_stmt) {\n  ", stmt_name);
      }
      bprintf(cg_main_output, "_rc_ = cql_prepare_frags(_db_, %s%s_stmt,\n  ", amp, stmt_name);
    }

    bprintf(cg_main_output, "_pieces_, ");
    cg_statement_pieces(sql.ptr, cg_main_output);
    bprintf(cg_main_output, ");\n");
  }
  else {
    CSTR suffix = has_shared_fragments ? "_var" : "";

    if (!has_prepare_stmt) {
      bprintf(cg_main_output, "_rc_ = cql_exec%s(_db_,\n  ", suffix);
    }
    else {
      if (reusing_statement) {
        bprintf(cg_main_output, "if (!%s_stmt) {\n  ", stmt_name);
      }
      bprintf(cg_main_output, "_rc_ = cql_prepare%s(_db_, %s%s_stmt,\n  ", suffix, amp, stmt_name);
    }

    if (!has_shared_fragments) {
      cg_pretty_quote_plaintext(sql.ptr, cg_main_output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);
    }
    else {
      uint32_t scount = cg_fragment_count();

      // declare the predicate variables if needed
      if (has_conditional_fragments) {
        bprintf(cg_main_output, "%d, _preds_%d,\n", scount, cur_bound_statement);
        bprintf(cg_declarations_output, "char _preds_%d[%d];\n", cur_bound_statement, scount);
        if (has_variables) {
          bprintf(cg_declarations_output, "char _vpreds_%d[%d];\n", cur_bound_statement, cur_variable_count);
        }
      }
      else {
        bprintf(cg_main_output, "%d, NULL,\n", scount);
      }

      CSTR *strs = (CSTR *)(shared_fragment_strings.ptr);
      for (size_t i = 0; i < scount; i++) {
        cg_pretty_quote_plaintext(strs[i], cg_main_output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);
        if (i + 1 < scount) {
          bprintf(cg_main_output, ",\n");
        }
        else {
          bprintf(cg_main_output, "\n");
        }
      }
    }
    bprintf(cg_main_output, ");\n");
  }

  if (reusing_statement) {
    bprintf(cg_main_output, "}\nelse {\n  _rc_ = SQLITE_OK;\n}\n");
  }

  CHARBUF_CLOSE(temp_stmt);
  CHARBUF_CLOSE(sql);

  reverse_list(&vars);

  if (count) {
    if (has_conditional_fragments) {
      bprintf(cg_main_output, "cql_multibind_var(&_rc_, _db_, %s%s_stmt, %d, _vpreds_%d", amp, stmt_name, count, cur_bound_statement);
    }
    else {
      bprintf(cg_main_output, "cql_multibind(&_rc_, _db_, %s%s_stmt, %d", amp, stmt_name, count);
    }

    // Now emit the binding args for each variable
    for (list_item *item = vars; item; item = item->next)  {
      Contract(item->ast->sem->name);
      bprintf(cg_main_output, ",\n              ");
      cg_bind_column(item->ast->sem->sem_type, item->ast->sem->name);
    }

    bprintf(cg_main_output, ");\n");
  }

  // if rollback fails we still need to release any savepoints, cannot exit to report error
  if (!is_ast_rollback_trans_stmt(stmt) && !is_ast_rollback_return_stmt(stmt)) {
    cg_error_on_not_sqlite_ok();
  }

  if (exec_only && vars) {
    bprintf(cg_main_output, "_rc_ = sqlite3_step(%s_stmt);\n", stmt_name);
    cg_error_on_rc_notequal("SQLITE_DONE");

    if (reusing_statement) {
      bprintf(cg_main_output, "sqlite3_reset(%s_stmt);\n", stmt_name);
    }
    else {
      bprintf(cg_main_output, "cql_finalize_stmt(&%s_stmt);\n", stmt_name);
    }
  }

  // vars is pool allocated, so we don't need to free it
  bytebuf_close(&shared_fragment_strings);

  return stmt_index;
}

// Checks to see if the given statement or statement list is unbound i.e. it
// does not mention any variables.  We do this so that we detect if the
// statement is safe to batch with others.  If it had binding then we would need
// to bind each statement in the block seperately and then there would be no
// point in batching.
static bool cg_verify_unbound_stmt(ast_node *stmt) {
  list_item *vars = NULL;

  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.variables_callback = cg_capture_variables;
  callbacks.variables_context = &vars;

  CHARBUF_OPEN(temp);
    gen_set_output_buffer(&temp);
    gen_statement_with_callbacks(stmt, &callbacks);
  CHARBUF_CLOSE(temp);

  // vars is pool allocated, so we don't need to free it
  return !vars;
}

// This emits the declaration for an "auto cursor" -- that is a cursor that
// includes storage for all the fields it can fetch.  It uses the struct helper
// to make a suitable struct and the creates the local and initializes its
// teardown function.  Code also has to go into the cleanup section for suitable
// teardown.
static void cg_declare_auto_cursor(CSTR cursor_name, sem_node *sem) {
  Contract(cursor_name);
  Contract(sem);

  sem_struct *sptr = sem->sptr;
  Contract(sptr);

  int32_t refs_count = refs_count_sptr(sptr);

  // when we do the variable group the struct has already been emitted
  if (!in_var_group_emit) {
    charbuf *out = in_var_group_decl ? cg_header_output : cg_fwd_ref_output;
    cg_c_struct_for_sptr(out, sptr, cursor_name);
  }

  CSTR scope = current_proc_name();
  CSTR suffix = scope ? "_" : "";
  scope = scope ? scope : "";

  CG_CHARBUF_OPEN_SYM(row_type, scope, suffix, cursor_name, "_row");

  if (in_var_group_decl) {
    // only extern the cursor
    bprintf(cg_header_output, "%s%s %s;\n",
      rt->symbol_visibility, row_type.ptr, cursor_name);
  }
  else if (refs_count) {
    CG_CHARBUF_OPEN_SYM(refs_offset, scope, suffix, cursor_name, "_refs_offset");

    bprintf(cg_declarations_output, "%s %s = { ._refs_count_ = %d, ._refs_offset_ = %s };\n",
      row_type.ptr, cursor_name, refs_count, refs_offset.ptr);
    bprintf(cg_cleanup_output, "  cql_teardown_row(%s);\n", cursor_name);
      cg_struct_teardown_info(cg_fwd_ref_output, sptr, cursor_name);

    CHARBUF_CLOSE(refs_offset);
  }
  else {
    bprintf(cg_declarations_output, "%s %s = { 0 };\n", row_type.ptr, cursor_name);
  }

  if (sem->sem_type & SEM_TYPE_SERIALIZE) {
    CHARBUF_OPEN(cols_name);
    CHARBUF_OPEN(types_name);

    bprintf(&cols_name, "%s_cols", cursor_name);
    bprintf(&types_name, "%s_data_types", cursor_name);

    if (in_var_group_decl) {
      bprintf(cg_header_output, "%scql_dynamic_cursor %s_dyn;\n",  rt->symbol_visibility, cursor_name);
    }
    else {
      cg_col_offsets(cg_declarations_output, sptr, cols_name.ptr, row_type.ptr);
      cg_data_types(cg_declarations_output, sptr, types_name.ptr);
      cg_dynamic_cursor(cg_declarations_output, sem->sptr, cursor_name, cols_name.ptr, types_name.ptr);
    }

    CHARBUF_CLOSE(types_name);
    CHARBUF_CLOSE(cols_name);
  }

  CHARBUF_CLOSE(row_type);
}

// Declare group is the form to create a group of  global variables with
// storage.  Note that this only creates the "extern" form of the group.  There
// is an emit_group statement that causes the definitions to be emitted see
// below.  The declarations are protected by #ifdef so that they can appear more
// than once in various header files without problems. The standard variable
// declaration helpers are all that is needed here.  Semantic analysis already
// verified that the group contains only viable globals.
static void cg_declare_group_stmt(ast_node *ast) {
  Contract(is_ast_declare_group_stmt(ast));
  Contract(!in_var_group_decl);
  Contract(!in_var_group_emit);

  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(stmt_list, ast->right);

  // Put a line marker in the header file in case we want a test suite that
  // verifies that. Note we have to do this only because this only generates
  // declarations so the normal logic for emitting these doesn't kick in.
  if (options.test) {
    bprintf(cg_declarations_output, "\n// The statement ending at line %d\n", ast->lineno);
    bprintf(cg_fwd_ref_output, "\n// The statement ending at line %d\n", ast->lineno);
  }

  // This can be duplicated so make it safe to emit twice. Note that the struct
  // decls go into a different stream so we wrap those, too.
  bprintf(cg_header_output, "#ifndef _%s_var_group_decl_\n", name);
  bprintf(cg_header_output, "#define _%s_var_group_decl_ 1\n", name);

  in_var_group_decl = true;
  cg_stmt_list(stmt_list);
  in_var_group_decl = false;

  bprintf(cg_header_output, "#endif\n");
}

// Emit group tells CQL to emit the variable definitions for the indicated
// groups into the current translation unit.  This should be done one time to
// avoid duplicate symbols at link time.  The indicated groups are enumerated
// and the definition form is emitted using the normal helpers.
static void cg_emit_group_stmt(ast_node *ast) {
  Contract(is_ast_emit_group_stmt(ast));
  EXTRACT(name_list, ast->left);
  Contract(!in_var_group_decl);
  Contract(!in_var_group_emit);

  // Put a line marker in the header file in case we want a test suite that
  // verifies that. Note we have to do this only because this only generates
  // declarations so the normal logic for emitting these doesn't kick in.
  if (options.test) {
    bprintf(cg_declarations_output, "\n// The statement ending at line %d\n", ast->lineno);
    bprintf(cg_fwd_ref_output, "\n// The statement ending at line %d\n", ast->lineno);
  }

  while (name_list) {
    EXTRACT_NAME_AST(name_ast, name_list->left);
    EXTRACT_STRING(name, name_ast);

    ast_node *group = find_variable_group(name);
    Contract(is_ast_declare_group_stmt(group));

    EXTRACT_NAME_AST(group_name_ast, group->left);
    EXTRACT_STRING(group_name, group_name_ast);
    EXTRACT_NOTNULL(stmt_list, group->right);

    Invariant(!StrCaseCmp(name, group_name));
    in_var_group_emit = true;
    cg_stmt_list(stmt_list);
    in_var_group_emit = false;

    name_list = name_list->right;
  }
}

// This causes enum declarations to go into the header file. Those enum values
// are not even used in our codegen because the ast is rewritten to have the
// actual value rather than the name.  However this will make it possible to use
// the enums in callers from C.  The enum values are "public" in this sense.
// This is a lot like the gen_sql code except it will be in C format.  Note C
// has no floating point enums so we have to do those with macros.
static void cg_emit_one_enum(ast_node *ast) {
  Contract(is_ast_declare_enum_stmt(ast));
  EXTRACT_NOTNULL(typed_name, ast->left);
  EXTRACT_NOTNULL(enum_values, ast->right);
  EXTRACT_ANY(name_ast, typed_name->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY_NOTNULL(type, typed_name->right);

  bprintf(cg_header_output, "#ifndef enum_%s_defined\n", name);
  bprintf(cg_header_output, "#define enum_%s_defined\n\n", name);

  if (core_type_of(type->sem->sem_type) == SEM_TYPE_INTEGER) {
    bprintf(cg_header_output, "enum %s {", name);

    while (enum_values) {
       EXTRACT_NOTNULL(enum_value, enum_values->left);
       EXTRACT_NAME_AST(enum_name_ast, enum_value->left);
       EXTRACT_STRING(enum_name, enum_name_ast);

       bprintf(cg_header_output, "\n  %s__%s = ", name, enum_name);

       eval_format_number(enum_name_ast->sem->value, EVAL_FORMAT_FOR_C, cg_header_output);

       if (enum_values->right) {
         bprintf(cg_header_output, ",");
       }

       enum_values = enum_values->right;
    }
    bprintf(cg_header_output, "\n};\n");
  }
  else {
    // * enums can't be float, so we have to do those as #define
    // * enums generally only hold ints so they might not be able to hold an int64
    //   so we have to do int64 as macros as well

    bprintf(cg_header_output, "\n// (%s has non integer values -- create a type alias and constants; best we can do.\n", name);
    CHARBUF_OPEN(tmp);
      cg_var_decl(&tmp, type->sem->sem_type, "enum", CG_VAR_DECL_PROTO);
      bprintf(cg_header_output, "typedef %s_%s;\n", tmp.ptr, name);
    CHARBUF_CLOSE(tmp);

    while (enum_values) {
       EXTRACT_NOTNULL(enum_value, enum_values->left);
       EXTRACT_NAME_AST(enum_name_ast, enum_value->left);
       EXTRACT_STRING(enum_name, enum_name_ast);

       bprintf(cg_header_output, "#define %s__%s ", name, enum_name);
       eval_format_number(enum_name_ast->sem->value, EVAL_FORMAT_FOR_C, cg_header_output);

       bprintf(cg_header_output, "\n");

       enum_values = enum_values->right;
    }
  }
  bprintf(cg_header_output, "\n#endif\n");
}

// We emit the enums into the current .h file so that C code can use those
// values to call our procedures.  The generated code from CQL uses the
// evaluated constants so these symbols are for "others" to use.
static void cg_emit_enums_stmt(ast_node *ast) {
  Contract(is_ast_emit_enums_stmt(ast));
  EXTRACT(name_list, ast->left);

  if (name_list) {
    // names specified: emit those
    while (name_list) {
      // names previously checked, we assert they are good here
      EXTRACT_STRING(name, name_list->left);
      EXTRACT_NOTNULL(declare_enum_stmt, find_enum(name));
      cg_emit_one_enum(declare_enum_stmt);
      name_list = name_list->right;
    }
  }
  else {
    // none specified: emit all
    for (list_item *item = all_enums_list; item; item = item->next) {
      EXTRACT_NOTNULL(declare_enum_stmt, item->ast);
      cg_emit_one_enum(declare_enum_stmt);
    }
  }
}

// This causes global constant declarations to go into the header file. Those
// constants are not even used in our codegen because the ast is rewritten to
// have the actual value rather than the name.  However this will make it
// possible to use the constant in callers from C.  The constant values are
// "public" in this sense.  This is a lot like the gen_sql code except it will
// be in C format.
static void cg_emit_one_const_group(ast_node *ast) {
  Contract(is_ast_declare_const_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(const_values, ast->right);
  EXTRACT_STRING(name, name_ast);

  bprintf(cg_header_output, "#ifndef const_group_%s_defined\n", name);
  bprintf(cg_header_output, "#define const_group_%s_defined\n\n", name);

  while (const_values) {
    EXTRACT_NOTNULL(const_value, const_values->left);
    EXTRACT_NAME_AST(const_name_ast, const_value->left);
    EXTRACT_STRING(const_name, const_name_ast);

    bprintf(cg_header_output, "#define %s ", const_name);

    if (is_numeric(const_value->sem->sem_type)) {
      eval_format_number(const_value->sem->value, EVAL_FORMAT_FOR_C, cg_header_output);
    }
    else {
      // We don't make a string object for string literals that are being
      // emitted, just the C literal.
      CHARBUF_OPEN(quoted);
        EXTRACT_STRING(literal, const_value->right);
        cg_requote_literal(literal, &quoted);
        bprintf(cg_header_output, "%s", quoted.ptr);
      CHARBUF_CLOSE(quoted);
    }

    bprintf(cg_header_output, "\n");

    const_values = const_values->right;
  }
  bprintf(cg_header_output, "\n#endif\n");
}

// We're emitting the constants of a group into the output header. We have to
// have this so that the constants can go into just one header of the developers
// choice.
static void cg_emit_constants_stmt(ast_node *ast) {
  Contract(is_ast_emit_constants_stmt(ast));
  EXTRACT_NOTNULL(name_list, ast->left);

  if (name_list) {
    // names specified: emit those
    while (name_list) {
      // names previously checked, we assert they are good here
      EXTRACT_STRING(name, name_list->left);
      EXTRACT_NOTNULL(declare_const_stmt, find_constant_group(name));
      cg_emit_one_const_group(declare_const_stmt);
      name_list = name_list->right;
    }
  }
}

// Declaring a cursor causes us to do the following:
//  * emit a local variable for the cursor in the declarations section
//  * emit cleanup logic for that local in the cleanup section
//  * execute the select or call statement that is associated with the cursor
//    * store the resulting statement for use later in fetch
//  * declare a hidden has_row local for the cursor so that the cursor name can
//    be used in expressions to see if a row was fetched.
static void cg_declare_cursor(ast_node *ast) {
  Contract(is_ast_declare_cursor(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(cursor_name, name_ast);

  bool_t is_for_select = false;
  bool_t is_for_call = false;
  bool_t is_for_expr = false;
  bool_t out_union_processing = false;
  bool_t is_boxed = !!(name_ast->sem->sem_type & SEM_TYPE_BOXED);
  bool_t is_unboxing = true;
  CSTR out_union_result_name = "";

  if (is_ast_call_stmt(ast->right)) {
    out_union_processing = has_out_union_stmt_result(ast);
    is_for_call = true;
    is_unboxing = false;
    EXTRACT_STRING(name, ast->right->left);
    out_union_result_name = name;
  }
  else if (is_row_source(ast->right)) {
    is_for_select = true;
    is_unboxing = false;
  }
  else {
    is_for_expr = true;
    if (ends_in_set(ast->right->sem->kind)) {
      out_union_processing = true;
      out_union_result_name = ast->left->sem->sptr->struct_name;
      is_unboxing = false;
    }
  }

  // only one of these (is boxed makes no sense with out union)
  Invariant(!out_union_processing || !is_boxed);

  // can't be both of these either
  Invariant(!out_union_processing || !is_unboxing);

  // unboxing implies is_boxed   a->b <==> (!a | b)
  Invariant(!is_unboxing || is_boxed);

  if (out_union_processing) {
    CG_CHARBUF_OPEN_SYM(result_ref, out_union_result_name, "_result_set_ref");

    bprintf(cg_declarations_output, "%s %s_result_set_ = NULL;\n", result_ref.ptr, cursor_name);
    bprintf(cg_declarations_output, "cql_int32 %s_row_num_ = 0;\n", cursor_name);
    bprintf(cg_declarations_output, "cql_int32 %s_row_count_ = 0;\n", cursor_name);
    bprintf(cg_cleanup_output, "  cql_object_release(%s_result_set_);\n", cursor_name);

    if (cg_in_loop && is_for_call) {
      // tricky case, the call might iterate so we have to clean up the cursor before we do the call
      bprintf(cg_main_output, "cql_object_release(%s_result_set_);\n", cursor_name);
    }

    if (is_for_expr) {
      EXTRACT_ANY_NOTNULL(expr, ast->right);
      CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

      bprintf(cg_main_output, "cql_set_object_ref((cql_object_ref *)&%s_result_set_, %s);\n", cursor_name, expr_value.ptr);
      bprintf(cg_main_output, "%s_row_num_ = -1;\n", cursor_name);
      bprintf(cg_main_output, "%s_row_count_ = cql_result_set_get_count((cql_result_set_ref)%s_result_set_);\n", cursor_name, cursor_name);

      CG_POP_EVAL(expr);
    }

    CHARBUF_CLOSE(result_ref);
  }
  else {
    bprintf(cg_declarations_output, "sqlite3_stmt *%s_stmt = NULL;\n", cursor_name);

    if (!is_boxed) {
      // easy case, no boxing, just finalize on exit.
      bprintf(cg_cleanup_output, "  cql_finalize_stmt(&%s_stmt);\n", cursor_name);

      if (cg_in_loop) {
        // tricky case, the call might iterate so we have to clean up the cursor before we do the call
        bprintf(cg_main_output, "cql_finalize_stmt(&%s_stmt);\n", cursor_name);
      }
    }
  }

  if (is_for_select) {
    // DECLARE [name] CURSOR FOR [select_stmt]
    // or
    // DECLARE [name] CURSOR FOR [explain_stmt]
    EXTRACT_ANY_NOTNULL(select_stmt, ast->right);

    if (is_boxed) {
      // The next prepare will finalize the statement, we don't want to do that
      // if the cursor is being handled by boxes. The box downcount will take care of it
      bprintf(cg_main_output, "%s_stmt = NULL;\n", cursor_name);
    }
    cg_bound_sql_statement(cursor_name, select_stmt, CG_PREPARE|CG_MINIFY_ALIASES);
  }
  else if (is_unboxing) {
    Invariant(is_for_expr);

    // DECLARE [name] CURSOR FOR [box_object_expr]
    EXTRACT_ANY_NOTNULL(expr, ast->right);

    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);
    CHARBUF_OPEN(box_name);

    bprintf(&box_name, "%s_object_", cursor_name);
    cg_copy(cg_main_output, box_name.ptr, SEM_TYPE_OBJECT, expr_value.ptr);
    bprintf(cg_main_output, "%s_stmt = cql_unbox_stmt(%s);\n", cursor_name, box_name.ptr);

    CHARBUF_CLOSE(box_name);
    CG_POP_EVAL(expr);
  }
  else if (is_for_expr) {
  }
  else {
    Invariant(is_for_call);
    // DECLARE [name] CURSOR FOR [call_stmt]]
    if (is_boxed) {
      // The next prepare will finalize the statement, we don't want to do that
      // if the cursor is being handled by boxes. The box downcount will take care of it
      bprintf(cg_main_output, "%s_stmt = NULL;\n", cursor_name);
    }

    EXTRACT_NOTNULL(call_stmt, ast->right);
    cg_call_stmt_with_cursor(call_stmt, cursor_name);
  }

  if (is_boxed) {
    // An object will control the lifetime of the cursor.  If the cursor is
    // boxed this is the object reference that will be used.  This way the exit
    // path is uniform regardless of whether or not the object was in fact boxed
    // in the control flow.  This is saying that it might be boxed later so we
    // use this general mechanism for lifetime. The cg_var_decl helper handles
    // cleanup too.

    CHARBUF_OPEN(box_name);
    bprintf(&box_name, "%s_object_", cursor_name);

    cg_var_decl(cg_declarations_output, SEM_TYPE_OBJECT, box_name.ptr, CG_VAR_DECL_FULL);

    // unbox case gets the object from the unbox operation above, so skip if unboxing

    if (!is_unboxing) {
      // Note we have to clear the stashed box object and then accept the new
      // box without increasing the retain count on the new box because it
      // starts with a +1 as usual. This is a job for cg_copy_for_create!

      CHARBUF_OPEN(box_value);
      bprintf(&box_value, "cql_box_stmt(%s_stmt)", cursor_name);
      cg_copy_for_create(cg_main_output, box_name.ptr, SEM_TYPE_OBJECT, box_value.ptr);
      CHARBUF_CLOSE(box_value);
    }

    CHARBUF_CLOSE(box_name);
  }

  if (name_ast->sem->sem_type & SEM_TYPE_HAS_SHAPE_STORAGE) {
    cg_declare_auto_cursor(cursor_name, name_ast->sem);
  }
  else {
    // if it's a global cursor (`!in_proc`) we have to assume we will need the
    // variable eventually so we emit it now; if it's a local then we only emit
    // it if we know it'll be used later on (as indicated by `SEM_TYPE_FETCH_INTO`)
    if (!in_proc || name_ast->sem->sem_type & SEM_TYPE_FETCH_INTO) {
      // make the cursor_has_row hidden variable
      CHARBUF_OPEN(temp);
      bprintf(&temp, "_%s_has_row_", cursor_name);
      cg_var_decl(cg_declarations_output, SEM_TYPE_BOOL | SEM_TYPE_NOTNULL, temp.ptr, CG_VAR_DECL_FULL);
      CHARBUF_CLOSE(temp);
    }
  }
}

// This is the cursor boxing primitive, we'll make an object variable for this
// cursor here. Note since the cursor is boxed its lifetime is already controlled
// by an object associated with the cursor.  This happens as soon as the cursor
// is created, however it is created. The codegen system knows that the cursor
// may be boxed at some point using the SEM_TYPE_BOXED flag
static void cg_set_from_cursor(ast_node *ast) {
  Contract(is_ast_set_from_cursor(ast));
  EXTRACT_ANY_NOTNULL(variable, ast->left);
  EXTRACT_ANY_NOTNULL(cursor, ast->right);
  EXTRACT_STRING(cursor_name, cursor);
  EXTRACT_STRING(var_name, variable);

  CHARBUF_OPEN(value);
  bprintf(&value, "%s_object_", cursor_name);


  CSTR prefix = "";
  if (is_out_parameter(variable->sem->sem_type)) {
    prefix = "*";
  }

  CHARBUF_OPEN(tmp_var_name);
  bprintf(&tmp_var_name, "%s%s", prefix, var_name);
  cg_copy(cg_main_output, tmp_var_name.ptr, SEM_TYPE_OBJECT, value.ptr);
  CHARBUF_CLOSE(tmp_var_name);

  CHARBUF_CLOSE(value);
}

// We're using the named cursors's semantic type to declare a cursor.
static void cg_declare_cursor_like(ast_node *name_ast) {
  EXTRACT_STRING(cursor_name, name_ast);

  Contract(name_ast->sem->sem_type & SEM_TYPE_HAS_SHAPE_STORAGE);
  cg_declare_auto_cursor(cursor_name, name_ast->sem);
}

// We're using some other names semantic type to declare a cursor.
static void cg_declare_cursor_like_name(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_name(ast));
  Contract(ast->right);
  EXTRACT_NAME_AST(name_ast, ast->left);

  cg_declare_cursor_like(name_ast);
}

// we're using the shape of a select statement to declare a cursor
static void cg_declare_cursor_like_select(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_select(ast));
  Contract(is_select_variant(ast->right));
  EXTRACT_NAME_AST(name_ast, ast->left);

  cg_declare_cursor_like(name_ast);
}

// we're using typed names (x int, y real) to make a cursor
static void cg_declare_cursor_like_typed_names(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_typed_names(ast));
  Contract(is_ast_typed_names(ast->right));
  EXTRACT_NAME_AST(name_ast, ast->left);

  cg_declare_cursor_like(name_ast);
}

// The value cursor form for sure will be fetched.   We emit the necessary
// locals for the cursor here.  Those are one for "_has_row_" field and another
// for each element of the structure the cursor holds.
static void cg_declare_value_cursor(ast_node *ast) {
  Contract(is_ast_declare_value_cursor(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(cursor_name, name_ast);
  EXTRACT_NOTNULL(call_stmt, ast->right);

  // DECLARE [name] CURSOR FETCH FROM [call_stmt]]
  cg_declare_auto_cursor(cursor_name, name_ast->sem);
  cg_call_stmt_with_cursor(call_stmt, cursor_name);
}

// Fetch values has been checked for the presence of all columns and seed values
// have already been added if needed.  All we have to generate evaluation of
// each value and then a store.  There is no "fetch values into name_list" form.
static void cg_fetch_values_stmt(ast_node *ast) {
  Contract(is_ast_fetch_values_stmt(ast));

  EXTRACT(insert_dummy_spec, ast->left);
  EXTRACT(name_columns_values, ast->right);
  EXTRACT_ANY_NOTNULL(cursor, name_columns_values->left)
  EXTRACT(columns_values, name_columns_values->right);
  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT(insert_list, columns_values->right);
  EXTRACT(name_list, column_spec->left);

  if (insert_dummy_spec) {
    cg_insert_dummy_spec(insert_dummy_spec);
  }

  // get the canonical name of the cursor (the string might be case-sensitively different)
  CSTR cursor_name = cursor->sem->name;

  // FETCH name [( name_list )] FROM VALUES (insert_list) [insert_dummy_spec]

  ast_node *value = insert_list;

  bprintf(cg_main_output, "%s._has_row_ = 1;\n", cursor_name);

  for (ast_node *item = name_list ; item; item = item->right, value = value->right) {
    EXTRACT_ANY_NOTNULL(expr, value->left);
    EXTRACT_ANY_NOTNULL(col, item->left);
    EXTRACT_STRING(var, col);

    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);
    CHARBUF_OPEN(temp);
    bprintf(&temp, "%s.%s", cursor_name, var);
    cg_store(cg_main_output, temp.ptr, col->sem->sem_type, expr->sem->sem_type, expr_is_null.ptr, expr_value.ptr);
    CHARBUF_CLOSE(temp);
    CG_POP_EVAL(expr);
  }
}

// Fetch has already been rigorously checked so we don't have to worry about
// argument counts or type mismatches in the codegen.  We have two cases:
//  * Fetch into variables
//    * loop over the variables which must match with the columns (!) and use
//      the cg_get_column helpers to emit the code for a store
//  * Fetch into auto variables
//    * loop over the field names of the sem_struct that corresponds to the
//      cursor
//    * set each local according to the automatically generated name as above
//
// Note: cg_get_column does the error processing
static void cg_fetch_stmt(ast_node *ast) {
  Contract(is_ast_fetch_stmt(ast));
  EXTRACT_ANY_NOTNULL(cursor_ast, ast->left);
  EXTRACT(name_list, ast->right);

  // use the canonical name, not the AST name (case could be different)
  CSTR cursor_name = cursor_ast->sem->name;

  // FETCH [name] [INTO [name_list]]

  bool_t uses_out_union = !!(ast->sem->sem_type & SEM_TYPE_USES_OUT_UNION);

  CHARBUF_OPEN(row_test);

  if (uses_out_union) {
    bprintf(cg_main_output, "%s_row_num_++;\n", cursor_name);
    bprintf(&row_test, "%s_row_num_ < %s_row_count_", cursor_name, cursor_name);
  }
  else {
    bprintf(cg_main_output, "_rc_ = sqlite3_step(%s_stmt);\n", cursor_name);
    bprintf(&row_test, "_rc_ == SQLITE_ROW");
  }

  if (ast->sem->sem_type & SEM_TYPE_HAS_SHAPE_STORAGE) {
    bprintf(cg_main_output, "%s._has_row_ = %s;\n", cursor_name, row_test.ptr);
  }
  else {
    bprintf(cg_main_output, "_%s_has_row_ = %s;\n", cursor_name, row_test.ptr);
  }

  CHARBUF_CLOSE(row_test);

  // if there is a row, then we need to read the row into the variables there
  // are two alternatives: reading into locals/args or reading into
  // auto-generated cursor variables.  Either way we get each column.

  sem_struct *sptr = ast->left->sem->sptr;
  if (uses_out_union) {
    bool_t dml_proc = is_dml_proc(ast->sem->sem_type);
    CSTR db_sym = "NULL";
    if (dml_proc) {
      // The db pointer passed to cql_copyoutrow(...) is used only to decode any
      // encoded columns. We provide the db pointer only if the result_set to
      // copy were created by a DML proc. The idea being that if it wasn't a DML
      // proc that made the result set then it could not have encoded anything
      // since it also, did not have the db pointer to do the encoding. So our
      // decode call will match what the proc could have done.
      db_sym = "_db_";
    }
    bprintf(cg_main_output, "cql_copyoutrow(%s, (cql_result_set_ref)%s_result_set_, %s_row_num_, %d",
      db_sym, cursor_name, cursor_name, sptr->count);
  }
  else {
    bprintf(cg_main_output, "cql_multifetch(_rc_, %s_stmt, %d", cursor_name, sptr->count);
  }


  CSTR newline = ",\n               ";

  if (name_list) {
    int32_t i = 0; // column get is zero based

    for (ast_node *item = name_list; item; item = item->right, i++) {
      EXTRACT_NAME_AST(name_ast, item->left);
      EXTRACT_STRING(var, name_ast);
      sem_t sem_type_var = name_ast->sem->sem_type;
      bprintf(cg_main_output, "%s", newline);
      cg_fetch_column(sem_type_var, var);
    }
  }
  else {
    for (uint32_t i = 0; i < sptr->count; i++) {
      CHARBUF_OPEN(temp);
      bprintf(&temp, "%s.%s", cursor_name, sptr->names[i]);
      bprintf(cg_main_output, "%s", newline);
      cg_fetch_column(sptr->semtypes[i], temp.ptr);
      CHARBUF_CLOSE(temp);
    }
  }
  bprintf(cg_main_output, ");\n");
  if (!uses_out_union) {
    cg_error_on_expr("_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE");
  }
}

static void cg_fetch_call_stmt(ast_node *ast) {
  Contract(is_ast_fetch_call_stmt(ast));
  EXTRACT_STRING(cursor_name, ast->left);
  EXTRACT_ANY_NOTNULL(call_stmt, ast->right);

  cg_call_stmt_with_cursor(call_stmt, cursor_name);
}

// The update cursor statement differs from the more general fetch form in that
// it is only to be used to tweak fields in an already loaded cursor.  The
// sematics are that if you try to "update" a cursor with no row the update is
// ignored. The purpose of this is to let you edit one or two fields of a row as
// you fetch them before using OUT or OUT UNION or INSERT ... FROM CURSOR.  You
// want to do this without having to restate all the columns, which besides
// being verbose makes it hard for people to see what things you are changing
// and what you are not.
static void cg_update_cursor_stmt(ast_node *ast) {
  Contract(is_ast_update_cursor_stmt(ast));
  EXTRACT_ANY(cursor, ast->left);
  EXTRACT_STRING(name, cursor);
  EXTRACT_NOTNULL(columns_values, ast->right);
  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT_ANY_NOTNULL(name_list, column_spec->left);
  EXTRACT_ANY_NOTNULL(insert_list, columns_values->right);

  bprintf(cg_main_output, "if (%s._has_row_) {\n", name);

  CG_PUSH_MAIN_INDENT(stores, 2);

  ast_node *col = name_list;
  ast_node *val = insert_list;

  for ( ; col && val; col = col->right, val = val->right) {
    ast_node *expr = val->left;
    ast_node *name_ast = col->left;

    CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);
    CHARBUF_OPEN(temp);
    bprintf(&temp, "%s.%s", name, name_ast->sem->name);
    cg_store(cg_main_output, temp.ptr, name_ast->sem->sem_type, expr->sem->sem_type, expr_is_null.ptr, expr_value.ptr);
    CHARBUF_CLOSE(temp);
    CG_POP_EVAL(expr);
  }

  CG_POP_MAIN_INDENT(stores);

  bprintf(cg_main_output, "}\n");
}

// Here we just emit the various case labels for the expression list of a
// SWITCH/WHEN clause.  There isn't much to this.
//  * the correct indent level is already set up
//  * if the constants are 64 make sure we emit them as such
//  * we know evaluation will work because the semantic pass already checked it
//  * formatting numbers never fails
static void cg_switch_expr_list(ast_node *ast, sem_t sem_type_switch_expr) {
  Contract(is_ast_expr_list(ast));

  while (ast) {
    Contract(is_ast_expr_list(ast));
    EXTRACT_ANY_NOTNULL(expr, ast->left);

    eval_node result = EVAL_NIL;
    eval(expr, &result);
    Invariant(result.sem_type != SEM_TYPE_ERROR); // already checked

    bprintf(cg_main_output, "case ");

    eval_format_number(&result, EVAL_FORMAT_FOR_C, cg_main_output);

    bprintf(cg_main_output, ":\n");

    ast = ast->right;
  }
}

// Switch actually generates pretty easily because of the constraints that were
// placed on the various expressions.  We know that the case lables are all
// integers and we know that the expression type of the switch expression is a
// not null integer type so we can easily generate the switch form.  Anything
// that could go wrong has already been checked.
static void cg_switch_stmt(ast_node *ast) {
  Contract(is_ast_switch_stmt(ast));
  EXTRACT_NOTNULL(switch_body, ast->right);
  EXTRACT_ANY_NOTNULL(expr, switch_body->left);
  EXTRACT_NOTNULL(switch_case, switch_body->right);

  // SWITCH [expr] [switch_body] END
  // SWITCH [expr] ALL VALUES [switch_body] END

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  bprintf(cg_main_output, "switch (%s) {\n", expr_value.ptr);
  CG_POP_EVAL(expr);

  CG_PUSH_MAIN_INDENT(cases, 2);

  bool_t first_case = true;

  bool_t has_default = false;
  for (ast_node *temp = switch_case; temp; temp = temp->right) {
    EXTRACT_NOTNULL(connector, temp->left);
    if (!connector->left) {
      has_default = true;
    }
  }

  while (switch_case) {
    EXTRACT_NOTNULL(connector, switch_case->left);
    EXTRACT(stmt_list, connector->right);

    // no stmt list corresponds to WHEN ... THEN NOTHING
    // we can skip the entire case set unless there is a default
    // in which case we have to emit it with just break...
    if (stmt_list || has_default) {
      if (!first_case) {
        bprintf(cg_main_output, "\n");  // break between statement lists
      }
      first_case = false;

      // no expr list corresponds to the else case
      if (connector->left) {
        EXTRACT_NOTNULL(expr_list, connector->left);
        cg_switch_expr_list(expr_list, expr->sem->sem_type);
      }
      else {
        bprintf(cg_main_output, "default:\n");
      }

      if (stmt_list) {
        cg_stmt_list(stmt_list);
      }
      bprintf(cg_main_output, "  break;\n");
    }
    switch_case = switch_case->right;
  }

  CG_POP_MAIN_INDENT(cases);
  bprintf(cg_main_output, "}\n");
}

// "While" suffers from the same problem as IF and as a consequence generating
// while (expression) would not generalize. The overall pattern for while has to
// look like this:
//
//  for (;;) {
//    prep statements;
//    condition = final expression;
//    if (!condition) break;
//
//    statements;
//  }
//
// Note that while can have leave and continue substatements which have to map
// to break and continue.   That means other top level statements that aren't
// loops must not create a C loop construct or break/continue would have the
// wrong target.
static void cg_while_stmt(ast_node *ast) {
  Contract(is_ast_while_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(stmt_list, ast->right);
  sem_t sem_type = expr->sem->sem_type;

  // WHILE [expr] BEGIN [stmt_list] END

  bprintf(cg_main_output, "for (;;) {\n");

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  CG_PUSH_MAIN_INDENT(loop, 2);
  if (is_nullable(sem_type)) {
    bprintf(cg_main_output, "if (!cql_is_nullable_true(%s, %s)) break;\n", expr_is_null.ptr, expr_value.ptr);
  }
  else {
    bprintf(cg_main_output, "if (!(%s)) break;\n", expr_value.ptr);
  }
  CG_POP_MAIN_INDENT(loop);

  int32_t loop_saved = cg_in_loop;
  cg_in_loop = LOOP_ANY;

  CG_POP_EVAL(expr);

  cg_stmt_list(stmt_list);

  bprintf(cg_main_output, "}\n");

  cg_in_loop = loop_saved;
}

// "For" suffers from the same problem as IF and as a consequence generating
// while (expression) would not generalize. The overall pattern for while has to
// look like this:
//
//  for (;;) {
//    prep statements;
//    condition = final expression;
//    if (!condition) break;
//
//    statements;
//  }
//
// Note that while can have leave and continue substatements which have to map
// to break and continue.   That means other top level statements that aren't
// loops must not create a C loop construct or break/continue would have the
// wrong target.
static void cg_for_stmt(ast_node *ast) {
  Contract(is_ast_for_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(for_info, ast->right);
  sem_t sem_type = expr->sem->sem_type;

  // FOR expr ; stmt_list BEGIN [stmt_list] END

  int32_t for_loop_saved = for_loop_cur;
  for_loop_cur = ++for_loop_count;

  bprintf(cg_main_output, "for (;;) {\n");

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  CG_PUSH_MAIN_INDENT(loop, 2);
  if (is_nullable(sem_type)) {
    bprintf(cg_main_output, "if (!cql_is_nullable_true(%s, %s)) break;\n", expr_is_null.ptr, expr_value.ptr);
  }
  else {
    bprintf(cg_main_output, "if (!(%s)) break;\n", expr_value.ptr);
  }
  CG_POP_MAIN_INDENT(loop);

  int32_t loop_saved = cg_in_loop;
  cg_in_loop = LOOP_FOR;

  CG_POP_EVAL(expr);

  cg_stmt_list(for_info->right);

  bprintf(cg_main_output, "for_continue_%d:\n", for_loop_cur);
  cg_stmt_list(for_info->left);

  bprintf(cg_main_output, "}\n");

  cg_in_loop = loop_saved;
  for_loop_cur = for_loop_saved;
}

// The general pattern for this is very simple:
//
//  for (;;) {
//    do the fetch;
//    if (no rows) break;
//    do your loop;
//  }
//
// It has to be this because the fetch might require many statements. There are
// helpers for all of this so it's super simple.
static void cg_loop_stmt(ast_node *ast) {
  Contract(is_ast_loop_stmt(ast));
  EXTRACT_NOTNULL(fetch_stmt, ast->left);
  EXTRACT(stmt_list, ast->right);
  EXTRACT_ANY_NOTNULL(cursor_ast, fetch_stmt->left);

  // Get the canonical name of the cursor (the name in the tree might be
  // case-sensitively different)
  CSTR cursor_name = cursor_ast->sem->name;

  // LOOP [fetch_stmt] BEGIN [stmt_list] END
  bprintf(cg_main_output, "for (;;) {\n");
  CG_PUSH_MAIN_INDENT(loop, 2);

  cg_fetch_stmt(fetch_stmt);

  if (fetch_stmt->left->sem->sem_type & SEM_TYPE_HAS_SHAPE_STORAGE) {
    bprintf(cg_main_output, "if (!%s._has_row_) break;\n", cursor_name);
  }
  else {
    // variable already emitted by the fetch statement above if needed
    bprintf(cg_main_output, "if (!_%s_has_row_) break;\n", cursor_name);
  }

  int32_t loop_saved = cg_in_loop;
  cg_in_loop = LOOP_ANY;

  CG_POP_MAIN_INDENT(loop);

  cg_stmt_list(stmt_list);

  bprintf(cg_main_output, "}\n");

  cg_in_loop = loop_saved;
}

// Only SQL loops are allowed to use C loops, so "continue" is perfect
static void cg_continue_stmt(ast_node *ast) {
  Contract(is_ast_continue_stmt(ast));

  // CONTINUE
  if (cg_in_loop == LOOP_FOR) {
    bprintf(cg_main_output, "goto for_continue_%d;\n", for_loop_cur);
  }
  else {
    bprintf(cg_main_output, "continue;\n");
  }
}

// Only SQL loops are allowed to use C loops, so "break" is perfect
static void cg_leave_stmt(ast_node *ast) {
  Contract(is_ast_leave_stmt(ast));

  // LEAVE
  bprintf(cg_main_output, "break;\n");
}

// We go to the main cleanup label and exit the current procedure
static void cg_return_stmt(ast_node *ast) {
  Contract(is_ast_return_stmt(ast) || is_ast_rollback_return_stmt(ast) || is_ast_commit_return_stmt(ast));

  // RETURN
  bool_t dml_proc = is_dml_proc(current_proc->sem->sem_type);
  if (dml_proc) {
    bprintf(cg_main_output, "_rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error\n");
  }
  bprintf(cg_main_output, "goto %s; // return\n", CQL_CLEANUP_DEFAULT_LABEL);
  return_used = true;
}

// Rollback the current procedure savepoint, then perform a return. Note that to
// rollback a savepoint you have to do the rollback AND the release and then
// you're unwound to the savepoint state.  The transaction in flight is still in
// flight if there is one.
static void cg_rollback_return_stmt(ast_node *ast) {
  Contract(is_ast_rollback_return_stmt(ast));

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
  ast_node *rollback = new_ast_rollback_trans_stmt(new_ast_str(current_proc_name()));
  ast_node *release = new_ast_release_savepoint_stmt(new_ast_str(current_proc_name()));
  AST_REWRITE_INFO_RESET();

  cg_bound_sql_statement(NULL, rollback, CG_EXEC);
  cg_bound_sql_statement(NULL, release, CG_EXEC);
  cg_return_stmt(ast);
}

// Commits the current procedure savepoint, then perform a return. Note
// savepoint semantics are just "release" is sort of like commit in that it
// doesn't rollback and becomes part of the current transaction which may or may
// not commit but that's what we mean by commit.
static void cg_commit_return_stmt(ast_node *ast) {
  Contract(is_ast_commit_return_stmt(ast));

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
  ast_node *commit = new_ast_release_savepoint_stmt(new_ast_str(current_proc_name()));
  AST_REWRITE_INFO_RESET();

  cg_bound_sql_statement(NULL, commit, CG_EXEC);
  cg_return_stmt(ast);
}

// Finalize the statement object associated with the cursor. Note this sets the
// cursor to null, so you can do it again.  Cleanup might also do this. That's
// fine.
static void cg_close_stmt(ast_node *ast) {
  Contract(is_ast_close_stmt(ast));
  EXTRACT_ANY_NOTNULL(cursor_ast, ast->left);
  EXTRACT_STRING(name, cursor_ast);

  // CLOSE [name]

  sem_t sem_type = cursor_ast->sem->sem_type;

  if (!(sem_type & SEM_TYPE_VALUE_CURSOR)) {
    bprintf(cg_main_output, "cql_finalize_stmt(&%s_stmt);\n", name);
  }

  if (sem_type & SEM_TYPE_HAS_SHAPE_STORAGE) {
    sem_struct *sptr = cursor_ast->sem->sptr;
    int32_t refs_count = refs_count_sptr(sptr);

    if (refs_count) {
      bprintf(cg_main_output, "cql_teardown_row(%s);\n", name);
    }
  }
}

// The OUT statement copies the current value of a cursor into an implicit OUT
// structure variable (_result_).  The type of the variable is inferred from the
// cursor you return.  All OUT statements in any given proc must agree on the
// exact type (this has already been verified).  At this point all we have to do
// is copy the fields.
static void cg_out_stmt(ast_node *ast) {
  Contract(is_ast_out_stmt(ast));

  // Get the canonical name of the cursor (the name in the tree might be
  // case-sensitively different)
  CSTR cursor_name = ast->left->sem->name;

  // OUT [cursor_name]

  // If there is a row, then we need to the values into the result.
  CHARBUF_OPEN(var);
  CHARBUF_OPEN(value);

  sem_t sem_type_has_row = SEM_TYPE_BOOL | SEM_TYPE_NOTNULL;

  ast_node *proc_name_ast = get_proc_name(current_proc);
  EXTRACT_STRING(proc_name, proc_name_ast);

  // We can just blindly copy out the values because FETCH puts something
  // intelligent there if there is no row available (e.g. null strings)
  bprintf(&var, "_result_->%s", "_has_row_");
  bprintf(&value, "%s._has_row_", cursor_name);
  cg_copy(cg_main_output, var.ptr, sem_type_has_row, value.ptr);

  CG_CHARBUF_OPEN_SYM(sym, proc_name, "_refs_offset");

  sem_struct *sptr = ast->left->sem->sptr;
  int32_t refs_count = refs_count_sptr(sptr);

  if (refs_count) {
    // if no ref count it starts null and stays null
    bprintf(cg_main_output, "_result_->_refs_count_ = %d;\n", refs_count);
    bprintf(cg_main_output, "_result_->_refs_offset_ = %s;\n", sym.ptr);
  }

  for (uint32_t i = 0; i < sptr->count; i++) {
    bclear(&var);
    bclear(&value);
    bprintf(&var, "_result_->%s", sptr->names[i]);
    bprintf(&value, "%s.%s", cursor_name, sptr->names[i]);
    cg_copy(cg_main_output, var.ptr, sptr->semtypes[i], value.ptr);
  }

  CHARBUF_CLOSE(sym);
  CHARBUF_CLOSE(value);
  CHARBUF_CLOSE(var);
}

static void cg_out_union_stmt(ast_node *ast) {
  Contract(is_ast_out_union_stmt(ast));

  // get the canonical name of the cursor (the name in the tree might be
  // case-sensitively different)
  CSTR cursor_name = ast->left->sem->name;

  // OUT UNION [cursor_name]

  bprintf(cg_main_output, "cql_retain_row(%s);\n", cursor_name);
  bprintf(cg_main_output, "if (%s._has_row_) ", cursor_name);
  bprintf(cg_main_output, "cql_bytebuf_append(&_rows_, (const void *)&%s, sizeof(%s));\n", cursor_name, cursor_name);
}

// Emit the string literal into the otuput if the current runtime matches
static void cg_echo_stmt(ast_node *ast) {
  Contract(is_ast_echo_stmt(ast));
  EXTRACT_STRING(rt_name, ast->left);
  EXTRACT_STRING(str, ast->right);

  // @ECHO [rt], [str]

  if (!StrCaseCmp(rt_name, options.rt)) {
    if (current_proc) {
      cg_decode_string_literal(str, cg_main_output);
    }
    else {
      cg_decode_string_literal(str, cg_declarations_output);
    }
  }
}

// This is the helper method to dispatch a call to an external function like
// "printf" given a name in the AST.  This is for when the user coded the call.
static void cg_call_external(ast_node *ast) {
  Contract(is_ast_call_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY(arg_list, ast->right);

  cg_call_named_external(name, arg_list);
}

// This is performs an external function call, normalizing strings and passing
// the current value of nullables.  It's all straight up value-calls.  This form
// is used when the name might not be in the AST, such as we need a call to a
// sqlite helper method with user provided args.  All we do here is emit the
// name and then use the arg list helper. The arg list helper gives us
// prep/invocation/cleanup buffers which we must emit.
static void cg_call_named_external(CSTR name, ast_node *arg_list) {
  CHARBUF_OPEN(invocation);
  CHARBUF_OPEN(prep);
  CHARBUF_OPEN(cleanup);

  // Note this function is called in an expression context such as for the
  // builtin "printf" SQL function it can also be called in the call statement
  // context such as "call printf();"  In the second case it's top level and the
  // stack doesn't matter as it will be reset but in the first case we need to
  // restore the temp stack after we are done with the args.
  int32_t stack_level_saved = stack_level;

  bprintf(&invocation, "%s(", name);
  cg_emit_external_arglist(arg_list, &prep, &invocation, &cleanup);
  bprintf(&invocation, ");\n");

  bprintf(cg_main_output, "%s%s%s", prep.ptr, invocation.ptr, cleanup.ptr);

  stack_level = stack_level_saved;  // put the scratch stack back

  CHARBUF_CLOSE(cleanup);
  CHARBUF_CLOSE(prep);
  CHARBUF_CLOSE(invocation);
}

// This is the hard work of doing the call actually happens.  We have to:
//   * evaluate each argument in the arg list
//     * for string literals, don't make a string_ref, just emit the literal as
//       a quoted string it's going to a C style call anyway...
//     * for strings
//       * add a prep statement to convert the string to a const char * in a temp
//       * include the temporary in the arg list
//       * add a cleanup statement to release the temporary
//     * for others, use the expression value
//   * burn the top of the stack, in case the result is stored in a temporary,
//     each arg gets a fresh top of stack so they don't clobber each others
//     results.
static void cg_emit_external_arglist(ast_node *arg_list, charbuf *prep, charbuf *invocation, charbuf *cleanup) {
  for (ast_node *item = arg_list; item; item = item->right) {
    EXTRACT_ANY(arg, item->left);
    sem_t sem_type_arg = arg->sem->sem_type;

    if (is_strlit(arg)) {
      // special case, don't make a string object for string literals that are going to
      // external methods like printf
      CHARBUF_OPEN(quoted);

      EXTRACT_STRING(literal, arg);
      cg_requote_literal(literal, &quoted);
      bprintf(invocation, "%s", quoted.ptr);

      CHARBUF_CLOSE(quoted);
    }
    else {
      CG_PUSH_EVAL(arg, C_EXPR_PRI_ROOT);

      if (is_text(sem_type_arg)) {
        // external/unknown proc, convert to cstr first
        temp_cstr_count++;
        bprintf(prep, "cql_alloc_cstr(_cstr_%d, %s);\n", temp_cstr_count, arg_value.ptr);
        bprintf(invocation, "_cstr_%d", temp_cstr_count);
        bprintf(cleanup, "cql_free_cstr(_cstr_%d, %s);\n", temp_cstr_count, arg_value.ptr);
      }
      else {
        bprintf(invocation, "%s", arg_value.ptr);
      }

      CG_POP_EVAL(arg);
    }

    if (item->right) {
      bprintf(invocation, ", ");
    }
  }
}

// We have to release any valid object we have before we call an out function or
// we will leak a reference.
static void cg_release_out_arg_before_call(sem_t sem_type_arg, sem_t sem_type_param, CSTR name) {
  if (is_ref_type(sem_type_arg)) {
    if (!is_in_parameter(sem_type_param)) {
      cg_store(cg_main_output, name, sem_type_arg, sem_type_arg, "1", "NULL");
    }
  }
}

// When performing a call there are several things we might need to do to the
// arguments in order to get the correct calling convention.
//  * strings are already references, they go as is.
//  * not-nullables can go as is, unless
//  * if the paramater is not nullable and the argument is compatible but not an
//    exact match, then we box the argument into a temporary not nullable and
//    pass that through
//  * finally, both the paramater and the argument was not nullable then we have
//    to recover the variable name from the evaluated value.
static void cg_emit_one_arg(ast_node *arg, sem_t sem_type_param, sem_t sem_type_arg, charbuf *invocation) {
  CG_PUSH_EVAL(arg, C_EXPR_PRI_ROOT);

  do {
    // check for special case of out parameters
    if (is_out_parameter(sem_type_param)) {
      Contract(is_variable(sem_type_arg));  // previously checked (semantic pass)
      if (is_out_parameter(sem_type_arg)) {
        bprintf(invocation, "%s", arg->sem->name);
      }
      else {
        bprintf(invocation, "&%s", arg->sem->name);
      }

      cg_release_out_arg_before_call(sem_type_arg, sem_type_param, arg->sem->name);
      break;
    }

    if (is_cursor_formal(sem_type_param)) {
      bprintf(invocation, "&%s_dyn", arg->sem->name);
      break;
    }

    if (is_ref_type(sem_type_arg)) {
      // normal case, pass the reference
      bprintf(invocation, "%s", arg_value.ptr);
      break;
    }

    bool_t must_box_arg = false;
    if (is_nullable(sem_type_param)) {
       must_box_arg |= is_ast_null(arg);
       must_box_arg |= is_not_nullable(sem_type_arg);
       must_box_arg |= core_type_of(sem_type_arg) != core_type_of(sem_type_param);
    }

    if (must_box_arg) {
      // we have to pass a nullable of the exact type, box to that.
      CG_PUSH_TEMP(box_var, sem_type_param);
      cg_store(cg_main_output, box_var.ptr, sem_type_param, sem_type_arg, arg_is_null.ptr, arg_value.ptr);
      bprintf(invocation, "%s", box_var.ptr);
      CG_POP_TEMP(box_var);
      // burn the stack slot for the temporary, it can't be re-used during the call
      stack_level++;
      break;
    }

    // check for bool normalization
    if (is_bool(sem_type_param) && !is_bool(sem_type_arg)) {
      // If it's not an exact match at this point we're in the not-null case for
      // sure or we would have had to box above. If the arg is not a bool,
      // normalize now.
      Invariant(!is_nullable(sem_type_arg));
      bprintf(invocation, "(!!(%s))", arg_value.ptr);
      break;
    }

    if (is_nullable(sem_type_param)) {
      // This is the unfortunate case where we have split out a temporary or
      // variable that was already nullable and we want to use it for the call.
      // The thing is we've split that nullable into two parts the .value and
      // the .isnull -- what we want is to just pass the variable itself, so
      // we're going to look at the value and reconstruct the variable by
      // stripping off the .value

      const uint32_t dot_value_length = 6;  //  .value is 6 characters.

      // if it was not null we'd be boxing, above.
      Invariant(is_nullable(sem_type_arg));
      // if it was a null literal, we'd be boxing
      Invariant(!is_null_type(sem_type_arg));
      // it's bigger than .value
      Invariant(arg_value.used > dot_value_length);
      // it ends in .value
      Invariant(!strcmp(".value", arg_value.ptr + arg_value.used - dot_value_length - 1));

      arg_value.used -= dot_value_length;
      arg_value.ptr[arg_value.used - 1] = 0;
    }

    // either way arg_value is now correct
    bprintf(invocation, "%s", arg_value.ptr);
  }  while (0);

  CG_POP_EVAL(arg);
}


// This generates the invocation for a user defined external function. Basically
// we do a simple C invoke with the matching argument types which are known
// exactly we do the usual argument conversions using cg_emit_one_arg just like
// when calling procedures however we capture the return type in a temporary
// variable created exactly for this purpose. Note we do this without using the
// usual macros because those would invoke the function twice: one time for
// is_null and one time for _value which is a no-no.  So here we emit a direct
// assignment much like we would in cg_store.  Except we don't have to do all
// the cg_store things because we know the target is a perfectly matching local
// variable we just created. This code is also used in the proc as func path
// hence the dml stuff.
static void cg_user_func(ast_node *ast, charbuf *is_null, charbuf *value) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  ast_node *params = NULL;
  ast_node *func_stmt = find_func(name);
  if (!func_stmt) func_stmt = find_unchecked_func(name);
  CSTR func_name = NULL;

  bool_t dml_proc = false;
  bool_t proc_as_func = false;
  bool_t out_arg_result = false;
  bool_t result_set_return = false;
  bool_t need_comma = false;
  bool_t unchecked_func = is_ast_declare_func_no_check_stmt(func_stmt);

  if (func_stmt) {
    EXTRACT_STRING(fname, func_stmt->left);
    params = get_func_params(func_stmt);
    func_name = fname;
  }
  else {
    // has to be one of these two, already validated
    ast_node *proc_stmt = find_proc(name);
    Invariant(proc_stmt);
    params = get_proc_params(proc_stmt);
    ast_node *proc_name_ast = get_proc_name(proc_stmt);
    EXTRACT_STRING(pname, proc_name_ast);
    func_name = pname;
    proc_as_func = true;
    dml_proc = is_dml_proc(proc_stmt->sem->sem_type);

    result_set_return = has_out_stmt_result(proc_stmt) || has_result_set(proc_stmt) || has_out_union_stmt_result(proc_stmt);
    out_arg_result = !result_set_return;
  }

  sem_t sem_type_result = ast->sem->sem_type;

  // The answer will be stored in this scratch variable, any type is possible
  CG_SETUP_RESULT_VAR(ast, sem_type_result);
  CHARBUF_OPEN(invocation);
  CG_CHARBUF_OPEN_SYM(func_sym, func_name, result_set_return ? "_fetch_results" : "");
  CG_CHARBUF_OPEN_SYM(result_ref, func_name, "_result_set_ref");
  CHARBUF_OPEN(cleanup);

  if (unchecked_func) {
    // This is a bit tricky.  As always in C output there may be some statements
    // that have to be emitted as part of this expression.  Some expressions in
    // SQL have flow control like CASE/WHEN/THEN/END So in this case we want to
    // call the function and capture its result to do this we have to emit the
    // preparatory statements, then use its invocation as part of an assignment
    // and then, and only then, emit the cleanup for the prep work.  Note that
    // the prep work can assign temporary string variables, commonly in external
    // calls we have to convert to C string.  As always the lua version of this
    // is much simpler.
    CHARBUF_OPEN(prep);
    bprintf(&invocation, "%s(", func_sym.ptr);
    cg_emit_external_arglist(arg_list, &prep, &invocation, &cleanup);
    bprintf(&invocation, ")");
    bprintf(cg_main_output, "%s", prep.ptr);
    CHARBUF_CLOSE(prep);
  }
  else {
    if (dml_proc) {
      bprintf(&invocation, "_rc_ = %s(_db_", func_sym.ptr);
      need_comma = true;
    }
    else {
      bprintf(&invocation, "%s(", func_sym.ptr);
      need_comma = false;
    }

    if (result_set_return) {
      // capture the result var
      if (need_comma) {
        bprintf(&invocation, ", ");
      }

      // the out arg is clobbered by the called function, we have to release it first
      bprintf(cg_main_output, "cql_object_release(%s);\n", result_var.ptr);
      bprintf(cg_main_output, "%s = NULL;\n", result_var.ptr);
      bprintf(&invocation, "(%s *)&%s", result_ref.ptr, result_var.ptr);
      need_comma = true;
    }

    proc_params_info info = {
      .output = &invocation,
      .params = params,
      .arg_list = arg_list,
      .need_comma = need_comma
    };

    // emit provided args, the param specs are needed for possible type conversions
    cg_emit_proc_params(&info);
    need_comma = info.need_comma;
    params = info.params;

    if (params && !info.arg_list) {
      // The only way this happens is when calling a stored proc like a function
      // using the last arg as the return type.
      Invariant(out_arg_result);
      Invariant(!params->right); // exactly one param was missing
      EXTRACT_NOTNULL(param, params->left);
      sem_t param_type = param->sem->sem_type;
      Invariant(is_out_parameter(param_type));
      Invariant(!is_in_parameter(param_type));

      // the result variable is not an in/out arg, it's just a regular local
      // it's otherwise the same as the paramater by consruction
      sem_t arg_type = param_type & sem_not(SEM_TYPE_OUT_PARAMETER|SEM_TYPE_IN_PARAMETER);

      cg_release_out_arg_before_call(arg_type, param_type, result_var.ptr);
      if (need_comma) {
        bprintf(&invocation, ", ");
      }
      bprintf(&invocation, "&%s", result_var.ptr);
    }

    bprintf(&invocation, ")");
  }

  // Now store the result of the call. The only trick here is we have to make
  // sure we honor create semantics otherwise we can just copy the data since
  // the variable is for sure an exact match for the call return by
  // construction.

  if (proc_as_func) {
    // just do the function call, the result variable assignment happens as part of the call
    bprintf(cg_main_output, "%s;\n", invocation.ptr);

    // if rollback fails we still need to release any savepoints, cannot exit to report error
    bool rollback_stmt = is_ast_rollback_trans_stmt(ast) || is_ast_rollback_return_stmt(ast);
    if (dml_proc && !rollback_stmt) {
      // cascade the failure
      cg_error_on_not_sqlite_ok();
    }
  }
  else if (is_create_func(func_stmt->sem->sem_type)) {
    cg_copy_for_create(cg_main_output, result_var.ptr, func_stmt->sem->sem_type, invocation.ptr);
  }
  else {
    cg_copy(cg_main_output, result_var.ptr, func_stmt->sem->sem_type, invocation.ptr);
  }

  // if any cleanup pending, safe to emit now (this is on the unchecked arm)
  bprintf(cg_main_output, "%s", cleanup.ptr);

  CHARBUF_CLOSE(cleanup);
  CHARBUF_CLOSE(result_ref);
  CHARBUF_CLOSE(func_sym);
  CHARBUF_CLOSE(invocation);
  CG_CLEANUP_RESULT_VAR();  // this will restore the scratch stack for us
}

// Forward the call processing to the general helper (with cursor arg)
static void cg_call_stmt(ast_node *ast) {
  // If the call has a result set it is stored in our result parameter just like
  // a loose select statement would be.  Note this can be overridden by a later
  // result which is totally ok.  Same as for select statements.
  cg_call_stmt_with_cursor(ast, NULL);
}

// emit the declarations for anything implicitly declared then do a normal call
static void cg_declare_out_call_stmt(ast_node *ast) {
  Contract(is_ast_declare_out_call_stmt(ast));
  EXTRACT_NOTNULL(call_stmt, ast->left);
  EXTRACT(arg_list, call_stmt->right);

  for (; arg_list; arg_list = arg_list->right) {
    EXTRACT_ANY_NOTNULL(arg, arg_list->left);
    if (arg->sem->sem_type & SEM_TYPE_IMPLICIT) {
      EXTRACT_STRING(var_name, arg);
      cg_declare_simple_var(arg->sem->sem_type, var_name);
    }
  }

  cg_call_stmt(call_stmt);
}

// This helper method walks all the args and all the formal paramaters at the
// same time it gets the appropriate type info for each and then generates the
// expression for the evaluation of that argument.
static void cg_emit_proc_params(proc_params_info *info) {
  // Harvest the input
  ast_node *arg_list = info->arg_list;
  ast_node *params = info->params;
  bool_t need_comma = info->need_comma;
  charbuf *output = info->output;

  for (;arg_list; arg_list = arg_list->right, params = params->right) {
    EXTRACT_ANY_NOTNULL(arg, arg_list->left);
    sem_t sem_type_arg = arg->sem->sem_type;

    EXTRACT_NOTNULL(param, params->left);
    sem_t sem_type_param = param->sem->sem_type;

    if (need_comma) {
      bprintf(output, ", ");
    }

    // note this might require type conversion, handled here.
    cg_emit_one_arg(arg, sem_type_param, sem_type_arg, output);
    need_comma = true;
  }

  // return info so that output can continue in case more is coming normally
  // args and params end at the same time but args can end early in the proc as
  // func case, we generate a temporary out argument as the last arg
  info->need_comma = need_comma;
  info->arg_list = arg_list;
  info->params = params;
}

// A call statement has several varieties:
//  * an external call to an unknown proc
//    * use the external call helper
//  * if the target is a dml proc
//    * add the _db_ argument, for sure we have it because if we call a DML proc
//      we are a DML proc so we, too, had such an arg.  Pass it along.
//    * capture the _rc_ return code and do the error processing.
//  * if the proc returns a relational result (see below) we use the given
//    cursor to capture it, or else we use the functions result argument as
//    indicated below
//
// There are a variety of call forms (we'll see the symmetric version of this in
// cg_create_proc_stmt).  The first thing to consider is, does the procedure
// produce some kind of relational result, there are four ways it can do this:
//
//   1. It returns a statement (it used a loose SELECT)
//   2. It returns a single row (it used OUT)
//   3. It returns a result set (it used OUT UNION)
//   4. It returns no relational result, just out args maybe.
//
//  Now we have to consider this particular call, and the chief question is are
//  we capturing the relational result in a cursor? If we are then referring to
//  the above:
//
//   1a. The cursor will be a statement cursor, holding the SQLite statement
//   2a. The cursor will hold the row, it is a value cursor (you can't step it)
//   3a. The cursor will hold a pointer to the result set which can be indexed
//   4a. A cursor cannot be used if there is no relational result.
//
//  Note that the error case above has already been detected in semantic
//  analysis so we would not be here if it happened.  This is true of the other
//  error cases as well.  If we're doing code-gen we know we're good.
//
//  If the result is not captured in a cursor then we have the following outcomes
//
//  1b. The current procedure returns statement as a relational result
//      (just as though it had done the select)
//  2b. This is not allowed, the row must be captured by a cursor (error).
//  3b. The current procedure returns the result set (just as though it had done
//      the OUT UNION)
//  4b. This is a "normal" function call with just normal arguments
//
// Compounding the above, the procedure might use the database or not.  If it
// uses the database (dml_proc) we have to add that argument and we expect a
// success code. If it doesn't use the database it can still return a relational
// result with OUT or OUT UNION.  It can't have done a SELECT (no database) or
// could it have called a procedure that did a SELECT (again, no database).  So
// the statement cursor case is eliminated. This creates a fairly complex matrix
// but most of the logic is highly similar.
//
// In call cases we can use the arg helper method to emit each arg.  There are
// several rules for each kind of arg, described above in cg_emit_one_arg.
static void cg_call_stmt_with_cursor(ast_node *ast, CSTR cursor_name) {
  Contract(is_ast_call_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY(expr_list, ast->right);

  // check for call to unknown proc, use canonical calling convention for those
  ast_node *proc_stmt = find_proc(name);
  if (!proc_stmt) {
    cg_call_external(ast);
    return;
  }

  ast_node *proc_name_ast = get_proc_name(proc_stmt);
  EXTRACT_STRING(proc_name, proc_name_ast);

  ast_node *params = get_proc_params(proc_stmt);
  bool_t dml_proc = is_dml_proc(proc_stmt->sem->sem_type);
  bool_t result_set_proc = has_result_set(ast);
  bool_t out_stmt_proc = has_out_stmt_result(ast);
  bool_t out_union_proc = has_out_union_stmt_result(ast);

  CSTR fetch_results = out_union_proc ? "_fetch_results" : "";

  CHARBUF_OPEN(invocation);
  CG_CHARBUF_OPEN_SYM(proc_sym, proc_name, fetch_results);
  CG_CHARBUF_OPEN_SYM(result_type, proc_name, "_row");
  CG_CHARBUF_OPEN_SYM(result_sym, proc_name, "_row", "_data");
  CG_CHARBUF_OPEN_SYM(result_set_ref, name, "_result_set_ref");

  // most cases will emit hidden arg, such as the db
  bool_t prefix_args = true;

  if (dml_proc) {
    bprintf(&invocation, "_rc_ = %s(_db_", proc_sym.ptr);
    if (out_union_proc && !cursor_name) {
      // This is case 3b above.  The tricky bit here is that there might be more
      // than one such call.  The callee is not going to release the out arg as
      // it might be junk from the callee's perspective so we have to release it
      // in case this call is in a loop or if this call is repeated in some
      // other way
      bprintf(cg_main_output, "cql_object_release(*_result_set_);\n");
      bprintf(&invocation, ", (%s *)_result_set_", result_set_ref.ptr);
    }
    else if (out_union_proc) {
      // this is case 3a above.
      Invariant(cursor_name); // either specified or the default _result_ variable
      bprintf(&invocation, ", &%s_result_set_", cursor_name);
    }
    else if (result_set_proc && cursor_name == NULL) {
      // This is case 1b above, prop the result as our output.  As with case 3b
      // above we have to pre-release _result_stmt_ because of repetition.
      bprintf(cg_main_output, "cql_finalize_stmt(_result_stmt);\n");
      bprintf(&invocation, ", _result_stmt");
    }
    else if (result_set_proc) {
      // this is case 1a above
      Invariant(cursor_name); // either specified or the default _result_ variable
      bprintf(&invocation, ", &%s_stmt", cursor_name);
    }
  }
  else {
    bprintf(&invocation, "%s(", proc_sym.ptr);
    if (out_union_proc && !cursor_name) {
      // this is 3b again, but with no database arg. As with case
      // 3b above we have to pre-release _result_stmt_ because of repetition.
      bprintf(cg_main_output, "cql_object_release(*_result_set_);\n");
      bprintf(&invocation, "(%s *)_result_set_", result_set_ref.ptr);
    }
    else if (out_union_proc) {
      // this is 3a again, but with no database arg
      Invariant(cursor_name); // either specified or the default _result_ variable
      bprintf(&invocation, "&%s_result_set_", cursor_name);
    }
    else {
      // no prefix args were emitted (case 4b, with no DML)
      prefix_args = false;
    }
  }

  // if we emitted something (most cases) and there are args, we need a comma now
  if (prefix_args && expr_list) {
    bprintf(&invocation, ", ");
  }

  // we don't need to manage the stack, we're always called at the top level
  // we're wiping it when we exit this function anyway
  Invariant(stack_level == 0);

  proc_params_info info = {
    .output = &invocation,
    .params = params,
    .arg_list = expr_list,
    .need_comma = false
  };

  // emit provided args, the param specs are needed for possible type conversions
  cg_emit_proc_params(&info);

  // For a fetch results proc we have to add the out argument here.
  // Declare that variable if needed.
  if (out_stmt_proc) {
    // this is case 2a above
    Invariant(cursor_name);  // this would be 2b, not allowed(!)
    if (dml_proc || params) {
      bprintf(&invocation, ", ");
    }
    bprintf(cg_main_output, "cql_teardown_row(%s);\n", cursor_name);
    bprintf(&invocation, "(%s *)&%s", result_type.ptr, cursor_name);
    bprintf(&invocation, "); // %s identical to cursor type\n", result_type.ptr);
  }
  else {
    bprintf(&invocation, ");\n");
  }

  bprintf(cg_main_output, "%s", invocation.ptr);

  if (out_union_proc && cursor_name) {
    // case 3a, capturing the cursor, we set the row index to -1 (it will be pre-incremented)
    bprintf(cg_main_output, "%s_row_num_ = %s_row_count_ = -1;\n", cursor_name, cursor_name);
  }

  // if rollback fails we still need to release any savepoints, cannot exit to report error
  bool rollback_stmt = is_ast_rollback_trans_stmt(ast) || is_ast_rollback_return_stmt(ast);
  if (dml_proc && !rollback_stmt) {
    // if there is an error code, check it, and cascade the failure
    cg_error_on_not_sqlite_ok();
  }

  if (out_union_proc && cursor_name) {
    // case 3a again
    bprintf(cg_main_output, "%s_row_count_ = cql_result_set_get_count((cql_result_set_ref)%s_result_set_);\n",
      cursor_name, cursor_name);
  }

  CHARBUF_CLOSE(result_set_ref);
  CHARBUF_CLOSE(result_sym);
  CHARBUF_CLOSE(result_type);
  CHARBUF_CLOSE(proc_sym);
  CHARBUF_CLOSE(invocation);
}

// Straight up DDL invocation.  The ast has the statement, execute it! We don't
// minify the aliases because DDL can have views and the view column names can
// be referred to in users of the view.  Loose select statements can have no
// external references to column aliases.
static void cg_any_ddl_stmt(ast_node *ast) {
  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_NO_MINIFY_ALIASES);
}

static void cg_std_dml_exec_stmt(ast_node *ast) {
  // Straight up DML invocation.  The ast has the statement, execute it!
  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);
}

// DML with PREPARE.  The ast has the statement. Note: _result_ is the output
// variable for the sqlite3_stmt we generate this was previously added when the
// stored proc params were generated.
static void cg_std_dml_prep_stmt(ast_node *ast) {
  Contract(is_row_source(ast));
  cg_bound_sql_statement("_result", ast, CG_PREPARE|CG_MINIFY_ALIASES);
}

// Declares the shared _seed_ variable if needed and then loads it from the
// indicated expression.
static void cg_insert_dummy_spec(ast_node *ast) {
  EXTRACT_ANY_NOTNULL(expr, ast->left); // the seed expr

  CSTR name = "_seed_";

  sem_t sem_type_var = SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL;
  sem_t sem_type_expr = expr->sem->sem_type;

  if (!seed_declared) {
    cg_var_decl(cg_declarations_output, sem_type_var, name, CG_VAR_DECL_FULL);
    seed_declared = true;
  }

  CG_PUSH_EVAL(expr, C_EXPR_PRI_ASSIGN);
  cg_store(cg_main_output, name, sem_type_var, sem_type_expr, expr_is_null.ptr, expr_value.ptr);
  CG_POP_EVAL(expr);
}

// set up the seed variable for dummy data if the relevant node is present
static void cg_opt_seed_process(ast_node *ast) {
  Contract(is_ast_insert_stmt(ast));
  EXTRACT_ANY_NOTNULL(insert_type, ast->left);
  EXTRACT_ANY(insert_dummy_spec, insert_type->left);

  if (insert_dummy_spec) {
    cg_insert_dummy_spec(insert_dummy_spec);
  }
}

// DML invocation but first set the seed variable if present
static void cg_insert_stmt(ast_node *ast) {
  Contract(is_ast_insert_stmt(ast));

  cg_opt_seed_process(ast);
  cg_bound_sql_statement(NULL, ast, CG_EXEC | CG_NO_MINIFY_ALIASES);
}

// DML invocation but first set the seed variable if present
static void cg_with_insert_stmt(ast_node *ast) {
  Contract(is_ast_with_insert_stmt(ast));
  EXTRACT_NOTNULL(insert_stmt, ast->right);
  cg_opt_seed_process(insert_stmt);
  cg_bound_sql_statement(NULL, ast, CG_EXEC | CG_NO_MINIFY_ALIASES);
}

// DML invocation but first set the seed variable if present
static void cg_insert_returning_stmt(ast_node *ast) {
  Contract(is_ast_insert_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(inner, ast->left);
  inner = is_ast_with_insert_stmt(inner) ? inner->right : inner;
  Contract(is_ast_insert_stmt(inner));
  cg_opt_seed_process(inner);
  cg_bound_sql_statement("_result", ast, CG_PREPARE|CG_NO_MINIFY_ALIASES);
}

// DML invocation but first set the seed variable if present
static void cg_with_upsert_stmt(ast_node *ast) {
  Contract(is_ast_with_upsert_stmt(ast));
  EXTRACT_NOTNULL(upsert_stmt, ast->right);
  EXTRACT_NOTNULL(insert_stmt, upsert_stmt->left);
  cg_opt_seed_process(insert_stmt);
  cg_bound_sql_statement(NULL, ast, CG_EXEC | CG_NO_MINIFY_ALIASES);
}

// DML invocation but first set the seed variable if present
static void cg_upsert_stmt(ast_node *ast) {
  Contract(is_ast_upsert_stmt(ast));
  EXTRACT_NOTNULL(insert_stmt, ast->left);

  cg_opt_seed_process(insert_stmt);
  cg_bound_sql_statement(NULL, ast, CG_EXEC | CG_NO_MINIFY_ALIASES);
}

// Very little magic is needed to do try/catch in our context.  The error
// handlers for all the sqlite calls check _rc_ and if it's an error they "goto"
// the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.
// Inside the try block, the cleanup handler is changed to the catch block. The
// catch block puts it back.  Otherwise, generate nested statements as usual.
static void cg_trycatch_helper(ast_node *try_list, ast_node *try_extras, ast_node *catch_list) {
  CHARBUF_OPEN(catch_start);
  CHARBUF_OPEN(catch_end);

  // We need unique labels for this block
  ++catch_block_count;
  bprintf(&catch_start, "catch_start_%d", catch_block_count);
  bprintf(&catch_end, "catch_end_%d", catch_block_count);

  // Divert the error target.
  CSTR saved_error_target = error_target;
  bool_t saved_error_target_used = error_target_used;
  error_target = catch_start.ptr;
  error_target_used = false;

  // Emit the try code.
  bprintf(cg_main_output, "// try\n{\n");

  cg_stmt_list(try_list);

  if (try_extras) {
    cg_stmt_list(try_extras);
  }

  // If we get to the end, skip the catch block.
  bprintf(cg_main_output, "  goto %s;\n}\n", catch_end.ptr);

  // Emit the catch code, with labels at the start and the end.
  if (error_target_used) {
    bprintf(cg_main_output, "%s: ", catch_start.ptr);
  }

  // Restore the error target, the catch block runs with the old error target
  error_target = saved_error_target;
  error_target_used = saved_error_target_used;
  CSTR rcthrown_saved = rcthrown_current;

  bprintf(cg_main_output, "{\n");

  CHARBUF_OPEN(rcthrown);

  bprintf(&rcthrown, "_rc_thrown_%d", ++rcthrown_index);
  rcthrown_current = rcthrown.ptr;
  bool_t rcthrown_used_saved = rcthrown_used;
  rcthrown_used = false;

  CHARBUF_OPEN(catch_block);
    charbuf *main_saved = cg_main_output;
    cg_main_output = &catch_block;

    cg_stmt_list(catch_list);

    cg_main_output = main_saved;

    if (rcthrown_used) {
      bprintf(cg_main_output, "  int32_t %s = _rc_;\n", rcthrown.ptr);
    }

    bprintf(cg_main_output, "%s", catch_block.ptr);

  CHARBUF_CLOSE(catch_block);

  rcthrown_current = rcthrown_saved;
  rcthrown_used = rcthrown_used_saved;

  bprintf(cg_main_output, "}\n%s:;\n", catch_end.ptr);

  CHARBUF_CLOSE(rcthrown);
  CHARBUF_CLOSE(catch_end);
  CHARBUF_CLOSE(catch_start);
}

// the helper does all the work, see those notes
static void cg_trycatch_stmt(ast_node *ast) {
  Contract(is_ast_trycatch_stmt(ast));
  EXTRACT_NAMED(try_list, stmt_list, ast->left);
  EXTRACT_NAMED(catch_list, stmt_list, ast->right);

  cg_trycatch_helper(try_list, NULL, catch_list);
}

// this is just a special try/catch
static void cg_proc_savepoint_stmt(ast_node *ast) {
  Contract(is_ast_proc_savepoint_stmt(ast));
  EXTRACT(stmt_list, ast->left);

  if (stmt_list) {
    AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
    ast_node *savepoint = new_ast_savepoint_stmt(new_ast_str(current_proc_name()));
    ast_node *release1  = new_ast_release_savepoint_stmt(new_ast_str(current_proc_name()));
    ast_node *release2  = new_ast_release_savepoint_stmt(new_ast_str(current_proc_name()));
    ast_node *rollback  = new_ast_rollback_trans_stmt(new_ast_str(current_proc_name()));
    ast_node *try_extra_stmts = new_ast_stmt_list(release1, NULL);
    ast_node *throw_stmt = new_ast_throw_stmt();
    ast_node *catch_stmts =
      new_ast_stmt_list(rollback,
      new_ast_stmt_list(release2,
      new_ast_stmt_list(throw_stmt, NULL)));
    AST_REWRITE_INFO_RESET();
    cg_bound_sql_statement(NULL, savepoint, CG_EXEC);
    cg_trycatch_helper(stmt_list, try_extra_stmts, catch_stmts);
  }
}

// Convert _rc_ into an error code.  If it already is one keep it. Then go to
// the current error target.
static void cg_throw_stmt(ast_node *ast) {
  Contract(is_ast_throw_stmt(ast));

  bprintf(cg_main_output, "_rc_ = cql_best_error(%s);\n", rcthrown_current);
  bprintf(cg_main_output, "cql_error_trace();\n");
  bprintf(cg_main_output, "goto %s;\n", error_target);
  error_target_used = true;
  rcthrown_used = true;
}

// Dispatch to one of the statement helpers using the symbol table. There are
// special rules for the DDL methods. If they appear in a global context
// (outside of any stored proc) they do not run, they are considered
// declarations only.
static void cg_one_stmt(ast_node *stmt, ast_node *misc_attrs) {
  // reset the temp stack
  stack_level = 0;

  symtab_entry *entry = symtab_find(cg_stmts, stmt->type);
  Contract(entry);

  if (!in_proc) {
    // DDL operations not in a procedure are ignored
    // but they can declare schema during the semantic pass
    if (entry->val == cg_any_ddl_stmt) {
       return;
    }

    // loose select statements also have no codegen, the global proc has no result type
    // todo what to do about insert returning here?  We have to ignore the returning part
    if (is_select_variant(stmt)) {
       return;
    }
  }


  // don't emit a # line directive for the echo statement because it would be messed
  // up if the echo doesn't end in a linefeed and that's legal.  And there is
  // normally no visible code for these things anyway.

  bool_t suppress_line_directive = is_ast_echo_stmt(stmt);

  // The declare group statement generates no real code and does not want to
  // contribute to the global proc by emitting a line directive...
  suppress_line_directive |= is_ast_declare_group_stmt(stmt) || is_ast_emit_group_stmt(stmt) || in_var_group_decl || in_var_group_emit || is_ast_ifdef_stmt(stmt) || is_ast_ifndef_stmt(stmt);

  if (!suppress_line_directive) {
    charbuf *line_out = (stmt_nesting_level == 1) ? cg_declarations_output : cg_main_output;
    cg_line_directive_min(stmt, line_out);
  }

  CHARBUF_OPEN(tmp_header);
  CHARBUF_OPEN(tmp_declarations);
  CHARBUF_OPEN(tmp_main);
  CHARBUF_OPEN(tmp_scratch);

  charbuf *header_saved = cg_header_output;
  charbuf *declarations_saved = cg_declarations_output;
  charbuf *main_saved = cg_main_output;
  charbuf *scratch_saved = cg_scratch_vars_output;

  // Redirect all output to the temporary buffers so we can see how big it is
  // The comments need to go before this, so we save the output then check it
  // then emit the generated code.

  cg_main_output = &tmp_main;
  cg_declarations_output = &tmp_declarations;
  cg_header_output = &tmp_header;
  cg_scratch_vars_output = &tmp_scratch;

  // These are all the statements there are, we have to find it in this table
  // or else someone added a new statement and it isn't supported yet.
  Invariant(entry);
  ((void (*)(ast_node*))entry->val)(stmt);

  // safe to put it back now
  cg_main_output = main_saved;
  cg_header_output = header_saved;
  cg_declarations_output = declarations_saved;
  cg_scratch_vars_output = scratch_saved;

  // Emit a helpful comment for top level statements.
  if (stmt_nesting_level == 1) {
    charbuf *out = cg_main_output;
    if (is_ast_declare_vars_type(stmt) || is_proc(stmt) || is_ast_echo_stmt(stmt)) {
      out = cg_declarations_output;
    }

    // Don't contaminate echo output with comments except in test, where we need
    // it for verification
    bool_t skip_comment = !options.test && suppress_line_directive;

    // If no code gen in the main buffer, don't add a comment, that will force a
    // global proc We used to have all kinds of special cases to detect the
    // statements that don't generate code and that was a bug farm.  So now
    // instead we just look to see if it made code.  If it didn't make code we
    // will not force the global proc to exist because of the stupid comment...
    skip_comment |= (out == cg_main_output && tmp_main.used == 1);

    // put a line marker in the header file in case we want a test suite that verifies that
    if (options.test) {
      bprintf(cg_header_output, "\n// The statement ending at line %d\n", stmt->lineno);
    }

    // Emit comments for most statements: we do not want to require the global
    // proc block just because there was a comment so this is suppressed for "no
    // code" things.
    if (!skip_comment) {
      if (options.test) {
        bprintf(out, "\n// The statement ending at line %d\n", stmt->lineno);
      }
      else {
        bprintf(cg_header_output, "\n// Generated from %s:%d\n", stmt->filename, stmt->lineno);
        bprintf(cg_declarations_output, "\n// Generated from %s:%d\n", stmt->filename, stmt->lineno);
      }
      // emit source comment
      bprintf(out, "\n/*\n");
      CHARBUF_OPEN(tmp);
      gen_stmt_level = 1;
      gen_set_output_buffer(&tmp);
      if (misc_attrs) {
        gen_misc_attrs(misc_attrs);
      }
      gen_one_stmt(stmt);
      // internal "*/" is fatal. "/*" can also be under certain compilation flags
      cg_remove_slash_star_and_star_slash(&tmp);
      bprintf(out, "%s", tmp.ptr);
      CHARBUF_CLOSE(tmp);
      bprintf(out, ";\n*/\n");
    }
  }

  // and finally write what we saved
  bprintf(cg_main_output, "%s", tmp_main.ptr);
  bprintf(cg_header_output, "%s", tmp_header.ptr);
  bprintf(cg_scratch_vars_output, "%s", tmp_scratch.ptr);
  bprintf(cg_declarations_output, "%s", tmp_declarations.ptr);

  CHARBUF_CLOSE(tmp_scratch);
  CHARBUF_CLOSE(tmp_main);
  CHARBUF_CLOSE(tmp_declarations);
  CHARBUF_CLOSE(tmp_header);
}

// Emit the nested statements with one more level of indenting.
static void cg_stmt_list(ast_node *head) {
  if (!head) {
    return;
  }

  stmt_nesting_level++;

  charbuf *saved_main = cg_main_output;
  CHARBUF_OPEN(temp);
  cg_main_output = &temp;

  // Check to see if the block starts with a sequence of DDL/DML, if it does we
  // can execute it in one go; this saves us a lot of error checking code at the
  // expense of less precise error tracing.

  if (in_proc && options.compress) {
    ast_node *ast = head;
    ast_node *prev = head;
    for (; ast; ast = ast->right) {
      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);

      symtab_entry *entry = symtab_find(cg_stmts, stmt->type);
      Contract(entry);

      if (entry->val != cg_any_ddl_stmt && entry->val != cg_std_dml_exec_stmt) {
        break;
      }
      prev = ast;
    }

    // try to run the first statements of the statement list in bulk but only do
    // this if we found at least 2 statements that match
    if (ast != head && ast != head->right) {
      ast_node *new_head = ast;

      // temporarily nix the tail of the statement list
      prev->right = NULL;

      // we can't do this if any of the statements require variable binding
      if (cg_verify_unbound_stmt(head)) {
        // unbound batch, we can do this
        cg_bound_sql_statement(NULL, head, CG_EXEC|CG_NO_MINIFY_ALIASES);

        // now skip this batch, we already emitted them all in one go
        head = new_head;
      }

      // repair the statement list back to normal
      prev->right = new_head;
    }
  }

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);
    cg_one_stmt(stmt, misc_attrs);
  }

  cg_main_output = saved_main;
  bindent(cg_main_output, &temp, 2);
  CHARBUF_CLOSE(temp);

  stmt_nesting_level--;
}

// Here we generate the type constant for the column The type must be one of the
// types that we can fetch from SQLite so that means not a struct, not the null
// type (the null type is reserved for the literal NULL, it's not a storage
// class) and certainly nothing that is a struct or sentinel type.  Likewise
// objects cannot be the result of a select, so that's out too.
static void cg_data_type(charbuf *output, sem_t sem_type) {
  Contract(is_unitary(sem_type));
  Contract(!is_null_type(sem_type));

  sem_t core_type = core_type_of(sem_type);

  switch (core_type) {
    case SEM_TYPE_INTEGER:
      bprintf(output, "CQL_DATA_TYPE_INT32");
      break;
    case SEM_TYPE_LONG_INTEGER:
      bprintf(output, "CQL_DATA_TYPE_INT64");
      break;
    case SEM_TYPE_REAL:
      bprintf(output, "CQL_DATA_TYPE_DOUBLE");
      break;
    case SEM_TYPE_BOOL:
      bprintf(output, "CQL_DATA_TYPE_BOOL");
      break;
    case SEM_TYPE_TEXT:
      bprintf(output, "CQL_DATA_TYPE_STRING");
      break;
    case SEM_TYPE_BLOB:
      bprintf(output, "CQL_DATA_TYPE_BLOB");
      break;
    case SEM_TYPE_OBJECT:
      bprintf(output, "CQL_DATA_TYPE_OBJECT");
      break;
  }
  if (is_not_nullable(sem_type)) {
    bprintf(output, " | CQL_DATA_TYPE_NOT_NULL");
  }
}

// All the data you need to make a getter or setter... there's a lot of it and
// most of it is the same for all cases
typedef struct function_info {
  CSTR name;
  CSTR col;
  int32_t col_index;
  charbuf *defs;
  charbuf *headers;
  bool_t uses_out;
  sem_t ret_type;
  CSTR ret_kind;
  sem_t name_type;
  CSTR result_set_ref_type;
  CSTR row_struct_type;
  CSTR sym_suffix;
  CSTR value_suffix;
} function_info;

// The inlineable version of the getter can be generated instead of the opened
// coded version as above This type inlines well because it uses a small number
// of standard helpers to do the fetching. The situation is not so different
// from the original open coded case above. This code mirrors
// cg_proc_result_set_getter
// * First we need to compute the name of the getter, it's fairly simple coming
//   from the name of the procedure that had the select and the field name that
//   we are getting.
// * Second we emit the body of the getter there's a few cases here
//   * for fragments, we don't do our own getting, the master assembled query
//     knows all the pieces so we delegate to it;  but we need to emit a
//     declaration for the getter in the master query
//   * for normal rowsets it's something like
//     cql_result_set_get_bool(result_set, row, column)
//   * for single row result sets it's just cql_result_set_get_bool(result_set,
//     0, column)
static void cg_proc_result_set_type_based_getter(function_info *_Nonnull info)
{
  charbuf *h = info->headers;
  charbuf *out = NULL;

  CG_CHARBUF_OPEN_SYM_WITH_PREFIX(
    col_getter_sym,
    rt->symbol_prefix,
    info->name,
    "_get_",
    info->col,
    info->sym_suffix);

  CHARBUF_OPEN(func_decl);
  cg_col_reader_type(&func_decl, info->ret_type, info->ret_kind, col_getter_sym.ptr);
  bprintf(&func_decl, "(%s _Nonnull result_set", info->result_set_ref_type);

  // a procedure that uses OUT gives exactly one row, so no index in the API
  if (!info->uses_out) {
    bprintf(&func_decl, ", cql_int32 row");
  }
  bprintf(&func_decl, ")");

  CSTR row = info->uses_out ? "0" : "row";

  // not set yet
  Invariant(!out);

  // The inline body will all go into the header file in the normal case. Note:
  // it's ok for these to be static inline because they have a different name
  bprintf(h, "#ifndef _%s_inline_\n", col_getter_sym.ptr);
  bprintf(h, "#define _%s_inline_\n\n", col_getter_sym.ptr);
  bprintf(h, "\nstatic inline %s {\n", func_decl.ptr);
  out = h;

  // definitely set now
  Invariant(out);

  bprintf(out, "  return ");

  // cast the data type in the buffer to the correct result type
  CSTR trailing_string = "";

  if (is_result_set_type(info->ret_type, info->ret_kind)) {
    bprintf(out, "(");
    cg_result_set_type_from_kind(out, info->ret_type, info->ret_kind);
    bprintf(out, ")(");
    trailing_string = ")";
  }

  if (is_ref_type(info->name_type) && is_nullable(info->ret_type)) {
    bprintf(out,
      "cql_result_set_get_is_null_col((cql_result_set_ref)result_set, %s, %d) ? NULL : ",
      row,
      info->col_index);
  }

  switch (info->name_type) {
    case SEM_TYPE_NULL:
      bprintf(out, "cql_result_set_get_is_null_col");
      break;
    case SEM_TYPE_BOOL:
      bprintf(out, "cql_result_set_get_bool_col");
      break;
    case SEM_TYPE_REAL:
      bprintf(out, "cql_result_set_get_double_col");
      break;
    case SEM_TYPE_INTEGER:
      bprintf(out, "cql_result_set_get_int32_col");
      break;
    case SEM_TYPE_LONG_INTEGER:
      bprintf(out, "cql_result_set_get_int64_col");
      break;
    case SEM_TYPE_TEXT:
      bprintf(out, "cql_result_set_get_string_col");
      break;
    case SEM_TYPE_BLOB:
      bprintf(out, "cql_result_set_get_blob_col");
      break;
    case SEM_TYPE_OBJECT:
      bprintf(out, "cql_result_set_get_object_col");
      break;
  }
  bprintf(out, "((cql_result_set_ref)result_set, %s, %d)%s;\n", row, info->col_index, trailing_string);
  bprintf(out, "}\n");
  bprintf(h, "\n#endif\n\n");

  CHARBUF_CLOSE(func_decl);
  CHARBUF_CLOSE(col_getter_sym);
}

#define DO_EMIT_SET_NULL true
#define DONT_EMIT_SET_NULL false

// This function generate a inline or export version of a setter by using the
// function_info passed in
//  1) We need to compute the name of the setter and also its visibility
//  2) We check if the function is setnull type using is_set_null parameter and if true we emit new typed
//      temp new_value_ var and we emit cql_set_null(new_value_), if is not a setnull funtion we emit a
//      cql_set_notnull(new_value_, new_value). We do this only for types
//        - cql_nullable_bool
//        - cql_nullable_double
//        - cql_nullable_int32
//        - cql_nullable_int64
//      otherwize we skip this step.
//  3) Using the correct resultset setter we emit the final set to mutate the resultset: cql_result_set_set_<type>
//
// Examples:
//
// using is_set_null = false.
// extern void query_set_x(query_result_set_ref _Nonnull result_set, cql_int32 new_value) {
//  cql_nullable_int32 new_value_;
//  cql_set_notnull(new_value_, new_value);
//  cql_result_set_set_int32_col((cql_result_set_ref)result_set, 0, 2, new_value_);
// }
//
// using is_set_null = true.
// extern void query_set_x_to_null(query_result_set_ref _Nonnull result_set) {
//  cql_nullable_int32 new_value_;
//  cql_set_null(new_value_);
//  cql_result_set_set_int32_col((cql_result_set_ref)result_set, 0, 2, new_value_);
// }
static void cg_proc_result_set_setter(function_info *_Nonnull info, bool_t is_set_null) {
  charbuf *out = info->headers;

  CG_CHARBUF_OPEN_SYM_WITH_PREFIX(
    col_getter_sym,
    rt->symbol_prefix,
    info->name,
    "_set_",
    info->col,
    info->sym_suffix);

  CHARBUF_OPEN(var_decl);

  if (!is_set_null) {
    cg_col_reader_type(&var_decl, info->ret_type, info->ret_kind, "new_value");
  }

  CHARBUF_OPEN(func_decl);

  bprintf(&func_decl, "#ifndef _%s_inline_\n", col_getter_sym.ptr);
  bprintf(&func_decl, "#define _%s_inline_\n\n", col_getter_sym.ptr);
  bprintf(&func_decl, "static inline void %s", col_getter_sym.ptr);
  bprintf(&func_decl, "(%s _Nonnull result_set", info->result_set_ref_type);

  // a procedure that uses OUT gives exactly one row, so no index in the API
  if (!info->uses_out) {
    bprintf(&func_decl, ", cql_int32 row");
  }

  if (is_set_null) {
    bprintf(out, "\n%s) {\n", func_decl.ptr);
  }
  else {
    bprintf(out, "\n%s, %s) {\n", func_decl.ptr, var_decl.ptr);
  }

  CSTR row = info->uses_out ? "0" : "row";
  bool_t is_ref = is_ref_type(info->name_type);
  if (is_ref && is_not_nullable(info->ret_type)) {
    bprintf(out, "  cql_contract_argument_notnull((void *)new_value, 2);\n");
  }

  if (is_set_null) {
    bprintf(out, "  cql_result_set_set_to_null_col((cql_result_set_ref)result_set, %s, %d);\n", row, info->col_index);
  }
  else {
    switch (info->name_type) {
      case SEM_TYPE_BOOL:
        bprintf(out, "  cql_result_set_set_bool_col");
        break;
      case SEM_TYPE_REAL:
        bprintf(out, "  cql_result_set_set_double_col");
        break;
      case SEM_TYPE_INTEGER:
        bprintf(out, "  cql_result_set_set_int32_col");
        break;
      case SEM_TYPE_LONG_INTEGER:
        bprintf(out, "  cql_result_set_set_int64_col");
        break;
      case SEM_TYPE_TEXT:
        bprintf(out, "  cql_result_set_set_string_col");
        break;
      case SEM_TYPE_BLOB:
        bprintf(out, "  cql_result_set_set_blob_col");
        break;
      case SEM_TYPE_OBJECT:
        bprintf(out, "  cql_result_set_set_object_col");
        break;
    }

    CHARBUF_OPEN(new_value_expr);

    if (is_result_set_type(info->ret_type, info->ret_kind)) {
      // the object setter takes a generic object type, so add the cast, this
      // way all the callers don't have to
      bprintf(&new_value_expr, "(cql_object_ref)");
    }

    bprintf(&new_value_expr, "new_value");

    bprintf(out, "((cql_result_set_ref)result_set, %s, %d, %s);\n", row, info->col_index, new_value_expr.ptr);

    CHARBUF_CLOSE(new_value_expr);
  }

  bprintf(out, "}\n");
  bprintf(out, "\n#endif\n");

  CHARBUF_CLOSE(func_decl);
  CHARBUF_CLOSE(var_decl);
  CHARBUF_CLOSE(col_getter_sym);
}

// Write out the autodrop info into the stream.
static void cg_one_autodrop(CSTR _Nonnull name, ast_node *_Nonnull misc_attr_value, void *_Nullable context) {
  Invariant(context);
  charbuf *output = (charbuf *)context;
  bprintf(output, "%s\\0", name);
}

// If a stored proc is marked with the autodrop annotation when we automatically
// drop the indicated tables when the proc is finished running.  The attributes
// should look like this:
// [[autodrop=(table1, table2, ,...)]]
static void cg_autodrops(ast_node *misc_attrs, charbuf *output) {
  if (!misc_attrs) {
     return;
  }
  CHARBUF_OPEN(temp);
    find_autodrops(misc_attrs, cg_one_autodrop, &temp);
    if (temp.used > 1) {
      bprintf(output, "    .autodrop_tables = \"%s\",\n", temp.ptr);
    }
  CHARBUF_CLOSE(temp);
}

typedef struct fetch_result_info {
  CSTR data_types_sym;
  CSTR col_offsets_sym;
  CSTR refs_offset_sym;
  CSTR identity_columns_sym;
  CSTR row_sym;
  CSTR proc_sym;
  CSTR perf_index;
  ast_node *misc_attrs;
  int32_t refs_count;
  bool_t has_identity_columns;
  bool_t dml_proc;
  bool_t use_stmt;
  int32_t indent;
  CSTR prefix;
} fetch_result_info;

// This generates the cql_fetch_info structure for the various output flavors
// there is some variability here and so it's useful to consolidate the logic.
// The factors are:
//   * if this is not a DML proc then there's no DB and no return code
//   * if there is no statement it means we're returning from a value cursor
//     (which implies the above, too)
//   * we may or may not have references in the data type, so we include those
//     if needed
//   * likewise identity columns
//   * the autodrops helper itself tests for the presence of the attribute in
//     the correct form
//
// The above represents the runtime cql_fetch_info struct that will be used to
// either fetch all rows or else fetch a single row from a given buffer.  Either
// way, the metadata is assembled here for use at runtime.
//
// Other fields are not conditional.
static void cg_fetch_info(fetch_result_info *info, charbuf *output)
{
  CHARBUF_OPEN(tmp);
    if (info->prefix) {
      bprintf(&tmp, "cql_fetch_info %s_info = {\n", info->prefix);
    }
    else {
      bprintf(&tmp, "cql_fetch_info info = {\n");
    }
    if (info->dml_proc) {
      bprintf(&tmp, "  .rc = rc,\n");
      bprintf(&tmp, "  .db = _db_,\n");
    }
    else {
      bprintf(&tmp, "  .rc = SQLITE_OK,\n"); // this case can't fail, there are no db ops
    }
    if (info->use_stmt) {
      bprintf(&tmp, "  .stmt = stmt,\n");
    }
    bprintf(&tmp, "  .data_types = %s,\n", info->data_types_sym);
    bprintf(&tmp, "  .col_offsets = %s,\n", info->col_offsets_sym);
    if (info->refs_count) {
      bprintf(&tmp, "  .refs_count = %d,\n", info->refs_count);
      bprintf(&tmp, "  .refs_offset = %s,\n", info->refs_offset_sym);
    }
    if (info->has_identity_columns) {
      bprintf(&tmp, "  .identity_columns = %s,\n", info->identity_columns_sym);
    }
    bprintf(&tmp, "  .rowsize = sizeof(%s),\n", info->row_sym);
    bprintf(&tmp, "  .crc = CRC_%s,\n", info->proc_sym);
    bprintf(&tmp, "  .perf_index = &%s,\n", info->perf_index);

    cg_autodrops(info->misc_attrs, &tmp);

    bprintf(&tmp, "};\n");
  bindent(output, &tmp,  info->indent);
  CHARBUF_CLOSE(tmp);
}

// If a stored procedure generates a result set then we need to do some extra
// work to create the C friendly rowset creating and accessing helpers.  If
// stored proc "foo" creates a row set then we need to:
//  * emit a struct "foo_row" that has the shape of each row
//    * this isn't used by the client code but we use it in our code-gen
//  * emit a function "foo_fetch_results" that will call "foo" and read the rows
//    from the statement created by "foo".
//    * this method will construct a result set object via cql_result_create and
//      store the data
//    * the remaining functions use cql_result_set_get_data and _get_count to
//      get the data back out
//  * for each named column emit a function "foo_get_[column-name]" which gets
//    that column out of the rowset for the indicated row number.
//  * prototypes for the above go into the main output header file
static void cg_proc_result_set(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  Contract(is_struct(ast->sem->sem_type));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT_STRING(name, ast->left);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  bool_t suppress_result_set = is_proc_suppress_result_set(ast);
  bool_t is_private = is_proc_private(ast);

  bool_t uses_out_union = has_out_union_stmt_result(ast);

  if (!uses_out_union && (suppress_result_set || is_private)) {
    return;
  }

  bool_t uses_out = has_out_stmt_result(ast);
  bool_t result_set_proc = has_result_set(ast);

  // exactly one of these
  Invariant(uses_out + uses_out_union + result_set_proc == 1);

  bool_t dml_proc = is_dml_proc(ast->sem->sem_type);

  // register the proc name if there is a callback, the particular result type
  // will do whatever it wants
  if (rt->register_proc_name) rt->register_proc_name(name);

  charbuf *h = cg_header_output;
  charbuf *d = cg_declarations_output;

  CSTR result_set_name = name;

  CHARBUF_OPEN(data_types);
  CHARBUF_OPEN(result_set_create);
  CHARBUF_OPEN(temp);
  CG_CHARBUF_OPEN_SYM(getter_prefix, name);
  CG_CHARBUF_OPEN_SYM(stored_proc_name_sym, name, "_stored_procedure_name");
  CG_CHARBUF_OPEN_SYM(result_set_sym, result_set_name, "_result_set");
  CG_CHARBUF_OPEN_SYM(result_set_ref, result_set_name, "_result_set_ref");
  CG_CHARBUF_OPEN_SYM(proc_sym, name);
  CG_CHARBUF_OPEN_SYM(row_sym, name, "_row");
  CG_CHARBUF_OPEN_SYM(data_types_sym, name, "_data_types");
  CG_CHARBUF_OPEN_SYM(data_types_count_sym, name, "_data_types_count");
  CG_CHARBUF_OPEN_SYM(col_offsets_sym, name, "_col_offsets");
  CG_CHARBUF_OPEN_SYM(refs_offset_sym, name, "_refs_offset");
  CG_CHARBUF_OPEN_SYM(identity_columns_sym, name, "_identity_columns");
  CG_CHARBUF_OPEN_SYM(result_count_sym, name, "_result_count");
  CG_CHARBUF_OPEN_SYM(fetch_results_sym, name, "_fetch_results");
  CG_CHARBUF_OPEN_SYM(copy_sym, name, "_copy");
  CG_CHARBUF_OPEN_SYM(perf_index, name, "_perf_index");

  sem_struct *sptr = ast->sem->sptr;
  uint32_t count = sptr->count;

  // setting up perf index
  bprintf(h, "#define CRC_%s %lldL\n", proc_sym.ptr, (llint_t)crc_charbuf(&proc_sym));

  bprintf(d, "static int32_t %s;\n", perf_index.ptr);

  bprintf(h, "\n%s", rt->symbol_visibility);
  bprintf(h, "cql_string_ref _Nonnull %s;\n", stored_proc_name_sym.ptr);
  bprintf(d, "\ncql_string_proc_name(%s, \"%s\");\n", stored_proc_name_sym.ptr, name);

  if (result_set_proc) {
    // First build the struct we need
    // As we walk the fields, construct the teardown operation needed
    // to clean up that field and save it.
    bprintf(d, "\ntypedef struct %s {\n", row_sym.ptr);
    cg_fields_in_canonical_order(d, sptr);
    bprintf(d, "} %s;\n", row_sym.ptr);
  }

  bprintf(h, "\n#define %s %d\n", data_types_count_sym.ptr, count);
  bprintf(&data_types,
          "\nuint8_t %s[%s] = {\n",
          data_types_sym.ptr,
          data_types_count_sym.ptr);

  // we always use typed getters, setup the function tables.
  bprintf(h,
    "\n%suint8_t %s[%s];\n",
    rt->symbol_visibility,
    data_types_sym.ptr,
    data_types_count_sym.ptr);

  bprintf(h, "\n");

  if (!is_proc_shared_fragment(ast)) {
     cg_result_set_type_decl(h, result_set_sym.ptr, result_set_ref.ptr);
  }

  // we may not want the getters, at all.
  //  * suppress_getters explicitly specified
  //  * private implies suppress result set s
  //  * suppress result set implies suppress getters
  bool_t suppress_getters = is_proc_suppress_getters(ast) || is_private || suppress_result_set;

  // we may want the setters.
  bool_t emit_setters = is_proc_emit_setters(ast);

  // For each field emit the _get_field method
  for (uint32_t i = 0; i < count; i++) {
    sem_t sem_type = sptr->semtypes[i];
    CSTR col = sptr->names[i];
    CSTR kind = sptr->kinds[i];

    bprintf(&data_types, "  ");
    cg_data_type(&data_types, sem_type);
    bprintf(&data_types, ", // %s\n", col);

    if (suppress_getters) {
      continue;
    }

    sem_t core_type = core_type_of(sem_type);
    bool_t col_is_nullable = is_nullable(sem_type);

    function_info info = {
      .name = name,
      .col = col,
      .col_index = (int32_t)i,
      .headers = h,
      .defs = d,
      .uses_out = uses_out,
      .result_set_ref_type = result_set_ref.ptr,
      .row_struct_type = row_sym.ptr,
      .ret_kind = kind,
    };

    if (col_is_nullable && !is_ref_type(sem_type)) {
      info.ret_type = SEM_TYPE_BOOL | SEM_TYPE_NOTNULL;
      info.name_type = SEM_TYPE_NULL;
      info.sym_suffix = "_is_null";
      cg_proc_result_set_type_based_getter(&info);

      info.ret_type = core_type | SEM_TYPE_NOTNULL;
      info.name_type = core_type;
      info.sym_suffix = "_value";
      cg_proc_result_set_type_based_getter(&info);

      if (emit_setters) {
        info.name_type = core_type;
        cg_proc_result_set_setter(&info, DONT_EMIT_SET_NULL);

        // set null setter
        info.sym_suffix = "_to_null";
        cg_proc_result_set_setter(&info, DO_EMIT_SET_NULL);
      }
    }
    else {
      info.ret_type = sem_type;
      info.name_type = core_type;
      info.sym_suffix = NULL;
      cg_proc_result_set_type_based_getter(&info);
      if (emit_setters) {
        cg_proc_result_set_setter(&info, DONT_EMIT_SET_NULL);
      }
    }
  }

  bprintf(h, "\n");

  CHARBUF_OPEN(is_null_getter);

  bool_t generate_copy_attr = misc_attrs && exists_attribute_str(misc_attrs, "generate_copy");

  // Check whether we need to generate a copy function.
  bool_t generate_copy = (generate_copy_attr ||
                         (rt->proc_should_generate_copy && rt->proc_should_generate_copy(name)));

  int32_t refs_count = refs_count_sptr(sptr);

  // generate reference and column offsets
  bprintf(&data_types, "};\n");
  bprintf(d, "%s", data_types.ptr);

  if (refs_count && !uses_out) {
    // note: fetch procs have already emitted this.
    cg_refs_offset(d, sptr, refs_offset_sym.ptr, row_sym.ptr);
  }

  cg_col_offsets(d, sptr, col_offsets_sym.ptr, row_sym.ptr);

  bool_t has_identity_columns = cg_identity_columns(h, d, name, misc_attrs, identity_columns_sym.ptr);

  bprintf(&result_set_create,
          "(%s)cql_result_set_create(%s, count, %d, %s, meta)",
          result_set_ref.ptr,
          uses_out ? "row" : "b.ptr",
          count,
          data_types_sym.ptr);

  CHARBUF_CLOSE(is_null_getter);

  // Emit foo_result_count, which is really just a proxy to
  // cql_result_set_get_count, but it is hiding the cql_result_set
  // implementation detail from the API of the generated code by providing a
  // proc-scoped function for it with the typedef for the result set.

  bclear(&temp);
  bprintf(&temp, "cql_int32 %s(%s _Nonnull result_set)", result_count_sym.ptr, result_set_ref.ptr);
  bprintf(h, "%s%s;\n", rt->symbol_visibility, temp.ptr);

  // emit the row count symbol
  bprintf(d, "\n%s {\n", temp.ptr);
  bprintf(d, "  return cql_result_set_get_count((cql_result_set_ref)result_set);\n");
  bprintf(d, "}\n");

  // Generate fetch result function
  if (uses_out) {
    // Emit foo_fetch_results, it has the same signature as foo only with a
    // result set instead of a statement.
    bclear(&temp);
    cg_emit_fetch_results_prototype(dml_proc, params, name, result_set_name, &temp);

    // ready for prototype and function begin now
    bprintf(h, "%s%s);\n", rt->symbol_visibility, temp.ptr);
    bprintf(d, "\n%s) {\n", temp.ptr);

    // emit profiling start signal
    bprintf(d, "  cql_profile_start(CRC_%s, &%s);\n", proc_sym.ptr, perf_index.ptr);

    // one row result set from out parameter

    bprintf(d, "  *result_set = NULL;\n");
    bprintf(d, "  %s *row = (%s *)calloc(1, sizeof(%s));\n", row_sym.ptr, row_sym.ptr, row_sym.ptr);
    bprintf(d, "  ");

    // optional db arg and return code
    if (dml_proc) {
      bprintf(d, "cql_code rc = %s(_db_, ", proc_sym.ptr);
    }
    else {
      bprintf(d, "%s(", proc_sym.ptr);
    }

    if (params) {
      cg_param_names(params, d);
      bprintf(d, ", ");
    }
    bprintf(d, "row);\n");

    fetch_result_info info = {
        .dml_proc = dml_proc,
        .use_stmt = false,
        .data_types_sym = data_types_sym.ptr,
        .col_offsets_sym = col_offsets_sym.ptr,
        .refs_count = refs_count,
        .refs_offset_sym = refs_offset_sym.ptr,
        .has_identity_columns = has_identity_columns,
        .identity_columns_sym = identity_columns_sym.ptr,
        .row_sym = row_sym.ptr,
        .proc_sym = proc_sym.ptr,
        .perf_index = perf_index.ptr,
        .misc_attrs = misc_attrs,
        .indent = 2,
    };

    cg_fetch_info(&info, d);

    if (dml_proc) {
      bprintf(d, "  return ");
    }
    else {
      bprintf(d, "  ");
    }
    bprintf(d, "cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);\n");
    bprintf(d, "}\n\n");
  }
  else if (result_set_proc) {
    // Emit foo_fetch_results, it has the same signature as foo only with a
    // result set instead of a statement.
    bclear(&temp);
    cg_emit_fetch_results_prototype(EMIT_DML_PROC, params, name, result_set_name, &temp);

    // To create the rowset we make a byte buffer object.  That object lets us
    // append row data to an in-memory stream.  Each row is fetched by binding
    // to a row object.  We use cg_get_column to read the columns.  The row
    // object of course has exactly the right type for each column.
    bprintf(h, "%s%s);\n", rt->symbol_visibility, temp.ptr);
    bprintf(d, "\n%s) {\n", temp.ptr);
    bprintf(d, "  sqlite3_stmt *stmt = NULL;\n");

    // emit profiling start signal
    bprintf(d, "  cql_profile_start(CRC_%s, &%s);\n", proc_sym.ptr, perf_index.ptr);

    // Invoke the base proc to get the statement
    bprintf(d, "  cql_code rc = %s(_db_, &stmt", proc_sym.ptr);
    if (params) {
      bprintf(d, ", ");
      cg_param_names(params, d);
    }
    bprintf(d, ");\n");

    // Now read in in all the rows using this fetch information
    fetch_result_info info = {
        .dml_proc = true,
        .use_stmt = true,
        .data_types_sym = data_types_sym.ptr,
        .col_offsets_sym = col_offsets_sym.ptr,
        .refs_count = refs_count,
        .refs_offset_sym = refs_offset_sym.ptr,
        .has_identity_columns = has_identity_columns,
        .identity_columns_sym = identity_columns_sym.ptr,
        .row_sym = row_sym.ptr,
        .proc_sym = proc_sym.ptr,
        .perf_index = perf_index.ptr,
        .misc_attrs = misc_attrs,
        .indent = 2,
    };

    cg_fetch_info(&info, d);
    bprintf(d, "  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);\n");
    bprintf(d, "}\n\n");
  }
  else {
    // this is the only case left
    Invariant(uses_out_union);

    fetch_result_info info = {
        .dml_proc = false,
        .use_stmt = false,
        .data_types_sym = data_types_sym.ptr,
        .col_offsets_sym = col_offsets_sym.ptr,
        .refs_count = refs_count,
        .refs_offset_sym = refs_offset_sym.ptr,
        .has_identity_columns = has_identity_columns,
        .identity_columns_sym = identity_columns_sym.ptr,
        .row_sym = row_sym.ptr,
        .proc_sym = proc_sym.ptr,
        .perf_index = perf_index.ptr,
        .misc_attrs = misc_attrs,
        .indent = 0,
        .prefix = proc_sym.ptr,
    };

    cg_fetch_info(&info, d);
  }

  if (generate_copy) {
    bprintf(
      h,
      "#define %s(result_set, result_set_to%s) \\\n"
      "cql_result_set_get_meta((cql_result_set_ref)(result_set))->copy( \\\n"
      "  (cql_result_set_ref)(result_set), \\\n"
      "  (cql_result_set_ref *)(result_set_to), \\\n"
      "  %s, \\\n"
      "  %s)\n",
      copy_sym.ptr,
      uses_out ? "": ", from, count",
      uses_out ? "0" : "from",
      uses_out ? "1" : "count");
  }

  if (rt->generate_equality_macros) {
    bclear(&temp);

    CG_CHARBUF_OPEN_SYM(hash_sym, name, uses_out ? "_hash" : "_row_hash");
    bprintf(
      h,
      "#define %s(result_set%s) "
      "cql_result_set_get_meta((cql_result_set_ref)(result_set))->rowHash((cql_result_set_ref)(result_set), %s)\n",
      hash_sym.ptr,
      uses_out ? "" : ", row",
      uses_out ? "0" : "row");

    CHARBUF_CLOSE(hash_sym);

    CG_CHARBUF_OPEN_SYM(equal_sym, name, uses_out ? "_equal" : "_row_equal");
    bprintf(
      h,
      "#define %s(rs1%s, rs2%s) \\\n"
      "cql_result_set_get_meta((cql_result_set_ref)(rs1))->rowsEqual( \\\n"
      "  (cql_result_set_ref)(rs1), \\\n"
      "  %s, \\\n"
      "  (cql_result_set_ref)(rs2), \\\n"
      "  %s)\n",
      equal_sym.ptr,
      uses_out ? "" : ", row1",
      uses_out ? "" : ", row2",
      uses_out ? "0" : "row1",
      uses_out ? "0" : "row2");
    CHARBUF_CLOSE(equal_sym);

    if (has_identity_columns) {
      CG_CHARBUF_OPEN_SYM(same_sym, name, uses_out ? "_same" : "_row_same");
      bprintf(
        h, "#define %s(rs1%s, rs2%s) \\\n"
        "cql_result_set_get_meta((cql_result_set_ref)(rs1))->rowsSame( \\\n"
        "  (cql_result_set_ref)(rs1), \\\n"
        "  %s, \\\n"
        "  (cql_result_set_ref)(rs2), \\\n"
        "  %s)\n",
        same_sym.ptr,
        uses_out ? "" : ", row1",
        uses_out ? "" : ", row2",
        uses_out ? "0" : "row1",
        uses_out ? "0" : "row2");
      CHARBUF_CLOSE(same_sym);
    }
  }

  CHARBUF_CLOSE(perf_index);
  CHARBUF_CLOSE(copy_sym);
  CHARBUF_CLOSE(fetch_results_sym);
  CHARBUF_CLOSE(result_count_sym);
  CHARBUF_CLOSE(identity_columns_sym);
  CHARBUF_CLOSE(refs_offset_sym);
  CHARBUF_CLOSE(col_offsets_sym);
  CHARBUF_CLOSE(data_types_count_sym);
  CHARBUF_CLOSE(data_types_sym);
  CHARBUF_CLOSE(row_sym);
  CHARBUF_CLOSE(proc_sym);
  CHARBUF_CLOSE(result_set_ref);
  CHARBUF_CLOSE(result_set_sym);
  CHARBUF_CLOSE(stored_proc_name_sym);
  CHARBUF_CLOSE(getter_prefix);
  CHARBUF_CLOSE(temp);
  CHARBUF_CLOSE(result_set_create);
  CHARBUF_CLOSE(data_types);
}

// Main entry point for code-gen. This will set up the buffers for the global
// variables and any loose calls or DML.  Any code that needs to run in the
// global scope will be added to the global_proc.  This is the only codegen
// error that is possible.  If you need global code and you don't have a global
// proc then you can't proceed.  Semantic analysis doÆ’esn't want to know that
// stuff. Otherwise all we do is set up the most general buffers for the global
// case and spit out a function with the correct name.
cql_noexport void cg_c_main(ast_node *head) {
  cql_exit_on_semantic_errors(head);
  exit_on_validating_schema();

  CSTR header_file_name = options.file_names[0];
  CSTR body_file_name = options.file_names[1];
  CSTR exports_file_name = NULL;

  uint32_t export_file_index = 2;

  if (options.generate_exports) {
    if (options.file_names_count <= export_file_index) {
      cql_error("--cg had the wrong number of arguments, argument %d was needed\n", export_file_index + 1);
      cql_cleanup_and_exit(1);
    }

    exports_file_name = options.file_names[export_file_index];
  }

  cg_c_init();

  cg_scratch_masks global_scratch_masks;
  cg_current_masks = &global_scratch_masks;
  cg_zero_masks(cg_current_masks);

  if (options.compress) {
    // seed the fragments with popular ones based on statistics
    CHARBUF_OPEN(ignored);

    cg_statement_pieces(", ", &ignored);
    cg_statement_pieces("AS ", &ignored);
    cg_statement_pieces("NOT ", &ignored);
    cg_statement_pieces(".", &ignored);
    cg_statement_pieces(",", &ignored);
    cg_statement_pieces(",\n  ", &ignored);
    cg_statement_pieces("id ", &ignored);
    cg_statement_pieces("id,", &ignored);
    cg_statement_pieces("KEY", &ignored);
    cg_statement_pieces("KEY ", &ignored);
    cg_statement_pieces("TEXT", &ignored);
    cg_statement_pieces("LONG_", &ignored);
    cg_statement_pieces("INT ", &ignored);
    cg_statement_pieces("INTEGER ", &ignored);
    cg_statement_pieces("ON ", &ignored);
    cg_statement_pieces("TEXT ", &ignored);
    cg_statement_pieces("CAST", &ignored);
    cg_statement_pieces("TABLE ", &ignored);
    cg_statement_pieces("(", &ignored);
    cg_statement_pieces(")", &ignored);
    cg_statement_pieces("( ", &ignored);
    cg_statement_pieces(") ", &ignored);
    cg_statement_pieces("0", &ignored);
    cg_statement_pieces("1", &ignored);
    cg_statement_pieces("= ", &ignored);
    cg_statement_pieces("__", &ignored);
    cg_statement_pieces("NULL ", &ignored);
    cg_statement_pieces("NULL,", &ignored);
    cg_statement_pieces("EXISTS ", &ignored);
    cg_statement_pieces("CREATE ", &ignored);
    cg_statement_pieces("DROP ", &ignored);
    cg_statement_pieces("TABLE ", &ignored);
    cg_statement_pieces("VIEW ", &ignored);
    cg_statement_pieces("PRIMARY ", &ignored);
    cg_statement_pieces("IF ", &ignored);
    cg_statement_pieces("(\n", &ignored);

    CHARBUF_CLOSE(ignored);
  }

  CHARBUF_OPEN(exports_file);
  CHARBUF_OPEN(header_file);
  CHARBUF_OPEN(body_file);
  CHARBUF_OPEN(indent);

  if (exports_file_name) {
    exports_output = &exports_file;

    if (rt->exports_prefix) {
      bprintf(exports_output, "%s", rt->exports_prefix);
    }
  }

  cg_stmt_list(head);

  bprintf(&body_file, "%s", rt->source_prefix);

  if (options.c_include_path) {
    // If your output path has inconvenient prefixes you can specify everything.
    // You use c_include_path to accomplish this.

    bprintf(&body_file, "#include \"%s\"\n\n", options.c_include_path);
  }
  else if (options.c_include_namespace) {
    // If your output is just a base name, you might want to prefix it.
    // You can use c_include_namespace for this option.

    bprintf(&body_file, "#include \"%s/%s\"\n\n", options.c_include_namespace, options.file_names[0]);
  }
  else {
    // If neither option specified then we use whatever was provided as the output path.
    // This is the most common case.
    bprintf(&body_file, "#include \"%s\"\n\n", options.file_names[0]);
  }

  bprintf(&body_file, "%s", rt->source_wrapper_begin);
  bprintf(&body_file, "#ifndef _MSC_VER\n");
  bprintf(&body_file, "#pragma clang diagnostic push\n");
  bprintf(&body_file, "#pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n");
  bprintf(&body_file, "#pragma clang diagnostic ignored \"-Wbitwise-op-parentheses\"\n");
  bprintf(&body_file, "#pragma clang diagnostic ignored \"-Wshift-op-parentheses\"\n");
  bprintf(&body_file, "#pragma clang diagnostic ignored \"-Wlogical-not-parentheses\"\n");
  bprintf(&body_file, "#pragma clang diagnostic ignored \"-Wlogical-op-parentheses\"\n");
  bprintf(&body_file, "#pragma clang diagnostic ignored \"-Wliteral-conversion\"\n");
  bprintf(&body_file, "#pragma clang diagnostic ignored \"-Wunused-but-set-variable\"\n");
  bprintf(&body_file, "#pragma clang diagnostic ignored \"-Wunused-function\"\n");
  bprintf(&body_file, "#endif\n");

  bprintf(&body_file, "%s", cg_fwd_ref_output->ptr);
  bprintf(&body_file, "%s", cg_constants_output->ptr);

  if (cg_pieces_output->used > 1) {
    bprintf(&body_file, "static const char _pieces_[] = \n%s;\n", cg_pieces_output->ptr);
  }
  bprintf(&body_file, "%s", cg_declarations_output->ptr);

  // main function after constants and decls (if needed)

  bool_t global_proc_needed = cg_main_output->used > 1 || cg_scratch_vars_output->used > 1;

  if (global_proc_needed) {
    exit_on_no_global_proc();

    bprintf(&body_file, "#define _PROC_ %s\n", global_proc_name);

    bindent(&indent, cg_scratch_vars_output, 2);
    bprintf(&body_file, "\ncql_code %s(sqlite3 *_Nonnull _db_) {\n", global_proc_name);
    cg_emit_rc_vars(&body_file);

    bprintf(&body_file, "%s", indent.ptr);
    bprintf(&body_file, "%s", cg_main_output->ptr);
    bprintf(&body_file, "\n");
    if (error_target_used) {
      bprintf(&body_file, "%s:\n", error_target);
    }
    bprintf(&body_file, "%s", cg_cleanup_output->ptr);
    bprintf(&body_file, "  return _rc_;\n");
    bprintf(&body_file, "}\n");
    bprintf(&body_file, "\n#undef _PROC_\n");
  }

  bprintf(&body_file, "#pragma clang diagnostic pop\n");
  bprintf(&body_file, "%s", rt->source_wrapper_end);

  bprintf(&header_file, "%s", rt->header_prefix);
  bprintf(&header_file, rt->cqlrt_template, rt->cqlrt);
  bprintf(&header_file, "%s", rt->header_wrapper_begin);
  bprintf(&header_file, "%s", cg_header_output->ptr);
  bprintf(&header_file, "%s", rt->header_wrapper_end);

  CHARBUF_CLOSE(indent);

  cql_write_file(header_file_name, header_file.ptr);

  if (options.nolines || options.test) {
    cql_write_file(body_file_name, body_file.ptr);
  }
  else {
    CHARBUF_OPEN(body_with_line_directives);

    cg_insert_line_directives(body_file.ptr, &body_with_line_directives);
    cql_write_file(body_file_name, body_with_line_directives.ptr);

    CHARBUF_CLOSE(body_with_line_directives);
  }

  if (exports_file_name) {
    cql_write_file(exports_file_name, exports_file.ptr);
  }

  CHARBUF_CLOSE(body_file);
  CHARBUF_CLOSE(header_file);
  CHARBUF_CLOSE(exports_file);

  cg_c_cleanup();
}

cql_noexport void cg_c_init(void) {
  cg_c_cleanup(); // reset globals/statics
  cg_common_init();

  Contract(!error_target_used);

  // one table for the whole translation unit
  Contract(!string_literals);
  string_literals = symtab_new_case_sens();

  Contract(!text_pieces);
  text_pieces = symtab_new_case_sens();

  Contract(!emitted_proc_decls);
  emitted_proc_decls = symtab_new();

  DDL_STMT_INIT(drop_table_stmt);
  DDL_STMT_INIT(drop_view_stmt);
  DDL_STMT_INIT(drop_index_stmt);
  DDL_STMT_INIT(drop_trigger_stmt);
  DDL_STMT_INIT(create_table_stmt);
  DDL_STMT_INIT(create_virtual_table_stmt);
  DDL_STMT_INIT(create_trigger_stmt);
  DDL_STMT_INIT(create_index_stmt);
  DDL_STMT_INIT(create_view_stmt);
  DDL_STMT_INIT(alter_table_add_column_stmt);

  NO_OP_STMT_INIT(expr_macro_def);
  NO_OP_STMT_INIT(stmt_list_macro_def);
  NO_OP_STMT_INIT(query_parts_macro_def);
  NO_OP_STMT_INIT(cte_tables_macro_def);
  NO_OP_STMT_INIT(select_expr_macro_def);
  NO_OP_STMT_INIT(select_core_macro_def);
  NO_OP_STMT_INIT(enforce_reset_stmt);
  NO_OP_STMT_INIT(enforce_normal_stmt);
  NO_OP_STMT_INIT(enforce_strict_stmt);
  NO_OP_STMT_INIT(enforce_push_stmt);
  NO_OP_STMT_INIT(enforce_pop_stmt);
  NO_OP_STMT_INIT(declare_schema_region_stmt);
  NO_OP_STMT_INIT(declare_deployable_region_stmt);
  NO_OP_STMT_INIT(begin_schema_region_stmt);
  NO_OP_STMT_INIT(end_schema_region_stmt);
  NO_OP_STMT_INIT(schema_upgrade_version_stmt);
  NO_OP_STMT_INIT(schema_upgrade_script_stmt);
  NO_OP_STMT_INIT(schema_ad_hoc_migration_stmt);
  NO_OP_STMT_INIT(schema_unsub_stmt);
  NO_OP_STMT_INIT(declare_enum_stmt);
  NO_OP_STMT_INIT(declare_const_stmt);
  NO_OP_STMT_INIT(declare_named_type);
  NO_OP_STMT_INIT(declare_proc_no_check_stmt);
  NO_OP_STMT_INIT(declare_func_no_check_stmt);
  NO_OP_STMT_INIT(declare_select_func_no_check_stmt);
  NO_OP_STMT_INIT(declare_select_func_stmt);
  NO_OP_STMT_INIT(declare_interface_stmt);
  NO_OP_STMT_INIT(op_stmt);
  NO_OP_STMT_INIT(keep_table_name_in_aliases_stmt);

  STD_DML_STMT_INIT(begin_trans_stmt);
  STD_DML_STMT_INIT(commit_trans_stmt);
  STD_DML_STMT_INIT(rollback_trans_stmt);
  STD_DML_STMT_INIT(savepoint_stmt);
  STD_DML_STMT_INIT(release_savepoint_stmt);
  STD_DML_STMT_INIT(delete_stmt);
  STD_DML_STMT_INIT(with_delete_stmt);
  STD_DML_STMT_INIT(update_stmt);
  STD_DML_STMT_INIT(with_update_stmt);

  // these prepare and then execute
  STD_PREP_STMT_INIT(upsert_returning_stmt);
  STD_PREP_STMT_INIT(update_returning_stmt);
  STD_PREP_STMT_INIT(delete_returning_stmt);
  STD_PREP_STMT_INIT(explain_stmt);
  STD_PREP_STMT_INIT(select_stmt);
  STD_PREP_STMT_INIT(with_select_stmt);

  // insert forms have some special processing for the 'seed' case
  STMT_INIT(insert_returning_stmt);
  STMT_INIT(insert_stmt);
  STMT_INIT(with_insert_stmt);
  STMT_INIT(upsert_stmt);
  STMT_INIT(with_upsert_stmt);

  STMT_INIT(expr_stmt);
  STMT_INIT(if_stmt);
  STMT_INIT(ifdef_stmt);
  STMT_INIT(ifndef_stmt);
  STMT_INIT(switch_stmt);
  STMT_INIT(for_stmt);
  STMT_INIT(while_stmt);
  STMT_INIT(leave_stmt);
  STMT_INIT(continue_stmt);
  STMT_INIT(return_stmt);
  STMT_INIT(rollback_return_stmt);
  STMT_INIT(commit_return_stmt);
  STMT_INIT(call_stmt);
  STMT_INIT(declare_out_call_stmt);
  STMT_INIT(declare_vars_type);
  STMT_INIT(declare_group_stmt);
  STMT_INIT(emit_group_stmt);
  STMT_INIT(assign);
  STMT_INIT(let_stmt);
  STMT_INIT(const_stmt);
  STMT_INIT(set_from_cursor);
  STMT_INIT(create_proc_stmt);
  STMT_INIT(emit_enums_stmt);
  STMT_INIT(emit_constants_stmt);
  STMT_INIT(declare_proc_stmt);
  STMT_INIT(declare_func_stmt);
  STMT_INIT(trycatch_stmt);
  STMT_INIT(proc_savepoint_stmt);
  STMT_INIT(throw_stmt);

  STMT_INIT(declare_cursor);
  STMT_INIT(declare_cursor_like_name);
  STMT_INIT(declare_cursor_like_select);
  STMT_INIT(declare_cursor_like_typed_names);
  STMT_INIT(declare_value_cursor);

  STMT_INIT(loop_stmt);
  STMT_INIT(fetch_stmt);
  STMT_INIT(fetch_values_stmt);
  STMT_INIT(update_cursor_stmt);
  STMT_INIT(fetch_call_stmt);

  STMT_INIT(close_stmt);
  STMT_INIT(out_stmt);
  STMT_INIT(out_union_stmt);
  STMT_INIT(echo_stmt);

  FUNC_INIT(sign);
  FUNC_INIT(abs);
  FUNC_INIT(sensitive);
  FUNC_INIT(nullable);
  FUNC_INIT(ifnull_throw);
  FUNC_INIT(ifnull_crash);
  FUNC_INIT(ifnull);
  FUNC_INIT(coalesce);
  FUNC_INIT(last_insert_rowid);
  FUNC_INIT(changes);
  FUNC_INIT(printf);
  FUNC_INIT(cql_get_blob_size);
  FUNC_INIT(cql_compressed);
  FUNC_INIT(cql_inferred_notnull);

  EXPR_INIT(num, cg_expr_num, "num", C_EXPR_PRI_ROOT);
  EXPR_INIT(str, cg_expr_str, "STR", C_EXPR_PRI_ROOT);
  EXPR_INIT(null, cg_expr_null, "NULL", C_EXPR_PRI_ROOT);
  EXPR_INIT(dot, cg_expr_dot, "DOT", C_EXPR_PRI_ROOT);

  EXPR_INIT(lshift, cg_binary, "<<", C_EXPR_PRI_SHIFT);
  EXPR_INIT(rshift, cg_binary, ">>", C_EXPR_PRI_SHIFT);
  EXPR_INIT(bin_and, cg_binary, "&", C_EXPR_PRI_BAND);
  EXPR_INIT(bin_or, cg_binary, "|", C_EXPR_PRI_BOR);

  EXPR_INIT(mul, cg_binary, "*", C_EXPR_PRI_MUL);
  EXPR_INIT(div, cg_binary, "/", C_EXPR_PRI_MUL);
  EXPR_INIT(mod, cg_binary, "%", C_EXPR_PRI_MUL);
  EXPR_INIT(add, cg_binary, "+", C_EXPR_PRI_ADD);
  EXPR_INIT(sub, cg_binary, "-", C_EXPR_PRI_ADD);
  EXPR_INIT(not, cg_unary, "!", C_EXPR_PRI_UNARY);
  EXPR_INIT(tilde, cg_unary, "~", C_EXPR_PRI_UNARY);
  EXPR_INIT(uminus, cg_unary, "-", C_EXPR_PRI_UNARY);
  EXPR_INIT(eq, cg_binary_compare, "==", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(ne, cg_binary_compare, "!=", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(lt, cg_binary_compare, "<", C_EXPR_PRI_LT_GT);
  EXPR_INIT(gt, cg_binary_compare, ">", C_EXPR_PRI_LT_GT);
  EXPR_INIT(ge, cg_binary_compare, ">=", C_EXPR_PRI_LT_GT);
  EXPR_INIT(le, cg_binary_compare, "<=", C_EXPR_PRI_LT_GT);
  EXPR_INIT(call, cg_expr_call, "CALL", C_EXPR_PRI_ROOT);
  EXPR_INIT(between_rewrite, cg_expr_between_rewrite, "BETWEEN", C_EXPR_PRI_ROOT);
  EXPR_INIT(and, cg_expr_and, "AND", C_EXPR_PRI_LAND);
  EXPR_INIT(or, cg_expr_or, "OR", C_EXPR_PRI_LOR);
  EXPR_INIT(select_stmt, cg_expr_select, "SELECT", C_EXPR_PRI_ROOT);
  EXPR_INIT(select_if_nothing_expr, cg_expr_select_if_nothing, "SELECT", C_EXPR_PRI_ROOT);
  EXPR_INIT(select_if_nothing_throw_expr, cg_expr_select_if_nothing_throw, "SELECT", C_EXPR_PRI_ROOT);
  EXPR_INIT(select_if_nothing_or_null_throw_expr, cg_expr_select_if_nothing_or_null_throw, "SELECT", C_EXPR_PRI_ROOT);
  EXPR_INIT(select_if_nothing_or_null_expr, cg_expr_select_if_nothing_or_null, "SELECT", C_EXPR_PRI_ROOT);
  EXPR_INIT(with_select_stmt, cg_expr_select, "WITH...SELECT", C_EXPR_PRI_ROOT);
  EXPR_INIT(is, cg_expr_is, "IS", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(is_not, cg_expr_is_not, "IS NOT", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(is_not_true, cg_expr_is_not_true, "IS NOT TRUE", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(is_not_false, cg_expr_is_not_false, "IS NOT FALSE", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(is_true, cg_expr_is_true, "IS TRUE", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(is_false, cg_expr_is_false, "IS FALSE", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(like, cg_binary_compare, "LIKE", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(not_like, cg_binary_compare, "LIKE", C_EXPR_PRI_EQ_NE);
  EXPR_INIT(in_pred, cg_expr_in_pred_or_not_in, "IN", C_EXPR_PRI_ROOT);
  EXPR_INIT(not_in, cg_expr_in_pred_or_not_in, "NOT IN", C_EXPR_PRI_ROOT);
  EXPR_INIT(case_expr, cg_expr_case, "CASE", C_EXPR_PRI_ROOT);
  EXPR_INIT(cast_expr, cg_expr_cast, "CAST", C_EXPR_PRI_ROOT);
  EXPR_INIT(type_check_expr, cg_expr_type_check, "TYPE CHECK", C_EXPR_PRI_ROOT);
}

// To make sure we start at a zero state.  This is really necessary stuff
// because of the amalgam.  In the context of the amalgam the compiler might be
// run more than once without the process exiting. Hence we have to reset the
// globals and empty the symbol tables.
cql_noexport void cg_c_cleanup() {
  cg_common_cleanup();

  SYMTAB_CLEANUP(string_literals);
  SYMTAB_CLEANUP(text_pieces);
  SYMTAB_CLEANUP(emitted_proc_decls);

  exports_output = NULL;
  error_target = NULL;
  cg_current_masks = NULL;

  cg_in_loop = LOOP_NONE;
  case_statement_count = 0;
  catch_block_count = 0;
  for_loop_count = 0;
  for_loop_cur = 0;
  error_target = CQL_CLEANUP_DEFAULT_LABEL;
  error_target_used = false;
  rcthrown_current = CQL_RCTHROWN_DEFAULT;
  rcthrown_used = false;
  rcthrown_index = 0;
  return_used = false;
  piece_last_offset = 0;
  seed_declared = false;
  stack_level = 0;
  string_literals_count = 0;
  temp_cstr_count = 0;
  temp_statement_emitted = false;
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_CG_COMMON)

// minimal stubs to avoid link errors

cql_noexport void cg_common_cleanup() {}
void cql_exit_on_semantic_errors(ast_node *head) {}

#else


// Storage declarations
cql_data_defn( symtab *_Nullable cg_stmts );
cql_data_defn( symtab *_Nullable cg_funcs );
cql_data_defn( symtab *_Nullable cg_exprs );
cql_data_defn( charbuf *_Nullable cg_header_output );
cql_data_defn( charbuf *_Nullable cg_main_output );
cql_data_defn( charbuf *_Nullable cg_fwd_ref_output );
cql_data_defn( charbuf *_Nullable cg_constants_output );
cql_data_defn( charbuf *_Nullable cg_declarations_output );
cql_data_defn( charbuf *_Nullable cg_scratch_vars_output );
cql_data_defn( charbuf *_Nullable cg_cleanup_output );
cql_data_defn( charbuf *_Nullable cg_pieces_output );

// Prints a symbol name, along with any configured prefix, to the specified buffer.
// Multiple CSTRs may be supplied to build the name, which will be concatenated
// together.  The configured symbol case will be applied to the full symbol name.
// The prefix will be included as specified.
//
// All input names are assumed to be in snake case already.
cql_noexport void cg_sym_name(cg_symbol_case symbol_case, charbuf *_Nonnull output, CSTR _Nonnull symbol_prefix, CSTR _Nonnull name, ...)
{
  // Print the prefix first
  bprintf(output, "%s", symbol_prefix);

  // Setup the arg list
  va_list args;
  va_start(args, name);

  CSTR name_component = name;

  // Check the case configuration
  switch (symbol_case) {
    case cg_symbol_case_snake:{
      // No need to modify it, everything in here is already snake case.
      do {
        bprintf(output, "%s", name_component);
      } while ((name_component = va_arg(args, CSTR)));
      break;
    }
    case cg_symbol_case_camel:
    case cg_symbol_case_pascal:{
      // Remove all underscores and uppercase each next character, along with the first if pascal case.
      bool should_upper = (symbol_case != cg_symbol_case_camel);
      do {
        const size_t len = strlen(name_component);
        for (size_t i = 0; i != len; ++i) {
          if (name_component[i] == '_') {
            should_upper = true;
          }
          else if (should_upper) {
            bputc(output, ToUpper(name_component[i]));
            should_upper = false;
          }
          else {
            bputc(output, name_component[i]);
          }
        }
      } while ((name_component = va_arg(args, CSTR)));
      break;
    }
  }
  va_end(args);
}

// normal charbuf allocation and open goes on the stack
// this macro is for the case where we want a durable buffer
// that will be used across multiple functions
#define ALLOC_AND_OPEN_CHARBUF_REF(x) \
  (x) = (charbuf *)calloc(1, sizeof(charbuf)); \
  bopen(x);

// and here's the cleanup for the durable buffer
#define CLEANUP_CHARBUF_REF(x) if (x) { bclose(x); free(x);  x = NULL; }

cql_noexport void cg_common_init(void)
{
  // All of these will leak, but we don't care.  The tool will shut down after running cg, so it is pointless to clean
  // up after ourselves here.
  cg_stmts = symtab_new();
  cg_funcs = symtab_new();
  cg_exprs = symtab_new();

  ALLOC_AND_OPEN_CHARBUF_REF(cg_header_output);
  ALLOC_AND_OPEN_CHARBUF_REF(cg_main_output);
  ALLOC_AND_OPEN_CHARBUF_REF(cg_fwd_ref_output);
  ALLOC_AND_OPEN_CHARBUF_REF(cg_constants_output);
  ALLOC_AND_OPEN_CHARBUF_REF(cg_declarations_output);
  ALLOC_AND_OPEN_CHARBUF_REF(cg_scratch_vars_output);
  ALLOC_AND_OPEN_CHARBUF_REF(cg_cleanup_output);
  ALLOC_AND_OPEN_CHARBUF_REF(cg_pieces_output);

  if (rt->cql_post_common_init) rt->cql_post_common_init();
}

// lots of AST nodes require no action -- this guy is very good at that.
cql_noexport void cg_no_op(ast_node * ast) {
}

// If there is a semantic error, we should not proceed with code generation.
// We find such an error at the root of the AST.  Note its important
// to be pristine in memory usage because the amalgam version of the compiler
// does not necessarily exit when it's done. It might be used in a long running
// process, like VSCode, and we don't want to leak memory.
cql_noexport void cql_exit_on_semantic_errors(ast_node *head) {
  if (head && is_error(head)) {
    cql_error("semantic errors present; no code gen.\n");
    cql_cleanup_and_exit(1);
  }
}

// If we are here then we've already determined that there is global code to emit.
// This is code that is outside of any procedure.  This is actually pretty common
// for instance the CQL unit test pattern relies on global code to make the tests run.
// If there is no procedure name for the global code then we have a problem.  We
// can't proceed.
cql_noexport void exit_on_no_global_proc() {
  if (!global_proc_name) {
    cql_error("There are global statements but no global proc name was specified (use --global_proc)\n");
    cql_cleanup_and_exit(1);
  }
}

// Produce a crc of a given charbuf using the CRC helpers.
cql_noexport crc_t crc_charbuf(charbuf *input) {
  crc_t crc = crc_init();
  crc = crc_update(crc, (const unsigned char *)input->ptr, input->used);
  return crc_finalize(crc);
}

// Produce a sha256 reduced to 64 bits using the SHA256 helpers
cql_noexport int64_t sha256_charbuf(charbuf *input) {
  SHA256_CTX ctx;
  sha256_init(&ctx);
  sha256_update(&ctx, (const SHA256_BYTE *)input->ptr, input->used - 1);
  SHA256_BYTE hash_bytes[64];
  sha256_final(&ctx, hash_bytes);
  int64_t *h = (int64_t *)hash_bytes;
  int64_t hash = h[0] ^ h[1] ^h[2] ^ h[3];
  return hash;
}

// See cg_find_first_line for more details on why this is what it is.
// All that's going on here is we recursively visit the tree and find the smallest
// line number that matches the given file in that branch.
int32_t cg_find_first_line_recursive(ast_node *ast, CSTR filename) {
  int32_t line = INT32_MAX;
  int32_t lleft = INT32_MAX;
  int32_t lright = INT32_MAX;

  // file name is usually the same actual string but not always
  if (ast->filename == filename || !strcmp(filename, ast->filename)) {
   line = ast->lineno;
  }

  if (ast_has_left(ast)) {
   lleft = cg_find_first_line_recursive(ast->left, filename);
   if (lleft < line) line = lleft;
  }

  if (ast_has_right(ast)) {
   lright = cg_find_first_line_recursive(ast->right, filename);
   if (lright < line) line = lright;
  }

  return line;
}

// What's going on here is that the AST is generated on REDUCE operations.
// that means the line number at the time any AST node was generated is
// the largest line number anywhere in that AST.  But if we're looking for
// the line number for a statement we want the line number where it started.
// The way to get that is to recurse through the tree and choose the smallest
// line number anywhere in the tree.  But, we must only use line numbers
// from the same file as the one we ended on.  If (e.g.) a procedure spans files
// this will cause jumping around but that's not really avoidable.
cql_noexport int32_t cg_find_first_line(ast_node *ast) {
  return cg_find_first_line_recursive(ast, ast->filename);
}

cql_noexport void cg_emit_name(charbuf *output, CSTR name, bool_t qid) {
  if (qid) {
    cg_decode_qstr(output, name);
  }
  else {
    bprintf(output, "%s", name);
  }
}

// emit a name or a quoted name as needed
cql_noexport void cg_emit_name_ast(charbuf *output, ast_node *name_ast) {
  EXTRACT_STRING(name, name_ast);
  cg_emit_name(output, name, is_qid(name_ast));
}

cql_noexport void cg_emit_sptr_index(charbuf *output, sem_struct *sptr, uint32_t i) {
  cg_emit_name(output, sptr->names[i], !!(sptr->semtypes[i] & SEM_TYPE_QID));
}

cql_noexport void cg_common_cleanup() {
  SYMTAB_CLEANUP(cg_stmts);
  SYMTAB_CLEANUP(cg_funcs);
  SYMTAB_CLEANUP(cg_exprs);

  CLEANUP_CHARBUF_REF(cg_header_output);
  CLEANUP_CHARBUF_REF(cg_main_output);
  CLEANUP_CHARBUF_REF(cg_fwd_ref_output);
  CLEANUP_CHARBUF_REF(cg_constants_output);
  CLEANUP_CHARBUF_REF(cg_declarations_output);
  CLEANUP_CHARBUF_REF(cg_scratch_vars_output);
  CLEANUP_CHARBUF_REF(cg_cleanup_output);
  CLEANUP_CHARBUF_REF(cg_pieces_output)
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_JSON)

// stubs to avoid link errors
cql_noexport void cg_json_schema_main(ast_node *head) {}

#else

// Perform codegen of the various nodes to json schema format



static void cg_fragment_with_params(charbuf *output, CSTR frag, ast_node *ast, gen_func fn);
static void cg_fragment_with_params_raw(charbuf *output, CSTR frag, ast_node *ast, gen_func fn);
static void cg_json_fk_target_options(charbuf *output, ast_node *ast);
static void cg_json_emit_region_info(charbuf *output, ast_node *ast);
static void cg_json_dependencies(charbuf *output, ast_node *ast);
static void cg_json_data_type(charbuf *output, sem_t sem_type, CSTR kind);

// These little helpers are for handling comma seperated lists where you may or may
// not need a comma in various places.  The local tracks if there is an item already
// present and you either get ",\n"  or just "\n" as needed.
#define BEGIN_LIST bool_t list_start = 1
#define CONTINUE_LIST bool_t list_start = 0
#define COMMA if (!list_start) bprintf(output, ",\n"); else list_start = 0
#define END_LIST if (!list_start) bprintf(output, "\n")

// These are the main output buffers for the various forms of statements we support
// we build these up as we encounter them, redirecting the local 'output' to one of these
static charbuf *queries;
static charbuf *deletes;
static charbuf *inserts;
static charbuf *updates;
static charbuf *general;
static charbuf *general_inserts;

// We use this to track every table we've ever seen and we remember what stored procedures use it
static symtab *tables_to_procs;

// The callback function for dependency analysis gets this structure as the anonymous context
typedef struct json_context {
  CSTR cookie;
  ast_node *proc_ast;
  charbuf *used_tables;
  charbuf *used_views;
  charbuf *insert_tables;
  charbuf *update_tables;
  charbuf *delete_tables;
  charbuf *from_tables;
  charbuf *used_procs;
} json_context;

// magic string to sanity check the context cuz we're paranoid
static char cookie_str[] = "cookie";

// compute the CRC for an arbitrary statement
static llint_t crc_stmt(ast_node *stmt) {
  CHARBUF_OPEN(temp);

  // Format the text with full annotations, this text isn't going to SQLite but it should capture
  // all aspects of the table/view/index/trigger including annotations.
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  gen_set_output_buffer(&temp);
  gen_statement_with_callbacks(stmt, &callbacks);
  llint_t result = (llint_t)crc_charbuf(&temp);

  CHARBUF_CLOSE(temp);
  return result;
}

static void cg_json_sql_name_ex(charbuf *output, CSTR name, bool qid) {
  if (qid) {
    CHARBUF_OPEN(sql_name);
    cg_unquote_encoded_qstr(&sql_name, name);
    cg_pretty_quote_plaintext(sql_name.ptr, output, PRETTY_QUOTE_JSON | PRETTY_QUOTE_SINGLE_LINE);
    CHARBUF_CLOSE(sql_name);
  }
  else {
    bprintf(output, "\"%s\"", name);
  }
}

static void cg_json_sptr_sql_name(charbuf *output, sem_struct *sptr, int32_t i) {
  CSTR name = sptr->names[i];
  cg_json_sql_name_ex(output, name, !!(sptr->semtypes[i] & SEM_TYPE_QID));
}

static void cg_json_sql_name(charbuf *output, ast_node *ast) {
  EXTRACT_STRING(name, ast);
  cg_json_sql_name_ex(output, name, is_qid(ast));
}

static void add_name_to_output(charbuf* output, ast_node *ast) {
  Contract(output);
  ast_node *name_ast = sem_get_name_ast(ast);
  if (output->used > 1) {
    bprintf(output, ", ");
  }
  cg_json_sql_name(output, name_ast);
}

// This is the callback function that tells us a view name was found in the body
// of the stored proc we are currently examining.  The void context information
// is how we remember which proc we were processing.   For each table we have
// a character buffer.  We look it up, create it if not present, and write into it.
// We also write into the buffer for the current proc which came in with the context.
static void cg_found_view(CSTR view_name, ast_node *name_ast, void* pvContext) {
  json_context *context = (json_context *)pvContext;
  Contract(context->cookie == cookie_str);  // sanity check
  Contract(context->used_views);

  add_name_to_output(context->used_views, name_ast);
}

// This is the callback function that tells us a table name was found in the body
// of the stored proc we are currently examining.  The void context information
// is how we remember which proc we were processing.   For each table we have
// a character buffer.  We look it up, create it if not present, and write into it.
// We also write into the buffer for the current proc which came in with the context.
static void cg_found_table(CSTR table_name, ast_node *table_ast, void* pvContext) {
  json_context *context = (json_context *)pvContext;
  Contract(context->cookie == cookie_str);  // sanity check
  Contract(context->used_tables);

  ast_node *proc_ast = context->proc_ast;

  if (is_ast_create_proc_stmt(proc_ast)) {
    Contract(tables_to_procs);

    charbuf* output = symtab_ensure_charbuf(tables_to_procs, table_name);

    // Get the proc name and add it to the list for this table
    add_name_to_output(output, proc_ast);
  }

  add_name_to_output(context->used_tables, table_ast);
}

static void cg_found_insert(CSTR table_name, ast_node *table_ast, void *pvContext)
{
  json_context *context = (json_context *)pvContext;
  Contract(context->cookie == cookie_str);  // sanity check

  add_name_to_output(context->insert_tables, table_ast);
}

static void cg_found_update(CSTR table_name, ast_node *table_ast, void *pvContext)
{
  json_context *context = (json_context *)pvContext;
  Contract(context->cookie == cookie_str);  // sanity check

  add_name_to_output(context->update_tables, table_ast);
}

static void cg_found_delete(CSTR table_name, ast_node *table_ast, void *pvContext)
{
  json_context *context = (json_context *)pvContext;
  Contract(context->cookie == cookie_str);  // sanity check

  add_name_to_output(context->delete_tables, table_ast);
}

static void cg_found_from(CSTR table_name, ast_node *table_ast, void *pvContext)
{
  json_context *context = (json_context *)pvContext;
  Contract(context->cookie == cookie_str);  // sanity check
  add_name_to_output(context->from_tables, table_ast);
}

static void cg_found_proc(CSTR proc_name, ast_node *name_ast, void *pvContext)
{
  json_context *context = (json_context *)pvContext;
  Contract(context->cookie == cookie_str);  // sanity check
  add_name_to_output(context->used_procs, name_ast);
}

// When processing generated SQL we get a callback every time a variable appears
// in the output stream.  This method records the variable name for use later
// in the _parameters array.
static bool_t cg_json_record_var(struct ast_node *_Nonnull ast, void *_Nullable context, charbuf *_Nonnull output) {
  // If this invariant fails that means the code is using cg_fragment when
  // cg_fragment_with_params is required (because variables were used).
  Invariant(context);
  charbuf *var = (charbuf *)context;

  bprintf(output, "?");
  if (var->used > 1) {
    bprintf(var, ", ");
  }
  bprintf(var, "\"%s\"", ast->sem->name);
  return true;
}

static void cg_json_test_details(charbuf *output, ast_node *ast, ast_node *misc_attrs) {
  if (options.test) {
    bprintf(output, "\nThe statement ending at line %d\n", ast->lineno);
    bprintf(output, "\n");

    gen_set_output_buffer(output);
    if (misc_attrs) {
      gen_with_callbacks(misc_attrs, gen_misc_attrs, NULL);
    }
    gen_with_callbacks(ast, gen_one_stmt, NULL);
    bprintf(output, "\n\n");
  }
}

// Just extract a name from the AST and emit it
static void cg_json_name(charbuf *output, ast_node *ast) {
  EXTRACT_STRING(name, ast);
  bprintf(output, "%s", name);
}

// Emit a quoted string into the JSON
static void cg_json_emit_string(charbuf *output, ast_node *ast) {
  Invariant(is_strlit(ast));
  EXTRACT_STRING(str, ast);

  // note str is the lexeme, so it is still quoted and escaped
  CHARBUF_OPEN(str1);
  CHARBUF_OPEN(str2);
  // requote it as a c style literal
  cg_decode_string_literal(str, &str1);
  cg_encode_json_string_literal(str1.ptr, &str2);
  bprintf(output, "%s", str2.ptr);
  CHARBUF_CLOSE(str2);
  CHARBUF_CLOSE(str1);
}

// Emit out a single miscellaneous attribute value into the current output stream
// We could be processing any kind of entity, we don't care.  We're just
// emitting a single value here.  The legal values are:
// * a list of nested values
// * an integer literal
// * a double literal
// * a string literal
// * a name
// * a quoted name `foo bar`
// * null
// String literals have to be unescaped from SQL format and reescaped into C format
static void cg_json_attr_value(charbuf *output, ast_node *ast) {
  if (is_ast_misc_attr_value_list(ast)) {
    bprintf(output, "[");
    for (ast_node *item = ast; item; item = item->right) {
      cg_json_attr_value(output, item->left);
      if (item->right) {
        bprintf(output, ", ");
      }
    }
    bprintf(output, "]");
  }
  else if (is_ast_str(ast)) {
    EXTRACT_STRING(str, ast);

    if (is_strlit(ast)) {
      cg_json_emit_string(output, ast);
    }
    else {
      // an identifier or QID
      cg_json_sql_name_ex(output, str, is_qid(ast));
    }
  }
  else if (is_ast_null(ast)) {
    // Null must be all in lowercase to be valid json, so we need a special case
    bprintf(output, "null");
  }
  else {
    gen_set_output_buffer(output);
    gen_sql_callbacks callbacks;
    init_gen_sql_callbacks(&callbacks);
    callbacks.mode = gen_mode_sql;
    callbacks.convert_hex = true;  // json doesn't support hex numbers
    gen_with_callbacks(ast, gen_root_expr, &callbacks);
  }
}

// Emit a single miscellaneous attribute name/value pair
// The name could be of the form foo:bar in which case we emit foo_bar
// The value is any of the legal values handled above in cg_json_attr_value.
static void cg_json_misc_attr(charbuf *output, ast_node *ast) {
  Contract(is_ast_misc_attr(ast));
  bprintf(output, "{\n");
  BEGIN_INDENT(attr, 2);
  bprintf(output, "\"name\" : \"");
  if (is_ast_dot(ast->left)) {
    cg_json_name(output, ast->left->left);
    bprintf(output, ":");
    cg_json_name(output, ast->left->right);
  }
  else {
    cg_json_name(output, ast->left);
  }
  bprintf(output, "\",\n\"value\" : ");
  if (ast->right) {
    cg_json_attr_value(output, ast->right);
  }
  else {
    bprintf(output, "1");
  }
  END_INDENT(attr);
  bprintf(output, "\n}");
}

// Emit a list of attributes for the current entity, it could be any kind of entity.
// Whatever it is we spit out the attributes here in array format.
static void cg_json_misc_attrs(charbuf *output, ast_node *_Nonnull list) {
  Contract(is_ast_misc_attrs(list));
  bprintf(output, "\"attributes\" : [\n");
  BEGIN_INDENT(attr, 2);
  BEGIN_LIST;

  for (ast_node *item = list; item; item = item->right) {
    COMMA;
    cg_json_misc_attr(output, item->left);
  }
  END_LIST;
  END_INDENT(attr);
  bprintf(output, "]");
}

// The column has its definition and attributes, output for the column goes
// into the direct output and maybe to the deferred outputs.  For instance if
// a column in an FK then is FKness is emitted into the fk buffer for later use
// in the fk section.
typedef struct col_info {
  // Inputs
  ast_node *def;
  ast_node *attrs;
  bool_t is_backed;  // true if the table we're emitting is backed

  // We write to these
  charbuf *col_pk;
  charbuf *col_uk;
  charbuf *col_fk;
} col_info;


static void cg_json_default_value(charbuf *output, ast_node *def) {
  if (is_ast_uminus(def)) {
    def = def->left;
    bprintf(output, "-");
  }
  cg_json_attr_value(output, def);
}

// Emits the JSON for all ad-hoc migration procs as a list
static void cg_json_ad_hoc_migration_procs(charbuf* output) {
  bprintf(output, "\"adHocMigrationProcs\" : [\n");
  BEGIN_INDENT(list, 2);
  BEGIN_LIST;

  for (list_item *item = all_ad_hoc_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_schema_ad_hoc_migration_stmt(ast));

    EXTRACT(version_annotation, ast->left);
    EXTRACT_OPTION(version, version_annotation->left);
    EXTRACT_STRING(name, version_annotation->right);

    ast_node *misc_attrs = NULL;
    ast_node *attr_target = ast->parent;
    if (is_ast_stmt_and_attr(attr_target)) {
      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target->parent);
      misc_attrs = misc;
    }

    cg_json_test_details(output, ast, misc_attrs);

    COMMA;
    bprintf(output, "{\n");
    BEGIN_INDENT(t, 2);
    bprintf(output, "\"name\" : \"%s\",\n", name);
    bprintf(output, "\"CRC\" : \"%lld\",\n", crc_stmt(ast));

    if (misc_attrs) {
      cg_json_misc_attrs(output, misc_attrs);
      bprintf(output, ",\n");
    }

    bprintf(output, "\"version\" : %d", version);
    END_INDENT(t);
    bprintf(output, "\n}");
  }

  uint32_t count = ad_hoc_recreate_actions->count;
  symtab_entry *actions = symtab_copy_sorted_payload(ad_hoc_recreate_actions, default_symtab_comparator);

  for (uint32_t i = 0; i < count; i++) {
    ast_node *ast = (ast_node *)actions[i].val;
    EXTRACT_STRING(group, ast->left);
    EXTRACT_STRING(proc, ast->right);

    ast_node *misc_attrs = NULL;
    ast_node *attr_target = ast->parent;
    if (is_ast_stmt_and_attr(attr_target)) {
      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target->parent);
      misc_attrs = misc;
    }

    cg_json_test_details(output, ast, misc_attrs);

    COMMA;
    bprintf(output, "{\n");
    BEGIN_INDENT(t, 2);
    bprintf(output, "\"name\" : \"%s\",\n", proc);
    bprintf(output, "\"CRC\" : \"%lld\",\n", crc_stmt(ast));

    if (misc_attrs) {
      cg_json_misc_attrs(output, misc_attrs);
      bprintf(output, ",\n");
    }

    bprintf(output, "\"onRecreateOf\" : \"%s\"", group);
    END_INDENT(t);
    bprintf(output, "\n}");
  }
  free(actions);

  END_LIST;
  END_INDENT(list);
  bprintf(output, "]");
}

// Emits the name and value for each value in the enumeration
static void cg_json_enum_values(ast_node *enum_values, charbuf *output) {
  Contract(is_ast_enum_values(enum_values));

  bprintf(output, "\"values\" : [\n");

  BEGIN_INDENT(list, 2);
  BEGIN_LIST;

  while (enum_values) {
     EXTRACT_NOTNULL(enum_value, enum_values->left);
     EXTRACT_NAME_AST(enum_name_ast, enum_value->left);
     EXTRACT_STRING(enum_name, enum_name_ast);

     COMMA;
     bprintf(output, "{\n");

     bprintf(output, "  \"name\" : \"%s\",\n", enum_name);
     bprintf(output, "  \"value\" : ");
     eval_format_number(enum_name_ast->sem->value, EVAL_FORMAT_NORMAL, output);
     bprintf(output, "\n}");

     enum_values = enum_values->right;
  }

  END_LIST;
  END_INDENT(list);

  bprintf(output, "]\n");
}

// Emits the JSON for all enumerations
static void cg_json_enums(charbuf* output) {
  bprintf(output, "\"enums\" : [\n");
  BEGIN_INDENT(list, 2);
  BEGIN_LIST;

  for (list_item *item = all_enums_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_declare_enum_stmt(ast));
    EXTRACT_NOTNULL(typed_name, ast->left);
    EXTRACT_NOTNULL(enum_values, ast->right);
    EXTRACT_ANY(name_ast, typed_name->left);
    EXTRACT_STRING(name, name_ast);
    EXTRACT_ANY_NOTNULL(type, typed_name->right);

    cg_json_test_details(output, ast, NULL);

    COMMA;
    bprintf(output, "{\n");
    BEGIN_INDENT(t, 2);
    bprintf(output, "\"name\" : \"%s\",\n", name);
    cg_json_data_type(output, type->sem->sem_type | SEM_TYPE_NOTNULL, NULL);
    bprintf(output, ",\n");

    cg_json_enum_values(enum_values, output);

    END_INDENT(t);
    bprintf(output, "}");
  }

  END_LIST;
  END_INDENT(list);
  bprintf(output, "]");
}

// emits the type and value for each constant in the constant group
static void cg_json_const_values(ast_node *const_values, charbuf *output) {
  Contract(is_ast_const_values(const_values));

  bprintf(output, "\"values\" : [\n");

  BEGIN_INDENT(list, 2);
  BEGIN_LIST;

  while (const_values) {
     EXTRACT_NOTNULL(const_value, const_values->left);
     EXTRACT_NAME_AST(const_name_ast, const_value->left);
     EXTRACT_STRING(const_name, const_name_ast);
     EXTRACT_ANY_NOTNULL(const_expr, const_value->right);

     COMMA;
     bprintf(output, "{\n");

     bprintf(output, "  \"name\" : \"%s\",\n", const_name);
     BEGIN_INDENT(type, 2);
       cg_json_data_type(output, const_expr->sem->sem_type, const_expr->sem->kind);
     END_INDENT(type);
     bprintf(output, ",\n");
     bprintf(output, "  \"value\" : ");

     if (is_strlit(const_expr)) {
       cg_json_emit_string(output, const_expr);
     }
     else {
       eval_format_number(const_expr->sem->value, EVAL_FORMAT_NORMAL, output);
     }

     bprintf(output, "\n}");

     const_values = const_values->right;
  }

  END_LIST;
  END_INDENT(list);

  bprintf(output, "]\n");
}

// Emits the JSON for all the global constants
// note that these are in groups for convenience but they are all global
// scope, not like enums.
static void cg_json_constant_groups(charbuf* output) {
  bprintf(output, "\"constantGroups\" : [\n");
  BEGIN_INDENT(list, 2);
  BEGIN_LIST;

  for (list_item *item = all_constant_groups_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_declare_const_stmt(ast));
    EXTRACT_NAME_AST(name_ast, ast->left);
    EXTRACT_NOTNULL(const_values, ast->right);
    EXTRACT_STRING(name, name_ast);

    cg_json_test_details(output, ast, NULL);

    COMMA;
    bprintf(output, "{\n");
    BEGIN_INDENT(t, 2);
    bprintf(output, "\"name\" : \"%s\",\n", name);

    cg_json_const_values(const_values, output);

    END_INDENT(t);
    bprintf(output, "}");
  }

  END_LIST;
  END_INDENT(list);
  bprintf(output, "]");
}

// Emits the JSON for all the unsubscription directives
static void cg_json_subscriptions(charbuf* output) {
  bprintf(output, "\"subscriptions\" : [\n");
  BEGIN_INDENT(list, 2);
  BEGIN_LIST;

  for (list_item *item = all_subscriptions_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_schema_unsub_stmt(ast));

    EXTRACT_NOTNULL(version_annotation, ast->left);
    EXTRACT_OPTION(vers, version_annotation->left);
    EXTRACT_STRING(name, version_annotation->right);
    CSTR region = ast->sem->region;

    cg_json_test_details(output, ast, NULL);

    COMMA;
    bprintf(output, "{\n");
    BEGIN_INDENT(t, 2);
    bprintf(output, "\"type\" : \"unsub\",\n");
    bprintf(output, "\"table\" : \"%s\"", name);
    if (region) {
      cg_json_emit_region_info(output, ast);
    }
    bprintf(output, ",\n\"version\" : %d\n", vers);
    END_INDENT(t);
    bprintf(output, "}");
  }

  END_LIST;
  END_INDENT(list);
  bprintf(output, "]");
}

static void cg_migration_proc(ast_node *ast, charbuf *output) {
  if (is_ast_dot(ast)) {
    EXTRACT_NOTNULL(dot, ast);
    EXTRACT_STRING(lhs, dot->left);
    EXTRACT_STRING(rhs, dot->right);
    bprintf(output,"\"%s:%s\"", lhs, rhs);
  }
  else {
    EXTRACT_STRING(migration_proc_name, ast);
    bprintf(output,"\"%s\"", migration_proc_name);
  }
}

// Searches for an "ast_create" node from a list and emits the name of the migration
// proc associated with it, if any
static void cg_json_added_migration_proc(charbuf *output, ast_node *list) {
  for (ast_node *attr = list; attr; attr = attr->right) {
    if (is_ast_create_attr(attr)){
      EXTRACT(version_annotation, attr->left);
      if (version_annotation && version_annotation->right) {
        bprintf(output,",\n\"addedMigrationProc\" : ");
        cg_migration_proc(version_annotation->right, output);
      }
    }
  }
}

// Searches for an "ast_delete" node from a list and emits the name of the migration
// proc associated with it, if any
static void cg_json_deleted_migration_proc(charbuf *output, ast_node *list) {
  for (ast_node *attr = list; attr; attr = attr->right) {
    if (is_ast_delete_attr(attr)){
      EXTRACT(version_annotation, attr->left);
      if (version_annotation && version_annotation->right) {
        bprintf(output,",\n\"deletedMigrationProc\" : ");
        cg_migration_proc(version_annotation->right, output);
      }
    }
  }
}

// Crack the semantic info for the column and emit that into the main output
// examine the attributes and emit those as needed.
static void cg_json_col_attrs(charbuf *output, col_info *info) {
  // most of the attributes are in the semantic type, we don't have to walk the tree for them
  // we do need to check for a default value.
  // Note that there are implications associated with this flags and semantic analysis
  // makes those conclusions (e.g. pk implies not null)
  // We don't want that logic again so we use the semantic type not the raw declaration

  ast_node *col = info->def;

  sem_t sem_type = col->sem->sem_type;
  CSTR name = col->sem->name;

  bool_t is_added = col->sem->create_version > 0;
  bool_t is_deleted = col->sem->delete_version > 0;
  bprintf(output, ",\n\"isAdded\" : %d", is_added);
  if (is_added) {
    bprintf(output, ",\n\"addedVersion\" : %d", col->sem->create_version);
    cg_json_added_migration_proc(output, info->attrs);
  }
  bprintf(output, ",\n\"isDeleted\" : %d", is_deleted);
  if (is_deleted) {
    bprintf(output, ",\n\"deletedVersion\" : %d", col->sem->delete_version);
    cg_json_deleted_migration_proc(output, info->attrs);
  }

  if (sem_type & SEM_TYPE_PK) {
    cg_json_sql_name_ex(info->col_pk, name, !!(sem_type & SEM_TYPE_QID));
  }

  if (sem_type & SEM_TYPE_UK) {
    if (info->col_uk->used > 1) {
      bprintf(info->col_uk, ",\n");
    }
    CHARBUF_OPEN(tmp);
    bprintf(&tmp, "%s_uk", name);
    bool_t is_qid = !!(sem_type & SEM_TYPE_QID);

    bprintf(info->col_uk, "{\n");
    bprintf(info->col_uk, "  \"name\" : ");
    cg_json_sql_name_ex(info->col_uk, tmp.ptr, is_qid);
    bprintf(info->col_uk, ",\n");
    bprintf(info->col_uk, "  \"columns\" : [ ");
    cg_json_sql_name_ex(info->col_uk, name, is_qid);
    bprintf(info->col_uk, " ],\n");
    bprintf(info->col_uk, "  \"sortOrders\" : [ \"\" ]\n");
    bprintf(info->col_uk, "}");

    CHARBUF_CLOSE(tmp);
  }

  // There could be several foreign keys, we have to walk the list of attributes and gather them all
  for (ast_node *attr = info->attrs; attr; attr = attr->right) {
    charbuf *saved = output;
    output = info->col_fk;
    if (is_ast_col_attrs_fk(attr)) {
      if (output->used > 1) {
        bprintf(output, ",\n");
      }
      bprintf(output, "{\n");
      BEGIN_INDENT(fk, 2)
      bprintf(output, "\"columns\" : [ \"%s\" ]", name);
      cg_json_fk_target_options(output, attr->left);
      END_INDENT(fk);
      bprintf(output,"\n}");
    }
    output = saved;
  }

  if (sem_type & SEM_TYPE_HAS_DEFAULT) {
    bprintf(output, ",\n\"defaultValue\" : ");
    cg_json_default_value(output, sem_get_col_default_value(info->attrs));
  }

  if (sem_type & SEM_TYPE_HAS_COLLATE) {
    // find the collate attribute and emit it (there can only be one)
    for (ast_node *attr = info->attrs; attr; attr = attr->right) {
      if (is_ast_col_attrs_collate(attr)) {
        bprintf(output, ",\n\"collate\" : ");
        cg_json_attr_value(output, attr->left);
      }
    }
  }

  if (sem_type & SEM_TYPE_HAS_CHECK) {
    // find the check attribute and emit it (there can only be one)
    for (ast_node *attr = info->attrs; attr; attr = attr->right) {
      if (is_ast_col_attrs_check(attr)) {
        EXTRACT_ANY_NOTNULL(when_expr, attr->left);
        cg_fragment_with_params(output, "checkExpr", when_expr, gen_root_expr);
      }
    }
  }

  if (info->is_backed) {
    bprintf(output, ",\n\"typeHash\" : %s", get_field_hash(name, sem_type));
  }

  // end with mandatory columns, this makes the json validation with yacc a little easier
  bprintf(output, ",\n\"isPrimaryKey\" : %d", !!(sem_type & SEM_TYPE_PK));
  bprintf(output, ",\n\"isUniqueKey\" : %d", !!(sem_type & SEM_TYPE_UK));
  bprintf(output, ",\n\"isAutoIncrement\" : %d", !!(sem_type & SEM_TYPE_AUTOINCREMENT));
}

// Starting from a semantic type, emit the appropriate JSON type
static void cg_json_data_type(charbuf *output, sem_t sem_type, CSTR kind) {
  sem_t core_type = core_type_of(sem_type);

  BEGIN_LIST;
  COMMA;
  bprintf(output, "\"type\" : \"");

  switch (core_type) {
    case SEM_TYPE_INTEGER:      bprintf(output, "integer"); break;
    case SEM_TYPE_TEXT:         bprintf(output, "text"); break;
    case SEM_TYPE_BLOB:         bprintf(output, "blob"); break;
    case SEM_TYPE_BOOL:         bprintf(output, "bool"); break;
    case SEM_TYPE_REAL:         bprintf(output, "real"); break;
    case SEM_TYPE_LONG_INTEGER: bprintf(output, "long"); break;
    case SEM_TYPE_OBJECT:       bprintf(output, "object"); break;
  }
  bprintf(output, "\"");

  if (kind) {
    COMMA;
    bprintf(output, "\"kind\" : \"%s\"", kind);
  }

  bool_t sensitive = !!sensitive_flag(sem_type);

  if (sensitive) {
    COMMA;
    bprintf(output, "\"isSensitive\" : %d", sensitive);
  }

  COMMA;
  bprintf(output, "\"isNotNull\" : %d", !is_nullable(sem_type));
}

// Starting with a column definition, emit the name and type information
// for the column.  If there are any miscellaneous attributes emit them as well.
// Finally gather the column attributes like not null etc. and emit those using
// the helper methods above.
static void cg_json_col_def(charbuf *output, col_info *info) {
  ast_node *def = info->def;

  Contract(is_ast_col_def(def));
  EXTRACT_NOTNULL(col_def_type_attrs, def->left);
  EXTRACT(misc_attrs, def->right);
  EXTRACT_ANY(attrs, col_def_type_attrs->right);
  EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
  EXTRACT_NAME_AST(name_ast, col_def_name_type->left);

  bprintf(output, "{\n");
  BEGIN_INDENT(col, 2);

  bprintf(output, "\"name\" : ");
  cg_json_sql_name(output, name_ast);
  bprintf(output, ",\n");

  if (misc_attrs) {
    cg_json_misc_attrs(output, misc_attrs);
    bprintf(output, ",\n");
  }
  cg_json_data_type(output, def->sem->sem_type, def->sem->kind);

  info->attrs = attrs;
  cg_json_col_attrs(output, info);

  END_INDENT(col);
  bprintf(output, "\n}");
}

// Emits a list of names into a one-line array of quoted names
static void cg_json_name_list(charbuf *output, ast_node *list) {
  Contract(is_ast_name_list(list));

  for (ast_node *item = list; item; item = item->right) {
    bprintf(output, "\"");
    cg_json_name(output, item->left);
    bprintf(output, "\"");
    if (item->right) {
      bprintf(output, ", ");
    }
  }
}

// This is useful for expressions known to have no parameters (e.g. constraint expressions)
// variables are illegal in such things so there can be no binding needed
static void cg_json_vanilla_expr(charbuf *output, ast_node *expr) {
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_echo; // we want all the text, unexpanded, so NOT for sqlite output (this is raw echo)
  gen_set_output_buffer(output);
  gen_with_callbacks(expr, gen_root_expr, &callbacks);
}

// Similar to the above, this is also a list of names but we emit two arrays
// one array for the names and another array for the sort orders specified if any.
// Note unspecified sort orders are emitted as "".
static void cg_json_indexed_columns(charbuf *cols, charbuf *orders, ast_node *list) {
  for (ast_node *item = list; item; item = item->right) {
    Contract(is_ast_indexed_columns(list));
    EXTRACT_NOTNULL(indexed_column, item->left);

    bprintf(cols, "\"");
    cg_json_vanilla_expr(cols, indexed_column->left);
    bprintf(cols, "\"");

    if (is_ast_asc(indexed_column->right)) {
      bprintf(orders, "\"asc\"");
    }
    else if (is_ast_desc(indexed_column->right)) {
      bprintf(orders, "\"desc\"");
    }
    else {
      bprintf(orders, "\"\"");
    }

    if (item->right) {
      bprintf(cols, ", ");
      bprintf(orders, ", ");
    }
  }
}

// The primary key def is emitted just as an ordinary name list
static void cg_json_pk_def(charbuf *output, ast_node *def) {
  Contract(is_ast_pk_def(def));
  EXTRACT_NOTNULL(indexed_columns_conflict_clause, def->right);
  EXTRACT_NOTNULL(indexed_columns, indexed_columns_conflict_clause->left);

  CHARBUF_OPEN(cols);
  CHARBUF_OPEN(orders);

  cg_json_indexed_columns(&cols, &orders, indexed_columns);

  bprintf(output, "\"primaryKey\" : [ %s ]", cols.ptr);
  bprintf(output, ",\n\"primaryKeySortOrders\" : [ %s ],\n", orders.ptr);

  CHARBUF_CLOSE(orders);
  CHARBUF_CLOSE(cols);
}

// This is just a little wrapper to set up the buffer to get the FK
// resolution action emitted without cloning that code.  gen_fk_action
// has a different contract than the usual generators (it doesn't take an AST)
// so I can't use the usual fragment helpers.
static void cg_json_action(charbuf *output, int32_t action) {
  CHARBUF_OPEN(sql);
  gen_set_output_buffer(&sql);
  if (!action) {
    action = FK_NO_ACTION;
  }
  gen_fk_action(action);
  bprintf(output, "\"%s\"", sql.ptr);
  CHARBUF_CLOSE(sql);
}

// Here we generate the update and delete actions plus the isDeferred state
// Everything is sitting pretty in the AST.
static void cg_json_fk_flags(charbuf *output, int32_t flags) {
  int32_t action = (flags & FK_ON_UPDATE) >> 4;

  bprintf(output, ",\n\"onUpdate\" : ");
  cg_json_action(output, action);

  action = (flags & FK_ON_DELETE);
  bprintf(output, ",\n\"onDelete\" : ");
  cg_json_action(output, action);

  // in sqlite anything that is not:
  // DEFERRABLE INITIALLY DEFERRED  is immediate
  // See 4.2. Deferred Foreign Key Constraints

  bool_t deferred = (flags & FK_DEFERRABLE) && (flags & FK_INITIALLY_DEFERRED);
  bprintf(output, ",\n\"isDeferred\" : %d", deferred);
}

// Generates the properties for a foreign key's target and the options
// that means the referencedTable, the columns as well as the flags
// using the helper above.
static void cg_json_fk_target_options(charbuf *output, ast_node *ast) {
  Contract(is_ast_fk_target_options(ast));

  EXTRACT_NOTNULL(fk_target, ast->left);
  EXTRACT_OPTION(flags, ast->right);
  EXTRACT_STRING(table_name, fk_target->left);
  EXTRACT_NAMED_NOTNULL(ref_list, name_list, fk_target->right);

  bprintf(output, ",\n\"referenceTable\" : \"%s\"", table_name);

  bprintf(output, ",\n\"referenceColumns\" : [ ");
  cg_json_name_list(output, ref_list);
  bprintf(output, " ]");
  cg_json_fk_flags(output, flags);
}

static void cg_json_opt_constraint_name(charbuf *output, ast_node *def) {
  if (def->left) {
    EXTRACT_NAME_AST(constraint_name_ast, def->left);
    bprintf(output, "\"name\" : ");
    cg_json_sql_name(output, constraint_name_ast);
    bprintf(output, ",\n");
  }
}

// A full FK definition consists of the constrained columns
// and the FK target.  This takes care of the columns and defers
// to the above for the target (the target is used in other cases too)
static void cg_json_fk_def(charbuf *output, ast_node *def) {
  Contract(is_ast_fk_def(def));
  EXTRACT_NOTNULL(fk_info, def->right);
  EXTRACT_NAMED_NOTNULL(src_list, name_list, fk_info->left);
  EXTRACT_NOTNULL(fk_target_options, fk_info->right);

  cg_json_opt_constraint_name(output, def);

  bprintf(output, "\"columns\" : [ ");
  cg_json_name_list(output, src_list);
  bprintf(output, " ]");

  cg_json_fk_target_options(output, fk_target_options);
}

// A unique key definition is just the name of the key and then
// the participating columns.
static void cg_json_unq_def(charbuf *output, ast_node *def) {
  Contract(is_ast_unq_def(def));
  EXTRACT_NOTNULL(indexed_columns_conflict_clause, def->right);
  EXTRACT_NOTNULL(indexed_columns, indexed_columns_conflict_clause->left);

  bprintf(output, "{\n");
  BEGIN_INDENT(uk, 2);
  cg_json_opt_constraint_name(output, def);

  CHARBUF_OPEN(cols);
  CHARBUF_OPEN(orders);

  cg_json_indexed_columns(&cols, &orders, indexed_columns);

  bprintf(output, "\"columns\" : [ %s ]", cols.ptr);
  bprintf(output, ",\n\"sortOrders\" : [ %s ]", orders.ptr);

  CHARBUF_CLOSE(orders);
  CHARBUF_CLOSE(cols);

  END_INDENT(uk);
  bprintf(output, "\n}");
}

// A check constraint is just an expression, possibly named
static void cg_json_check_def(charbuf *output, ast_node *def) {
  Contract(is_ast_check_def(def));
  EXTRACT_ANY_NOTNULL(expr, def->right);

  bprintf(output, "{\n");
  BEGIN_INDENT(chk, 2);
  cg_json_opt_constraint_name(output, def);
  cg_fragment_with_params_raw(output, "checkExpr", expr, gen_root_expr);
  END_INDENT(chk);
  bprintf(output, "\n}");
}

// This is the list of "columns and keys" that form a table. In order to
// organize these we make several passes on the column list. We loop once
// for the columns then again for the PKs, then the FK, and finally UK.
// Note that in each case there is a chance that columns will contribute to
// the contents with keys that are defined directly on the column.
// That's ok, those are just buffered up and emitted with each section.
// All this several passes business just results in for sure all the column direct
// stuff comes before non column related stuff in each section.
static void cg_json_col_key_list(charbuf *output, ast_node *ast) {
  Contract(is_ast_create_table_stmt(ast));
  EXTRACT_ANY(list, ast->right);
  Contract(is_ast_col_key_list(list));

  CHARBUF_OPEN(col_pk);
  CHARBUF_OPEN(col_uk);
  CHARBUF_OPEN(col_fk);

  col_info info;
  info.col_pk = &col_pk;
  info.col_uk = &col_uk;
  info.col_fk = &col_fk;
  info.is_backed = is_backed(ast->sem->sem_type);

  {
    bprintf(output, "\"columns\" : [\n");
    BEGIN_INDENT(cols, 2);
    BEGIN_LIST;
    for (ast_node *item = list; item; item = item->right) {
      EXTRACT_ANY_NOTNULL(def, item->left);
      if (is_ast_col_def(def)) {
        COMMA;
        info.def = def;
        info.attrs = NULL;
        cg_json_col_def(output, &info);
      }
    }
    END_LIST;
    END_INDENT(cols);
    bprintf(output, "],\n");
  }

  ast_node *pk_def = NULL;

  {
    if (col_pk.used > 1) {
      bprintf(output, "\"primaryKey\" : [ %s ],\n", col_pk.ptr);
      bprintf(output, "\"primaryKeySortOrders\" : [ \"\" ],\n");
    }
    else {
      for (ast_node *item = list; item; item = item->right) {
        EXTRACT_ANY_NOTNULL(def, item->left);
        if (is_ast_pk_def(def)) {
          cg_json_pk_def(output, def);
          pk_def = def;
        }
      }
      if (!pk_def) {
        bprintf(output, "\"primaryKey\" : [  ],\n");
        bprintf(output, "\"primaryKeySortOrders\" : [  ],\n");
      }
    }
  }


  if (pk_def && pk_def->left) {
    EXTRACT_STRING(pk_name, pk_def->left);
    bprintf(output, "\"primaryKeyName\" : \"%s\",\n", pk_name);
  }

  {
    bprintf(output, "\"foreignKeys\" : [\n");
    BEGIN_INDENT(fks, 2);
    BEGIN_LIST;
    if (col_fk.used > 1) {
      COMMA;
      bprintf(output, "%s", col_fk.ptr);
    }
    for (ast_node *item = list; item; item = item->right) {
      EXTRACT_ANY_NOTNULL(def, item->left);
      if (is_ast_fk_def(def)) {
        COMMA;
        bprintf(output, "{\n");
        BEGIN_INDENT(fk, 2);
        cg_json_fk_def(output, def);
        END_INDENT(fk);
        bprintf(output, "\n}");
      }
    }
    END_LIST;
    END_INDENT(fks);
    bprintf(output, "],\n");
  }

  {
    bprintf(output, "\"uniqueKeys\" : [\n");
    BEGIN_INDENT(uk, 2);
    BEGIN_LIST;
    if (col_uk.used > 1) {
      COMMA;
      bprintf(output, "%s", col_uk.ptr);
    }
    for (ast_node *item = list; item; item = item->right) {
      EXTRACT_ANY_NOTNULL(def, item->left);
      if (is_ast_unq_def(def)) {
        COMMA;
        cg_json_unq_def(output, def);
      }
    }
    END_LIST;
    END_INDENT(uk);
    bprintf(output, "],\n");
  }

  {
    bprintf(output, "\"checkExpressions\" : [\n");
    BEGIN_INDENT(chk, 2);
    BEGIN_LIST;
    for (ast_node *item = list; item; item = item->right) {
      EXTRACT_ANY_NOTNULL(def, item->left);
      if (is_ast_check_def(def)) {
        COMMA;
        cg_json_check_def(output, def);
      }
    }
    END_LIST;
    END_INDENT(chk);
    bprintf(output, "]");
  }

  CHARBUF_CLOSE(col_fk);
  CHARBUF_CLOSE(col_uk);
  CHARBUF_CLOSE(col_pk);
}

// Here we walk all the indices, extract out the key info for each index and
// emit it.  The indices have a few flags plus columns and a sort order for
// each column.
static void cg_json_indices(charbuf *output) {
  bprintf(output, "\"indices\" : [\n");
  BEGIN_INDENT(indices, 2);
  BEGIN_LIST;

  for (list_item *item = all_indices_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_index_stmt(ast));

    EXTRACT_NOTNULL(create_index_on_list, ast->left);
    EXTRACT_NOTNULL(flags_names_attrs, ast->right);
    EXTRACT_NOTNULL(connector, flags_names_attrs->right);
    EXTRACT_NOTNULL(index_names_and_attrs, connector->left);
    EXTRACT_OPTION(flags, flags_names_attrs->left);
    EXTRACT_NOTNULL(indexed_columns, index_names_and_attrs->left);
    EXTRACT(opt_where, index_names_and_attrs->right);
    EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);
    EXTRACT_NAME_AST(table_name_ast, create_index_on_list->right);
    EXTRACT_STRING(table_name, table_name_ast);

    ast_node *misc_attrs = NULL;
    ast_node *attr_target = ast->parent;
    if (is_ast_stmt_and_attr(attr_target)) {
      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target->parent);
      misc_attrs = misc;
    }

    cg_json_test_details(output, ast, misc_attrs);

    COMMA;
    bprintf(output, "{\n");

    BEGIN_INDENT(index, 2);

    bool_t is_deleted = ast->sem->delete_version > 0;
    bprintf(output, "\"name\" : ");
    cg_json_sql_name(output, index_name_ast);
    bprintf(output, ",\n\"CRC\" : \"%lld\"", crc_stmt(ast));
    bprintf(output, ",\n\"table\" : ");
    cg_json_sql_name(output, table_name_ast);
    bprintf(output, ",\n\"isUnique\" : %d", !!(flags & INDEX_UNIQUE));
    bprintf(output, ",\n\"ifNotExists\" : %d", !!(flags & INDEX_IFNE));
    bprintf(output, ",\n\"isDeleted\" : %d", is_deleted);
    if (is_deleted) {
      bprintf(output, ",\n\"deletedVersion\" : %d", ast->sem->delete_version);
    }

    if (ast->sem->region) {
      cg_json_emit_region_info(output, ast);
    }

    if (opt_where) {
      bprintf(output, ",\n\"where\" : \"");
      cg_json_vanilla_expr(output, opt_where->left);
      bprintf(output, "\"");
    }

    if (misc_attrs) {
      bprintf(output, ",\n");
      cg_json_misc_attrs(output, misc_attrs);
    }

    CHARBUF_OPEN(cols);
    CHARBUF_OPEN(orders);

    cg_json_indexed_columns(&cols, &orders, indexed_columns);

    bprintf(output, ",\n\"columns\" : [ %s ]", cols.ptr);
    bprintf(output, ",\n\"sortOrders\" : [ %s ]", orders.ptr);

    CHARBUF_CLOSE(orders);
    CHARBUF_CLOSE(cols);

    END_INDENT(index);
    bprintf(output, "\n}");
  }

  END_INDENT(indices);
  END_LIST;
  bprintf(output, "]");
}

static void cg_json_opt_bool(charbuf *output, int32_t flag, CSTR desc) {
  if (flag) {
    bprintf(output, ",\n\"%s\" : 1", desc);
  }
}

// Here we walk all the triggers, we extract the essential flags from
// the trigger statement and emit those into the metadata as well. The main
// body is emitted verbatim.
static void cg_json_triggers(charbuf *output) {
  bprintf(output, "\"triggers\" : [\n");
  BEGIN_INDENT(indices, 2);
  BEGIN_LIST;

  for (list_item *item = all_triggers_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_trigger_stmt(ast));

    EXTRACT_OPTION(flags, ast->left);
    EXTRACT_NOTNULL(trigger_body_vers, ast->right);
    EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
    EXTRACT_NAME_AST(trigger_name_ast, trigger_def->left);
    EXTRACT_NOTNULL(trigger_condition, trigger_def->right);
    EXTRACT_OPTION(cond_flags, trigger_condition->left);
    flags |= cond_flags;
    EXTRACT_NOTNULL(trigger_op_target, trigger_condition->right);
    EXTRACT_NOTNULL(trigger_operation, trigger_op_target->left);
    EXTRACT_OPTION(op_flags,  trigger_operation->left);
    EXTRACT(name_list, trigger_operation->right);
    flags |= op_flags;
    EXTRACT_NOTNULL(trigger_target_action, trigger_op_target->right);
    EXTRACT_STRING(table_name, trigger_target_action->left);
    EXTRACT_NOTNULL(trigger_action, trigger_target_action->right);
    EXTRACT_OPTION(action_flags, trigger_action->left);
    flags |= action_flags;
    EXTRACT_NOTNULL(trigger_when_stmts, trigger_action->right);
    EXTRACT_ANY(when_expr, trigger_when_stmts->left);
    EXTRACT_NOTNULL(stmt_list, trigger_when_stmts->right);

    ast_node *misc_attrs = NULL;
    ast_node *attr_target = ast->parent;
    if (is_ast_stmt_and_attr(attr_target)) {
      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target->parent);
      misc_attrs = misc;
    }

    cg_json_test_details(output, ast, misc_attrs);

    // use the canonical name (which may be case-sensitively different)
    ast_node *canonical_ast = find_table_or_view_even_deleted(table_name);
    ast_node *target_name_ast = sem_get_name_ast(canonical_ast);

    COMMA;
    bprintf(output, "{\n");

    BEGIN_INDENT(trigger, 2);

    bool_t is_deleted = ast->sem->delete_version > 0;
    bprintf(output, "\"name\" : ");
    cg_json_sql_name(output, trigger_name_ast);
    bprintf(output, ",\n\"CRC\" : \"%lld\"", crc_stmt(ast));
    bprintf(output, ",\n\"target\" : ");
    cg_json_sql_name(output, target_name_ast);
    bprintf(output, ",\n\"isTemp\" : %d", !!(flags & TRIGGER_IS_TEMP));
    bprintf(output, ",\n\"ifNotExists\" : %d", !!(flags & TRIGGER_IF_NOT_EXISTS));
    bprintf(output, ",\n\"isDeleted\" : %d", is_deleted);
    if (is_deleted) {
      bprintf(output, ",\n\"deletedVersion\" : %d", ast->sem->delete_version);
    }

    // only one of these
    cg_json_opt_bool(output, (flags & TRIGGER_BEFORE), "isBeforeTrigger");
    cg_json_opt_bool(output, (flags & TRIGGER_AFTER), "isAfterTrigger");
    cg_json_opt_bool(output, (flags & TRIGGER_INSTEAD_OF), "isInsteadOfTrigger");

    // only one of these
    cg_json_opt_bool(output, (flags & TRIGGER_DELETE), "isDeleteTrigger");
    cg_json_opt_bool(output, (flags & TRIGGER_INSERT), "isInsertTrigger");
    cg_json_opt_bool(output, (flags & TRIGGER_UPDATE), "isUpdateTrigger");

    cg_json_opt_bool(output, (flags & TRIGGER_FOR_EACH_ROW), "forEachRow");

    if (when_expr) {
      cg_fragment_with_params(output, "whenExpr", when_expr, gen_root_expr);
    }

    cg_fragment_with_params(output, "statement", ast, gen_one_stmt);

    if (ast->sem->region) {
      cg_json_emit_region_info(output, ast);
    }

    if (misc_attrs) {
      bprintf(output, ",\n");
      cg_json_misc_attrs(output, misc_attrs);
    }

    cg_json_dependencies(output, ast);

    END_INDENT(trigger);
    bprintf(output, "\n}");
  }

  END_INDENT(indices);
  END_LIST;
  bprintf(output, "]");
}

static void cg_json_region_deps(charbuf *output, CSTR sym) {
  // Every name we encounter has already been validated!
  ast_node *region = find_region(sym);
  Invariant(region);

  bprintf(output, "\"using\" : [ ");

  EXTRACT(region_list, region->right);
  for (ast_node *item = region_list; item; item = item->right) {
    Contract(is_ast_region_list(item));
    EXTRACT_NOTNULL(region_spec, item->left);
    EXTRACT_STRING(item_name, region_spec->left);
    bprintf(output, "\"%s\"", item_name);
    if (item->right) {
      bprintf(output, ", ");
    }
  }
  bprintf(output, " ]");

  bprintf(output, ",\n\"usingPrivately\" : [ ");

  for (ast_node *item = region_list; item; item = item->right) {
    Contract(is_ast_region_list(item));
    EXTRACT_NOTNULL(region_spec, item->left);
    EXTRACT_OPTION(type, region_spec->right);
    bprintf(output, "%d", type == PRIVATE_REGION);
    if (item->right) {
      bprintf(output, ", ");
    }
  }
  bprintf(output, " ]");
}

// To compute the deployed_in_region we only need to know its definiton
// * a normal object (not a region) indicates the region it is in by filling
//   in the region of its semantic node
// * a region indicates the deployment region it is in by filling in
//   the region of its semantic node
// * therefore to go from an object to its deployed region you first
//   get the region the object is in and then get the region that region is in
// * note that deployable regions do not necessarily cover everything so
//   if the object is in a region that is not yet in an deployable region
//   it's marked as an orphan.
static CSTR get_deployed_in_region(ast_node *ast) {
  CSTR deployedInRegion = "(orphan)";
  // if we are in no region at all, we're an orphan
  if (ast->sem->region) {
    // this is the region we are in, look it up
    ast_node *reg = find_region(ast->sem->region);

    // the region of that region is our deployment region
    if (reg->sem->region) {
       deployedInRegion = reg->sem->region;
    }
  }

  return deployedInRegion;
}

// Emit the region info and the deployment region info as needed
static void cg_json_emit_region_info(charbuf *output, ast_node *ast) {
  bprintf(output, ",\n\"region\" : \"%s\"", ast->sem->region);
  bprintf(output, ",\n\"deployedInRegion\" : \"%s\"", get_deployed_in_region(ast));
}

// Here we walk all the regions, we get the dependency information for
// that region and emit it.
//
static void cg_json_regions(charbuf *output) {
  bprintf(output, "\"regions\" : [\n");
  BEGIN_INDENT(regout, 2);
  BEGIN_LIST;

  symtab_entry *regs = symtab_copy_sorted_payload(schema_regions, default_symtab_comparator);

  for (list_item *item = all_regions_list; item; item = item->next) {
    ast_node *ast = item->ast;
    EXTRACT_STRING(name, ast->left);

    cg_json_test_details(output, ast, NULL);

    COMMA;
    bprintf(output, "{\n\"name\" : \"%s\",\n", name);
    CSTR deployedInRegion = get_deployed_in_region(ast);
    bprintf(output, "\"isDeployableRoot\" : %d,\n", !!(ast->sem->sem_type & SEM_TYPE_DEPLOYABLE));
    bprintf(output, "\"deployedInRegion\" : \"%s\",\n", deployedInRegion);
    cg_json_region_deps(output, name);
    bprintf(output, "\n}");
  }
  END_LIST;
  END_INDENT(regout);
  bprintf(output, "]");
  free(regs);
}

// Emit the result columns in the select list -- their names and types.
// This is the projection of the select.
static void cg_json_projection(charbuf *output, ast_node *ast) {
  Contract(ast);
  Contract(ast->sem);

  sem_struct *sptr = ast->sem->sptr;

  bprintf(output, ",\n\"projection\" : [\n");
  BEGIN_INDENT(proj, 2);
  BEGIN_LIST;

  for (uint32_t i = 0; i < sptr->count; i++) {
    COMMA;
    bprintf(output, "{\n");
    BEGIN_INDENT(type, 2);
    bprintf(output, "\"name\" : ");
    cg_json_sptr_sql_name(output, sptr, (int32_t)i);
    bprintf(output, ",\n");
    cg_json_data_type(output, sptr->semtypes[i], sptr->kinds[i]);
    END_INDENT(type);
    bprintf(output, "\n}");
  }
  END_LIST;
  END_INDENT(proj);
  bprintf(output, "]");
}

// The set of views look rather like the query section in as much as
// they are in fact nothing more than named select statements.  However
// the output here is somewhat simplified.  We only emit the whole select
// statement and any binding args, we don't also emit all the pieces of the select.
static void cg_json_views(charbuf *output) {
  bprintf(output, "\"views\" : [\n");
  BEGIN_INDENT(views, 2);

  int32_t i = 0;
  for (list_item *item = all_views_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_view_stmt(ast));

    ast_node *misc_attrs = NULL;
    ast_node *attr_target = ast->parent;
    if (is_ast_stmt_and_attr(attr_target)) {
      EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target->parent);
      misc_attrs = misc;
    }

    cg_json_test_details(output, ast, misc_attrs);

    EXTRACT_OPTION(flags, ast->left);
    EXTRACT_NOTNULL(view_and_attrs, ast->right);
    EXTRACT_NOTNULL(view_details_select, view_and_attrs->left);
    EXTRACT_NOTNULL(view_details, view_details_select->left);
    EXTRACT_ANY_NOTNULL(select_stmt, view_details_select->right);
    EXTRACT_NAME_AST(name_ast, view_details->left);

    if (i > 0) {
      bprintf(output, ",\n");
    }
    bprintf(output, "{\n");

    bool_t is_deleted = ast->sem->delete_version > 0;
    BEGIN_INDENT(view, 2);
    bprintf(output, "\"name\" : ");
    cg_json_sql_name(output, name_ast);
    bprintf(output, ",\n\"CRC\" : \"%lld\"", crc_stmt(ast));
    bprintf(output, ",\n\"isTemp\" : %d", !!(flags & VIEW_IS_TEMP));
    bprintf(output, ",\n\"isDeleted\" : %d", is_deleted);
    if (is_deleted) {
      bprintf(output, ",\n\"deletedVersion\" : %d", ast->sem->delete_version);
      cg_json_deleted_migration_proc(output, view_and_attrs);
    }

    if (ast->sem->region) {
      cg_json_emit_region_info(output, ast);
    }

    if (misc_attrs) {
      bprintf(output, ",\n");
      cg_json_misc_attrs(output, misc_attrs);
    }

    cg_json_projection(output, select_stmt);
    cg_fragment_with_params(output, "select", select_stmt, gen_one_stmt);
    cg_json_dependencies(output, ast);
    END_INDENT(view);
    bprintf(output, "\n}\n");
    i++;
  }

  END_INDENT(views);
  bprintf(output, "]");
}

static void cg_json_table_indices(list_item *head, charbuf *output) {
  bprintf(output, "\"indices\" : [ ");

  bool_t needs_comma = 0;
  for (list_item *item = head; item; item = item->next) {
    ast_node *ast = item->ast;

    // don't include deleted indices
    if (ast->sem->delete_version > 0) {
       continue;
    }

    Invariant(is_ast_create_index_stmt(ast));
    EXTRACT_NOTNULL(create_index_on_list, ast->left);
    EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);

    if (needs_comma) {
      bprintf(output, ", ");
    }

    cg_json_sql_name(output, index_name_ast);
    needs_comma = 1;
  }
  bprintf(output, " ]");
}

// The table output is the tables name, the assorted flags, and misc attributes
// the rest of the table output is produced by walking the column and key list
// using the helper above.
static void cg_json_table(charbuf *output, ast_node *ast) {
  Invariant(is_ast_create_table_stmt(ast));

  EXTRACT_NOTNULL(create_table_name_flags, ast->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
  EXTRACT_ANY_NOTNULL(col_key_list, ast->right);

  int32_t temp = flags & TABLE_IS_TEMP;
  int32_t if_not_exist = flags & TABLE_IF_NOT_EXISTS;
  int32_t no_rowid = flags & TABLE_IS_NO_ROWID;

  ast_node *misc_attrs = NULL;

  ast_node *attr_target = ast->parent;
  if (is_virtual_ast(ast)) {
    // for virtual tables, we have to go up past the virtual table node to get the attributes
    attr_target = attr_target->parent;
  }

  if (is_ast_stmt_and_attr(attr_target)) {
    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc, attr_target->parent);
    misc_attrs = misc;
  }

  cg_json_test_details(output, ast, misc_attrs);

  bprintf(output, "{\n");

  BEGIN_INDENT(table, 2);

  bool_t is_added = ast->sem->create_version > 0;

  bool_t is_deleted = ast->sem->delete_version > 0;
  bool_t is_unsub = ast->sem->unsubscribed > 0;

  bprintf(output, "\"name\" : ");
  cg_json_sql_name(output, name_ast);

  CHARBUF_OPEN(table_schema);
  gen_sql_callbacks schema_callbacks;
  init_gen_sql_callbacks(&schema_callbacks);
  schema_callbacks.mode = gen_mode_sql;
  gen_set_output_buffer(&table_schema);
  gen_statement_with_callbacks(ast, &schema_callbacks);
  bprintf(output, ",\n\"schema\" : ");
  cg_encode_json_string_literal(table_schema.ptr, output);
  CHARBUF_CLOSE(table_schema);

  bprintf(output, ",\n\"CRC\" : \"%lld\"", crc_stmt(ast));
  bprintf(output, ",\n\"isTemp\" : %d", !!temp);
  bprintf(output, ",\n\"ifNotExists\" : %d", !!if_not_exist);
  bprintf(output, ",\n\"withoutRowid\" : %d", !!no_rowid);
  bprintf(output, ",\n\"isAdded\" : %d", is_added);
  if (is_added) {
    bprintf(output, ",\n\"addedVersion\" : %d", ast->sem->create_version);
    cg_json_added_migration_proc(output, table_flags_attrs);
  }
  // deleted state includes deleted or unsubscribed
    bprintf(output, ",\n\"isDeleted\" : %d", is_deleted || is_unsub);
  if (is_deleted) {
    bprintf(output, ",\n\"deletedVersion\" : %d", ast->sem->delete_version);
    cg_json_deleted_migration_proc(output, table_flags_attrs);
  }
  bprintf(output, ",\n\"isRecreated\": %d", ast->sem->recreate);

  if (ast->sem->recreate_group_name) {
    bprintf(output, ",\n\"recreateGroupName\" : \"%s\"", ast->sem->recreate_group_name);
  }

  if (is_unsub) {
     bprintf(output, ",\n\"unsubscribedVersion\" : %d", ast->sem->unsubscribed);
  }

  if (is_backing(ast->sem->sem_type)) {
    bprintf(output, ",\n\"isBacking\" : 1");
  }
  else if (is_backed(ast->sem->sem_type)) {
    bprintf(output, ",\n\"isBacked\" : 1");
    bprintf(output, ",\n\"typeHash\" : %s", gen_type_hash(ast));
  }

  if (ast->sem->region) {
    cg_json_emit_region_info(output, ast);
  }

  if (is_virtual_ast(ast)) {
    bprintf(output, ",\n\"isVirtual\" : 1");
    bprintf(output, ",\n\"isEponymous\" : %d", !!(flags & VTAB_IS_EPONYMOUS));
    EXTRACT_NOTNULL(create_virtual_table_stmt, ast->parent);
    EXTRACT_NOTNULL(module_info, create_virtual_table_stmt->left);
    EXTRACT_STRING(module_name, module_info->left);
    EXTRACT_ANY(module_args, module_info->right);
    bprintf(output, ",\n\"module\" : \"%s\"", module_name);
    if (module_args) {
      bprintf(output, ",\n\"moduleArgs\" : ");
      if (is_ast_following(module_args)) {
        CHARBUF_OPEN(sql);
          gen_set_output_buffer(&sql);
          gen_sql_callbacks callbacks;
          init_gen_sql_callbacks(&callbacks);
          gen_with_callbacks(col_key_list, gen_col_key_list, &callbacks);
          cg_encode_json_string_literal(sql.ptr, output);
        CHARBUF_CLOSE(sql);
      }
      else {
        CHARBUF_OPEN(sql);
          gen_set_output_buffer(&sql);
          gen_sql_callbacks callbacks;
          init_gen_sql_callbacks(&callbacks);
          gen_with_callbacks(module_args, gen_misc_attr_value_list, &callbacks);
          cg_encode_json_string_literal(sql.ptr, output);
        CHARBUF_CLOSE(sql);
      }
    }
  }

  CONTINUE_LIST;

  if (ast->sem->table_info->index_list) {
    COMMA;
    cg_json_table_indices(ast->sem->table_info->index_list, output);
  }

  if (misc_attrs) {
    COMMA;
    cg_json_misc_attrs(output, misc_attrs);
  }

  COMMA;
  cg_json_col_key_list(output, ast);

  END_INDENT(table);
  END_LIST;
  bprintf(output, "}");
}

// The tables section is simply an array of table entries under the tables key
static void cg_json_tables(charbuf *output) {
  bprintf(output, "\"tables\" : [\n");
  BEGIN_INDENT(tables, 2);
  BEGIN_LIST;

  for (list_item *item = all_tables_list; item; item = item->next) {
    ast_node *ast = item->ast;
    if (is_virtual_ast(ast)) {
      continue;
    }
    COMMA;
    cg_json_table(output, ast);
  }

  END_INDENT(tables);
  END_LIST;
  bprintf(output, "]");
}

// The tables section is simply an array of table entries under the tables key
static void cg_json_virtual_tables(charbuf *output) {
  bprintf(output, "\"virtualTables\" : [\n");
  BEGIN_INDENT(tables, 2);
  BEGIN_LIST;

  for (list_item *item = all_tables_list; item; item = item->next) {
    ast_node *ast = item->ast;
    if (!is_virtual_ast(ast)) {
      continue;
    }
    COMMA;
    cg_json_table(output, ast);
  }

  END_INDENT(tables);
  END_LIST;
  bprintf(output, "]");
}

// This helper emits one parameter for a single stored proc.  Each will be
// used as the legal arguments to the statement we are binding.  If any of
// the parameters are of the 'out' flavor then this proc is "complex"
// so we simply return false and let it fall into the general bucket.
static bool_t cg_json_param(charbuf *output, ast_node *ast, CSTR *infos) {
  Contract(is_ast_param(ast));
  EXTRACT_ANY(opt_inout, ast->left);
  EXTRACT_NOTNULL(param_detail, ast->right);
  EXTRACT_STRING(name, param_detail->left);

  bool_t simple = 1;

  bprintf(output, "{\n");
  BEGIN_INDENT(type, 2);

  if (is_ast_inout(opt_inout)) {
    bprintf(output, "\"binding\" : \"inout\",\n");
    simple = 0;
  }
  else if (is_ast_out(opt_inout)) {
    bprintf(output, "\"binding\" : \"out\",\n");
    simple = 0;
  }

  bprintf(output, "\"name\" : \"%s\",\n", name);

  if (infos) {
    CSTR base_name = infos[0];
    CSTR shape_name = infos[1];
    CSTR shape_type = infos[2];

    if (shape_name[0]) {
      // this is an expansion of the form shape_name LIKE shape_type
      // the formal arg will have a name like "shape_name_base_name" (underscore between the parts)
      bprintf(output, "\"argOrigin\" : \"%s %s %s\",\n", shape_name, shape_type, base_name);
    }
    else if (shape_type[0]) {
      // this is an expansion of the form LIKE shape_type
      // the formal arg will have a name like "base_name_" (trailing underscore)
      bprintf(output, "\"argOrigin\" : \"%s %s\",\n", shape_type, base_name);
    }
    else {
      // this is a normal arg, it was not auto-expanded from anything
      // the formal arg will have the name "base_name"
      bprintf(output, "\"argOrigin\" : \"%s\",\n", base_name);
    }
  }

  cg_json_data_type(output, ast->sem->sem_type, ast->sem->kind);

  END_INDENT(type);

  bprintf(output, "\n}");
  return simple;
}

// Here we walk all the parameters of a stored proc and process each in turn.
// If any parameter is not valid, the entire proc becomes not valid.
static bool_t cg_json_params(charbuf *output, ast_node *ast, CSTR *infos) {
  bool_t simple = 1;

  BEGIN_LIST;
  while (ast) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left);

    COMMA;

    simple &= cg_json_param(output, param, infos);

    ast = ast->right;

    // There are 3 strings per arg, one each for the shape name, shape type, and base name
    // these desribe how automatically generated arguments were created.
    if (infos) {
      infos += 3;
    }
  }
  END_LIST;

  return simple;
}

static bool_t found_shared_fragment;

// simply record the factthat we found a shared fragment
static bool_t cg_json_call_in_cte(ast_node *cte_body, void *context, charbuf *buffer) {
  found_shared_fragment = true;
  return false;
}

// Use the indicated generation function to create a SQL fragment.  The fragment
// may have parameters.  They are captured and emitted as an array.
static void cg_fragment_with_params_raw(charbuf *output, CSTR frag, ast_node *ast, gen_func fn) {
  CHARBUF_OPEN(sql);
  CHARBUF_OPEN(vars);
  gen_set_output_buffer(&sql);
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.variables_callback = cg_json_record_var;
  callbacks.variables_context = &vars;
  callbacks.cte_proc_callback = cg_json_call_in_cte;

  found_shared_fragment = false;

  bprintf(output, "\"%s\" : ", frag);
  gen_with_callbacks(ast, fn, &callbacks);
  cg_pretty_quote_plaintext(sql.ptr, output, PRETTY_QUOTE_JSON | PRETTY_QUOTE_SINGLE_LINE);
  bprintf(output, ",\n\"%sArgs\" : [ %s ]", frag, vars.ptr);

  CHARBUF_CLOSE(vars);
  CHARBUF_CLOSE(sql);
}

// Same as the above, but the most common case requires continuing a list
// so this helper does that.
static void cg_fragment_with_params(charbuf *output, CSTR frag, ast_node *ast, gen_func fn)
{
  bprintf(output, ",\n");
  cg_fragment_with_params_raw(output, frag, ast, fn);
}

// Use the indicated generation function to create a SQL fragment.  The fragment
// may not have parameters.  This is not suitable for use where expressions
// will be present.
static void cg_fragment(charbuf *output, CSTR frag, ast_node *ast, gen_func fn) {
  CHARBUF_OPEN(sql);
  gen_set_output_buffer(&sql);
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.variables_callback = cg_json_record_var;
  callbacks.variables_context = NULL;  // forces invariant violation if any variables

  bprintf(output, ",\n\"%s\" : ", frag);
  gen_with_callbacks(ast, fn, &callbacks);
  cg_pretty_quote_plaintext(sql.ptr, output, PRETTY_QUOTE_JSON | PRETTY_QUOTE_SINGLE_LINE);

  CHARBUF_CLOSE(sql);
}

// The row sources (select, insert returns, explain query plan) are emitted
// along with their projection and the full statement with bindings.  That
// here we handle the statement and bindings.  Once upon a time we also emitted
// fragments of the select statement but that was removed because such pieces
// proved of little use.
static void cg_json_any_row_source(charbuf *output, ast_node *ast) {
  Contract(is_row_source(ast));

  cg_fragment_with_params(output, "statement", ast, gen_one_stmt);
}

// Here we emit the following bits of information
// * the table we are inserting into
// * the insert type (INSERT, INSERT OR REPLACE etc)
// * the insert columns (the ones we are specifying)
// * a fragment for the entire statement with all the args
// * [optional] a fragment for each inserted value with its args
static void cg_json_insert_stmt(charbuf *output, ast_node *ast, bool_t emit_values) {
  // Both insert types have been unified in the AST
  Contract(is_insert_stmt(ast));
  Contract(!is_ast_insert_returning_stmt(ast));  // this is handled as a query

  ast_node *insert_stmt = ast;

  // extract the insert part it may be behind the WITH clause and it may be the insert part of an upsert
  if (is_ast_with_insert_stmt(ast)) {
    insert_stmt = ast->right;
  }
  else if (is_ast_upsert_stmt(ast)) {
    insert_stmt = ast->left;
  }
  else if (is_ast_with_upsert_stmt(ast)) {
    insert_stmt = ast->right->left;
  }

  Contract(is_ast_insert_stmt(insert_stmt));

  EXTRACT_ANY_NOTNULL(insert_type, insert_stmt->left);
  EXTRACT_NOTNULL(name_columns_values, insert_stmt->right);
  EXTRACT_NAME_AST(name_ast, name_columns_values->left)
  EXTRACT_NOTNULL(columns_values, name_columns_values->right);
  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT_ANY(columns_values_right, columns_values->right);
  EXTRACT(name_list, column_spec->left);

  // use the canonical name (which may be case-sensitively different)
  CSTR name = name_ast->sem->sptr->struct_name;

  bprintf(output, ",\n\"table\" : \"%s\"", name);
  cg_fragment_with_params(output, "statement", ast, gen_one_stmt);

  cg_fragment(output, "statementType", insert_type, gen_insert_type);

  bprintf(output, ",\n\"columns\" : [ ");
  if (name_list) {
    cg_json_name_list(output, name_list);
  }
  bprintf(output, " ]");

  if (emit_values) {
    // We only try to emit values if we know there is one row of them
    // So the select statement can only be a values clause with only one list of values.
    // This is guaranteed because of is_simple_insert(...) already checked this.
    // The general insert form might have arguments in all sorts of places and
    // so it can't be readily analyzed by downstream tools.  This very simple
    // insert form can be manipulated in interesting ways.  A downstream tool might
    // want to convert it into an upsert or some such.  In any case, we pull
    // out the very simple inserts to allow them to be more deeply analyzed.

    bprintf(output, ",\n\"values\" : [\n");
    BEGIN_LIST;
    BEGIN_INDENT(v1, 2);
    if (is_ast_select_stmt(columns_values_right)) {
      EXTRACT(select_stmt, columns_values_right);
      EXTRACT_NOTNULL(select_core_list, select_stmt->left);
      EXTRACT(select_core_compound, select_core_list->right);
      EXTRACT_NOTNULL(select_core, select_core_list->left);
      EXTRACT_NOTNULL(values, select_core->right);
      columns_values_right = values->left;
    }
    Invariant(columns_values_right == NULL || is_ast_insert_list(columns_values_right));
    EXTRACT(insert_list, columns_values_right);
    for (ast_node *item = insert_list; item; item = item->right) {
      COMMA;
      bprintf(output, "{\n");
      BEGIN_INDENT(v2, 2);
      cg_fragment_with_params_raw(output, "value", item->left, gen_root_expr);
      END_INDENT(v2);
      bprintf(output, "\n}");
    }
    END_INDENT(v1);
    END_LIST;
    bprintf(output, "]");
  }
}

// Delete statement gets the table name and the full statement and args
// as one fragment.
static void cg_json_delete_stmt(charbuf *output, ast_node * ast) {
  Contract(is_delete_stmt(ast));
  ast_node *delete_stmt = is_ast_with_delete_stmt(ast) ? ast->right : ast;
  EXTRACT_NAME_AST(name_ast, delete_stmt->left);

  // use the canonical name (which may be case-sensitively different)
  CSTR name = name_ast->sem->sptr->struct_name;

  bprintf(output, ",\n\"table\" : \"%s\"", name);
  cg_fragment_with_params(output, "statement", ast, gen_one_stmt);
}

// Update statement gets the table name and the full statement and args
// as one fragment.
static void cg_json_update_stmt(charbuf *output, ast_node *ast) {
  Contract(is_update_stmt(ast));
  ast_node *update_stmt = is_ast_with_update_stmt(ast) ? ast->right : ast;

  EXTRACT_NAME_AST(name_ast, update_stmt->left);

  // use the canonical name (which may be case-sensitively different)
  CSTR name = name_ast->sem->sptr->struct_name;

  bprintf(output, ",\n\"table\" : \"%s\"", name);
  cg_fragment_with_params(output, "statement", ast, gen_one_stmt);
}

// Start a new section for any kind of thing, if testing we spew the test info here
// This lets us attribute the output to a particular line number in the test file.
// This code also adds the pesky comma that goes before any new items in the same
// section.
static void cg_begin_item_attrs(charbuf *output, ast_node *ast, ast_node *misc_attrs) {
  Contract(ast);

  if (output->used > 1) bprintf(output, ",\n");
  cg_json_test_details(output, ast, misc_attrs);
  bprintf(output, "{\n");
}

// For symetry we have this lame end function
static void cg_end_proc(charbuf *output, ast_node *ast) {
  bprintf(output, "\n}");
}

// Emit the arguments to the proc, track if they are valid (i.e. no OUT args)
// If not valid, the proc will be "general"
static bool_t cg_parameters(charbuf *output, ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  bool_t simple = 1;

  bytebuf *arg_info = find_proc_arg_info(name);
  CSTR *infos = arg_info ? (CSTR *)arg_info->ptr : NULL;

  bprintf(output, ",\n\"args\" : [\n");
  BEGIN_INDENT(parms, 2);
  simple = cg_json_params(output, params, infos);
  END_INDENT(parms);
  bprintf(output, "]");

  return simple;
}

// The purpose of the "simple" versions is to enable code-rewriters to replace
// the proc with the DML directly and bind it.  The code gen can some idea of what's
// going on in the simple cases -- it's a single row insert.  In those cases it's
// possible to skip the C codegen entirely.  You can just bind and run the DML.
bool_t static is_simple_insert(ast_node *ast) {
  if (!is_ast_insert_stmt(ast)) {
    return false;
  }

  EXTRACT_NOTNULL(name_columns_values, ast->right);
  EXTRACT_NOTNULL(columns_values, name_columns_values->right);
  if (!is_select_variant(columns_values->right)) {
    // the insert statement does not have a select statement
    return true;
  }

  EXTRACT(select_stmt, columns_values->right);
  EXTRACT_NOTNULL(select_core_list, select_stmt->left);
  EXTRACT(select_core_compound, select_core_list->right);
  if (select_core_compound != NULL) {
    // The select statement is a compound select therefore it's not simple insert
    return false;
  }

  EXTRACT_NOTNULL(select_core, select_core_list->left);
  if (!is_ast_values(select_core->right)) {
    // The select statement does not have VALUES clause then it's not simple insert
    return false;
  }

  EXTRACT_NOTNULL(values, select_core->right);
  if (values->right) {
    // The values clause has multiple list of value therefore it's not a simple insert
    return false;
  }

  // The insert statement contains a select statement that only has a VALUES clause
  // and the VALUES clause has only one list of values.
  return true;
}

static void cg_json_general_proc(ast_node *ast, ast_node *misc_attrs, CSTR params) {
  charbuf *output = general;
  cg_begin_item_attrs(output, ast, misc_attrs);
  sem_t sem_type = ast->sem->sem_type;
  BEGIN_INDENT(proc, 2)
  bprintf(output, "%s", params);
  bool_t has_any_result_set = !!ast->sem->sptr;
  bool_t uses_out_union = !!(sem_type & SEM_TYPE_USES_OUT_UNION);
  bool_t uses_out = !!(sem_type & SEM_TYPE_USES_OUT);
  bool_t select_result = !uses_out && !uses_out_union && has_any_result_set;

  if (has_any_result_set) {
    cg_json_projection(output, ast);
  }

  // clearer coding of the result types including out union called out seperately
  if (uses_out) {
    Invariant(has_any_result_set);
    bprintf(output, ",\n\"hasOutResult\" : 1");
  }
  else if (uses_out_union) {
    Invariant(has_any_result_set);
    bprintf(output, ",\n\"hasOutUnionResult\" : 1");
  }
  else if (select_result) {
    Invariant(has_any_result_set);
    bprintf(output, ",\n\"hasSelectResult\" : 1");
  }
  else {
    Invariant(!has_any_result_set);
  }

  bprintf(output, ",\n\"usesDatabase\" : %d", !!(sem_type & SEM_TYPE_DML_PROC));
  END_INDENT(proc);
}

// For procedures and triggers we want to walk the statement list and emit a set
// of dependency entries that show what the code in question is using and how.
// We track tables that are used and if they appear in say the FROM clause
// (or some other read-context) or if they are the subject of an insert, update,
// or delete.  We also track the use of nested procedures and produce a list of
// procs the subject might call.  Of course no proc calls ever appear in triggers.
static void cg_json_dependencies(charbuf *output, ast_node *ast) {
  json_context context;
  CHARBUF_OPEN(used_tables);
  CHARBUF_OPEN(used_views);
  CHARBUF_OPEN(insert_tables);
  CHARBUF_OPEN(update_tables);
  CHARBUF_OPEN(delete_tables);
  CHARBUF_OPEN(from_tables);
  CHARBUF_OPEN(used_procs);

  context.cookie = cookie_str;
  context.proc_ast = ast;
  context.used_tables = &used_tables;
  context.used_views = &used_views;
  context.insert_tables = &insert_tables;
  context.delete_tables = &delete_tables;
  context.update_tables = &update_tables;
  context.from_tables = &from_tables;
  context.used_procs = &used_procs;

  table_callbacks callbacks = {
      .notify_table_or_view_drops = false,
      .notify_fk = false,
      .notify_triggers = false,
      .callback_any_table = cg_found_table,
      .callback_any_view = cg_found_view,
      .callback_inserts = cg_found_insert,
      .callback_updates = cg_found_update,
      .callback_deletes = cg_found_delete,
      .callback_from = cg_found_from,
      .callback_proc = cg_found_proc,
      .callback_context = &context,
  };
  find_table_refs(&callbacks, ast);

  if (insert_tables.used > 1) {
    bprintf(output, ",\n\"insertTables\" : [ %s ]", insert_tables.ptr);
  }
  if (update_tables.used > 1) {
    bprintf(output, ",\n\"updateTables\" : [ %s ]", update_tables.ptr);
  }
  if (delete_tables.used > 1) {
    bprintf(output, ",\n\"deleteTables\" : [ %s ]", delete_tables.ptr);
  }
  if (from_tables.used > 1) {
    bprintf(output, ",\n\"fromTables\" : [ %s ]", from_tables.ptr);
  }
  if (used_procs.used > 1) {
    bprintf(output, ",\n\"usesProcedures\" : [ %s ]", used_procs.ptr);
  }
  if (used_views.used > 1) {
    bprintf(output, ",\n\"usesViews\" : [ %s ]", used_views.ptr);
  }

  bprintf(output, ",\n\"usesTables\" : [ %s ]", used_tables.ptr);

  CHARBUF_CLOSE(used_procs);
  CHARBUF_CLOSE(from_tables);
  CHARBUF_CLOSE(delete_tables);
  CHARBUF_CLOSE(update_tables);
  CHARBUF_CLOSE(insert_tables);
  CHARBUF_CLOSE(used_views);
  CHARBUF_CLOSE(used_tables);
}


static void cg_defined_in_file(charbuf *output, ast_node *ast) {
  CHARBUF_OPEN(tmp);
    // quote the file as a json style literaj
    CSTR filename = ast->filename;
    #ifdef _WIN32
    CSTR slash = strrchr(filename, '\\');
    #else
    CSTR slash = strrchr(filename, '/');
    #endif
    if (slash) {
      filename = slash + 1;
    }
    cg_encode_json_string_literal(filename, &tmp);
    bprintf(output, ",\n\"definedInFile\" : %s",  tmp.ptr);
  CHARBUF_CLOSE(tmp);
}

static void cg_defined_on_line(charbuf *output, ast_node *ast) {
  int32_t lineno = cg_find_first_line(ast);
  bprintf(output, ",\n\"definedOnLine\" : %d", lineno);
}

static void cg_json_declare_interface(charbuf *output, ast_node *ast, ast_node *misc_attrs) {
  Contract(is_ast_declare_interface_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT_NOTNULL(typed_names, proc_params_stmts->right);

  cg_begin_item_attrs(output, ast, NULL);

  BEGIN_INDENT(interface, 2);
  bprintf(output, "\"name\" : \"%s\"", name);
  cg_defined_in_file(output, ast);
  cg_defined_on_line(output, ast);

  if (misc_attrs) {
    bprintf(output, ",\n");
    cg_json_misc_attrs(output, misc_attrs);
  }

  cg_json_projection(output, ast);
  END_INDENT(interface);

  cg_end_proc(output, ast);
}

static void cg_json_declare_func(charbuf *stmt_out, ast_node *ast, ast_node *misc_attrs) {
  bool_t select_func = is_ast_declare_select_func_no_check_stmt(ast) || is_ast_declare_select_func_stmt(ast);
  bool_t non_select_func = is_ast_declare_func_no_check_stmt(ast) || is_ast_declare_func_stmt(ast);
  bool_t no_check_func = is_ast_declare_func_no_check_stmt(ast) || is_ast_declare_select_func_no_check_stmt(ast);
  Contract(select_func || non_select_func);

  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT(params, func_params_return->left);

  CHARBUF_OPEN(declare_func_buffer);
  charbuf *output = &declare_func_buffer;

  bprintf(output, "\"name\" : \"%s\"", name);

  if (!no_check_func) {
    // emit parameters.
    bprintf(output, ",\n\"args\" : [\n");
    BEGIN_INDENT(parms, 2);
    cg_json_params(output, params, NULL);
    END_INDENT(parms);
    bprintf(output, "]");
  }

  // emit attributes.
  if (misc_attrs) {
    bprintf(output, ",\n");
    cg_json_misc_attrs(output, misc_attrs);
  }

  // emit return type.
  EXTRACT_ANY_NOTNULL(data_type, func_params_return->right);

  bool_t creates_object = false;
  if (is_ast_typed_names(data_type)) {
    // table valued function
    cg_json_projection(output, data_type);
  }
  else {
    if (is_ast_create_data_type(data_type)) {
      creates_object = true;
      data_type = data_type->left;
    }

    bprintf(output, ",\n\"returnType\" : {\n");
    BEGIN_INDENT(type, 2);
    cg_json_data_type(output, data_type->sem->sem_type, data_type->sem->kind);
    END_INDENT(type);
    bprintf(output, "\n}");
  }

  if (!select_func) {
    // emit whether this function is a "create" function or not.
    // (this means its return value begins with a +1 ref that the caller now owns)
    // always false for table valued functions
    bprintf(output, ",\n\"createsObject\" : %d", (int)creates_object);
  }

  // add this function to the list.
  output = stmt_out;
  cg_begin_item_attrs(output, ast, misc_attrs);
  BEGIN_INDENT(func, 2);
  bprintf(output, "%s", declare_func_buffer.ptr);
  END_INDENT(func);

  // clean up
  CHARBUF_CLOSE(declare_func_buffer);
  cg_end_proc(output, ast);
}


// the no check version has no args, and it is never DML, and never has a shape
static void cg_json_declare_proc_no_check(charbuf *stmt_out, ast_node *ast, ast_node *misc_attrs) {
  Contract(is_ast_declare_proc_no_check_stmt(ast));
  EXTRACT_ANY_NOTNULL(proc_name, ast->left);
  EXTRACT_STRING(name, proc_name);

  CHARBUF_OPEN(declare_proc_buffer);
  charbuf *output = &declare_proc_buffer;

  // emit function name.
  bprintf(output, "\"name\" : \"%s\"", name);

  // emit attributes.
  if (misc_attrs) {
    bprintf(output, ",\n");
    cg_json_misc_attrs(output, misc_attrs);
  }

  // add this proc to the list.
  output = stmt_out;
  cg_begin_item_attrs(output, ast, misc_attrs);
  BEGIN_INDENT(proc, 2);
  bprintf(output, "%s", declare_proc_buffer.ptr);
  END_INDENT(proc);

  // cleanup
  CHARBUF_CLOSE(declare_proc_buffer);
  cg_end_proc(output, ast);
}

static void cg_json_declare_proc(charbuf *stmt_out, ast_node *ast, ast_node *misc_attrs) {
  Contract(is_ast_declare_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_name_type, ast->left);
  EXTRACT_NAME_AST(name_ast, proc_name_type->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);

  CHARBUF_OPEN(declare_proc_buffer);
  charbuf *output = &declare_proc_buffer;

  // emit function name.
  bprintf(output, "\"name\" : \"%s\"", name);

  // emit parameters.
  bprintf(output, ",\n\"args\" : [\n");
  BEGIN_INDENT(parms, 2);
  cg_json_params(output, params, NULL);
  END_INDENT(parms);
  bprintf(output, "]");

  // emit attributes.
  if (misc_attrs) {
    bprintf(output, ",\n");
    cg_json_misc_attrs(output, misc_attrs);
  }

  // emit projections.
  sem_t sem_type = ast->sem->sem_type;
  bool_t has_any_result_set = !!ast->sem->sptr;
  if (has_any_result_set) {
    cg_json_projection(output, ast);
  }

  // emit use db or not.
  bprintf(output, ",\n\"usesDatabase\" : %d", !!(sem_type & SEM_TYPE_DML_PROC));

  // add this proc to the list.
  output = stmt_out;
  cg_begin_item_attrs(output, ast, misc_attrs);
  BEGIN_INDENT(proc, 2);
  bprintf(output, "%s", declare_proc_buffer.ptr);
  END_INDENT(proc);

  // cleanup
  CHARBUF_CLOSE(declare_proc_buffer);
  cg_end_proc(output, ast);
}

// If we find a procedure definition we crack its arguments and first statement
// If it matches one of the known types we generate the details for it.  Otherwise
// it goes into the general bucket.  The output is redirected to the appropriate
// output stream for the type of statement and then a suitable helper is dispatched.
// Additionally, each procedure includes an array of tables that it uses regardless
// of the type of procedure.
static void cg_json_create_proc(charbuf *unused, ast_node *ast, ast_node *misc_attrs) {
  Contract(is_ast_create_proc_stmt(ast));
  Contract(unused == NULL);  // proc output is complicated, this code knows what to do
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);

  // shared fragments are invisible to the JSON or anything else, they have
  // no external interface.
  if (is_proc_shared_fragment(ast)) {
    return;
  }

  CHARBUF_OPEN(param_buffer);
  charbuf *output = &param_buffer;

  bprintf(output, "\"name\" : \"%s\"", name);
  cg_defined_in_file(output, name_ast);
  cg_defined_on_line(output, ast);

  bool_t simple = cg_parameters(output, ast);

  cg_json_dependencies(output, ast);

  if (ast->sem->region) {
    cg_json_emit_region_info(output, ast);
  }

  if (misc_attrs) {
    bprintf(output, ",\n");
    cg_json_misc_attrs(output, misc_attrs);
  }

  if (!stmt_list) {
    output = general;
    cg_json_general_proc(ast, misc_attrs, param_buffer.ptr);
    goto cleanup;
  }

  EXTRACT_STMT_AND_MISC_ATTRS(stmt, nested_misc_attrs, stmt_list);

  // if more than one statement it isn't simple
  if (stmt_list->right) {
    simple = 0;
  }

  // we have to see if it uses shared fragments, this can't be "simple"
  // because the parameters can be synthetic and require assignments and such
  if (simple && is_row_source(stmt)) {
    found_shared_fragment = false;
    CHARBUF_OPEN(scratch);
    cg_json_any_row_source(&scratch, stmt); // easy way to walk the tree
    CHARBUF_CLOSE(scratch);
    // the above sets this by side-effect in the callback
    simple = !found_shared_fragment;
  }

  if (simple && is_row_source(stmt)) {
    output = queries;
    cg_begin_item_attrs(output, ast, misc_attrs);
    BEGIN_INDENT(proc, 2);
    bprintf(output, "%s", param_buffer.ptr);
    cg_json_projection(output, stmt);
    cg_json_any_row_source(output, stmt);
    END_INDENT(proc);
  }
  else if (simple && is_insert_stmt(stmt)) {
    bool_t simple_insert = is_simple_insert(stmt);

    output = simple_insert ? inserts : general_inserts;
    cg_begin_item_attrs(output, ast, misc_attrs);
    BEGIN_INDENT(proc, 2);
    bprintf(output, "%s", param_buffer.ptr);
    cg_json_insert_stmt(output, stmt, simple_insert);
    END_INDENT(proc);
  }
  else if (simple && is_delete_stmt(stmt)) {
    output = deletes;
    cg_begin_item_attrs(output, ast, misc_attrs);
    BEGIN_INDENT(proc, 2);
    bprintf(output, "%s", param_buffer.ptr);
    cg_json_delete_stmt(output, stmt);
    END_INDENT(proc);
  }
  else if (simple && is_update_stmt(stmt)) {
    output = updates;
    cg_begin_item_attrs(output, ast, misc_attrs);
    BEGIN_INDENT(proc, 2);
    bprintf(output, "%s", param_buffer.ptr);
    cg_json_update_stmt(output, stmt);
    END_INDENT(proc);
  }
  else {
    output = general;
    cg_json_general_proc(ast, misc_attrs, param_buffer.ptr);
  }

cleanup:
  CHARBUF_CLOSE(param_buffer);
  cg_end_proc(output, ast);
}

// This lets us have top level attributes that go into the main output stream
// this is stuff like the name of the database and so forth.  By convention these
// are placed as an attribution on the statements "declare database object".
// Attributes for any object variables named *database are unified so that
// different schema fragments can contribute easily.
static void cg_json_database_var(charbuf *output, ast_node *ast, ast_node *misc_attrs) {
  Contract(is_ast_declare_vars_type(ast));
  EXTRACT_NOTNULL(name_list, ast->left);
  EXTRACT_ANY_NOTNULL(data_type, ast->right);

  bool_t first_attr = output->used == 1;

  // we're looking for "declare *database object"  and nothing else. Note the '*',
  // which indicates that we will match any variable ending with "database".
  if (misc_attrs && !name_list->right && is_object(data_type->sem->sem_type)) {
    EXTRACT_STRING(name, name_list->left);
    if (StrEndsWith(name, "database")) {

      if (first_attr) {
        bprintf(output, "\n");
      }

      cg_json_test_details(output, ast, misc_attrs);

      BEGIN_INDENT(attr, 2);

      // The attributes from all the various sources are unified, they will
      // go into one attributes block.  Note there can be duplicates but that's
      // not a problem for the schema and may even be desired.  Note also
      // that even if we had only one such object there could still be duplicates
      // because again, attributes on a single object are not unique.  They mean
      // whatever you want them to mean.  So we just spit them out and let
      // the consumer sort it out.  In practice this isn't really a problem.
      // Whatever tool is downstream will complain if the attributes are badly formed.
      for (ast_node *item = misc_attrs; item; item = item->right) {
        if (!first_attr) {
          bprintf(output, ",\n");
        }
        first_attr = false;
        cg_json_misc_attr(output, item->left);
      }

      END_INDENT(attr);
    }
  }
}


// all the generic statement handlers look like this
// this is a custom functor to call them
typedef struct {
  void (*func)(charbuf *out, ast_node *ast, ast_node *misc_attrs);
  charbuf *out;
} json_dispatch;

#undef STMT_INIT
#define STMT_INIT(x, func, out) \
  json_dispatch json_disp_ ## x = { func,  out }; \
  symtab_add(stmts, k_ast_ ## x, (void *)&json_disp_ ##x)

// Here we create several buffers for the various statement types and then redirect
// output into the appropriate buffer as we walk the statements.  Finally each buffer
// is emitted in order.
static void cg_json_stmt_list(charbuf *output, ast_node *head) {
  CHARBUF_OPEN(query_buf);
  CHARBUF_OPEN(insert_buf);
  CHARBUF_OPEN(update_buf);
  CHARBUF_OPEN(delete_buf);
  CHARBUF_OPEN(general_buf);
  CHARBUF_OPEN(general_inserts_buf);
  CHARBUF_OPEN(attributes_buf);
  CHARBUF_OPEN(declare_procs_buf);
  CHARBUF_OPEN(declare_no_check_procs_buf);
  CHARBUF_OPEN(declare_funcs_buf);
  CHARBUF_OPEN(declare_no_check_funcs_buf);
  CHARBUF_OPEN(declare_select_funcs_buf);
  CHARBUF_OPEN(declare_no_check_select_funcs_buf);
  CHARBUF_OPEN(declare_interfaces_buf);

  queries = &query_buf;
  inserts = &insert_buf;
  updates = &update_buf;
  deletes = &delete_buf;
  general = &general_buf;
  general_inserts = &general_inserts_buf;

  symtab *stmts = symtab_new();

  STMT_INIT(create_proc_stmt, cg_json_create_proc, NULL);
  STMT_INIT(declare_vars_type, cg_json_database_var, &attributes_buf);
  STMT_INIT(declare_interface_stmt, cg_json_declare_interface, &declare_interfaces_buf);
  STMT_INIT(declare_proc_stmt, cg_json_declare_proc, &declare_procs_buf);
  STMT_INIT(declare_proc_no_check_stmt, cg_json_declare_proc_no_check, &declare_no_check_procs_buf);
  STMT_INIT(declare_func_stmt, cg_json_declare_func, &declare_funcs_buf);
  STMT_INIT(declare_func_no_check_stmt, cg_json_declare_func, &declare_no_check_funcs_buf);
  STMT_INIT(declare_select_func_stmt, cg_json_declare_func, &declare_select_funcs_buf);
  STMT_INIT(declare_select_func_no_check_stmt, cg_json_declare_func, &declare_no_check_select_funcs_buf);


  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);

    // declares can be duplicated, we don't want to emit more than one into the JSON
    // e.g. you can declare the same proc twice
    if (is_alias_ast(stmt)) {
      continue;
    }

    // Search for the functions we declared above and dispatch
    symtab_entry *entry = symtab_find(stmts, stmt->type);
    if (!entry) {
      continue;
    }

    json_dispatch *disp = (json_dispatch *)entry->val;
    disp->func(disp->out, stmt, misc_attrs);
  }

  symtab_delete(stmts);

  bprintf(output, "\"attributes\" : [");
  bprintf(output, "%s", attributes_buf.ptr);
  bprintf(output, "\n],\n");

  bprintf(output, "\"queries\" : [\n");
  bindent(output, queries, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"inserts\" : [\n");
  bindent(output, inserts, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"generalInserts\" : [\n");
  bindent(output, general_inserts, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"updates\" : [\n");
  bindent(output, updates, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"deletes\" : [\n");
  bindent(output, deletes, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"general\" : [\n");
  bindent(output, general, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"declareProcs\" : [\n");
  bindent(output, &declare_procs_buf, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"declareNoCheckProcs\" : [\n");
  bindent(output, &declare_no_check_procs_buf, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"declareFuncs\" : [\n");
  bindent(output, &declare_funcs_buf, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"declareNoCheckFuncs\" : [\n");
  bindent(output, &declare_no_check_funcs_buf, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"declareSelectFuncs\" : [\n");
  bindent(output, &declare_select_funcs_buf, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"declareNoCheckSelectFuncs\" : [\n");
  bindent(output, &declare_no_check_select_funcs_buf, 2);
  bprintf(output, "\n],\n");

  bprintf(output, "\"interfaces\" : [\n");
  bindent(output, &declare_interfaces_buf, 2);
  bprintf(output, "\n]");

  CHARBUF_CLOSE(declare_interfaces_buf);
  CHARBUF_CLOSE(declare_no_check_select_funcs_buf);
  CHARBUF_CLOSE(declare_select_funcs_buf);
  CHARBUF_CLOSE(declare_no_check_funcs_buf);
  CHARBUF_CLOSE(declare_funcs_buf);
  CHARBUF_CLOSE(declare_no_check_procs_buf);
  CHARBUF_CLOSE(declare_procs_buf);
  CHARBUF_CLOSE(attributes_buf);
  CHARBUF_CLOSE(general_inserts_buf);
  CHARBUF_CLOSE(general_buf);
  CHARBUF_CLOSE(delete_buf);
  CHARBUF_CLOSE(update_buf);
  CHARBUF_CLOSE(insert_buf);
  CHARBUF_CLOSE(query_buf);

  // Ensure the globals do not hold any pointers so that leaksan will find any leaks
  // All of these have already been freed (above)
  queries = NULL;
  deletes = NULL;
  inserts = NULL;
  updates = NULL;
  general = NULL;
  general_inserts = NULL;
}

// Here we emit a top level fragment that has all the tables and
// all the procedures that use that table.  This is the reverse mapping
// from the proc section where each proc defines which tables it uses.
// i.e. we can use this map to go from a dirty table name to a list of
// affected queries/updates etc.
static void cg_json_table_users(charbuf *output) {
  uint32_t count = tables_to_procs->count;
  symtab_entry *deps = symtab_copy_sorted_payload(tables_to_procs, default_symtab_comparator);

  bprintf(output, "\"tableUsers\" : {\n");
  BEGIN_INDENT(users, 2);
  BEGIN_LIST;
  for (uint32_t i = 0; i < count; i++) {
    CSTR sym = deps[i].sym;
    charbuf *buf = (charbuf*)deps[i].val;

    COMMA;
    bprintf(output, "\"%s\" : [ %s ]", sym, buf->ptr);
  }
  END_LIST;
  END_INDENT(users);
  bprintf(output, "}");
  free(deps);
}

// Main entry point for json schema format
cql_noexport void cg_json_schema_main(ast_node *head) {
  Contract(options.file_names_count == 1);

  cql_exit_on_semantic_errors(head);

  tables_to_procs = symtab_new();

  CHARBUF_OPEN(main);
  charbuf *output = &main;

  bprintf(output, "%s", rt->source_prefix);

  // master dictionary begins
  bprintf(output, "\n{\n");
  BEGIN_INDENT(defs, 2);
  cg_json_tables(output);
  bprintf(output, ",\n");
  cg_json_virtual_tables(output);
  bprintf(output, ",\n");
  cg_json_views(output);
  bprintf(output, ",\n");
  cg_json_indices(output);
  bprintf(output, ",\n");
  cg_json_triggers(output);
  bprintf(output, ",\n");
  cg_json_stmt_list(output, head);
  bprintf(output, ",\n");
  cg_json_regions(output);
  bprintf(output, ",\n");
  cg_json_ad_hoc_migration_procs(output);
  bprintf(output, ",\n");
  cg_json_enums(output);
  bprintf(output, ",\n");
  cg_json_constant_groups( output);
  bprintf(output, ",\n");
  cg_json_subscriptions( output);

  if (options.test) {
    bprintf(output, ",\n");
    cg_json_table_users(output);
  }

  END_INDENT(defs);
  bprintf(output, "\n}\n");

  cql_write_file(options.file_names[0], output->ptr);
  CHARBUF_CLOSE(main);

  SYMTAB_CLEANUP(tables_to_procs);
}
#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Perform codegen of the various nodes to "LUA".

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_CG_LUA)

// stubs to avoid link errors.
cql_noexport void cg_lua_main(ast_node *head) {}
cql_noexport void cg_lua_init(void) {}
cql_noexport void cg_lua_cleanup() {}

#else


// relevant LUA binding order
#define LUA_EXPR_PRI_ROOT -999
#define LUA_EXPR_PRI_ASSIGN 0
#define LUA_EXPR_PRI_LOR 1
#define LUA_EXPR_PRI_LAND 2
#define LUA_EXPR_PRI_EQ_NE 3
#define LUA_EXPR_PRI_LT_GT 3
#define LUA_EXPR_PRI_BOR  4
#define LUA_EXPR_PRI_BXOR  5 // not used
#define LUA_EXPR_PRI_BAND 6
#define LUA_EXPR_PRI_SHIFT 7
#define LUA_EXPR_PRI_ADD 8
#define LUA_EXPR_PRI_MUL 9
#define LUA_EXPR_PRI_UNARY 10
#define LUA_EXPR_PRI_HIGHEST 999

static void cg_lua_expr(ast_node *node, charbuf *value, int32_t pri);
static void cg_lua_stmt_list(ast_node *node);
static void cg_lua_get_column(sem_t sem_type, CSTR cursor, int32_t index, CSTR var, charbuf *output);
static void cg_lua_binary(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new);
static void cg_lua_is_or_is_not(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new);
static void cg_lua_store_same_type(charbuf *output, CSTR var, sem_t sem_type, CSTR value);
static void cg_lua_store(charbuf *output, CSTR var, sem_t sem_type_var, sem_t sem_type_expr, CSTR value);
static void cg_lua_call_stmt_with_cursor(ast_node *ast, CSTR cursor_name);
static void cg_lua_proc_result_set(ast_node *ast);
static void cg_lua_var_decl(charbuf *output, sem_t sem_type, CSTR base_name);
static void cg_lua_emit_external_arglist(ast_node *expr_list, charbuf *invocation);
static void cg_lua_call_named_external(CSTR name, ast_node *expr_list);
static void cg_lua_user_func(ast_node *ast, charbuf *value);
static void cg_lua_copy(charbuf *output, CSTR var, sem_t sem_type_var, CSTR value);
static void cg_lua_insert_dummy_spec(ast_node *ast);
static void cg_lua_declare_simple_var(sem_t sem_type, CSTR name);
static void cg_lua_put_typecode(charbuf *output, sem_t sem_type);
cql_noexport void cg_lua_init(void);

// lots of AST nodes require no action -- this guy is very good at that.
static void cg_lua_no_op(ast_node * ast) {
}

// Emits a sql statement with bound args.
static int32_t cg_lua_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_lua_exec);

// These globals represent the major state of the code-generator

// True if we are presently emitting a stored proc
static bool_t lua_in_proc = 0;

// True if we are emitting a variable group
static bool_t lua_in_var_group_emit = false;

// True if we are in a loop (hence the statement might run again)
static bool_t lua_in_loop = 0;

// exports file if we are outputing exports
static charbuf *lua_exports_output = NULL;

// The stack level, which facilitates safe re-use of scratch variables.
static int32_t lua_stack_level = 0;

// Case statements might need to generate a unique label for their "else" code
// We count the statements to make an easy label
static int32_t lua_case_statement_count = 0;

// We need a local to hold the (const char *) conversion of a string reference
// when calling out to external code. This gives each such temporary a unique name.
static int32_t lua_temp_cstr_count = 0;

// This tells us if we needed a temporary statement to do an exec or prepare
// with no visible statement result.  If we emitted the temporary we have to
// clean it up.  Examples of this set x := (select 1);   or  DELETE from foo;
static bool_t lua_temp_statement_emitted = 0;

// This tells us if we have already emitted the declaration for the dummy data
// seed variable holder _seed_ in the current context.
static bool_t lua_seed_declared;

// Each catch block needs a unique pair of lables, they are numbered.
static int32_t lua_catch_block_count = 0;

#define CQL_CLEANUP_DEFAULT_LABEL "cql_cleanup"

// In the event of a failure of a sql block or a throw we need to emit
// a goto to the current cleanup target. This is it.  Try/catch manipulate this.
static CSTR lua_error_target = CQL_CLEANUP_DEFAULT_LABEL;

#define CQL_LUA_RCTHROWN_DEFAULT "CQL_OK"  // no variable at the root level, it's just "ok"
// When we need the most recent caught error code we have to use the variable that is
// holding the right value.  Each catch scope has its own corresponding to the error
// that it caught.

static CSTR lua_rcthrown_current = CQL_LUA_RCTHROWN_DEFAULT;
static int32_t lua_rcthrown_index = 0;
static bool_t lua_rcthrown_used = false;

// We set this to true when we have used the error target in the current context
// The current context is either the current procedure or the current try/catch block
// If this is true we need to emit the cleanup label.
static bool_t lua_error_target_used = false;

// We set this to true if a "return" statement happened in a proc.  This also
// forces the top level "cql_cleanup" to be emitted.  We need a different flag for this
// because no matter how deeply nested we are "return" goes to the outermost error target.
// If this is set we will emit that top level target even if there were no other uses.
static bool_t lua_return_used = false;

// We use this table to track named scratch variables that we might need
// this is used in cases where the name has to be computed and there may be several of them
static symtab *lua_named_temporaries;

// The current shared fragment number in the current procdure
static int32_t proc_cte_index;

// This is the mapping between the original parameter name and the aliased name
// for a particular parameter of a particular shared CTE fragment
static symtab *proc_arg_aliases;

// This is the mapping between the original CTE and the aliased name
// for a particular parameter of a particular shared CTE fragment
static symtab *proc_cte_aliases;

// Shared fragment management state
// These are the important fragment classifications, we can use simpler codegen if
// some of these are false.
static bool_t lua_has_conditional_fragments;
static bool_t lua_has_shared_fragments;
static bool_t lua_has_variables;

// Each prepared statement in a proc gets a unique index
static int32_t lua_prepared_statement_index;

// Each bound statement in a proc gets a unique index
static int32_t lua_cur_bound_statement;

// this holds the text of the generated SQL broken at fragment boundaries
static bytebuf lua_shared_fragment_strings = {NULL, 0, 0};

// these track the current and max predicate number, these
// correspond 1:1 with a fragment string in the shared_fragment_strings buffer
static int32_t lua_max_fragment_predicate = 0;
static int32_t lua_cur_fragment_predicate = 0;

// these track the current variable count, we snapshot the previous count
// before generating each fragment string so we know how many variables were in there
// we use these to emit the appropriate booleans for each bound variable
static int32_t lua_prev_variable_count;
static int32_t lua_cur_variable_count;
static bool_t lua_continue_label_needed;
static int32_t lua_continue_label_number;
static int32_t lua_continue_label_next;

static bool_t lua_in_inline_function_fragment;

// the current proc name or null
static CSTR lua_current_proc_name() {
  CSTR result = NULL;
  if (current_proc) {
    ast_node *proc_name_ast = get_proc_name(current_proc);
    EXTRACT_STRING(proc_name, proc_name_ast);
    result = proc_name;
  }

  return result;
}

// generate an error if the given expression is true (note this drives tracing)
static void cg_lua_error_on_expr(CSTR expr) {
  bprintf(cg_main_output, "if %s then cql_error_trace(_rc_, _db_); goto %s; end\n", expr, lua_error_target);
  lua_error_target_used = true;
}

// generate an error if the return code is not the required value (helper for common case)
static void cg_lua_error_on_rc_notequal(CSTR required) {
  CHARBUF_OPEN(tmp);
  bprintf(&tmp, "_rc_ ~= %s", required);
  cg_lua_error_on_expr(tmp.ptr);
  CHARBUF_CLOSE(tmp);
}

// generate an error if the return code is not CQL_OK (helper for common case)
static void cg_lua_error_on_not_sqlite_ok() {
  cg_lua_error_on_expr("_rc_ ~= CQL_OK");
}

// This tells us if a subtree should be wrapped in ()
// Basically we know the binding strength of the context (pri) and the current element (pri_new)
// Weaker contexts get parens.  Equal contexts get parens on the right side because all ops
// are left to right associtive in SQL. Stronger child contexts never need parens because
// the operator already binds tighter than its parent in the tree.
static bool_t lua_needs_paren(ast_node *ast, int32_t pri_new, int32_t pri) {
  // if the priorities are different then parens are needed
  // if and only if the new priority (this node) is weaker than the
  // containing priority (the parent node)

  if (pri_new != pri) {
    return pri_new < pri;
  }

  // If equal binding strength, put parens on the right of the expression
  // because our entire world is left associative.
  //
  //  so e.g.  *(a, /(b,c)) becomes a*(b/c);

  return ast->parent->right == ast;
}

// emits a cql_to_num call including a few special cases
// e.g. cql_to_num(true) and cql_to_num(false) are very common
static void cg_lua_emit_to_num(charbuf *output, CSTR input) {
  if (!strcmp("true", input)) {
    bprintf(output, "1");
    return;
  }
  if (!strcmp("false", input)) {
    bprintf(output, "0");
    return;
  }
  if (!strcmp("nil", input)) {
    bprintf(output, "nil");
    return;
  }
  bprintf(output, "cql_to_num(%s)", input);
}

// converts a boolean into a number if necessary
// this is important because stuff like "true + 1 == 2" must be true
static void cg_lua_to_num(sem_t sem_type, charbuf *value) {
  if (is_bool(sem_type)) {
     CHARBUF_OPEN(temp);
     bprintf(&temp, "%s", value->ptr);
     bclear(value);
     cg_lua_emit_to_num(value, temp.ptr);
     CHARBUF_CLOSE(temp);
  }
}

// emits a cql_to_float call
static void cg_lua_emit_to_float(charbuf *output, CSTR input) {
  if (!strcmp("nil", input)) {
    bprintf(output, "nil");
    return;
  }
  bprintf(output, "cql_to_float(%s)", input);
}

// converts a boolean into a number if necessary
// this is important because stuff like "true + 1 == 2" must be true
static void cg_lua_to_float(sem_t sem_type, charbuf *value) {
  if (!is_real(sem_type)) {
     CHARBUF_OPEN(temp);
     bprintf(&temp, "%s", value->ptr);
     bclear(value);
     cg_lua_emit_to_float(value, temp.ptr);
     CHARBUF_CLOSE(temp);
  }
}

// Emits cql_to_bool include special cases for the most common conversions
// 0, 1, and nil all get hard coded treatment, otherwise use the helper.
static void cg_lua_emit_to_bool(charbuf *output, CSTR input) {
  if (!strcmp("1", input)) {
    bprintf(output, "true");
    return;
  }
  if (!strcmp("0", input)) {
    bprintf(output, "false");
    return;
  }
  if (!strcmp("nil", input)) {
    bprintf(output, "nil");
    return;
  }
  bprintf(output, "cql_to_bool(%s)", input);
}

// converts a numeric type into a boolean, this is important because
// in lua 0 is not falsey.  So we must always generate stuff like
// if cql_to_bool(int_expression) if we have a numeric exprecession and
// need a boolean expression.
static void cg_lua_to_bool(sem_t sem_type, charbuf *value) {
  if (!is_bool(sem_type)) {
     CHARBUF_OPEN(temp);
     bprintf(&temp, "%s", value->ptr);
     bclear(value);
     cg_lua_emit_to_bool(value, temp.ptr);
     CHARBUF_CLOSE(temp);
  }
}

// We have a series of masks to remember if we have emitted any given scratch variable.
// We might need several temporaries at the same level if different types appear
// at the same level but in practice we tend not to run into such things.  Mostly
// this works very well at arranging for the same scratch nullable int (or whatever)
// to be re-used in every statement.  The stack depth is limited to bundles of 64bits
//  with thisrepresentation. One bit for each stack level tracks if the temp has been
// generated.  This could be extended if needed...
typedef struct cg_lua_type_masks {
  uint64_t reals[CQL_MAX_STACK/64];
  uint64_t bools[CQL_MAX_STACK/64];
  uint64_t ints[CQL_MAX_STACK/64];
  uint64_t longs[CQL_MAX_STACK/64];
  uint64_t strings[CQL_MAX_STACK/64];
  uint64_t objects[CQL_MAX_STACK/64];
  uint64_t blobs[CQL_MAX_STACK/64];
} cg_lua_type_masks;

// There is one set of masks for nullables and another for not-nullables.
// Lua has very little need of this stuff, switch & case are good examples
typedef struct cg_lua_scratch_masks {
  cg_lua_type_masks nullables;
  cg_lua_type_masks notnullables;
} cg_lua_scratch_masks;

// Any new name context might need new temporaries, this points to the current
// context.  In practice it is set when we start processing a proc and it
// is cleared when we exit that proc.
static cg_lua_scratch_masks *_Nullable cg_lua_current_masks;

// just like it sounds
static void cg_lua_zero_masks(cg_lua_scratch_masks *_Nonnull masks) {
  memset(masks, 0, sizeof(*masks));
}

// Reference types and non-null locals begin at a zero value.  References are especially
// crucial because if they started at something other than null then we would try to
// release that pointer on exit which would be bad.  Note that this means that even
// a non-null text variable (for instance) begins at null when it is initialized.  This is
// much like the _Nonnull clang option which can't prevent a global variable from starting
// at null.  It's a bit weird but there isn't really a viable alternative short of some
// non-null BS value which seems worse.
static void cg_lua_emit_local_init(charbuf *output, sem_t sem_type)
{
  if (is_nullable(sem_type)) {
    // no init needed
    bprintf(output, "\n");
    return;
  }

  sem_t core_type = core_type_of(sem_type);
  switch (core_type) {
    case SEM_TYPE_INTEGER:
    case SEM_TYPE_LONG_INTEGER:
      bprintf(output, " = 0\n");
      break;

    case SEM_TYPE_TEXT:
    case SEM_TYPE_BLOB:
    case SEM_TYPE_OBJECT:
      // no init needed
      bprintf(output, "\n");
      break;

    case SEM_TYPE_REAL:
      bprintf(output, " = 0.0\n");
      break;

    case SEM_TYPE_BOOL:
      bprintf(output, " = false\n");
      break;
   }
}

// Emit a declaration for a local whose name is base_name and whose type
// is given by sem_type.   Is_local really only decides if we add "\n" to
// the end of the output.  This lets us use the same helper for list of
// arg-prototypes as a list of declarations.
// The real "trick" here is:
//  * flags might say it's an output parameter in which case we declare a pointer
//  * flags might indicate nullable, in which case we need the struct version
//  * text is always a reference, nullable or no.  But if you make a text local
//    then we also gotta clean it up.
static void cg_lua_var_decl(charbuf *output, sem_t sem_type, CSTR name) {
  Contract(is_unitary(sem_type));
  Contract(!is_null_type(sem_type)); // null alias never gets here
  Contract(cg_main_output);

  if (lua_in_var_group_emit) {
    // we only need initializers for not-null types that are not reference types
    // here we are avoiding bogus looking codegen taking advantage that
    // variables have the value nil by default which is the correct starting
    // value for nullable types and ref types.
    if (is_nullable(sem_type) || is_ref_type(sem_type)) {
      // no init needed
      return;
    }
  }
  else {
    // variable groups are global by construction so don't emit "local" for them
    // if we're here this not a variable group
    bprintf(output, "local ");
  }

  bprintf(output, "%s", name);
  cg_lua_emit_local_init(output, sem_type);
}

// Sometimes when we need a scratch variable to store an intermediate result
// we can avoid the scratch variable entirely and use the target of the assignment
// in flight for the storage.  For instance:
//   declare x, y integer;
//   set y := 1;
//   set x := case when y == 1 then 3 else 2 end;
//
// A scratch variable is not used to hold the result of the RHS of the set because
// the target of the assignment is known and compatible.
// The target must match the exact type including nullability.  Note bogus
// sensitive assignments or incompatible assignments were already ruled out
// in semantic analysis.
static bool_t lua_is_assignment_target_reusable(ast_node *ast, sem_t sem_type) {
  if (ast && ast->parent && (is_ast_assign(ast->parent) || is_ast_let_stmt(ast->parent))) {
    EXTRACT_NAME_AST(name_ast, ast->parent->left);
    sem_t sem_type_target = name_ast->sem->sem_type;
    sem_type_target &= (SEM_TYPE_CORE | SEM_TYPE_NOTNULL);
    return sem_type_target == sem_type;
  }
  return false;
}

// The scratch variable helper uses the given sem_type and the current
// stack level to create a temporary variable name for that type at that level.
// If the variable does not already have a declaration (as determined by the masks)
// then a declaration is added to the scratch_vars section.
static void cg_lua_scratch_var(ast_node *ast, sem_t sem_type, charbuf *var, charbuf *value) {
  Contract(is_unitary(sem_type));
  Contract(!is_null_type(sem_type));

  sem_t core_type = core_type_of(sem_type);
  sem_type &= (SEM_TYPE_CORE | SEM_TYPE_NOTNULL);

  Contract(lua_stack_level < CQL_MAX_STACK);

  // try to avoid creating a scratch variable if we can use the target of an assignment in flight.
  if (lua_is_assignment_target_reusable(ast, sem_type)) {
    Invariant(ast && ast->parent && ast->parent->left);
    EXTRACT_NAME_AST(name_ast, ast->parent->left);
    EXTRACT_STRING(name, name_ast);
    bprintf(var, "%s", name);
  }
  else {
    // Generate a scratch variable name of the correct type.  We don't generate
    // the declaration of any given scratch variable more than once.  We use the
    // current stack level to make the name.  This means that have to burn a stack level
    // if you want more than one scratch.  Stacklevel is normally increased by
    // the CG_LUA_PUSH_EVAL macro which does the recursion but it can also be manually
    // increased if temporaries are needed for some other reason.  Any level of
    // recursion is expected to fix all that.

    CSTR prefix;

    cg_lua_type_masks *pmask;
    if (is_nullable(sem_type)) {
      pmask = &cg_lua_current_masks->nullables;
      prefix = "_tmp_n";
    }
    else {
      pmask = &cg_lua_current_masks->notnullables;
      prefix = "_tmp";
    }

    uint64_t *usedmask = NULL;

    switch (core_type) {
      case SEM_TYPE_INTEGER:
        bprintf(var, "%s_int_%d", prefix, lua_stack_level);
        usedmask = pmask->ints;
        break;
      case SEM_TYPE_BLOB:
        bprintf(var, "%s_blob_%d", prefix, lua_stack_level);
        usedmask = pmask->blobs;
        break;
      case SEM_TYPE_OBJECT:
        bprintf(var, "%s_object_%d", prefix, lua_stack_level);
        usedmask = pmask->objects;
        break;
      case SEM_TYPE_TEXT:
        bprintf(var, "%s_text_%d", prefix, lua_stack_level);
        usedmask = pmask->strings;
        break;
      case SEM_TYPE_LONG_INTEGER:
        bprintf(var, "%s_int64_%d", prefix, lua_stack_level);
        usedmask = pmask->longs;
        break;
      case SEM_TYPE_REAL:
        bprintf(var, "%s_double_%d", prefix, lua_stack_level);
        usedmask = pmask->reals;
        break;
      case SEM_TYPE_BOOL:
        bprintf(var, "%s_bool_%d", prefix, lua_stack_level);
        usedmask = pmask->bools;
        break;
    }

    int32_t index = lua_stack_level/64;
    uint64_t mask = ((uint64_t)1) << (lua_stack_level % 64);

    // Emit scratch if needed.
    if (!(usedmask[index] & mask)) {
      cg_lua_var_decl(cg_scratch_vars_output, sem_type, var->ptr);
      usedmask[index] |= mask;
    }
  }

  // If the value expression is desired, generate them here.
  if (value) {
    bprintf(value, "%s", var->ptr);
  }
}

// Set nullable output type to null.
static void cg_lua_set_null(charbuf *output, CSTR name, sem_t sem_type) {
  bprintf(output, "%s = nil\n", name);
}

// Once we've done any type conversions for the basic types we can do pretty simple assignments
// The nullable non-reference types typically need of the helper macros unless it's an exact-type copy
// operation.  This function is used by cg_lua_store near the finish line.
static void cg_lua_copy(charbuf *output, CSTR var, sem_t sem_type_var, CSTR value) {
  bprintf(output, "%s = %s\n", var, value);
}

// This is most general store function.  Given the type of the destination and the type of the source
// plus the value of the source it generates the correct operation to set it.
// * if storing to a boolean from a non-boolean normalize the result to true/false
// * if storing to a non-boolean from a boolean normalize the result to 0/1
static void cg_lua_store(charbuf *output, CSTR var, sem_t sem_type_var, sem_t sem_type_expr, CSTR value) {
  // dead store -- source = target
  if (!strcmp(var, value)) {
    // dead store -- source = target
    return;
  }

  CHARBUF_OPEN(result);
  bprintf(&result, "%s", value);

  // Normalize floats and bools for storage
  if (is_real(sem_type_var) && !is_real(sem_type_expr)) {
    cg_lua_to_float(sem_type_expr, &result);
  }
  else if (is_bool(sem_type_var) && !is_bool(sem_type_expr)) {
    cg_lua_to_bool(sem_type_expr, &result);
  }
  else if (!is_bool(sem_type_var) && is_bool(sem_type_expr)) {
    cg_lua_to_num(sem_type_expr, &result);
  }

  cg_lua_copy(output, var, sem_type_var, result.ptr);
  CHARBUF_CLOSE(result);
}

// This is a simple helper for store where we know that the type of the thing being stored
// is exactly the same as the type of the thing we are storing.  This is used when we
// just made a temporary of exactly the correct type to hold an expression.  cg_lua_store
// handles this all but this helper lets you specify only one type.
static void cg_lua_store_same_type(charbuf *output, CSTR var, sem_t sem_type, CSTR value) {
  cg_lua_store(output, var, sem_type, sem_type, value);
}

// All the normal (no short-circuit) binary operators
// can be handled the same way.
//   * op is the operator text
//   * value is  the usual outputs
//   * pri is the strength of the caller
//   * pri_new is the strength of "op"
// The helper lua_needs_paren() tells us if we should wrap this subtree in parens (see above)
// If the inputs are not nullable then we can make the easy case of returning the
// result in the value string (and 0 for is null).  Otherwise, cg_lua_combine_nullables
// does the job.
static void cg_lua_binary(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  // left op right
  bool_t force_call = false;

  ast_node *l = ast->left;
  ast_node *r = ast->right;

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_left = l->sem->sem_type;
  sem_t sem_type_right = r->sem->sem_type;

  CSTR op_name = ast->type;

  // Integer division in Lua has different truncation policy for negative
  // numbers than C, we have to emulate the C/SQLite behavior
  if (!strcmp(op, "/")) {
    if (core_type_of(sem_type_result) != SEM_TYPE_REAL) {
       // lua integer division operator
       op_name = "idiv";
       force_call = true;
    }
  }

  // Integer mod in lua results in different signs for negative
  // numbers than C. We have to emulate the C/SQLite behavior
  // Mod is only allowed to operate on integer so we don't have to check
  if (!strcmp(op, "%")) {
    force_call = true;
  }

  if (!strcmp(op, "~=")) {
    if (core_type_of(sem_type_right) == SEM_TYPE_BLOB) {
      force_call = true;
      op_name = "blob_ne";
    }
  }

  if (!strcmp(op, "==")) {
    if (core_type_of(sem_type_right) == SEM_TYPE_BLOB) {
      force_call = true;
      op_name = "blob_eq";
    }
  }

  if (!strcmp(op, "like") || !strcmp(op, "not_like")) {
    force_call = true;
  }

  if (sem_type_result == SEM_TYPE_NULL) {
    bprintf(value, "nil");
    return;
  }

  // this hold the formula for the answer
  CG_LUA_PUSH_EVAL(l, pri_new);
  CG_LUA_PUSH_EVAL(r, pri_new);

  cg_lua_to_num(sem_type_left, &l_value);
  cg_lua_to_num(sem_type_right, &r_value);

  if (!strcmp(l_value.ptr, "nil") || !strcmp(r_value.ptr, "nil")) {
    bprintf(value, "nil");
  }
  else if (force_call || is_nullable(sem_type_left) || is_nullable(sem_type_right)) {
    bprintf(value, "cql_%s(%s, %s)", op_name, l_value.ptr, r_value.ptr);
  }
  else {
    if (lua_needs_paren(ast, pri_new, pri)) {
      bprintf(value, "(%s %s %s)", l_value.ptr, op, r_value.ptr);
    }
    else {
      bprintf(value, "%s %s %s", l_value.ptr, op, r_value.ptr);
    }
  }

  CG_LUA_POP_EVAL(r);
  CG_LUA_POP_EVAL(l);
}

// All the "is" operators are the same as binary ops but they do not handle null
// specially.  e.g. null is null evaluates with = with no extra null logic needed
// so they can be handled even more simply than regular binary ops
// can be handled the same way.
//   * op is the operator text
//   * value is  the usual outputs
//   * pri is the strength of the caller
//   * pri_new is the strength of "op"
// The helper lua_needs_paren() tells us if we should wrap this subtree in parens (see above)
// If the inputs are not nullable then we can make the easy case of returning the
// result in the value string (and 0 for is null).
static void cg_lua_is_or_is_not(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  // left op right

  ast_node *l = ast->left;
  ast_node *r = ast->right;

  sem_t sem_type_left = l->sem->sem_type;
  sem_t sem_type_right = r->sem->sem_type;

  // this hold the formula for the answer
  CG_LUA_PUSH_EVAL(l, pri_new);
  CG_LUA_PUSH_EVAL(r, pri_new);

  cg_lua_to_num(sem_type_left, &l_value);
  cg_lua_to_num(sem_type_right, &r_value);

  if (!strcmp(op, "~=") && core_type_of(sem_type_right) == SEM_TYPE_BLOB) {
    bprintf(value, "cql_blob_is_ne(%s, %s)", l_value.ptr, r_value.ptr);
  }
  else if (!strcmp(op, "==") && core_type_of(sem_type_right) == SEM_TYPE_BLOB) {
    bprintf(value, "cql_blob_is_eq(%s, %s)", l_value.ptr, r_value.ptr);
  }
  else if (lua_needs_paren(ast, pri_new, pri)) {
    bprintf(value, "(%s %s %s)", l_value.ptr, op, r_value.ptr);
  }
  else {
    bprintf(value, "%s %s %s", l_value.ptr, op, r_value.ptr);
  }

  CG_LUA_POP_EVAL(r);
  CG_LUA_POP_EVAL(l);
}

// code gen for expr IS FALSE
// operands already known to be of the correct type so all we have to do is
// check for nullable or not nullable and generate the appropriate code using
// either the helper or just looking at the value
// this must never return nil
static void cg_lua_expr_is_false(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_false(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  // expr IS FALSE
  sem_t sem_type_is_expr = expr->sem->sem_type;

  // we always put parens because ! is the highest binding, so we can use ROOT, the callee never needs parens
  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  if (is_nullable(sem_type_is_expr)) {
    bprintf(value, "cql_is_false(%s)", expr_value.ptr);
  }
  else if (is_bool(sem_type_is_expr)) {
    bprintf(value, "not(%s)", expr_value.ptr);
  }
  else {
    bprintf(value, "(%s == 0)", expr_value.ptr);
  }

  CG_LUA_POP_EVAL(expr);
}

// code gen for expr IS NOT FALSE
// operands already known to be of the correct type so all we have to do is
// check for nullable or not nullable and generate the appropriate code using
// either the helper or just looking at the value
// this must never return nil
static void cg_lua_expr_is_not_false(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_not_false(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  sem_t sem_type_is_expr = expr->sem->sem_type;

  // expr IS NOT FALSE

  // we always put parens because ! is the highest binding, so we can use ROOT, the callee never needs parens
  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  if (is_nullable(sem_type_is_expr)) {
    bprintf(value, "cql_is_not_false(%s)", expr_value.ptr);
  }
  else if (is_bool(sem_type_is_expr)) {
    bprintf(value, "%s", expr_value.ptr);
  }
  else {
    bprintf(value, "(%s ~= 0)", expr_value.ptr);
  }

  CG_LUA_POP_EVAL(expr);
}

// code gen for expr IS TRUE
// operands already known to be of the correct type so all we have to do is
// check for nullable or not nullable and generate the appropriate code using
// either the helper or just looking at the value
// this must never return nil
static void cg_lua_expr_is_true(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_true(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  sem_t sem_type_is_expr = expr->sem->sem_type;

  // we always put parens because ! is the highest binding, so we can use ROOT, the callee never needs parens
  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  if (is_nullable(sem_type_is_expr)) {
    bprintf(value, "cql_is_true(%s)", expr_value.ptr);
  }
  else if (is_bool(sem_type_is_expr)) {
    bprintf(value, "%s", expr_value.ptr);
  }
  else {
    bprintf(value, "(%s ~= 0)", expr_value.ptr);
  }

  CG_LUA_POP_EVAL(expr);
}

// code gen for expr IS NOT TRUE
// operands already known to be of the correct type so all we have to do is
// check for nullable or not nullable and generate the appropriate code using
// either the helper or just looking at the value
// this must never return nil
static void cg_lua_expr_is_not_true(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_is_not_true(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  sem_t sem_type_is_expr = expr->sem->sem_type;

  // expr IS NOT TRUE

  // we always put parens because ! is the highest binding, so we can use ROOT, the callee never needs parens
  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  if (is_nullable(sem_type_is_expr)) {
    bprintf(value, "cql_is_not_true(%s)", expr_value.ptr);
  }
  else if (is_bool(sem_type_is_expr)) {
    bprintf(value, "not(%s)", expr_value.ptr);
  }
  else {
    bprintf(value, "(%s == 0)", expr_value.ptr);
  }

  CG_LUA_POP_EVAL(expr);
}

// The logical operations are fairly tricky, the code generators for
// each of them are very similar.  In simple cases the direct operator can be
// used, otherwise we wrap the right operand in an anonymous function to defer
// its evaluation and then do the logical op with short circuiting via a helper
static void cg_lua_expr_and_or(ast_node *ast, CSTR str, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_or(ast) || is_ast_and(ast));
  Contract(pri_new == LUA_EXPR_PRI_LOR || pri_new == LUA_EXPR_PRI_LAND);

  EXTRACT_ANY_NOTNULL(l, ast->left);
  EXTRACT_ANY_NOTNULL(r, ast->right);

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_left = l->sem->sem_type;
  sem_t sem_type_right = r->sem->sem_type;

  if (is_ast_null(l) && is_ast_null(r)) {
    bprintf(value, "nil");
    return;
  }

  CG_LUA_RESERVE_RESULT_VAR(ast, sem_type_result);
  CG_LUA_PUSH_EVAL(l, pri_new);
  CHARBUF_OPEN(right_eval);
  charbuf *saved = cg_main_output;
  cg_main_output = &right_eval;

  CG_LUA_PUSH_EVAL(r, pri_new);
  cg_main_output = saved;

  if (!is_nullable(sem_type_result) && right_eval.used == 1) {
    cg_lua_to_bool(sem_type_left, &l_value);
    cg_lua_to_bool(sem_type_right, &r_value);

    if (lua_needs_paren(ast, pri_new, pri)) {
      bprintf(value, "(");
    }
    bprintf(value, "%s %s %s", l_value.ptr, str, r_value.ptr);

    if (lua_needs_paren(ast, pri_new, pri)) {
      bprintf(value, ")");
    }
  }
  else {
    if (right_eval.used > 1) {
      // the answer is coming back in a variable
      CG_LUA_USE_RESULT_VAR();

      // we don't need to normalize the left or the right to bool because
      // the helper functions will handle that for us.
      //
      // NOPE, don't even: cg_lua_to_bool(sem_type_left, &l_value);
      // NOPE, don't even: cg_lua_to_bool(sem_type_right, &r_value);

      CSTR short_circuit_value = !strcmp("or", str) ? "true" : "false";

      // we need a scratch for the left to avoid evaluating it twice
      CG_LUA_PUSH_TEMP(temp, SEM_TYPE_BOOL);
      cg_lua_store_same_type(cg_main_output, temp.ptr, SEM_TYPE_BOOL, l_value.ptr);

      // This is the open coded short circuit version, the only difference between
      // `and` and `or` is the short circuit value (true or false) and of course
      // the test and final logical operation.  The rest of the code is the same.
      bprintf(cg_main_output, "if cql_is_%s(%s) then\n", short_circuit_value, temp.ptr);
      bprintf(cg_main_output, "  "); // indent the one line
      cg_lua_store_same_type(cg_main_output, result_var.ptr, sem_type_result, short_circuit_value);
      bprintf(cg_main_output, "else\n");

        // The evaluation of the right goes here, it could include things that
        // throw (like proc as func calls) so we have to be careful to leave it
        // in a context where "goto cleanup" still works, that means we can't wrap it
        // in a function call like we do in the easier case below.
        CG_PUSH_MAIN_INDENT(r, 2)
        bprintf(cg_main_output, "%s", right_eval.ptr);
        CHARBUF_OPEN(result_expr);
        bprintf(&result_expr, "cql_logical_%s(%s, %s)", str, temp.ptr, r_value.ptr);
        cg_lua_store_same_type(cg_main_output, result_var.ptr, sem_type_result, result_expr.ptr);
        CHARBUF_CLOSE(result_expr);
        CG_POP_MAIN_INDENT(r);

      bprintf(cg_main_output, "end\n");  // end if
      CG_LUA_POP_TEMP(temp);
    }
    else {
      // one line version
      bprintf(value, "cql_shortcircuit_%s(%s, function() return %s end)",
        str, l_value.ptr, r_value.ptr);
    }
  }

  CG_LUA_POP_EVAL(r);
  CHARBUF_CLOSE(right_eval);
  CG_LUA_POP_EVAL(l);
  CG_LUA_CLEANUP_RESULT_VAR();
}

// The unary operators are handled just like the binary operators.  All of the
// LUA outputs have the form (op arg).  We just have to decide if we need parens.
// We use the same rules for parens here as in other places.  "pri" tells us
// the context of the caller, if it is stronger than our operator then we need parens.
static void cg_lua_unary(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  // op [left]

  EXTRACT_ANY_NOTNULL(expr, ast->left);
  sem_t sem_type_expr = expr->sem->sem_type;

  if (!strcmp(op, "-") && is_ast_num(expr)) {
    // we have to do special code gen for -9223372036854775808
    // to avoid compiler warnings...  This is how the literal
    // gets handled in limits.h as well...
    EXTRACT_NUM_TYPE(num_type, expr);
    EXTRACT_NUM_VALUE(lit, expr);

    if (num_type == NUM_LONG && !strcmp("9223372036854775808", lit)) {
      // emit MIN_LONG in a way that the LUA compiler can accept
      bprintf(value, "(-9223372036854775807 - 1)");
      return;
    }
  }

  CHARBUF_OPEN(result);
  CG_LUA_PUSH_EVAL(expr, pri_new)

  // the NOT operator requires that we normalize to bool
  if (!strcmp(op, "not")) {
    cg_lua_to_bool(sem_type_expr, &expr_value);
  }
  else {
    cg_lua_to_num(sem_type_expr, &expr_value);
  }

  if (lua_needs_paren(ast, pri_new, pri)) {
    bprintf(&result, "(%s%s)", op, expr_value.ptr);
  }
  else {
    // We always add a space to avoid creating "--" or "++"
    // expr_value might be -1 or -x or some such.  This way we're
    // always safe at the cost of a space.
    bprintf(&result, "%s %s", op, expr_value.ptr);
  }

  if (is_not_nullable(sem_type_expr)) {
    bprintf(value, "%s", result.ptr);
  }
  else {
    bprintf(value, "cql_unary_%s(%s)", ast->type, expr_value.ptr);
  }

  CG_LUA_POP_EVAL(expr);
  CHARBUF_CLOSE(result);
}

// sign has a standard helper
static void cg_lua_func_sign(ast_node *call_ast, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  // sign ( expr )

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);
  bprintf(value, "cql_unary_sign(%s)", expr_value.ptr);
  CG_LUA_POP_EVAL(expr);
}

// abs has a standard helper
static void cg_lua_func_abs(ast_node *call_ast, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_ANY_NOTNULL(expr, arg_list->left); // first arg

  // abs ( expr )

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);
  bprintf(value, "cql_unary_abs(%s)", expr_value.ptr);
  CG_LUA_POP_EVAL(expr);
}

// This helper generates the tests for each entry in the IN list.
// we generate the appropriate equality test.  We use a helper function
// for blob comparison for flexibility. Note expr is already known
// to be not null here.  There was previous codegen for that case.  The result
// is either bool or nullable bool.
static void cg_lua_in_or_not_in_expr_list(ast_node *head, CSTR expr, CSTR result, sem_t sem_type_result, bool_t is_not_in) {
  Contract(is_bool(sem_type_result));
  CSTR found_value = is_not_in ? "false" : "true";
  CSTR not_found_value = is_not_in ? "true" : "false";

  cg_lua_store_same_type(cg_main_output, result, sem_type_result, found_value);

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_ANY_NOTNULL(in_expr, ast->left)

    // null can't ever match anything, waste of time.
    if (is_ast_null(in_expr)) {
      continue;
    }

    int32_t lua_stack_level_saved = lua_stack_level;
    CG_LUA_PUSH_EVAL(in_expr, LUA_EXPR_PRI_EQ_NE);

    sem_t sem_type_expr = in_expr->sem->sem_type;

    cg_lua_to_num(sem_type_expr, &in_expr_value);

    if (core_type_of(sem_type_expr) == SEM_TYPE_BLOB) {
      bprintf(cg_main_output, "if cql_blob_eq(%s, %s) then break end\n", expr, in_expr_value.ptr);
    }
    else {
      bprintf(cg_main_output, "if %s == %s then break end\n", expr, in_expr_value.ptr);
    }

    CG_LUA_POP_EVAL(in_expr);

    // This comparison clause fully used any temporaries associated with expr
    // this is kind of like the result variable case, except we didn't store the result
    // we used it in the "if" test, but we're done with it.
    lua_stack_level = lua_stack_level_saved;
  }

  cg_lua_store_same_type(cg_main_output, result, sem_type_result, not_found_value);
}

// The [NOT] IN structure is the simplest of the multi-test forms.
// It's actually a special case of case/when if you like.
// Each item in the [NOT] IN needs to be evaluated because there is no rule
// that says they are constants.
// NOT IN is just a similar reversed check compare IN starting with opposite result value.
// The general pattern for  X IN (U, V) looks like this
//
//  int result;
//  repeat
//    prep statements for X;
//    temp = X;
//    if temp is null then result = null break; end [only needed if X is nullable]
//
//    result = true  /* cg_lua_in_or_not_in_expr_list generates the alternatives */
//    (result = false if NOT IN case)
//
//    prep statements for U;
//    compute U;
//    if (temp == U) break;
//
//    prep statements for V
//    compute V
//    if temp == V then break end
//
//    result = false
//    (result = true if NOT IN case)
//   until true
//
// The result ends up in the is_null and value fields as usual.
static void cg_lua_expr_in_pred_or_not_in(
  ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_in_pred(ast) || is_ast_not_in(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left)
  EXTRACT(expr_list, ast->right);

  // [expr] [NOT] IN ( [expr_list] )

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;

  if (is_null_type(sem_type_expr)) {
    bprintf(value, "nil");
    return;
  }

  // The answer will be stored in this scratch variable.
  // note: we do not allow the assignment variable to be used because it might be
  // in the candidate list. Since we write to it before we're done the early
  // "result = 1" would kill something like  r := x in (r, b);
  CG_LUA_SETUP_RESULT_VAR(NULL, sem_type_result);

  bprintf(cg_main_output, "repeat\n");

  CG_PUSH_MAIN_INDENT2(do);

  // Evaluate the expression and stow it in a temporary.
  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);
  CG_LUA_PUSH_TEMP(temp, sem_type_expr);

  cg_lua_to_num(sem_type_expr, &expr_value);

  // Copy the expression, we can't evaluate it more than once, so stow it.
  cg_lua_store_same_type(cg_main_output, temp.ptr, sem_type_expr, expr_value.ptr);

  // If the expression is null the result is null
  if (is_nullable(sem_type_expr)) {
    bprintf(cg_main_output, "if %s == nil then\n", temp_value.ptr);
    bprintf(cg_main_output, "  ");
    cg_lua_set_null(cg_main_output, result_var.ptr, sem_type_result);
    bprintf(cg_main_output, "  break\n");
    bprintf(cg_main_output, "end\n");
  }

  // Now generate the list
  cg_lua_in_or_not_in_expr_list(expr_list, temp_value.ptr, result_var.ptr, sem_type_result, is_ast_not_in(ast));

  CG_LUA_POP_TEMP(temp);
  CG_LUA_POP_EVAL(expr);
  CG_POP_MAIN_INDENT(do);
  CG_LUA_CLEANUP_RESULT_VAR();

  bprintf(cg_main_output, "until true\n");
}

// This helper method emits the alternatives for the case.  If there was an
// expression the temporary holding the expression is in expr.  Expr has
// already been tested for null if that was a possibility so we only need its
// value at this point.
static void cg_lua_case_list(ast_node *head, CSTR expr, CSTR result, sem_t sem_type_result) {
  Contract(is_ast_case_list(head));

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_NOTNULL(when, ast->left);
    EXTRACT_ANY_NOTNULL(case_expr, when->left);
    EXTRACT_ANY_NOTNULL(then_expr, when->right);

    // WHEN [case_expr] THEN [then_expr]

    sem_t sem_type_then_expr = then_expr->sem->sem_type;
    sem_t sem_type_case_expr = case_expr->sem->sem_type;

    int32_t lua_stack_level_saved = lua_stack_level;
    CG_LUA_PUSH_EVAL(case_expr, LUA_EXPR_PRI_EQ_NE);

    if (expr) {
      bprintf(cg_main_output, "if %s == %s then\n", expr, case_expr_value.ptr);
    }
    else {
      cg_lua_to_bool(sem_type_case_expr, &case_expr_value);
      bprintf(cg_main_output, "if %s then\n", case_expr_value.ptr);
    }
    CG_LUA_POP_EVAL(case_expr);

    // The comparison above clause fully used any temporaries associated with expr
    lua_stack_level = lua_stack_level_saved;

    CG_PUSH_MAIN_INDENT2(then);
    CG_LUA_PUSH_EVAL(then_expr, LUA_EXPR_PRI_ROOT);

    cg_lua_store(cg_main_output, result, sem_type_result, sem_type_then_expr, then_expr_value.ptr);
    bprintf(cg_main_output, "break\n");

    CG_LUA_POP_EVAL(then_expr);
    CG_POP_MAIN_INDENT(then);
    bprintf(cg_main_output, "end\n");

    // This 'then' clause stored its result, temporaries no longer needed
    // This is just like the result variable case
    lua_stack_level = lua_stack_level_saved;
  }
}

// Case looks a lot like IN except the net result is computed at each step
// and the test is different at each step.  It's a straight generalization.
//
// Case X when U then R1 when V then R2 else R3 end;
//
//   declare result (whatever type holds R1, R2, and R3)
//
//   repeat
//     statements to evaluate X
//     temp = X
//     [ if temp is null then goto case_else end ] optional if temp is nullable
//
//     statements to evaluate U
//     if temp == U then
//       statements to evaluate R1
//       result = R1
//       break
//     end
//
//     statements to evaluate V
//     if temp == V then
//       statements to evaluate R2
//       result = R2
//       break
//     end
//
//   ::case_else::
//     statements to evaluate R3;
//     result = R3
//   until true
//
// If the X is omitted then U and V are normal boolean expressions and
// the code becomes if (U) etc  if (V) etc. with no temp.
static void cg_lua_expr_case(ast_node *case_expr, CSTR str, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_case_expr(case_expr));
  EXTRACT_ANY(expr, case_expr->left);
  EXTRACT_NOTNULL(connector, case_expr->right);
  EXTRACT_NOTNULL(case_list, connector->left);
  EXTRACT_ANY(else_expr, connector->right);

  // if we need an else label, this will hold the value.
  int32_t else_label_number = -1;

  sem_t sem_type_result = case_expr->sem->sem_type;

  // CASE [expr]? [case_list] ELSE [else_expr] END

  // The answer will be stored in this scratch variable, any type is possible
  CG_LUA_SETUP_RESULT_VAR(case_expr, sem_type_result);

  bprintf(cg_main_output, "repeat\n");

  CG_PUSH_MAIN_INDENT2(do);

  // if the form is case expr when ... then save the expr in a temporary
  if (expr) {
    sem_t sem_type_expr = expr->sem->sem_type;
    CG_LUA_PUSH_TEMP(temp, sem_type_expr);

    int32_t lua_stack_level_saved = lua_stack_level;

    // Compute the value of the expression.
    CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_EQ_NE);

    // Store it in the temporary we just made, which has the exact correct type (we just made it)
    cg_lua_store_same_type(cg_main_output, temp.ptr, sem_type_expr, expr_value.ptr);

    // here "temp" is like a mini-result variable... anything from expr can be released
    // we only need temp now, so restore to that level.
    lua_stack_level = lua_stack_level_saved;

    // If the expression is null, then we go to the else logic.  Note: there is always else logic
    // either the user provides it or we do (to use null as the default).
    if (is_nullable(sem_type_expr)) {
      else_label_number = ++lua_case_statement_count;
      bprintf(cg_main_output, "if %s == nil then ", temp_value.ptr);
      bprintf(cg_main_output, "goto case_else_%d end\n", else_label_number);
    }

    cg_lua_case_list(case_list, temp_value.ptr, result_var.ptr, sem_type_result);

    CG_LUA_POP_EVAL(expr);
    CG_LUA_POP_TEMP(temp);
  }
  else {
    // Otherwise do the case list with no expression...
    cg_lua_case_list(case_list, NULL, result_var.ptr, sem_type_result);
  }

  if (else_label_number >= 0) {
    bprintf(cg_main_output, "::case_else_%d::\n", else_label_number);
  }

  // If there is an else clause, spit out the result for that now.
  // Note that lack of an else is by-construction a nullable outcome because
  // the semantics of case say that if you miss all the cases you get null.
  if (else_expr) {
    sem_t sem_type_else = else_expr->sem->sem_type;

    CG_LUA_PUSH_EVAL(else_expr, LUA_EXPR_PRI_ROOT);

    cg_lua_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_else, else_expr_value.ptr);

    CG_LUA_POP_EVAL(else_expr);
  }
  else {
    // No else, result must be nullable. (enforced by cg_lua_set_null)
    cg_lua_set_null(cg_main_output, result_var.ptr, sem_type_result);
  }

  CG_POP_MAIN_INDENT(do);
  CG_LUA_CLEANUP_RESULT_VAR();

  bprintf(cg_main_output, "until true\n");
}

// we have built-in support for numeric casts only, the SQL string cast operations are highly
// complex with interesting parsing rules and so forth.  We don't try to do those at all
// but there's no reason we can't do the simple numeric conversions in the non-SQL path
static void cg_lua_expr_cast(ast_node *cast_expr, CSTR str, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_cast_expr(cast_expr));

  ast_node *expr = cast_expr->left;

  sem_t sem_type_result = cast_expr->sem->sem_type;
  sem_t core_type_result = core_type_of(sem_type_result);
  sem_t sem_type_expr = expr->sem->sem_type;
  sem_t core_type_expr = core_type_of(sem_type_expr);

  CG_LUA_PUSH_EVAL(expr, pri_new);

  if (core_type_expr == SEM_TYPE_NULL) {
    bprintf(value, "nil");
  }
  else if (core_type_expr == core_type_result) {
    // no-op cast, just pass through -- we have to add parens because they were
    // implicit in the call syntax of cast -- so this is the safe/easy thing to do
    bprintf(value, "(%s)", expr_value.ptr);
  }
  else switch (core_type_result) {
    case SEM_TYPE_INTEGER:
    case SEM_TYPE_LONG_INTEGER:
      bprintf(value, "cql_to_integer(%s)", expr_value.ptr);
      break;

    case SEM_TYPE_REAL:
      bprintf(value, "cql_to_float(%s)", expr_value.ptr);
      break;

    case SEM_TYPE_BOOL:
      bprintf(value, "cql_to_bool(%s)", expr_value.ptr);
      break;
  }

  CG_LUA_POP_EVAL(expr);
}

// we have built-in type_check fun which use to check an expr strictly match a type.
// during semantic analysis otherwise error. At the codegen phase we just emit
// the expr since the type check already succeeded.
static void cg_lua_expr_type_check(ast_node *type_check_expr, CSTR str, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_type_check_expr(type_check_expr));
  EXTRACT_ANY_NOTNULL(expr, type_check_expr->left);

  CG_LUA_PUSH_EVAL(expr, pri_new);

  // type checking of the expression already happened during semantic analysis.
  // It's safe to just output it
  bprintf(value, "%s", expr_value.ptr);

  CG_LUA_POP_EVAL(expr);
}

// This converts from SQL string literal format to C literal format.
//  * the single quotes around the string become double quotes
//  * escaped single quote becomes just single quote
//  * backslash escapes are preserved
static void cg_lua_requote_literal(CSTR str, charbuf *output) {
  CHARBUF_OPEN(plaintext);
  cg_decode_string_literal(str, &plaintext);
  cg_encode_c_string_literal(plaintext.ptr, output);
  CHARBUF_CLOSE(plaintext);
}

// Here we use the helper above to create a variable name for the literal
// then we declare that variable and emit the initializer.  The macro
// cql_string_literal does the job for us while allowing the different
// string implementations.  These go into the constants section.
static void cg_lua_string_literal(CSTR str, charbuf *output) {
  Contract(str);
  Contract(str[0] == '\'');

  // no fancy tricks, just emit the string
  cg_lua_requote_literal(str, output);
}

// The rewritten between expression is designed to be super easy to code gen.
// The semantic analyzer has already turned the between or not beween into a normal
// combination of and/or so all we have to do is load up the temporary with the test
// value and then evaluate the test expression. Between and not between look the same
// to the codgen (they will have different expressions).  This lets us get all that
// weird short circuit behavior super easy.  It's literally the AND/OR code running.
static void cg_lua_expr_between_rewrite(
  ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_between_rewrite(ast));
  EXTRACT_NOTNULL(range, ast->right);
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_ANY_NOTNULL(test, range->right);

  // BETWEEN REWRITE [var := expr] CHECK [test]

  sem_t sem_type_var = expr->sem->sem_type;

  if (is_ast_null(expr)) {
    bprintf(value, "nil");
    return;
  }

  // we have to do this after we have checked the expression for the null case
  // if it is the null case the variable we generated for temporary storage
  // would be rewritten to the null constant and this next extract fails
  // the early out handles that case so we're now in the normal invariant.
  EXTRACT_STRING(var, range->left);

  cg_lua_var_decl(cg_declarations_output, sem_type_var, var);

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ASSIGN);
  cg_lua_store_same_type(cg_main_output, var, sem_type_var, expr_value.ptr);
  CG_LUA_POP_EVAL(expr);

  cg_lua_expr(test, value, pri);
}

// This is the first of the key primitives in codegen -- it generates the
// output buffers for an identifier.  There are a few interesting cases.
//
//   * LUA identifiers are very simple, we don't need structs or temps so
//     we can simply emit the name with no changes
//   * we have special case code for the @RC identifier for the most recent result code
//   * we have to undo the cursor transform _C_has_row_ into C._has_row_ because
//     cursors are uniform in LUA, this is goofy but works for now
//   * when processing shared fragments we might need to alias local variables
//     to their computed value
//
// Note: It's important to use the semantic name sem->name rather than the text
// of the ast because the user might refer case insensitively to the variable FoO
// and we need to emit the canonical name (e.g. foo, or Foo, or whatever it was).
static void cg_lua_id(ast_node *expr, charbuf *value) {
  sem_t sem_type = expr->sem->sem_type;
  Invariant(is_variable(sem_type));

  // Crucial, we want the canonical version of the name, not any MixED case version
  // the user might have typed.
  CSTR name = expr->sem->name;

  // map the logical @rc variable to the correct saved version
  if (!strcmp(name, "@rc")) {
    bprintf(value, "%s", lua_rcthrown_current);
    lua_rcthrown_used = true;
    return;
  }

  // The semantic pass changed something like 'if C' into if '_C_has_row_' which
  // is a bit lame but I can't fix it just now. The cg pass should be doing this
  // transform with a dot operator but in any case we can undo it with a kludge.
  if (name[0] == '_') {
     int32_t len = (int32_t)strlen(name);
     int32_t plen = sizeof("_has_row_") - 1;
     int32_t index = len - plen;
     if (len > plen && strcmp(name + index, "_has_row_") == 0) {
       for (int32_t i = 1; i < index; i++) {
         bputc(value, name[i]);
       }
       bprintf(value, "._has_row_");
       return;
     }
  }

  // while generating expressions for the CTE assignments we might have to
  // rename the proc args to the name in the outermost context
  if (proc_arg_aliases) {
    symtab_entry *entry = symtab_find(proc_arg_aliases, name);
    if (entry) {
      EXTRACT_ANY_NOTNULL(var, entry->val);
      name = var->sem->name;
    }
  }

  bprintf(value, "%s", name);
}

// Recall that coalesce returns the first non-null arg from the list of arguments.
// The arguments must be type compatible, this was previously verified.  To do
// the codgen for coalesce(X,Y) we use a pattern like this:
//   declare result of the appropriate type;
//   repeat
//     evaluate X
//     if x is not null then
//       result = X  -- we can use the form where  X is known to be not null
//       break       -- we're done...
//     end
//     ... other cases just like the above...
//     ... the final case has no test, use it even if null
//     evaluate Y
//     result = Y
//   until true
static void cg_lua_func_coalesce(ast_node *call_ast, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // ifnull ( [arg_list] )
  // coalesce ( [arg_list] )

  sem_t sem_type_result = call_ast->sem->sem_type;

  // the answer will be stored in this scratch variable
  CG_LUA_SETUP_RESULT_VAR(call_ast, sem_type_result);

  bprintf(cg_main_output, "repeat\n");
  CG_PUSH_MAIN_INDENT2(do);
  for (ast_node *ast = arg_list; ast; ast = ast->right) {
    EXTRACT_ANY_NOTNULL(expr, ast->left);

    sem_t sem_type_expr = expr->sem->sem_type;

    CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

    // Generate the test for all but the last choice.
    if (ast->right) {
      bprintf(cg_main_output, "if %s ~= nil then\n  ", expr_value.ptr);
    }

    cg_lua_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_expr, expr_value.ptr);

    if (ast->right) {
      bprintf(cg_main_output, "  break\n");
      bprintf(cg_main_output, "end\n");
    }

    CG_LUA_POP_EVAL(expr);
  }
  CG_POP_MAIN_INDENT(do);
  bprintf(cg_main_output, "until true\n");
  CG_LUA_CLEANUP_RESULT_VAR();
}

// Ifnull is an alias for coalesce, with only two args.
static void cg_lua_func_ifnull(ast_node *call_ast, charbuf *value) {
  cg_lua_func_coalesce(call_ast, value);
}

// no-op function, we just force parents to not screw up the order of ops
static void cg_lua_func_sensitive(ast_node *call_ast, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // sensitive ( any expression ) -- at run time this function is a no-op
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  // we just evaluate the inner expression
  // we have to fake a high binding strength so that it will for sure emit parens
  // as the nullable() construct looks like has parens and we don't know our context
  // oh well, extra parens is better than the temporaries of doing this with PUSH_EVAL etc.
  cg_lua_expr(expr, value, LUA_EXPR_PRI_HIGHEST);
}

// no-op function, we just force parents to not screw up the order of ops
static void cg_lua_func_nullable(ast_node *call_ast, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // nullable ( any expression ) -- at run time this function is a no-op
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  // we just evaluate the inner expression
  // we have to fake a high binding strength so that it will for sure emit parens
  // as the nullable() construct looks like has parens and we don't know our context
  // oh well, extra parens is better than the temporaries of doing this with PUSH_EVAL etc.
  cg_lua_expr(expr, value, LUA_EXPR_PRI_HIGHEST);
}

typedef enum {
  LUA_ATTEST_NOTNULL_VARIANT_CRASH,
  LUA_ATTEST_NOTNULL_VARIANT_INFERRED,
  LUA_ATTEST_NOTNULL_VARIANT_THROW,
} lua_attest_notnull_variant;

// Generates code for all functions of the attest_notnull family.
static void cg_lua_func_attest_notnull(ast_node *call_ast, charbuf *value, lua_attest_notnull_variant variant) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // notnull ( a_nullable_expression )

  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  // result known to be not null so easy codegen

  sem_t sem_type_expr = expr->sem->sem_type;
  Invariant(is_nullable(sem_type_expr));  // expression must already be in a temp

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  switch (variant) {
    case LUA_ATTEST_NOTNULL_VARIANT_CRASH:
      bprintf(cg_main_output, "cql_invariant(%s ~= nil)\n", expr_value.ptr);
      break;

    case LUA_ATTEST_NOTNULL_VARIANT_INFERRED:
      // Semantic analysis has guaranteed that the input is not going to be
      // NULL so we don't need to check anything here.
      break;

    case LUA_ATTEST_NOTNULL_VARIANT_THROW:
      bprintf(cg_main_output, "if %s == nil then\n", expr_value.ptr);
      bprintf(cg_main_output, "  _rc_ = CQL_ERROR\n");
      bprintf(cg_main_output, "  cql_error_trace(_rc_, _db_)\n");
      bprintf(cg_main_output, "  goto %s\n", lua_error_target);
      bprintf(cg_main_output, "end\n");
      lua_error_target_used = true;
      break;
  }

  bprintf(value, "%s", expr_value.ptr);

  CG_LUA_POP_EVAL(expr);
}

static void cg_lua_func_ifnull_throw(ast_node *call_ast, charbuf *value) {
  cg_lua_func_attest_notnull(call_ast, value, LUA_ATTEST_NOTNULL_VARIANT_THROW);
}

static void cg_lua_func_ifnull_crash(ast_node *call_ast, charbuf *value) {
  cg_lua_func_attest_notnull(call_ast, value, LUA_ATTEST_NOTNULL_VARIANT_CRASH);
}

// The `cql_inferred_notnull` function is not used by the programmer directly,
// but rather inserted via a rewrite during semantic analysis to coerce a value
// of a nullable type to be nonnull. The reason for this approach, as opposed to
// just changing the type directly, is that there are also representational
// differences between values of nullable and nonnull types; some conversion is
// required.
static void cg_lua_func_cql_inferred_notnull(ast_node *call_ast, charbuf *value) {
  cg_lua_func_attest_notnull(call_ast, value, LUA_ATTEST_NOTNULL_VARIANT_INFERRED);
}

// This is a no-op for now, that is no compression.
// i.e. lua codegen doesn't have compressed string forms yet so we just emit a normal literal
static void cg_lua_func_cql_compressed(ast_node *call_ast, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);
  EXTRACT_STRING(str, expr);

  cg_lua_string_literal(str, value);
}

// There's a helper for this method, just call it.  Super easy.
static void cg_lua_func_changes(ast_node *ast, charbuf *value) {
  bprintf(value, "cql_changes(_db_)");
}

// There's a helper for this method, just call it.  Super easy.
static void cg_lua_func_last_insert_rowid(ast_node *ast, charbuf *value) {
  bprintf(value, "cql_last_insert_rowid(_db_)");
}

// Printf also has a helper, we just call it.  There are other helpers to emit
// a call to an external (not stored proc) function.  Use that.
static void cg_lua_func_printf(ast_node *call_ast, charbuf *value) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  CG_LUA_SETUP_RESULT_VAR(call_ast, SEM_TYPE_TEXT | SEM_TYPE_NOTNULL);
  CHARBUF_OPEN(inv);
  bprintf(&inv, "%s = cql_printf", result_var.ptr);
  cg_lua_call_named_external(inv.ptr, arg_list);
  CHARBUF_CLOSE(inv);
  CG_LUA_CLEANUP_RESULT_VAR();
}

// wrapper function for the builtin cql_get_blob_size
// this is super simple in LUA because the nullable case is the same as the not nullable case
static void cg_lua_func_cql_get_blob_size(ast_node *ast, charbuf *value) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_ANY_NOTNULL(expr, arg_list->left);

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  // store cql_get_blob_size call in temp. e.g: cql_get_blob_size(expr_value)
  bprintf(value, "cql_get_blob_size(%s)", expr_value.ptr);

  CG_LUA_POP_EVAL(expr);
}

// This is some kind of function call in an expression context.  Look up the method
// and call one of the cg_lua_func_* workers above.  All arg combos are known to be good
// because semantic analysis verified them already.
static void cg_lua_expr_call(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);

  // name( [arg_list] )

  if (find_func(name) || find_proc(name) || find_unchecked_func(name)) {
    cg_lua_user_func(ast, value);
  }
  else {
    symtab_entry *entry = symtab_find(cg_funcs, name);
    Invariant(entry);  // names have already been verified!
    ((void (*)(ast_node *, charbuf *))entry->val)(ast, value);
  }
}

// Numeric literal, spit it out.
static void cg_lua_expr_num(ast_node *expr, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_num(expr));
  EXTRACT_NUM_TYPE(num_type, expr);
  EXTRACT_NUM_VALUE(lit, expr);

  // a numeric literal
  if (num_type == NUM_BOOL) {
    // in LUA, the codegen for bools has to be "true" "false" because 0 is not falsey
    bprintf(value, "%s", strcmp(lit, "0") ? "true" : "false");
  }
  else {
    bprintf(value, "%s", lit);
  }
}

// string nodes are simple in LUA as we can generate simple ids or string literals consistently
static void cg_lua_expr_str(ast_node *expr, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  // String could be an id, or a literal -- literals start with single quote.
  Contract(is_ast_str(expr));
  EXTRACT_STRING(str, expr);
  if (is_strlit(expr)) {
    // Note str is the lexeme, so it is still quoted and escaped.
    cg_lua_string_literal(str, value);
  }
  else {
    cg_lua_id(expr, value);
  }
}

// the "dot" operator (e.g. C.x) is handled on the ID path
static void cg_lua_expr_dot(ast_node *expr, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  // X.Y has a net local name computed by semantic analysis.  Use it like any other id.
  Contract(is_ast_dot(expr));
  cg_lua_id(expr, value);
}

// the null constant
static void cg_lua_expr_null(ast_node *expr, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_null(expr));
  // null literal
  bprintf(value, "nil");
}

// This is the main entry point for codegen of an expression.  It dispatches
// to one of the above workers for all the complex types and handles a few primitives
// in place.
static void cg_lua_expr(ast_node *expr, charbuf *value, int32_t pri) {
  Contract(value);
  Contract(value->used == 1);  // just the null (i.e. empty buffer)

  // These are all the expressions there are, we have to find it in this table
  // or else someone added a new expression type and it isn't supported yet.
  symtab_entry *entry = symtab_find(cg_exprs, expr->type);
  Invariant(entry);
  cg_lua_expr_dispatch *disp = (cg_lua_expr_dispatch *)entry->val;
  disp->func(expr, disp->str, value, pri, disp->pri_new);
}

// This is a nested select expression.  To evaluate we will
//  * prepare a temporary to hold the result
//  * generate the bound SQL statement
//  * extract the exactly one argument into the result variable
//    which is of exactly the right type
//  * use that variable as the result.
// The helper methods take care of sqlite error management.
static void cg_lua_expr_select(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_select_variant(ast));

  // SELECT [select_opts] [select_expr_list_con]

  sem_t sem_type_result = ast->sem->sem_type;

  CG_LUA_SETUP_RESULT_VAR(ast, sem_type_result);

  int32_t stmt_index = cg_lua_bound_sql_statement(NULL, ast, CG_PREPARE | CG_MINIFY_ALIASES);

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  // exactly one column is allowed, already checked in semantic analysis, fetch it
  bprintf(cg_main_output, "_rc_ = cql_step(%s)\n", temp_stmt.ptr);
  cg_lua_error_on_rc_notequal("CQL_ROW");
  cg_lua_get_column(sem_type_result, temp_stmt.ptr, 0, result_var.ptr, cg_main_output);

  // if statement index 0 then we're not re-using this statement in a loop
  if (stmt_index == 0) {
    bprintf(cg_main_output, "cql_finalize_stmt(%s)\n", temp_stmt.ptr);
    bprintf(cg_main_output, "%s = nil\n", temp_stmt.ptr);
  }
  else {
    bprintf(cg_main_output, "cql_reset_stmt(%s)\n", temp_stmt.ptr);
  }

  CHARBUF_CLOSE(temp_stmt);
  CG_LUA_CLEANUP_RESULT_VAR();
}

// select if nothing is exactly the same codegen as regular select
// the throwing which is done by default was make explcit.  The normal
// codegen already does the "throw" (i.e. goto the current error target).
static void cg_lua_expr_select_if_nothing_throw(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_throw_expr(ast));
  EXTRACT_ANY_NOTNULL(select_expr, ast->left);
  cg_lua_expr_select(select_expr, op, value, pri, pri_new);
}

// This helper does the evaluation of the select statement portion of the
// (SELECT ... IF NOTHING ...) forms.  Importantly the result type of the
// select might not exactly match the result type of expression because
// the default value could be of a different type and it might cause the
// overall expression to be not null.  So here we have to fetch just the
// select statement part into its own result variable of the exact correct type
// later we will safely assign that result to the final type if it held a value
static int32_t cg_lua_expr_select_frag(ast_node *ast, charbuf *value) {
  sem_t sem_type_result = ast->sem->sem_type;

  CG_LUA_SETUP_RESULT_VAR(ast, sem_type_result);

  int32_t stmt_index = cg_lua_bound_sql_statement(NULL, ast, CG_PREPARE | CG_MINIFY_ALIASES);

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  // exactly one column is allowed, already checked in semantic analysis, fetch it
  bprintf(cg_main_output, "_rc_ = cql_step(%s)\n", temp_stmt.ptr);
  cg_lua_error_on_expr("_rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE");
  bprintf(cg_main_output, "if _rc_ == CQL_ROW then\n");
  cg_lua_get_column(sem_type_result, temp_stmt.ptr, 0, result_var.ptr, cg_main_output);

  CHARBUF_CLOSE(temp_stmt);
  CG_LUA_CLEANUP_RESULT_VAR();

  // note that callers are expected to check the remaining error codes and clean up
  // the temp statement.

  return stmt_index;
}

// This is a nested select expression.  To evaluate we will
//  * prepare a temporary to hold the result
//  * generate the bound SQL statement
//  * extract the exactly one argument into the result variable
//    which is of exactly the right type
//  * use that variable as the result.
//  * if there is no row, we use the default expression
// The helper methods takes care of sqlite error management.
static void cg_lua_expr_select_if_nothing(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_expr(ast));

  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  // SELECT [select_opts] [select_expr_list_con] IF NOTHING expr

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;
  sem_t sem_type_select = select_stmt->sem->sem_type;

  // this is the overall result
  CG_LUA_SETUP_RESULT_VAR(ast, sem_type_result);

  CHARBUF_OPEN(select_value);

  // the select statement might have a different result type than overall
  // e.g. (select an_int from somewhere if nothing 2.5), the overall result is real
  int32_t stmt_index = cg_lua_expr_select_frag(select_stmt, &select_value);

  // we're inside of the "if __rc__ == CQL_ROW then" case
  // we need to store the result of the select in our output variable
  // note that these are known to be compatible (already verified) but they might not
  // be the exact same type, hence the copy.  In this case we're definitely using the value.
  bprintf(cg_main_output, "  ");
  cg_lua_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_select, select_value.ptr);

  bprintf(cg_main_output, "else\n  ");

  // if no row found, then evaluate and use the default
  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ASSIGN);
  cg_lua_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_expr, expr_value.ptr);
  CG_LUA_POP_EVAL(expr);

  bprintf(cg_main_output, "end\n");

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  // if statement index 0 then we're not re-using this statement in a loop
  if (stmt_index == 0) {
    bprintf(cg_main_output, "cql_finalize_stmt(%s)\n", temp_stmt.ptr);
    bprintf(cg_main_output, "%s = nil\n", temp_stmt.ptr);
  }
  else {
    bprintf(cg_main_output, "cql_reset_stmt(%s)\n", temp_stmt.ptr);
  }

  CHARBUF_CLOSE(temp_stmt);
  CHARBUF_CLOSE(select_value);

  CG_LUA_CLEANUP_RESULT_VAR();
}

// This is a nested select expression.  To evaluate we will
//  * prepare a temporary to hold the result
//  * generate the bound SQL statement
//  * extract the exactly one argument into the result variable
//    which is of exactly the right type
//  * use that variable as the result.
//  * if there is no row, or the returned value is null we use the default expression
// The helper methods take care of sqlite error management.
static void cg_lua_expr_select_if_nothing_or_null(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_or_null_expr(ast));

  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  // SELECT [select_opts] [select_expr_list_con] IF NOTHING expr

  sem_t sem_type_result = ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;
  sem_t sem_type_select = select_stmt->sem->sem_type;

  CG_LUA_SETUP_RESULT_VAR(ast, sem_type_result);

  CHARBUF_OPEN(select_value);

  // the select statement might have a different result type than overall
  // e.g. (select an_int from somewhere if nothing 2.5), the overall result is real
  int32_t stmt_index = cg_lua_expr_select_frag(select_stmt, &select_value);

  // we're inside of the "if _rc_ == CQL_ROW then" case
  // in this variation we have to first see if the result is null before we use it
  bprintf(cg_main_output, "end\n");
  bprintf(cg_main_output, "if _rc_ == CQL_DONE or %s == nil then\n  ", select_value.ptr);

  // now row or null result, evaluate the default
  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ASSIGN);
  cg_lua_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_expr, expr_value.ptr);
  CG_LUA_POP_EVAL(expr);

  bprintf(cg_main_output, "else\n  ");
  // ok to use the value we fetched, go ahead an copy it to its final destination
  // note this may change the type but only in a compatible way
  cg_lua_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_select, select_value.ptr);
  bprintf(cg_main_output, "end\n");
  bprintf(cg_main_output, "_rc_ = CQL_OK\n");

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  // if statement index 0 then we're not re-using this statement in a loop
  if (stmt_index == 0) {
    bprintf(cg_main_output, "cql_finalize_stmt(%s)\n", temp_stmt.ptr);
    bprintf(cg_main_output, "%s = nil\n", temp_stmt.ptr);
  }
  else {
    bprintf(cg_main_output, "cql_reset_stmt(%s)\n", temp_stmt.ptr);
  }

  CHARBUF_CLOSE(temp_stmt);
  CHARBUF_CLOSE(select_value);

  CG_LUA_CLEANUP_RESULT_VAR();
}

// This is a nested select expression.  To evaluate we will
//  * prepare a temporary to hold the result
//  * generate the bound SQL statement
//  * extract the exactly one argument into the result variable
//    which is of exactly the right type
//  * use that variable as the result.
//  * if there is no row, or the returned value is null we throw
// The helper methods take care of sqlite error management.
static void cg_lua_expr_select_if_nothing_or_null_throw(ast_node *ast, CSTR op, charbuf *value, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_or_null_throw_expr(ast));

  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);

  // SELECT [select_opts] [select_expr_list_con] IF NOTHING THROW

  sem_t sem_type_result = ast->sem->sem_type;

  CG_LUA_SETUP_RESULT_VAR(ast, sem_type_result);

  CHARBUF_OPEN(select_value);

  // the select statement might have a different result type than overall
  // e.g. (select an_int from somewhere if nothing 2.5), the overall result is real
  int32_t stmt_index = cg_lua_expr_select_frag(select_stmt, &select_value);

  // we're inside of the "if _rc_ == CQL_ROW then" case
  // in this variation we have to first see if the result is null before we use it
  bprintf(cg_main_output, "end\n");
  bprintf(cg_main_output, "if _rc_ == CQL_DONE or %s == nil then\n", select_value.ptr);
  bprintf(cg_main_output, "  cql_error_trace(_rc_, _db_)\n");
  bprintf(cg_main_output, "  goto %s\n", lua_error_target);
  bprintf(cg_main_output, "else\n  ");
  // ok to use the value we fetched, go ahead an copy it to its final destination
  // note this may change the type but only in a compatible way
  cg_lua_store(cg_main_output, result_var.ptr, sem_type_result, sem_type_result, select_value.ptr);
  bprintf(cg_main_output, "end\n");
  bprintf(cg_main_output, "_rc_ = CQL_OK\n");

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  // if statement index 0 then we're not re-using this statement in a loop
  if (stmt_index == 0) {
    bprintf(cg_main_output, "cql_finalize_stmt(%s)\n", temp_stmt.ptr);
    bprintf(cg_main_output, "%s = nil\n", temp_stmt.ptr);
  }
  else {
    bprintf(cg_main_output, "cql_reset_stmt(%s)\n", temp_stmt.ptr);
  }

  CHARBUF_CLOSE(temp_stmt);
  CHARBUF_CLOSE(select_value);

  CG_LUA_CLEANUP_RESULT_VAR();
}

// This is the elementary piece of the if-then construct, it's one condition
// and one statement list.  It can happen in the context of the top level
// if or any else-if.  In lua 0 is not falsey so we have to be sure to
// convert numerics to bools but otherwise things are very easy/normal.
// Nil is falsey so no issues there.
//
// > if nil then print("truthy") end;
// > if 0 then print("truthy") end;
// truthy
// > if 1 then print("truthy") end;
// truthy
// if false then print("truthy") end;
//
static void cg_lua_cond_action(ast_node *ast) {
  Contract(is_ast_cond_action(ast));
  EXTRACT(stmt_list, ast->right);
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  // [expr ast->left] THEN stmt_list

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  sem_t sem_type_expr = expr->sem->sem_type;

  cg_lua_to_bool(sem_type_expr, &expr_value);

  bprintf(cg_main_output, "if %s then\n", expr_value.ptr);

  CG_LUA_POP_EVAL(expr);

  if (stmt_list) {
    cg_lua_stmt_list(stmt_list);
  }
}

// Recursively emits the else-if chain.  These have to nest to allow for
// expressions to generate statements.
static void cg_lua_elseif_list(ast_node *ast, ast_node *elsenode) {
  if (ast) {
    Contract(is_ast_elseif(ast));
    EXTRACT(cond_action, ast->left);

    // ELSE IF [cond_action]
    bprintf(cg_main_output, "else\n");
      CG_PUSH_MAIN_INDENT2(else);
      cg_lua_cond_action(cond_action);
      cg_lua_elseif_list(ast->right, elsenode);
      CG_POP_MAIN_INDENT(else);
  }
  else if (elsenode) {
    Contract(is_ast_else(elsenode));
    // ELSE [stmt_list]
    EXTRACT(stmt_list, elsenode->left);
    bprintf(cg_main_output, "else\n");
    cg_lua_stmt_list(stmt_list);
  }

  bprintf(cg_main_output, "end\n");
}

// This evaluates an expression and discards the result
// We could optimize this more by looking to see if
// the expression could possibly have side effects
// and not emitting it if it is side-effect free.
static void cg_lua_expr_stmt(ast_node *ast) {
  Contract(is_ast_expr_stmt(ast));

  EXTRACT_ANY_NOTNULL(expr, ast->left);

  CG_LUA_PUSH_EVAL(expr, C_EXPR_PRI_ROOT);

  bprintf(cg_main_output, "__cql_ignored__ = %s\n__cql_ignored__ = nil\n", expr_value.ptr);

  CG_LUA_POP_EVAL(expr);
}

static void cg_lua_ifdef_stmt(ast_node *ast) {
  Contract(is_ast_ifdef_stmt(ast) || is_ast_ifndef_stmt(ast));
  EXTRACT_ANY_NOTNULL(evaluation, ast->left);
  EXTRACT_NOTNULL(pre, ast->right);
  bool_t is_true = is_ast_is_true(evaluation);

  // We don't want to count these statements as nested, we're still global
  // If were were global before.
  stmt_nesting_level--;

  if (is_true) {
    EXTRACT(stmt_list, pre->left);
    cg_lua_stmt_list(stmt_list);
  }
  else {
    EXTRACT(stmt_list, pre->right);
    if (stmt_list) {
      cg_lua_stmt_list(stmt_list);
    }
  }

  // Put back the statement level
  stmt_nesting_level++;
}

static void cg_lua_ifndef_stmt(ast_node *ast) {
  // the true/false evaluation has already been done and we are is_true if
  // we take the true branch
  cg_lua_ifdef_stmt(ast);
}

// As with the other cases the fact that expressions might require statements
// complicates the codegen. If there is an else-if (expression) that expression
// might itself require statements to compute the expression.  Even a logical AND
// might require statements if there is nullability involved.
// That means the overall pattern has to look like this, with nesting.
//
//   prep statements;
//   result = final expression
//   if result then
//     statements
//   else
//     prep statements;
//     result = final expression
//     if result then
//       statements
//     else
//      statements
//     end
//   end
static void cg_lua_if_stmt(ast_node *ast) {
  Contract(is_ast_if_stmt(ast));

  EXTRACT_NOTNULL(cond_action, ast->left);
  EXTRACT_NOTNULL(if_alt, ast->right);

  // IF [cond_action] [if_alt]
  cg_lua_cond_action(cond_action);

  EXTRACT(elseif, if_alt->left);
  EXTRACT_NAMED(elsenode, else, if_alt->right);
  cg_lua_elseif_list(elseif, elsenode);

  // END IF
}

// This code uses the same cg_lua_store helper method to do an assignment as
// is used all over the place for assigning to scratch variables.  All
// we have to do here is pull the name and types out of the ast.
static void cg_lua_assign(ast_node *ast) {
  Contract(is_ast_assign(ast) || is_ast_let_stmt(ast) || is_ast_const_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  CSTR name = name_ast->sem->name;  // crucial: use the canonical name not the specified name

  Contract(lua_stack_level == 0);

  // SET [name] := [expr]

  sem_t sem_type_var = name_ast->sem->sem_type;
  sem_t sem_type_expr = expr->sem->sem_type;

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ASSIGN);
  cg_lua_store(cg_main_output, name, sem_type_var, sem_type_expr, expr_value.ptr);
  CG_LUA_POP_EVAL(expr);
}

// In the LET statement, we declare the variable based on type, emit that
// then do the usual SET codegen.
static void cg_lua_let_stmt(ast_node *ast) {
  Contract(is_ast_let_stmt(ast) || is_ast_const_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);

  // null type variables are null aliases, they are rewritten away
  if (is_null_type(name_ast->sem->sem_type)) {
    return;
  }

  cg_lua_declare_simple_var(name_ast->sem->sem_type, name);
  cg_lua_assign(ast);
}

// In the CONST statement, emit the same codegen as LET statement.
// Immutability enforcement is done during semantic analysis.
static void cg_lua_const_stmt(ast_node *ast) {
  Contract(is_ast_const_stmt(ast));
  cg_lua_let_stmt(ast);
}

// Walk all the params of a stored proc and emit each one with a comma where needed.
static void cg_lua_params(ast_node *ast, charbuf *decls, charbuf *returns) {
  Contract(is_ast_params(ast));

  while (ast) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left);

    sem_t sem_type  = param->sem->sem_type;
    if (is_in_parameter(sem_type)) {
      if (decls->used > 1) {
        bprintf(decls, ", ");
      }
      bprintf(decls, "%s", param->sem->name);
    }

    if (is_out_parameter(sem_type)) {
      if (returns->used > 1) {
        bprintf(returns, ", ");
      }
      bprintf(returns, "%s", param->sem->name);
    }

    ast = ast->right;
  }
}

// Emit any initialization code needed for the parameters
// in particular out parameters assume that there is garbage
// in the out location, so they hammer a NULL or 0 into that slot.
static void cg_lua_param_init(ast_node *ast, charbuf *body) {
  Contract(is_ast_param(ast));
  EXTRACT_NOTNULL(param_detail, ast->right);
  EXTRACT_NAME_AST(name_ast, param_detail->left)
  EXTRACT_STRING(name, name_ast);

  // [in out] name [datatype]

  sem_t sem_type = name_ast->sem->sem_type;

  // In a proc decl the out arg initialized to null, this avoids attempting
  // to release any incoming garbage value and ensures some sanity in the event
  // the the return code is ignored...  Nobody ignores return codes, right?
  if (is_out_parameter(sem_type) && !is_in_parameter(sem_type)) {
    cg_lua_var_decl(body, sem_type, name);
  }
}

// Walk all the params of a stored proc, if any of them require initialization code
// in the body, emit that here.
static void cg_lua_params_init(ast_node *ast, charbuf *body) {
  Contract(is_ast_params(ast));

  while (ast) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left);

    cg_lua_param_init(param, body);

    ast = ast->right;
  }
}

// Emit the return code variables for the procedure
// if the procedure uses throw then it needs the saved RC as well so we can re-throw it
static void cg_lua_emit_rc_vars(charbuf *output) {
  bprintf(output, "  local _rc_ = CQL_OK\n");
}

// For LUA the contract rules are simple:
// * in not null args need a contract
// * out args are not really args, they are return values so nothing to check
// * inout args are in as an arg and out as as a return value, so check if not null
//
static void cg_lua_emit_contracts(ast_node *ast, charbuf *b) {
  Contract(is_ast_params(ast));
  Contract(b);

  bool_t did_emit_contract = false;

  int32_t position = 1;
  for (ast_node *params = ast; params; params = params->right, position++) {
    Contract(is_ast_params(params));
    EXTRACT_NOTNULL(param, params->left);
    EXTRACT_NOTNULL(param_detail, param->right);
    EXTRACT_NAME_AST(name_ast, param_detail->left);
    EXTRACT_STRING(name, name_ast);
    sem_t sem_type = name_ast->sem->sem_type;

    if (is_out_parameter(sem_type) && !is_in_parameter(sem_type)) {
      // in LUA these are return value nothing to check
      continue;
    }

    bool_t notnull = is_not_nullable(sem_type);

    if (notnull) {
      bprintf(b, "  cql_contract_argument_notnull(%s, %d)\n", name, position);
      did_emit_contract = true;
    }
  }

  if (did_emit_contract) {
    bprintf(b, "\n");
  }
}

// emit the fetch results function defintion (not the body) into the indicated buffer
static void cg_lua_emit_fetch_results_prototype(
  bool_t dml_proc,
  ast_node *params,
  CSTR proc_name,
  charbuf *decl)
{
  CG_CHARBUF_OPEN_SYM(fetch_results_sym, proc_name, "_fetch_results");
  CHARBUF_OPEN(args);
  CHARBUF_OPEN(returns);

  // optional db reference
  if (dml_proc) {
    bprintf(&args, "_db_");
  }

  // args to forward
  if (params) {
    cg_lua_params(params, &args, &returns);
  }

  bprintf(decl, "function %s(%s)\n", fetch_results_sym.ptr, args.ptr);

  CHARBUF_CLOSE(returns);
  CHARBUF_CLOSE(args);
  CHARBUF_CLOSE(fetch_results_sym);
}

// The prototype for the given procedure goes into the given buffer.  This
// is a naked prototype, so additional arguments could be added -- it will be
// missing the trailing ")" and it will not have EXPORT or anything like that
// on it.
static void cg_lua_emit_proc_prototype(ast_node *ast, charbuf *proc_decl) {
  Contract(is_ast_create_proc_stmt(ast) || is_ast_declare_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  CSTR name = NULL;

  // in lua declare generates nothing so it's always this case
  Invariant(is_ast_create_proc_stmt(ast));

  if (is_ast_create_proc_stmt(ast)) {
    EXTRACT_STRING(n, ast->left);
    name = n;
  }
  /* snipping in case we need something in the future for the declare case
  else {
    // LUA has no exterrn prototype form and we're not doing headers so nothing to do
    EXTRACT_NOTNULL(proc_name_type, ast->left);
    EXTRACT_STRING(n, proc_name_type->left);
    name = n;
  } */

  bool_t dml_proc = is_dml_proc(ast->sem->sem_type);
  bool_t out_union_proc = has_out_union_stmt_result(ast);

  // if you're doing out_union then the row fetcher is all there is
  CSTR suffix = out_union_proc ? "_fetch_results" : "";

  CG_CHARBUF_OPEN_SYM(proc_name_base, name);
  CG_CHARBUF_OPEN_SYM(proc_sym, name, suffix);
  CHARBUF_OPEN(args);
  CHARBUF_OPEN(returns);

  // CREATE PROC [name] ( [params] )
  if (params) {
    cg_lua_params(params, &args, &returns);
  }

  if (dml_proc) {
    bprintf(proc_decl, "%s(_db_", proc_sym.ptr);
    if (args.used > 1) {
      bprintf(proc_decl, ", ");
      bprintf(proc_decl, "%s", args.ptr);
    }
  }
  else {
    bprintf(proc_decl, "%s(%s", proc_sym.ptr, args.ptr);
  }

  CHARBUF_CLOSE(returns);
  CHARBUF_CLOSE(args);
  CHARBUF_CLOSE(proc_sym);
  CHARBUF_CLOSE(proc_name_base);
}

// Emitting a stored proc is mostly setup.  We have a bunch of housekeeping to do:
//  * create new scratch buffers for the body and the locals and the cleanup section
//  * save the current output globals
//  * set the globals to point to those buffers
//  * save the old scratch masks and create new ones
//  * emit the prototype of the LUA function for this proc
//  * recursively spit out the statements
//  * when this is all done assemble the pieces into the original output streams
//  * procedures that use SQL will get a hidden _db_ argument
//  * procedures that return a result set will get a statement result value
//    * and the additional procedures for creating the result set and accessing it are emitted
//  * cursor OUT forms get rows output or a single row output
static void cg_lua_create_proc_stmt(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  bool_t private_proc = is_proc_private(ast);
  bool_t dml_proc = is_dml_proc(ast->sem->sem_type);
  bool_t result_set_proc = has_result_set(ast);
  bool_t out_stmt_proc = has_out_stmt_result(ast);
  bool_t out_union_proc = has_out_union_stmt_result(ast);
  bool_t calls_out_union = has_out_union_call(ast);
  proc_cte_index = 0;
  lua_cur_bound_statement = 0;
  int32_t lua_prepared_statement_index_saved = lua_prepared_statement_index;
  lua_prepared_statement_index = 0;

  // shared frags have already been ruled out
  Invariant(!is_proc_shared_fragment(ast));

  CHARBUF_OPEN(proc_fwd_ref);
  CHARBUF_OPEN(proc_contracts);
  CHARBUF_OPEN(proc_body);
  CHARBUF_OPEN(proc_locals);
  CHARBUF_OPEN(proc_cleanup);

  bool_t saved_lua_error_target_used = lua_error_target_used;
  lua_error_target_used = false;
  lua_return_used = false;

  int32_t saved_lua_rcthrown_index = lua_rcthrown_index;
  lua_rcthrown_index = 0;

  bool_t saved_lua_rcthrown_used = lua_rcthrown_used;
  lua_rcthrown_used = 0;

  bool_t saved_temp_emitted = lua_temp_statement_emitted;
  bool_t saved_lua_seed_declared = lua_seed_declared;
  charbuf *saved_main = cg_main_output;
  charbuf *saved_decls = cg_declarations_output;
  charbuf *saved_scratch = cg_scratch_vars_output;
  charbuf *saved_cleanup = cg_cleanup_output;
  charbuf *saved_fwd_ref = cg_fwd_ref_output;
  cg_lua_scratch_masks *saved_masks = cg_lua_current_masks;

  Invariant(lua_named_temporaries == NULL);
  lua_named_temporaries = symtab_new();

  cg_lua_scratch_masks masks;
  cg_lua_current_masks = &masks;
  cg_lua_zero_masks(cg_lua_current_masks);
  lua_temp_statement_emitted = false;
  lua_in_proc = true;
  lua_in_var_group_emit = false;
  current_proc = ast;
  lua_seed_declared = false;

  bprintf(cg_declarations_output, "\n");

  // if you're doing out_union then the row fetcher is all there is
  CSTR suffix = out_union_proc ? "_fetch_results" : "";

  CG_CHARBUF_OPEN_SYM(proc_name_base, name);
  CG_CHARBUF_OPEN_SYM(proc_sym, name, suffix);

  CHARBUF_OPEN(proc_decl);
  cg_lua_emit_proc_prototype(ast, &proc_decl);

  // CREATE PROC [name] ( [params] )
  if (params) {
    cg_lua_params_init(params, &proc_locals);
    if (!private_proc) {
      cg_lua_emit_contracts(params, &proc_contracts);
    }
  }

  cg_fwd_ref_output = &proc_fwd_ref;
  cg_main_output = &proc_body;
  cg_declarations_output = &proc_locals;
  cg_scratch_vars_output = &proc_locals;
  cg_cleanup_output = &proc_cleanup;

  // BEGIN [stmt_list] END
  cg_lua_stmt_list(stmt_list);

  cg_fwd_ref_output = saved_fwd_ref;
  cg_main_output = saved_main;
  cg_declarations_output = saved_decls;
  cg_scratch_vars_output = saved_scratch;
  cg_cleanup_output = saved_cleanup;
  cg_lua_current_masks = saved_masks;
  lua_temp_statement_emitted = saved_temp_emitted;
  lua_seed_declared = saved_lua_seed_declared;

  bprintf(cg_declarations_output, "%s", proc_fwd_ref.ptr);
  bprintf(cg_declarations_output, "function %s)\n", proc_decl.ptr);
  bprintf(cg_declarations_output, "%s", proc_contracts.ptr);

  if (dml_proc) {
    cg_lua_emit_rc_vars(cg_declarations_output);
    if (result_set_proc) {
      bprintf(cg_declarations_output, "  local _result_stmt = nil\n");
    }
  }

  if (out_stmt_proc) {
    bprintf(cg_declarations_output, "  local _result_ = nil\n");
  }

  if (calls_out_union) {
    bprintf(cg_declarations_output, "  local _result_set_ = {}\n");
  }
  else if (out_union_proc) {
    bprintf(cg_declarations_output, "  local _rows_ = {}\n");
  }

  bindent(cg_declarations_output, &proc_locals, 2);
  if (proc_locals.used > 1) {
    bprintf(cg_declarations_output, "\n");
  }

  bprintf(cg_declarations_output, "%s", proc_body.ptr);

  if (dml_proc) {
    bprintf(cg_declarations_output, "  _rc_ = CQL_OK\n");
  }

  if (lua_error_target_used || lua_return_used) {
    bprintf(cg_declarations_output, "\n::%s::", lua_error_target);
  }

  bprintf(cg_declarations_output, "\n");

  if (proc_cleanup.used > 1) {
    bprintf(cg_declarations_output, "%s", proc_cleanup.ptr);
  }

  if (result_set_proc) {
    // Because of control flow it's possible that we never actually ran a select statement
    // even if there were no errors.  Or maybe we caught the error.  In any case if we
    // are not producing an error then we have to produce an empty result set to go with it.
    bprintf(cg_declarations_output, "  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end\n");
  }

  CHARBUF_OPEN(returns);

  if (dml_proc) {
    bprintf(&returns, "_rc_");
  }

  if (result_set_proc) {
    bprintf(&returns, ", _result_stmt");
  }

  if (out_stmt_proc) {
    if (returns.used > 1) {
      bprintf(&returns, ", ");
    }
    bprintf(&returns, "_result_");
  }

  if (calls_out_union) {
    if (returns.used > 1) {
      bprintf(&returns, ", ");
    }
    bprintf(&returns, "_result_set_");
  }
  else if (out_union_proc) {
    if (returns.used > 1) {
      bprintf(&returns, ", ");
    }
    bprintf(&returns, "_rows_");
  }

  ast_node *item = params;
  while (item) {
    EXTRACT_ANY_NOTNULL(param, item->left);
    if (is_out_parameter(param->sem->sem_type)) {
      if (returns.used > 1)  {
        bprintf(&returns, ", ");
      }
      bprintf(&returns, "%s", param->sem->name);
    }
    item = item->right;
  }

  if (returns.used > 1)  {
    bprintf(cg_declarations_output, "  return %s\n", returns.ptr);
  }

  bprintf(cg_declarations_output, "end\n");

  CHARBUF_CLOSE(returns);
  CHARBUF_CLOSE(proc_decl);
  CHARBUF_CLOSE(proc_sym);
  CHARBUF_CLOSE(proc_name_base);
  CHARBUF_CLOSE(proc_cleanup);
  CHARBUF_CLOSE(proc_locals);
  CHARBUF_CLOSE(proc_body);
  CHARBUF_CLOSE(proc_contracts);
  CHARBUF_CLOSE(proc_fwd_ref);

  if (out_stmt_proc || out_union_proc || result_set_proc) {
    cg_lua_proc_result_set(ast);
  }

  lua_in_proc = false;
  current_proc = NULL;

  symtab_delete(lua_named_temporaries);
  lua_named_temporaries = NULL;
  lua_error_target_used = saved_lua_error_target_used;
  lua_rcthrown_index = saved_lua_rcthrown_index;
  lua_rcthrown_used = saved_lua_rcthrown_used;
  Invariant(!strcmp(lua_error_target, CQL_CLEANUP_DEFAULT_LABEL));
  Invariant(!strcmp(lua_rcthrown_current, CQL_LUA_RCTHROWN_DEFAULT));
  lua_prepared_statement_index = lua_prepared_statement_index_saved;
}

static void cg_lua_declare_simple_var(sem_t sem_type, CSTR name) {
  cg_lua_var_decl(cg_declarations_output, sem_type, name);
}

// Emit a bunch of variable declarations for normal variables.
// cg_lua_var_decl does exactly this job for us.  Add any global variables to
// the header file output.
static void cg_lua_declare_vars_type(ast_node *declare_vars_type) {
  Contract(is_ast_declare_vars_type(declare_vars_type));
  EXTRACT_NOTNULL(name_list, declare_vars_type->left);

  // DECLARE [name_list] [data_type]

  for (ast_node *ast = name_list; ast; ast = ast->right) {
    EXTRACT_NAME_AST(name_ast, ast->left);
    EXTRACT_STRING(name, name_ast);

    cg_lua_declare_simple_var(name_ast->sem->sem_type, name);
  }
}

// This is a callback method handed to the gen_ method that creates SQL for us
// it will call us every time it finds a variable that needs to be bound.  That
// variable is replaced by ? in the SQL output.  We end up with a list of variables
// to bind on a silver platter (but in reverse order).
static bool_t cg_lua_capture_variables(ast_node *ast, void *context, charbuf *buffer) {
  // all variables have a name
  Contract(ast->sem->name);

  // If the current context is inline function expansion then arg variables
  // are emitted as is -- we rewrite these so that they come from an inline table
  // e.g.
  //   'select x + y'
  // becomes
  //   '(select x + y from (select arg1 x, arg2 y))'
  //
  // as a result x, y are not bound variables
  if (lua_in_inline_function_fragment) {
    return false;
  }

  lua_cur_variable_count++;

  symtab_entry *entry = symtab_find(proc_arg_aliases, ast->sem->name);
  if (entry) {
    // this variable has been rewritten to a new name, use the alias
    ast = entry->val;
  }

  list_item **head = (list_item**)context;
  add_item_to_list(head, ast);

  gen_printf("?");
  return true;
}

// This is a callback method handed to the gen_ method that creates SQL for us
// it will call us every time it finds a cte table that needs to be generated.
// If this is one of the tables that is supposed to be an "argument" then
// we will remove the stub definition of the CTE.  References to this name
// will be changed to required table in another callback
static bool_t cg_lua_suppress_cte(ast_node *ast, void *context, charbuf *buffer) {
  Contract(is_ast_cte_table(ast));
  EXTRACT(cte_decl, ast->left);
  EXTRACT_STRING(name, cte_decl->left);

  // if we have an alias we suppress the name
  symtab_entry *entry = symtab_find(proc_cte_aliases, name);
  return !!entry;
}

// This a callback method handed to the gen_ method that creates SQL for us
// it will call us every time it finds a table reference that needs to be generated.
// If this is one of the tables that is supposed to be an "argument" then
// we will emit the desired value instead of the stub name.   Note that
// this is always the name of a CTE and CTE of the old name was suppressed
// using the callback above cg_lua_suppress_cte
static bool_t cg_lua_table_rename(ast_node *ast, void *context, charbuf *buffer) {
  // this is a simple table factor, so an actual name...
  EXTRACT_STRING(name, ast);
  bool_t handled = false;

  // if we have an alias we suppress the name
  symtab_entry *entry = symtab_find(proc_cte_aliases, name);
  if (entry) {
    EXTRACT(cte_binding, entry->val);
    EXTRACT_STRING(actual, cte_binding->left);
    gen_printf("%s", actual);
    handled = true;
  }

  return handled;
}

// This helper method fetches a single column from a select statement.  The result
// is to be stored in the local variable "var"
static void cg_lua_get_column(sem_t sem_type, CSTR cursor, int32_t index, CSTR var, charbuf *output) {
  if (core_type_of(sem_type) == SEM_TYPE_BOOL) {
    bprintf(output, "  %s = cql_to_bool(cql_get_value(%s, %d))\n", var, cursor, index);
  }
  else {
    bprintf(output, "  %s = cql_get_value(%s, %d)\n", var, cursor, index);
  }
}

// Emit a declaration for the temporary statement _temp_stmt_ if we haven't
// already done so.  Also emit the cleanup once.
static void lua_ensure_temp_statement(int32_t stmt_index) {
  if (lua_temp_statement_emitted && stmt_index == 0) {
    return;
  }

  CHARBUF_OPEN(temp_stmt);
  CG_TEMP_STMT_NAME(stmt_index, &temp_stmt);

  bprintf(cg_declarations_output, "local %s = nil\n", temp_stmt.ptr);
  bprintf(cg_cleanup_output, "  cql_finalize_stmt(%s)\n", temp_stmt.ptr);
  bprintf(cg_cleanup_output, "  %s = nil\n", temp_stmt.ptr);

  if (stmt_index == 0) {
    lua_temp_statement_emitted = true;
  }

  CHARBUF_CLOSE(temp_stmt);
}

// This tells us how many fragments we emitted using some size math
static uint32_t cg_lua_fragment_count() {
  return (uint32_t)(lua_shared_fragment_strings.used / sizeof(CSTR));
}

// when we complete a chunk of fragment text we have to emit the predicates
// for the variables that were in that chunk.  We do this in the same
// context as the conditional for that string.
static void cg_lua_flush_variable_predicates() {
  if (!lua_has_conditional_fragments) {
    return;
  }

  while (lua_prev_variable_count < lua_cur_variable_count) {
    if (lua_cur_fragment_predicate == 0 || lua_cur_fragment_predicate + 1 == lua_max_fragment_predicate) {
      bprintf(cg_main_output, "_vpreds_%d[%d] = true -- pred %d known to be true\n",
      lua_cur_bound_statement,
      lua_prev_variable_count++,
      lua_cur_fragment_predicate);
    }
    else {
      // If we're back in previous context we can always just use the predicate value
      // for that context which was set in an earlier block.
      // TODO: I think we can prove that it's always true in the code block we are in
      // so this could be = 1 and hence is the same as the above.
      bprintf(cg_main_output, "_vpreds_%d[%d] = _preds_%d[%d]\n",
        lua_cur_bound_statement,
        lua_prev_variable_count++,
        lua_cur_bound_statement,
        lua_cur_fragment_predicate);
    }
  }
}

// If we have set up the predicate for this chunk of text we can just use it
// we see that by looking at how many predicates we set up and if we
// are past that point. If we need a predicate for the current line
// we use the predicate value for the "current" predicate scope,
// which nests.  Whatever the current predicate is we use that
// and make an entry in the array.  So that way there is always
// one computed predicate for each chunk of text we plan to emit.
static void cg_lua_fragment_copy_pred() {
  if (!lua_has_conditional_fragments) {
    return;
  }

  uint32_t count = cg_lua_fragment_count();
  if (count + 1 == lua_max_fragment_predicate) {
    return;
  }

  if (lua_cur_fragment_predicate == 0) {
    bprintf(cg_main_output, "_preds_%d[%d] = true\n",
      lua_cur_bound_statement,
      lua_max_fragment_predicate++);
  }
  else {
    // TODO: I think we can prove that it's always true in the code block we are in
    // so this could be = true and hence is the same as the above.
    bprintf(cg_main_output, "_preds_%d[%d] = _preds_%d[%d]\n",
      lua_cur_bound_statement,
      lua_max_fragment_predicate++,
      lua_cur_bound_statement,
      lua_cur_fragment_predicate);
  }

  cg_lua_flush_variable_predicates();
}

// First we make sure we have a predicate row and then we emit the line
// assuming there is anything to emit...
static void cg_lua_emit_one_frag(charbuf *buffer) {
  // TODO: can we make this an invariant?
  if (buffer->used > 1) {
    cg_lua_fragment_copy_pred();
    CSTR str = Strdup(buffer->ptr);
    bytebuf_append_var(&lua_shared_fragment_strings, str);
    bclear(buffer);
  }
}

// Emit a fragment from a statement, note that this can nest
static void cg_lua_fragment_stmt(ast_node *stmt, charbuf *buffer) {
  gen_one_stmt(stmt);
  cg_lua_emit_one_frag(buffer);
  cg_lua_flush_variable_predicates();
}

// a new block in a conditional, this is the "it's true" case for it
// assign it a number and move on.  Note the code is always inside of
// if (the_expression_was_true) {...}
static void cg_lua_fragment_setpred() {
  lua_cur_fragment_predicate = lua_max_fragment_predicate;
  if (lua_has_conditional_fragments) {
    bprintf(cg_main_output, "_preds_%d[%d] = true\n",
      lua_cur_bound_statement,
      lua_max_fragment_predicate++);
  }
}

// Emit the if condition for the conditional fragment and then generate the
// predicate setting as well as the SQL for that part of the fragment.
static void cg_lua_fragment_cond_action(ast_node *ast, charbuf *buffer) {
  Contract(is_ast_cond_action(ast));
  EXTRACT_NOTNULL(stmt_list, ast->right);
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  // [expr ast->left] THEN stmt_list

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  bprintf(cg_main_output, "if %s then\n", expr_value.ptr);

  CG_LUA_POP_EVAL(expr);

  int32_t cur_fragment_predicate_saved = lua_cur_fragment_predicate;

  CG_PUSH_MAIN_INDENT2(ifbody);
  cg_lua_fragment_setpred();

  // and we emit the next statement string fragment
  cg_lua_fragment_stmt(stmt_list->left, buffer);

  lua_cur_fragment_predicate = cur_fragment_predicate_saved;

  CG_POP_MAIN_INDENT(ifbody);
}

// Here we're just walking the elseif list, as with normal codegen when we get
// to the end we deal with the elsenode.  We can't do the else node in the caller
// because we need to emit it inside the deepest matching parens.  So we just
// push the elsenode down the recursion until its needed.
static void cg_lua_fragment_elseif_list(ast_node *ast, ast_node *elsenode, charbuf *buffer) {
  if (ast) {
    Contract(is_ast_elseif(ast));
    EXTRACT(cond_action, ast->left);

    // ELSE IF [cond_action]
    bprintf(cg_main_output, "else\n");
      CG_PUSH_MAIN_INDENT2(else);
      cg_lua_fragment_cond_action(cond_action, buffer);
      cg_lua_fragment_elseif_list(ast->right, elsenode, buffer);
      CG_POP_MAIN_INDENT(else);
    bprintf(cg_main_output, "end\n");
  }
  else if (elsenode) {
    Contract(is_ast_else(elsenode));
    // ELSE [stmt_list]
    EXTRACT(stmt_list, elsenode->left);

    bprintf(cg_main_output, "else\n");
      CG_PUSH_MAIN_INDENT2(else);

      int32_t cur_fragment_predicate_saved = lua_cur_fragment_predicate;
      cg_lua_fragment_setpred();

      // this is the next string fragment
      cg_lua_fragment_stmt(stmt_list->left, buffer);

      lua_cur_fragment_predicate = cur_fragment_predicate_saved;
      CG_POP_MAIN_INDENT(else);
    bprintf(cg_main_output, "end\n");
  }
}

// This handles the expression fragment case, this is rewritten so that
// the arguments of the expression fragment become columns of one row of table
// e.g.
// [[shared_fragment]]
// create proc ex_frag(x integer)
// begin
//    select x + 2 * x as result;
// end
//
// this becomes
//
// "SELECT x + 2 * x from (select ? as x)"
//
// The expression fragment is not allowed to have its own from clause which means
// we can use the from clause for our own purposes (local binding).  The is very
// helpful if the fragment happens often or if the argument would otherwise have
// to be evaluated many times.  But it comes at the cost of a one-row query.
static bool_t cg_lua_inline_func(ast_node *call_ast, void *context, charbuf *buffer) {
  Contract(is_ast_call(call_ast));
  EXTRACT_STRING(proc_name, call_ast->left);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!is_inline_func_call(call_ast)) {
    return false;
  }

  // flush what we have so far
  cg_lua_emit_one_frag(buffer);

  ast_node *ast = find_proc(proc_name);

  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  bool_t saved_in_inline_function_fragment = lua_in_inline_function_fragment;
  symtab *saved_proc_arg_aliases = proc_arg_aliases;
  symtab *saved_proc_cte_aliases = proc_cte_aliases;
  lua_in_inline_function_fragment = true;

  proc_arg_aliases = NULL;
  proc_cte_aliases = NULL;

  gen_printf("(");

  // Emit a fragment from a statement, note that this can nest
  cg_lua_fragment_stmt(stmt, buffer);

  proc_arg_aliases = saved_proc_arg_aliases;
  proc_cte_aliases = saved_proc_cte_aliases;
  lua_in_inline_function_fragment = saved_in_inline_function_fragment;

  if (params) {
    // If there are any args we create a nested select expression
    // to bind them to the variable names.  Note that this means
    // args are evaluated once which could be important if there
    // are SQL functions with side-effects being used (highly rare)
    // or expensive functions.
    gen_printf(" FROM (SELECT ");

    while (params) {
      Invariant(is_ast_params(params));
      Invariant(arg_list); // expressions match the args

      EXTRACT_NOTNULL(param, params->left);
      EXTRACT_ANY_NOTNULL(expr, arg_list->left);

      EXTRACT_NOTNULL(param_detail, param->right);
      EXTRACT_NAME_AST(param_name_ast, param_detail->left)
      EXTRACT_STRING(param_name, param_name_ast);

      gen_root_expr(expr);
      gen_printf(" %s", param_name);
      if (params->right) {
        gen_printf(", ");
      }

      // guaranteed to stay in lock step
      params = params->right;
      arg_list = arg_list->right;
    }
    gen_printf(")");
  }

  gen_printf(")");
  cg_lua_emit_one_frag(buffer);

  return true;
}

// Here we've found a call expression where a CTE should be so like
// with
//  X(*) as (call foo(1,2,3))
// select * from X;
//
// or
//
// with
//  X(*) as (call foo(1,2,3) USING foo as source1, bar = source2)
// select * from X;
//
// What we're going to do is replace the call with the body of the procedure that is being called.
// We have to do a few things to make this work:
//  * the args to the procedure have to be evaluated and put into locals
//  * any use of those arguments has to be redirected to said locals (so rename the locals)
//  * naturally any of those arguments can't be database things (wrong context) so we can evaluate them
//    all in advance
//  * if the call has the "USING" form then we have to alias all instances of the mentioned
//    tables in the target procedure to be the values that were provided
//  * any such args/aliases have been pre-validated during semantic analysis
//  * code gen is designed to keep as many string literals identical as possible so that they can be folded
static bool_t cg_lua_call_in_cte(ast_node *cte_body, void *context, charbuf *buffer) {
  EXTRACT_NOTNULL(call_stmt, cte_body->left);
  EXTRACT(cte_binding_list, cte_body->right);

  EXTRACT_STRING(name, call_stmt->left);
  EXTRACT_ANY(expr_list, call_stmt->right);

  ast_node *ast = find_proc(name);

  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);

  bool_t saved_in_inline_function_fragment = lua_in_inline_function_fragment;
  symtab *saved_proc_arg_aliases = proc_arg_aliases;
  symtab *saved_proc_cte_aliases = proc_cte_aliases;
  lua_in_inline_function_fragment = false;

  symtab *new_arg_aliases = symtab_new();
  proc_cte_aliases = symtab_new();

  while (cte_binding_list) {
    EXTRACT_NOTNULL(cte_binding, cte_binding_list->left);
    EXTRACT_STRING(formal, cte_binding->right);
    EXTRACT_STRING(actual, cte_binding->left);

    // The "actual" might itself be an alias from the outer scope
    // be sure to push that down if that's the case.  One level
    // is always enough because each level does its own push if
    // needed.

    bool_t handled = false;

    if (saved_proc_cte_aliases) {
      symtab_entry *entry = symtab_find(saved_proc_cte_aliases, actual);
      if (entry) {
        symtab_add(proc_cte_aliases, formal, entry->val);
        handled = true;
      }
    }

    if (!handled) {
      // normal case, the first time a name is aliased
      symtab_add(proc_cte_aliases, formal, cte_binding);
    }

    cte_binding_list = cte_binding_list->right;
  }

  if (params) {
    // move to the next index if we need to alias anything
    proc_cte_index++;
  }

  while (params) {
    Invariant(is_ast_params(params));
    Invariant(expr_list); // expressions match the args

    EXTRACT_NOTNULL(param, params->left);
    EXTRACT_ANY_NOTNULL(expr, expr_list->left);

    EXTRACT_NOTNULL(param_detail, param->right);
    EXTRACT_NAME_AST(param_name_ast, param_detail->left)
    EXTRACT_STRING(param_name, param_name_ast);

    sem_t sem_type_var = param_name_ast->sem->sem_type;

    CSTR alias_name = dup_printf("_p%d_%s_", proc_cte_index, param_name);

    AST_REWRITE_INFO_SET(param->lineno, param->filename);

    ast_node *alias  = new_ast_str(alias_name);
    symtab_add(new_arg_aliases, param_name, alias);
    alias->sem = new_sem(sem_type_var);
    alias->sem->name = alias_name;
    alias->sem->kind = param_name_ast->sem->kind;

    AST_REWRITE_INFO_RESET();

    // emit the declaration
    cg_lua_var_decl(cg_declarations_output, sem_type_var, alias_name);

    sem_t sem_type_expr = expr->sem->sem_type;

    // evaluate the expression and assign
    // note that any arg aliases here are in the context of the caller not the callee
    // we're setting up the aliases for the callee right now and they aren't ready yet even
    // but that's ok because the expressions are in the context of the caller.

    // todo: if the evaluation has a nested select statement then we will have to re-enter
    // all of this.  We can either ban that (which isn't insane really) or else we can
    // save the codegen state like callbacks and such so that it can re-enter.  That's
    // the desired path.

    CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ASSIGN);
    cg_lua_store(cg_main_output, alias_name, sem_type_var, sem_type_expr, expr_value.ptr);
    CG_LUA_POP_EVAL(expr);

    // guaranteed to stay in lock step
    params = params->right;
    expr_list = expr_list->right;
  }

  // exactly one statment
  Invariant(!stmt_list->right);

  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  // now replace the aliases for just this one bit
  proc_arg_aliases = new_arg_aliases;

  cg_lua_emit_one_frag(buffer);

  // we need the column names for our select
  // we'll accomplish this by generating a CTE wrapper
  // the column names are were already in the original text but
  // we want to minify those out, we could turn off alias minification here
  // but if we did that then we couldn't share the text of the fragment
  // so instead we make a wrapper that has exatly the column names we need

  bool_t is_nested_select = is_ast_table_or_subquery(cte_body->parent);
  cte_proc_call_info* info = (cte_proc_call_info*)context;
  bool_t saved_minify_aliases = info->callbacks->minify_aliases;

  CHARBUF_OPEN(wrapper);
  if (is_nested_select) {
    // We need to keep column names of the generated SELECT
    // when generating shared fragments as a subquery.
    info->callbacks->minify_aliases = false;

    bprintf(&wrapper, "(");
    cg_lua_emit_one_frag(&wrapper);
  }
  else {
    // Use the original global setting
    // (subcalls inside a CTE of a fragment in a nested select can use original setting)
    info->callbacks->minify_aliases = info->minify_aliases;
  }

  if (is_ast_if_stmt(stmt)) {
    EXTRACT_NOTNULL(cond_action, stmt->left);
    EXTRACT_NOTNULL(if_alt, stmt->right);
    EXTRACT(elseif, if_alt->left);
    EXTRACT_NAMED_NOTNULL(elsenode, else, if_alt->right);

    cg_lua_fragment_cond_action(cond_action, buffer);
    cg_lua_fragment_elseif_list(elseif, elsenode, buffer);
  }
  else {
    cg_lua_fragment_stmt(stmt, buffer);
  }

  if (is_nested_select) {
    bprintf(&wrapper, ")");
    cg_lua_emit_one_frag(&wrapper);
  }

  info->callbacks->minify_aliases = saved_minify_aliases;
  CHARBUF_CLOSE(wrapper);

  symtab_delete(proc_arg_aliases);
  symtab_delete(proc_cte_aliases);
  proc_arg_aliases = saved_proc_arg_aliases;
  proc_cte_aliases = saved_proc_cte_aliases;
  lua_in_inline_function_fragment = saved_in_inline_function_fragment;

  return true;
}

// We're looking for the presence of any shared fragments and in particular
// the presence of conditionals within them.  We don't have to do much for
// this check but we do have to recurse the search as the normal walk doesn't
// go into the body of shared fragments and the conditionals might be deeper
// in the tree.
static bool_t cg_lua_search_conditionals_call_in_cte(ast_node *cte_body, void *context, charbuf *buffer) {
  EXTRACT_NOTNULL(call_stmt, cte_body->left);
  EXTRACT_STRING(name, call_stmt->left);

  ast_node *ast = find_proc(name);

  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  lua_has_conditional_fragments |= is_ast_if_stmt(stmt);
  lua_has_shared_fragments = true;

  // recurse the fragment contents, we might find more stuff, like variables
  // and such deeper in the tree
  gen_one_stmt(stmt);

  return false;
}

// We simply record that we found some variables, any variables
static bool_t cg_lua_note_variable_exists(ast_node *cte_body, void *context, charbuf *buffer) {
  lua_has_variables = true;
  return false;
}

// The inline function counts as a shared fragment and we recurse to find any
// internal shared fragments or conditional fragments inside of the inline function.
// Note that even though it has no FROM clause the inline function could have
// a nested select inside of its select list and therefore all fragment types
// can appear inside of an inline function fragment.
static bool_t cg_lua_note_inline_func(ast_node *call_ast, void *context, charbuf *buffer) {
  Contract(is_ast_call(call_ast));
  EXTRACT_STRING(proc_name, call_ast->left);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);

  if (!is_inline_func_call(call_ast)) {
    return false;
  }

  ast_node *ast = find_proc(proc_name);

  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  // recurse the fragment contents, we might find more stuff, like variables
  // and such deeper in the tree
  gen_one_stmt(stmt);

  lua_has_shared_fragments = true;
  return false;
}


// We set up a walk of the tree using the echo functions but
// we are going to note what kinds of things we spotted while doing
// the walk.  We need to know in advance what style of codegen we'll
// be doing.
static void cg_lua_classify_fragments(ast_node *stmt) {
  lua_has_shared_fragments = false;
  lua_has_conditional_fragments = false;
  lua_has_variables = false;

  CHARBUF_OPEN(sql);
  gen_set_output_buffer(&sql);
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.cte_proc_callback = cg_lua_search_conditionals_call_in_cte;
  callbacks.variables_callback = cg_lua_note_variable_exists;
  callbacks.func_callback = cg_lua_note_inline_func;
  gen_statement_with_callbacks(stmt, &callbacks);
  CHARBUF_CLOSE(sql);
}

// This is the most important function for sqlite access;  it does the heavy
// lifting of generating the C code to prepare and bind a SQL statement.
// If cg_lua_exec is true (CG_EXEC) then the statement is executed immediately
// and finalized.  No results are expected.  To accomplish this we do the following:
//   * figure out the name of the statement, either it's given to us
//     or we're using the temp statement
//   * call get_statement_with_callback to get the text of the SQL from the AST
//     * the callback will give us all the variables to bind
//     * count the variables so we know what column numbers to use (the list is backwards!)
//   * if CG_EXEC and no variables we can use the simpler sqlite3_exec form
//   * bind any variables
//   * if there are variables CG_EXEC will step and finalize
static int32_t cg_lua_bound_sql_statement(CSTR stmt_name, ast_node *stmt, int32_t cg_lua_flags) {
  list_item *vars = NULL;

  lua_cur_bound_statement++;
  lua_cur_fragment_predicate = 0;
  lua_max_fragment_predicate = 0;
  lua_prev_variable_count = 0;
  lua_cur_variable_count = 0;
  int32_t stmt_index = 0;

  bytebuf_open(&lua_shared_fragment_strings);

  cg_lua_classify_fragments(stmt);

  if (lua_has_conditional_fragments) {
    bprintf(cg_main_output, "_preds_%d = {}\n", lua_cur_bound_statement);
    if (lua_has_variables) {
      bprintf(cg_main_output, "_vpreds_%d = {}\n", lua_cur_bound_statement);
    }
  }

  bool_t may_reuse_statement = !lua_has_conditional_fragments && lua_in_loop;
  bool_t reusing_statement = false;

  bool_t minify_aliases = !!(cg_lua_flags & CG_MINIFY_ALIASES);
  bool_t exec_only = !!(cg_lua_flags & CG_EXEC);

  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.variables_callback = cg_lua_capture_variables;
  callbacks.variables_context = &vars;
  callbacks.minify_casts = true;
  callbacks.minify_aliases = minify_aliases;
  callbacks.long_to_int_conv = true;
  callbacks.cte_proc_callback = cg_lua_call_in_cte;
  callbacks.cte_suppress_callback = cg_lua_suppress_cte;
  callbacks.table_rename_callback = cg_lua_table_rename;
  callbacks.func_callback = cg_lua_inline_func;

  cte_proc_call_info cte_proc_context;
  callbacks.cte_proc_context = &cte_proc_context;
  cte_proc_context.callbacks = &callbacks;
  cte_proc_context.minify_aliases = minify_aliases;

  CHARBUF_OPEN(sql);
  gen_set_output_buffer(&sql);
  gen_statement_with_callbacks(stmt, &callbacks);

  // whether or not there is a prepare statement
  bool_t has_prepare_stmt = !exec_only || vars;

  uint32_t count = 0;
  for (list_item *item = vars; item; item = item->next, count++) ;

  CHARBUF_OPEN(temp_stmt);

  if (stmt_name == NULL && has_prepare_stmt) {
    if (may_reuse_statement) {
      stmt_index = ++lua_prepared_statement_index;
      reusing_statement = true;
    }
    lua_ensure_temp_statement(stmt_index);
    CG_TEMP_STMT_BASE_NAME(stmt_index, &temp_stmt);
    stmt_name = temp_stmt.ptr;
  }

  // take care of what's left in the buffer after the other fragments have been emitted
  if (lua_has_shared_fragments) {
    cg_lua_emit_one_frag(&sql);
  }

  {
    CSTR suffix = lua_has_shared_fragments ? "_var" : "";

    if (!has_prepare_stmt) {
      bprintf(cg_main_output, "_rc_ = cql_exec%s(_db_,\n  ", suffix);
    }
    else {
      if (reusing_statement) {
        bprintf(cg_main_output, "if %s_stmt == nil then\n  ", stmt_name);
      }
      bprintf(cg_main_output, "_rc_, %s_stmt = cql_prepare%s(_db_, \n  ", stmt_name, suffix);
    }

    if (!lua_has_shared_fragments) {
      cg_pretty_quote_plaintext(sql.ptr, cg_main_output, PRETTY_QUOTE_C);
    }
    else {
      uint32_t scount = cg_lua_fragment_count();

      // declare the predicate variables if needed
      if (lua_has_conditional_fragments) {
        bprintf(cg_main_output, "%d, _preds_%d,\n", scount, lua_cur_bound_statement);
        bprintf(cg_declarations_output, "local _preds_%d  -- %d possible fragments\n", lua_cur_bound_statement, scount);
        if (lua_has_variables) {
          bprintf(cg_declarations_output, "local _vpreds_%d -- %d possible bindings\n", lua_cur_bound_statement, lua_cur_variable_count);
        }
      }
      else {
        bprintf(cg_main_output, "%d, nil,\n", scount);
      }

      bprintf(cg_main_output, "  {\n");
      CSTR *strs = (CSTR *)(lua_shared_fragment_strings.ptr);
      for (size_t i = 0; i < scount; i++) {
        bprintf(cg_main_output, "  ");
        cg_pretty_quote_plaintext(strs[i], cg_main_output, PRETTY_QUOTE_C);
        if (i + 1 < scount) {
          bprintf(cg_main_output, ",\n");
        }
        else {
          bprintf(cg_main_output, "\n");
        }
      }
      bprintf(cg_main_output, "  }\n");
    }
    bprintf(cg_main_output, ")\n");
  }

  if (reusing_statement) {
    bprintf(cg_main_output, "  ");
    cg_lua_error_on_not_sqlite_ok();
    bprintf(cg_main_output, "end\n");
  }
  else {
    cg_lua_error_on_not_sqlite_ok();
  }

  CHARBUF_CLOSE(temp_stmt);
  CHARBUF_CLOSE(sql);

  reverse_list(&vars);

  if (count) {
    CHARBUF_OPEN(typestring);
    bputc(&typestring, '"');

    // Now emit the binding args for each variable
    for (list_item *item = vars; item; item = item->next)  {
      sem_t sem_type = item->ast->sem->sem_type;
      cg_lua_put_typecode(&typestring, sem_type);
    }

    bputc(&typestring, '"');

    if (lua_has_conditional_fragments) {
      bprintf(cg_main_output, "_rc_ = cql_multibind_var(_db_, %s_stmt, %d, _vpreds_%d, %s, ",
        stmt_name, count, lua_cur_bound_statement, typestring.ptr);
    }
    else {
      bprintf(cg_main_output, "_rc_ = cql_multibind(_db_, %s_stmt, %s, ",
        stmt_name, typestring.ptr);
    }

    CHARBUF_CLOSE(typestring);


    // Now emit the binding args for each variable
    for (list_item *item = vars; item; item = item->next)  {
      Contract(item->ast->sem->name);
      if (item != vars) {
        bprintf(cg_main_output, ", ");
      }
      bprintf(cg_main_output, "%s", item->ast->sem->name);
    }

    bprintf(cg_main_output, ")\n");
    cg_lua_error_on_not_sqlite_ok();
  }

  if (exec_only && vars) {
    bprintf(cg_main_output, "_rc_ = cql_step(%s_stmt)\n", stmt_name);
    cg_lua_error_on_rc_notequal("CQL_DONE");
    if (reusing_statement) {
      bprintf(cg_main_output, "cql_reset_stmt(%s_stmt)\n", stmt_name);
    }
    else {
      bprintf(cg_main_output, "cql_finalize_stmt(%s_stmt)\n", stmt_name);
      bprintf(cg_main_output, "%s_stmt = nil\n", stmt_name);
    }
  }

  // vars is pool allocated, so we don't need to free it
  bytebuf_close(&lua_shared_fragment_strings);
  return stmt_index;
}

static void cg_lua_emit_field_names(charbuf *output, sem_struct *sptr) {
  Contract(sptr);

  bprintf(output, "{ ");
    for (uint32_t i = 0; i < sptr->count; i++) {
    if (i > 0) {
      bprintf(output, ", ");
    }
    if (strcmp(sptr->names[i], "_anon")) {
      bprintf(output, "\"%s\"", sptr->names[i]);
    }
    else {
      bprintf(output, "\"_anon%d\"", i);
    }
  }
  bprintf(output, " }");
}

// copied here for easy reference
//
// #define SEM_TYPE_BOOL 1         // the subtree is a bool
// #define SEM_TYPE_INTEGER 2      // the subtree is an integer
// #define SEM_TYPE_LONG_INTEGER 3 // the subtree is a long_integer
// #define SEM_TYPE_REAL 4         // the subtree is a real
// #define SEM_TYPE_TEXT 5         // the subtree is a text type
// #define SEM_TYPE_BLOB 6         // the subtree is a blob type
// #define SEM_TYPE_OBJECT 7       // the subtree is any object type
//
// code meanings
//
// f = flag = bool  (b is for blob)
// i = integer
// l = long_int
// d = double (the real type)
// s = string (the text type)
// b = blob
// o = object
//
// these are the same codes used by the blob encoder
//
// Note if the sem type codes were ever re-ordered a zillion tests
// would break until these lines were fixed so there isn't really
// a maintenance issue here.  There are actually more subtle
// order dependencies for range checks so this doesn't really
// add anything new.
//
static char code_nullable[] = "@fildsbo";
static char code_not_nullable[] = "@FILDSBO";

static void cg_lua_put_typecode(charbuf *output, sem_t sem_type) {
  sem_t core_type = core_type_of(sem_type);
  bool_t nullable = is_nullable(sem_type);
  Invariant(core_type >= SEM_TYPE_NULL && core_type <= SEM_TYPE_OBJECT);
  bputc(output, nullable ? code_nullable[core_type] : code_not_nullable[core_type]);
}

static void cg_lua_emit_field_types(charbuf *output, sem_struct *sptr) {
  bputc(output, '"');

  for (uint32_t i = 0; i < sptr->count; i++) {
    sem_t sem_type = sptr->semtypes[i];
    cg_lua_put_typecode(output, sem_type);
  }

  bputc(output, '"');
}

// This emits the declaration for an "auto cursor" -- that is a cursor
// that includes storage for all the fields it can fetch.  In LUA all
// cursors have storage.  When you do FETCH INTO first the cursor is loaded
// and then the variables are assigned, so there is only the one path.
static void cg_lua_declare_auto_cursor(CSTR cursor_name, sem_struct *sptr) {
  Contract(cursor_name);
  Contract(sptr);

  CSTR local = "local ";
  if (lua_in_var_group_emit) {
    local = "";
  }

  // this should really zero the cursor
  bprintf(cg_declarations_output, "%s%s = { _has_row_ = false }\n", local, cursor_name);
  bprintf(cg_declarations_output, "%s%s_fields_ = ", local, cursor_name);
  cg_lua_emit_field_names(cg_declarations_output, sptr);
  bprintf(cg_declarations_output, "\n");
  bprintf(cg_declarations_output, "%s%s_types_ = ", local, cursor_name);
  cg_lua_emit_field_types(cg_declarations_output, sptr);
  bprintf(cg_declarations_output, "\n");
}

// Declaring a cursor causes us to do the following:
//  * emit a local variable for the cursor in the declarations section
//  * emit cleanup logic for that local in the cleanup section
//  * execute the select or call statement that is associated with the cursor
//    * store the resulting statement for use later in fetch
//  * declare a hidden has_row local for the cursor so that the cursor name
//    can be used in expressions to see if a row was fetched.
static void cg_lua_declare_cursor(ast_node *ast) {
  Contract(is_ast_declare_cursor(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(cursor_name, name_ast);

  // TODO, finalize cursor before fetching if in loop cg_c does this

  bool_t is_for_select = false;
  bool_t is_for_call = false;
  bool_t is_for_expr = false;
  bool_t out_union_processing = false;
  bool_t is_boxed = !!(name_ast->sem->sem_type & SEM_TYPE_BOXED);
  bool_t is_unboxing = true;

  if (is_ast_call_stmt(ast->right)) {
    out_union_processing = has_out_union_stmt_result(ast);
    is_for_call = true;
    is_unboxing = false;
    EXTRACT_STRING(name, ast->right->left);
  }
  else if (is_row_source(ast->right)) {
    is_for_select = true;
    is_unboxing = false;
  }
  else {
    is_for_expr = true;
    if (ends_in_set(ast->right->sem->kind)) {
      out_union_processing = true;
      is_unboxing = false;
    }
  }

  // only one of these (is boxed makes no sense with out union)
  Invariant(!out_union_processing || !is_boxed);

  // can't be both of these either
  Invariant(!out_union_processing || !is_unboxing);

  // unboxing implies is_boxed   a->b <==> (!a | b)
  Invariant(!is_unboxing || is_boxed);

  if (out_union_processing) {
    bprintf(cg_declarations_output, "local %s_result_set_ = nil\n", cursor_name);
    bprintf(cg_declarations_output, "local %s_row_num_ = 0\n", cursor_name);
    bprintf(cg_declarations_output, "local %s_row_count_ = 0\n", cursor_name);

    if (is_for_expr) {
      EXTRACT_ANY_NOTNULL(expr, ast->right);
      CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

      bprintf(cg_main_output, "%s_result_set_ = %s\n", cursor_name, expr_value.ptr);
      bprintf(cg_main_output, "%s_row_num_ = 0\n", cursor_name);
      bprintf(cg_main_output, "%s_row_count_ = #(%s_result_set_)\n", cursor_name, cursor_name);

      CG_LUA_POP_EVAL(expr);
    }
  }
  else {
    bprintf(cg_declarations_output, "local %s_stmt = nil\n", cursor_name);

    if (!is_boxed) {
      // easy case, no boxing, just finalize on exit.
      bprintf(cg_cleanup_output, "  cql_finalize_stmt(%s_stmt)\n", cursor_name);
      bprintf(cg_cleanup_output, "  %s_stmt = nil\n", cursor_name);

      if (lua_in_loop) {
        // tricky case, the call might iterate so we have to clean up the cursor before we do the call
        bprintf(cg_main_output, "cql_finalize_stmt(%s_stmt)\n", cursor_name);
      }
    }
  }

  if (is_for_select) {
    // DECLARE [name] CURSOR FOR [select_stmt]
    // or
    // DECLARE [name] CURSOR FOR [explain_stmt]
    EXTRACT_ANY_NOTNULL(select_stmt, ast->right);

    if (is_boxed) {
      // The next prepare will finalize the statement, we don't want to do that
      // if the cursor is being handled by boxes. The box downcount will take care of it
      bprintf(cg_main_output, "%s_stmt = nil\n", cursor_name);
    }
    cg_lua_bound_sql_statement(cursor_name, select_stmt, CG_PREPARE|CG_MINIFY_ALIASES);
  }
  else if (is_unboxing) {
    Invariant(is_for_expr);

    // DECLARE [name] CURSOR FOR [box_object_expr]
    EXTRACT_ANY_NOTNULL(expr, ast->right);
    CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

    bprintf(cg_main_output, "%s_stmt = %s\n", cursor_name, expr_value.ptr);

    CG_LUA_POP_EVAL(expr);
  }
  else if (is_for_expr) {
  }
  else {
    Invariant(is_for_call);
    // DECLARE [name] CURSOR FOR [call_stmt]]
    if (is_boxed) {
      // The next prepare will finalize the statement, we don't want to do that
      // if the cursor is being handled by boxes. The box downcount will take care of it
      bprintf(cg_main_output, "%s_stmt = nil\n", cursor_name);
    }

    EXTRACT_NOTNULL(call_stmt, ast->right);
    cg_lua_call_stmt_with_cursor(call_stmt, cursor_name);
  }

  // in lua we always use "auto cursor" form we don't do cursor without storage
  // we just copy from the cursor if we need to when doing fetch into.  This makes
  // things a lot more symmetric.
  cg_lua_declare_auto_cursor(cursor_name, name_ast->sem->sptr);

  // in C you have to put something in the .h file if you want to have a global cursor
  // we have none of that in LUA so... nothing here... for global cursor stuff.  see cg_c.c
  // if you want to see the sadness that is C.
}

// This is the cursor boxing primitive, we'll make an object variable for this cursor here
// Note since the cursor is boxed its lifetime is already controlled by an object associated
// with the cursor.  This happens as soon as the cursor is created, however it is created.
// The codegen system knows that the cursor may be boxed at some point using the SEM_TYPE_BOXED flag
static void cg_lua_set_from_cursor(ast_node *ast) {
  Contract(is_ast_set_from_cursor(ast));
  EXTRACT_ANY_NOTNULL(variable, ast->left);
  EXTRACT_ANY_NOTNULL(cursor, ast->right);
  EXTRACT_STRING(cursor_name, cursor);
  EXTRACT_STRING(var_name, variable);

  // in LUA the statement is already an object, we just store it
  bprintf(cg_main_output, "%s = %s_stmt\n", var_name, cursor_name);
}

static void cg_lua_declare_cursor_like(ast_node *name_ast) {
  EXTRACT_STRING(cursor_name, name_ast);

  Contract(name_ast->sem->sem_type & SEM_TYPE_HAS_SHAPE_STORAGE);
  cg_lua_declare_auto_cursor(cursor_name, name_ast->sem->sptr);
}

static void cg_lua_declare_cursor_like_name(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_name(ast));
  Contract(ast->right);
  EXTRACT_NAME_AST(name_ast, ast->left);

  cg_lua_declare_cursor_like(name_ast);
}

static void cg_lua_declare_cursor_like_select(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_select(ast));
  Contract(is_row_source(ast->right));
  EXTRACT_NAME_AST(name_ast, ast->left);

  cg_lua_declare_cursor_like(name_ast);
}

static void cg_lua_declare_cursor_like_typed_names(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_typed_names(ast));
  Contract(is_ast_typed_names(ast->right));
  EXTRACT_NAME_AST(name_ast, ast->left);

  cg_lua_declare_cursor_like(name_ast);
}

// The value cursor form for sure will be fetched.   We emit the necessary locals
// for the cursor here.
static void cg_lua_declare_value_cursor(ast_node *ast) {
  Contract(is_ast_declare_value_cursor(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(cursor_name, name_ast);
  EXTRACT_NOTNULL(call_stmt, ast->right);

  // DECLARE [name] CURSOR FETCH FROM [call_stmt]]
  cg_lua_declare_auto_cursor(cursor_name, name_ast->sem->sptr);
  cg_lua_call_stmt_with_cursor(call_stmt, cursor_name);
}

// Fetch values has been checked for the presence of all columns and seed values
// have already been added if needed.
static void cg_lua_fetch_values_stmt(ast_node *ast) {
  Contract(is_ast_fetch_values_stmt(ast));

  EXTRACT(insert_dummy_spec, ast->left);
  EXTRACT(name_columns_values, ast->right);
  EXTRACT_ANY_NOTNULL(cursor, name_columns_values->left)
  EXTRACT(columns_values, name_columns_values->right);
  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT(insert_list, columns_values->right);
  EXTRACT(name_list, column_spec->left);

  if (insert_dummy_spec) {
    cg_lua_insert_dummy_spec(insert_dummy_spec);
  }

  // get the canonical name of the cursor (the string might be case-sensitively different)
  CSTR cursor_name = cursor->sem->name;

  // FETCH name [( name_list )] FROM VALUES (insert_list) [insert_dummy_spec]

  ast_node *value = insert_list;

  bprintf(cg_main_output, "%s._has_row_ = true\n", cursor_name);

  for (ast_node *item = name_list ; item; item = item->right, value = value->right) {
    EXTRACT_ANY_NOTNULL(expr, value->left);
    EXTRACT_ANY_NOTNULL(col, item->left);
    EXTRACT_STRING(var, col);

    CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);
    CHARBUF_OPEN(temp);
    bprintf(&temp, "%s.%s", cursor_name, var);
    cg_lua_store(cg_main_output, temp.ptr, col->sem->sem_type, expr->sem->sem_type, expr_value.ptr);
    CHARBUF_CLOSE(temp);
    CG_LUA_POP_EVAL(expr);
  }
}

// Fetch has already been rigorously checked so we don't have to worry about
// argument counts or type mismatches in the codegen.  We have two cases:
//  * Fetch into variables
//    * loop over the variables which must match with the columns (!) and
//      use the cg_lua_get_column helpers to emit the code for a store
//  * Fetch into auto variables
//    * loop over the field names of the sem_struct that corresponds to the cursor
//    * set each local according to the automatically generated name as above
// Note: cg_lua_get_column does the error processing
static void cg_lua_fetch_stmt(ast_node *ast) {
  Contract(is_ast_fetch_stmt(ast));
  EXTRACT_ANY_NOTNULL(cursor_ast, ast->left);
  EXTRACT(name_list, ast->right);

  // use the canonical name, not the AST name (case could be different)
  CSTR cursor_name = cursor_ast->sem->name;

  // FETCH [name] [INTO [name_list]]

  bool_t uses_out_union = !!(ast->sem->sem_type & SEM_TYPE_USES_OUT_UNION);

  if (uses_out_union) {
    bprintf(cg_main_output, "%s_row_num_ = %s_row_num_ + 1\n", cursor_name, cursor_name);
    bprintf(cg_main_output, "if %s_row_num_ <= %s_row_count_ then\n", cursor_name, cursor_name);
    bprintf(cg_main_output, "  %s = %s_result_set_[%s_row_num_]\n", cursor_name, cursor_name, cursor_name);
    bprintf(cg_main_output, "else\n");
    // this should really zero the cursor
    bprintf(cg_main_output, "  %s = { _has_row_ = false }\n", cursor_name);
    bprintf(cg_main_output, "end\n");
  }

  // if there is a row, then we need to read the row into the variables
  // there are two alternatives: reading into locals/args or reading into
  // auto-generated cursor variables.  Either way we get each column.

  sem_struct *sptr = ast->left->sem->sptr;
  if (uses_out_union) {
  }
  else {
    bprintf(cg_main_output, "-- step and fetch\n");
    bprintf(cg_main_output, "_rc_ = cql_multifetch(%s_stmt, %s, %s_types_, %s_fields_",
      cursor_name, cursor_name, cursor_name, cursor_name);
    bprintf(cg_main_output, ")\n");
    cg_lua_error_on_expr("_rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE");
  }

  // the fetch INTO case reads out the fields from cursor which was fetched as usual
  if (name_list) {
    int32_t i = 0; // column get is zero based

    for (ast_node *item = name_list; item; item = item->right, i++) {
      EXTRACT_NAME_AST(name_ast, item->left);
      EXTRACT_STRING(var, name_ast);
      bprintf(cg_main_output, "%s = %s.", var, cursor_name);
      if (strcmp(sptr->names[i], "_anon")) {
        bprintf(cg_main_output, "%s", sptr->names[i]);
      }
      else {
        bprintf(cg_main_output, "_anon%d", i);
      }
      bprintf(cg_main_output, "\n");
    }
  }
}

static void cg_lua_fetch_call_stmt(ast_node *ast) {
  Contract(is_ast_fetch_call_stmt(ast));
  EXTRACT_STRING(cursor_name, ast->left);
  EXTRACT_ANY_NOTNULL(call_stmt, ast->right);

  cg_lua_call_stmt_with_cursor(call_stmt, cursor_name);
}

// The update cursor statement differs from the more general fetch form in that
// it is only to be used to tweak fields in an already loaded cursor.  The sematics
// are that if you try to "update" a cursor with no row the update is ignored.
// The purpose of this is to let you edit one or two fields of a row as you fetch them
// before using OUT or OUT UNION or INSERT ... FROM CURSOR.  You want to do this
// without having to restate all the columns, which besides being verbose makes it hard
// for people to see what things you are changing and what you are not.
static void cg_lua_update_cursor_stmt(ast_node *ast) {
  Contract(is_ast_update_cursor_stmt(ast));
  EXTRACT_ANY(cursor, ast->left);
  EXTRACT_STRING(name, cursor);
  EXTRACT_NOTNULL(columns_values, ast->right);
  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT_ANY_NOTNULL(name_list, column_spec->left);
  EXTRACT_ANY_NOTNULL(insert_list, columns_values->right);

  bprintf(cg_main_output, "if %s._has_row_ then\n", name);

  CG_PUSH_MAIN_INDENT2(stores);

  ast_node *col = name_list;
  ast_node *val = insert_list;

  for ( ; col && val; col = col->right, val = val->right) {
    ast_node *expr = val->left;
    ast_node *name_ast = col->left;

    CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);
    CHARBUF_OPEN(temp);
    bprintf(&temp, "%s.%s", name, name_ast->sem->name);
    cg_lua_store(cg_main_output, temp.ptr, name_ast->sem->sem_type, expr->sem->sem_type, expr_value.ptr);
    CHARBUF_CLOSE(temp);
    CG_LUA_POP_EVAL(expr);
  }

  CG_POP_MAIN_INDENT(stores);

  bprintf(cg_main_output, "end\n");
}

// Here we just emit the various values for an IF expression that is part of
// a SWITCH/WHEN clause
//  * the correct indent level is already set up
//  * we know evaluation will work because the semantic pass already checked it
//  * formatting numbers never fails, we use LUA number format
static void cg_lua_switch_expr_list(ast_node *ast, sem_t sem_type_switch_expr, CSTR val) {
  Contract(is_ast_expr_list(ast));

  bprintf(cg_main_output, "if ");

  while (ast) {
    Contract(is_ast_expr_list(ast));
    EXTRACT_ANY_NOTNULL(expr, ast->left);

    eval_node result = EVAL_NIL;
    eval(expr, &result);
    Invariant(result.sem_type != SEM_TYPE_ERROR); // already checked

    bprintf(cg_main_output, "%s == ", val);

    eval_format_number(&result, EVAL_FORMAT_FOR_LUA, cg_main_output);

    if (ast->right) {
      bprintf(cg_main_output, " or ");
    }

    ast = ast->right;
  }
  bprintf(cg_main_output, " then\n");
}

// Switch actually generates pretty easily because of the constraints that were
// placed on the various expressions.  We know that the case lables are all
// integers and we know that the expression type of the switch expression is
// a not null integer type so we can easily generate the switch form.  Anything
// that could go wrong has already been checked.  In LUA there is no switch
// statement so we just generate a series of IF statements and an ELSE case.
// We put all that into a repeat .. until true loop so that we can use "break"
// to get out of the loop.
static void cg_lua_switch_stmt(ast_node *ast) {
  Contract(is_ast_switch_stmt(ast));
  EXTRACT_NOTNULL(switch_body, ast->right);
  EXTRACT_ANY_NOTNULL(expr, switch_body->left);
  EXTRACT_NOTNULL(switch_case, switch_body->right);

  // SWITCH [expr] [switch_body] END
  // SWITCH [expr] ALL VALUES [switch_body] END

  sem_t sem_type_expr = expr->sem->sem_type;

  CG_LUA_PUSH_TEMP(val, sem_type_expr);
  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);
  cg_lua_copy(cg_main_output, val.ptr, sem_type_expr, expr_value.ptr);
  CG_LUA_POP_EVAL(expr);

  bprintf(cg_main_output, "repeat\n");

  CG_PUSH_MAIN_INDENT2(cases);

  bool_t first_case = true;

  bool_t has_default = false;
  for (ast_node *temp = switch_case; temp; temp = temp->right) {
    EXTRACT_NOTNULL(connector, temp->left);
    if (!connector->left) {
      has_default = true;
    }
  }

  while (switch_case) {
    EXTRACT_NOTNULL(connector, switch_case->left);
    EXTRACT(stmt_list, connector->right);

    // no stmt list corresponds to WHEN ... THEN NOTHING
    // we can skip the entire case set unless there is a default
    // in which case we have to emit it with just break...
    if (stmt_list || has_default) {
      if (!first_case) {
        bprintf(cg_main_output, "\n");  // break between statement lists
      }
      first_case = false;

      // no expr list corresponds to the else case
      if (connector->left) {
        EXTRACT_NOTNULL(expr_list, connector->left);
        cg_lua_switch_expr_list(expr_list, expr->sem->sem_type, val.ptr);
      }
      else {
        bprintf(cg_main_output, "-- default\n");
      }

      if (stmt_list) {
        cg_lua_stmt_list(stmt_list);
      }

      if (connector->left) {
        bprintf(cg_main_output, "  break\n");
        bprintf(cg_main_output, "end\n");
      }
    }
    switch_case = switch_case->right;
  }

  CG_POP_MAIN_INDENT(cases);
  bprintf(cg_main_output, "until true\n");

  CG_LUA_POP_TEMP(val);
}

// "While" suffers from the same problem as IF and as a consequence
// generating while (expression) would not generalize.
// The overall pattern for while has to look like this:
//
//  while true
//  do
//    prep statements;
//    condition = final expression;
//    if  not(condition) then break end
//
//    statements;
//    ::continue_label%d::
//  end
//
// Note that while can have leave and continue substatements which have to map
// to break and goto ::continue::.   That means other top level statements that aren't loops
// must not create a C loop construct or break/continue would have the wrong target.
static void cg_lua_while_stmt(ast_node *ast) {
  Contract(is_ast_while_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(stmt_list, ast->right);
  sem_t sem_type = expr->sem->sem_type;

  bool_t lua_continue_label_needed_saved = lua_continue_label_needed;
  int32_t lua_continue_label_number_saved = lua_continue_label_number;
  lua_continue_label_needed = false;
  lua_continue_label_next++;
  lua_continue_label_number = lua_continue_label_next;

  // WHILE [expr] BEGIN [stmt_list] END

  bprintf(cg_main_output, "while true\n");
  bprintf(cg_main_output, "do\n");

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  // note that not(nil) is true in lua because nil is falsey
  // so we correctly break out of the while if the expression's value is nil
  cg_lua_to_bool(sem_type, &expr_value);
  CG_PUSH_MAIN_INDENT2(loop);
  bprintf(cg_main_output, "if not(%s) then break end\n", expr_value.ptr);
  CG_POP_MAIN_INDENT(loop);

  bool_t loop_saved = lua_in_loop;
  lua_in_loop = true;

  CG_LUA_POP_EVAL(expr);

  cg_lua_stmt_list(stmt_list);

  if (lua_continue_label_needed) {
    bprintf(cg_main_output, "::continue%d::\n", lua_continue_label_number);
  }

  bprintf(cg_main_output, "end\n");

  lua_in_loop = loop_saved;
  lua_continue_label_needed = lua_continue_label_needed_saved;
  lua_continue_label_number = lua_continue_label_number_saved;
}

// "For" suffers from the same problem as IF and as a consequence
// generating while (expression) would not generalize.
// The overall pattern for while has to look like this:
//
//  while true
//  do
//    prep statements;
//    condition = final expression;
//    if  not(condition) then break end
//
//    statements;
//    ::continue_label%d::
//  end
//
// Note that while can have leave and continue substatements which have to map
// to break and goto ::continue::.   That means other top level statements that aren't loops
// must not create a C loop construct or break/continue would have the wrong target.
static void cg_lua_for_stmt(ast_node *ast) {
  Contract(is_ast_for_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(for_info, ast->right);
  sem_t sem_type = expr->sem->sem_type;

  bool_t lua_continue_label_needed_saved = lua_continue_label_needed;
  int32_t lua_continue_label_number_saved = lua_continue_label_number;
  lua_continue_label_needed = false;
  lua_continue_label_next++;
  lua_continue_label_number = lua_continue_label_next;

  // FOR expr; stmt_list; BEGIN [stmt_list] END

  bprintf(cg_main_output, "while true\n");
  bprintf(cg_main_output, "do\n");

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ROOT);

  // note that not(nil) is true in lua because nil is falsey
  // so we correctly break out of the while if the expression's value is nil
  cg_lua_to_bool(sem_type, &expr_value);
  CG_PUSH_MAIN_INDENT2(loop);
  bprintf(cg_main_output, "if not(%s) then break end\n", expr_value.ptr);
  CG_POP_MAIN_INDENT(loop);

  bool_t loop_saved = lua_in_loop;
  lua_in_loop = true;

  CG_LUA_POP_EVAL(expr);

  if (for_info->right) {
    cg_lua_stmt_list(for_info->right);
  }

  if (lua_continue_label_needed) {
    bprintf(cg_main_output, "::continue%d::\n", lua_continue_label_number);
  }

  cg_lua_stmt_list(for_info->left);

  bprintf(cg_main_output, "end\n");

  lua_in_loop = loop_saved;
  lua_continue_label_needed = lua_continue_label_needed_saved;
  lua_continue_label_number = lua_continue_label_number_saved;
}

// The general pattern for this is very simple:
//   while true
//   do
//     do the fetch
//     if no rows then break end
//     do your loop
//   end
// It has to be this because the fetch might require many statements.
// There are helpers for all of this so it's super simple.
static void cg_lua_loop_stmt(ast_node *ast) {
  Contract(is_ast_loop_stmt(ast));
  EXTRACT_NOTNULL(fetch_stmt, ast->left);
  EXTRACT(stmt_list, ast->right);
  EXTRACT_ANY_NOTNULL(cursor_ast, fetch_stmt->left);

  // get the canonical name of the cursor (the name in the tree might be case-sensitively different)
  CSTR cursor_name = cursor_ast->sem->name;

  // LOOP [fetch_stmt] BEGIN [stmt_list] END

  bprintf(cg_main_output, "while true\ndo\n");
  CG_PUSH_MAIN_INDENT2(loop);

  cg_lua_fetch_stmt(fetch_stmt);

  bprintf(cg_main_output, "if not %s._has_row_ then break end\n", cursor_name);

  bool_t loop_saved = lua_in_loop;
  lua_in_loop = true;

  bool_t lua_continue_label_needed_saved = lua_continue_label_needed;
  int32_t lua_continue_label_number_saved = lua_continue_label_number;
  lua_continue_label_needed = false;
  lua_continue_label_next++;
  lua_continue_label_number = lua_continue_label_next;

  CG_POP_MAIN_INDENT(loop);

  cg_lua_stmt_list(stmt_list);

  if (lua_continue_label_needed) {
    bprintf(cg_main_output, "::continue%d::\n", lua_continue_label_number);
  }

  bprintf(cg_main_output, "end\n");

  lua_in_loop = loop_saved;
  lua_continue_label_needed = lua_continue_label_needed_saved;
  lua_continue_label_number = lua_continue_label_number_saved;
}

// Only SQL loops are allowed to use C loops, so "continue" is perfect
static void cg_lua_continue_stmt(ast_node *ast) {
  Contract(is_ast_continue_stmt(ast));

  // CONTINUE
  bprintf(cg_main_output, "goto continue%d\n", lua_continue_label_number);
  lua_continue_label_needed = true;
}

// Only SQL loops are allowed to use C loops, so "break" is perfect
static void cg_lua_leave_stmt(ast_node *ast) {
  Contract(is_ast_leave_stmt(ast));

  // LEAVE
  bprintf(cg_main_output, "break\n");
}

// We go to the main cleanup label and exit the current procedure
static void cg_lua_return_stmt(ast_node *ast) {
  Contract(is_ast_return_stmt(ast) || is_ast_rollback_return_stmt(ast) || is_ast_commit_return_stmt(ast));

  // RETURN
  bool_t dml_proc = is_dml_proc(current_proc->sem->sem_type);
  if (dml_proc) {
    bprintf(cg_main_output, "_rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error\n");
  }
  bprintf(cg_main_output, "goto %s -- return\n", CQL_CLEANUP_DEFAULT_LABEL);
  lua_return_used = true;
}

// Rollback the current procedure savepoint, then perform a return.
// Note that to rollback a savepoint you have to do the rollback AND the release
// and then you're unwound to the savepoint state.  The transaction in flight is
// still in flight if there is one.
static void cg_lua_rollback_return_stmt(ast_node *ast) {
  Contract(is_ast_rollback_return_stmt(ast));

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
  ast_node *rollback = new_ast_rollback_trans_stmt(new_ast_str(lua_current_proc_name()));
  ast_node *release = new_ast_release_savepoint_stmt(new_ast_str(lua_current_proc_name()));
  AST_REWRITE_INFO_RESET();

  cg_lua_bound_sql_statement(NULL, rollback, CG_EXEC);
  cg_lua_bound_sql_statement(NULL, release, CG_EXEC);
  cg_lua_return_stmt(ast);
}

// Commits the current procedure savepoint, then perform a return.
// Note savepoint semantics are just "release" is sort of like commit
// in that it doesn't rollback and becomes part of the current transaction
// which may or may not commit but that's what we mean by commit.
static void cg_lua_commit_return_stmt(ast_node *ast) {
  Contract(is_ast_commit_return_stmt(ast));

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
  ast_node *commit = new_ast_release_savepoint_stmt(new_ast_str(lua_current_proc_name()));
  AST_REWRITE_INFO_RESET();

  cg_lua_bound_sql_statement(NULL, commit, CG_EXEC);
  cg_lua_return_stmt(ast);
}

// Finalize the statement object associated with the cursor.
// Note this sets the cursor to null, so you can do it again.  Cleanup
// might also do this. That's fine.
static void cg_lua_close_stmt(ast_node *ast) {
  Contract(is_ast_close_stmt(ast));
  EXTRACT_ANY_NOTNULL(cursor_ast, ast->left);
  EXTRACT_STRING(name, cursor_ast);

  // CLOSE [name]

  sem_t sem_type = cursor_ast->sem->sem_type;

  if (!(sem_type & SEM_TYPE_VALUE_CURSOR)) {
    bprintf(cg_main_output, "cql_finalize_stmt(%s_stmt)\n", name);
    bprintf(cg_main_output, "%s_stmt = nil\n", name);
  }
  // this should really zero the cursor
  bprintf(cg_main_output, "%s = { _has_row_ = false }\n", name);
}

// The OUT statement copies the current value of a cursor into an implicit
// OUT structure variable (_result_).  The type of the variable is inferred
// from the cursor you return.  All OUT statements in any given proc must
// agree on the exact type (this has already been verified).  At this point
// all we have to do is copy the fields.
static void cg_lua_out_stmt(ast_node *ast) {
  Contract(is_ast_out_stmt(ast));

  // get the canonical name of the cursor (the name in the tree might be case-sensitively different)
  CSTR cursor_name = ast->left->sem->name;

  // OUT [cursor_name]

  bprintf(cg_main_output, "_result_ = cql_clone_row(%s)\n", cursor_name);
}

static void cg_lua_out_union_stmt(ast_node *ast) {
  Contract(is_ast_out_union_stmt(ast));

  // get the canonical name of the cursor (the name in the tree might be case-sensitively different)
  CSTR cursor_name = ast->left->sem->name;

  // OUT UNION [cursor_name]

  bprintf(cg_main_output, "if %s._has_row_ then\n", cursor_name);
  bprintf(cg_main_output, "  table.insert(_rows_, cql_clone_row(%s))\n", cursor_name);
  bprintf(cg_main_output, "end\n");
}

// emit the string literal into the otuput if the current runtime matches
static void cg_lua_echo_stmt(ast_node *ast) {
  Contract(is_ast_echo_stmt(ast));
  EXTRACT_STRING(rt_name, ast->left);
  EXTRACT_STRING(str, ast->right);

  // @ECHO [rt], [str]

  if (!StrCaseCmp(rt_name, options.rt)) {
    if (current_proc) {
      cg_decode_string_literal(str, cg_main_output);
    }
    else {
      cg_decode_string_literal(str, cg_declarations_output);
    }
  }
}

// This is the helper method to dispatch a call to an external function like "printf"
// given a name in the AST.  This is for when the user coded the call.
static void cg_lua_call_external(ast_node *ast) {
  Contract(is_ast_call_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY(arg_list, ast->right);

  cg_lua_call_named_external(name, arg_list);
}

// This is performs an external function call, normalizing strings and passing
// the current value of nullables.  It's all straight up value-calls.  This form
// is used when the name might not be in the AST, such as we need a call to
// a sqlite helper method with user provided args.  All we do here is emit
// the  name and then use the arg list helper.
// The arg list helper gives us prep/invocation/cleanup buffers which we must emit.
static void cg_lua_call_named_external(CSTR name, ast_node *arg_list) {
  CHARBUF_OPEN(invocation);

  // Note this function is called in an expression context such as
  // for the builtin "printf" SQL function it can also be called in the call
  // statement context such as "call printf();"  In the second case it's
  // top level and the stack doesn't matter as it will be reset but in the first
  // case we need to restore the temp stack after we are done with the args.
  int32_t lua_stack_level_saved = lua_stack_level;

  bprintf(&invocation, "%s(", name);
  cg_lua_emit_external_arglist(arg_list, &invocation);
  bprintf(&invocation, ")\n");

  bprintf(cg_main_output, "%s", invocation.ptr);

  lua_stack_level = lua_stack_level_saved;  // put the scratch stack back

  CHARBUF_CLOSE(invocation);
}

// This is the hard work of doing the call actually happens.  We have to:
//   * evaluate each argument in the arg list
//   * emit a standard call for the lot
//   * there are no out args, so any reference to an out arg means the local copy
//   * there is no return value (that's what native functions are for)
static void cg_lua_emit_external_arglist(ast_node *arg_list, charbuf *invocation) {
  for (ast_node *item = arg_list; item; item = item->right) {
    EXTRACT_ANY(arg, item->left);

    CG_LUA_PUSH_EVAL(arg, LUA_EXPR_PRI_ROOT);
    bprintf(invocation, "%s", arg_value.ptr);
    CG_LUA_POP_EVAL(arg);

    if (item->right) {
      bprintf(invocation, ", ");
    }
  }
}

// When performing a call there are several things we might need to do to the arguments
// in order to get the correct calling convention.
//  * strings are already references, they go as is.
//  * not-nullables can go as is, unless
//  * if the paramater is not nullable and the argument is compatible but not an exact match,
//    then we box the argument into a temporary not nullable and pass that through
//  * finally, both the paramater and the argument was not nullable then we have to recover
//    the variable name from the evaluated value.
static void cg_lua_emit_one_arg(ast_node *arg, sem_t sem_type_param, sem_t sem_type_arg, charbuf *invocation, charbuf *returns) {
  CG_LUA_PUSH_EVAL(arg, LUA_EXPR_PRI_ROOT);

  if (is_out_parameter(sem_type_param)) {
    if (returns->used > 1) {
      bprintf(returns, ", ");
    }
    bprintf(returns, "%s", arg->sem->name);
  }

  if (is_in_parameter(sem_type_param)) {
    // either way arg_value is now correct
    if (invocation->used > 1) {
      bprintf(invocation, ", ");
    }

    if (is_cursor_formal(sem_type_param)) {
      // cursor formal expands to three actual arguments
      bprintf(invocation, "%s, %s_types_, %s_fields_", arg->sem->name, arg->sem->name, arg->sem->name);
    }
    else if (is_bool(sem_type_param) && !is_bool(sem_type_arg)) {
       cg_lua_emit_to_bool(invocation, arg_value.ptr);
    }
    else if (!is_bool(sem_type_param) && is_bool(sem_type_arg)) {
       cg_lua_emit_to_num(invocation, arg_value.ptr);
    }
    else {
      bprintf(invocation, "%s", arg_value.ptr);
    }
  }

  CG_LUA_POP_EVAL(arg);
}

// This generates the invocation for a user defined external function.
// Basically we do a simple invoke with the matching argument types which are known exactly
// we do the usual argument conversions using cg_lua_emit_one_arg just like when calling procedures
// however we capture the return type in a temporary variable created exactly for this purpose.
// This code is also used in the proc as func path hence the dml stuff
static void cg_lua_user_func(ast_node *ast, charbuf *value) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  ast_node *params = NULL;
  ast_node *func_stmt = find_func(name);
  if (!func_stmt) func_stmt = find_unchecked_func(name);
  CSTR func_name = NULL;

  bool_t proc_as_func = false;
  bool_t dml_proc = false;
  bool_t result_set_return = false;
  bool_t unchecked_func = is_ast_declare_func_no_check_stmt(func_stmt);

  if (func_stmt) {
    EXTRACT_STRING(fname, func_stmt->left);
    params = get_func_params(func_stmt);
    func_name = fname;
  }
  else {
    // has to be one of these two, already validated
    ast_node *proc_stmt = find_proc(name);
    Invariant(proc_stmt);
    params = get_proc_params(proc_stmt);
    ast_node *proc_name_ast = get_proc_name(proc_stmt);
    EXTRACT_STRING(pname, proc_name_ast);
    func_name = pname;
    proc_as_func = true;
    dml_proc = is_dml_proc(proc_stmt->sem->sem_type);

    result_set_return = has_out_stmt_result(proc_stmt) || has_result_set(proc_stmt) || has_out_union_stmt_result(proc_stmt);
  }

  sem_t sem_type_result = ast->sem->sem_type;

  // The answer will be stored in this scratch variable, any type is possible
  CG_LUA_SETUP_RESULT_VAR(ast, sem_type_result);
  CHARBUF_OPEN(args);
  CHARBUF_OPEN(returns);
  CG_CHARBUF_OPEN_SYM(func_sym, func_name, result_set_return ? "_fetch_results" : "");

  if (dml_proc) {
    // at least one arg for the out arg so add _db_ with comma
    bprintf(&args, "_db_");
    bprintf(&returns, "_rc_");
  }

  if (returns.used > 1) {
    bprintf(&returns, ", ");
  }
  bprintf(&returns, "%s", result_var.ptr);

  if (unchecked_func) {
    Invariant(!params); // no params for unchecked, so no out params
    cg_lua_emit_external_arglist(arg_list, &args);
  }
  else {
    for (ast_node *item = arg_list; item; item = item->right, params = params->right) {
      EXTRACT_ANY(arg, item->left);
      sem_t sem_type_arg = arg->sem->sem_type;

      EXTRACT_NOTNULL(param, params->left);
      sem_t sem_type_param = param->sem->sem_type;

      cg_lua_emit_one_arg(arg, sem_type_param, sem_type_arg, &args, &returns);
    }
  }

  // Now store the result of the call.
  // the only trick here is we have to make sure we honor create semantics
  // otherwise we can just copy the data since the variable is for sure
  // an exact match for the call return by construction.

  bprintf(cg_main_output, "%s = %s(%s)\n", returns.ptr, func_sym.ptr, args.ptr);

  if (proc_as_func && dml_proc) {
    // cascade the failure
    cg_lua_error_on_not_sqlite_ok();
  }

  CHARBUF_CLOSE(func_sym);
  CHARBUF_CLOSE(returns);
  CHARBUF_CLOSE(args);
  CG_LUA_CLEANUP_RESULT_VAR();  // this will restore the scratch stack for us
}

// Forward the call processing to the general helper (with cursor arg)
static void cg_lua_call_stmt(ast_node *ast) {
  // If the call has a result set it is stored in our result parameter
  // just like a loose select statement would be.  Note this can be
  // overridden by a later result which is totally ok.  Same as for select
  // statements.
  cg_lua_call_stmt_with_cursor(ast, NULL);
}

// emit the declarations for anything implicitly declared then do a normal call
static void cg_lua_declare_out_call_stmt(ast_node *ast) {
  Contract(is_ast_declare_out_call_stmt(ast));
  EXTRACT_NOTNULL(call_stmt, ast->left);
  EXTRACT(arg_list, call_stmt->right);

  for (; arg_list; arg_list = arg_list->right) {
    EXTRACT_ANY_NOTNULL(arg, arg_list->left);
    if (arg->sem->sem_type & SEM_TYPE_IMPLICIT) {
      EXTRACT_STRING(var_name, arg);
      cg_lua_declare_simple_var(arg->sem->sem_type, var_name);
    }
  }

  cg_lua_call_stmt(call_stmt);
}


// This helper method walks all the args and all the formal paramaters at the same time
// it gets the appropriate type info for each and then generates the expression
// for the evaluation of that argument.
static void cg_lua_emit_proc_params(charbuf *output, charbuf *results, ast_node *params, ast_node *args) {
  for (ast_node *item = args; item; item = item->right, params = params->right) {
    EXTRACT_ANY_NOTNULL(arg, item->left);
    sem_t sem_type_arg = arg->sem->sem_type;

    EXTRACT_NOTNULL(param, params->left);
    sem_t sem_type_param = param->sem->sem_type;

    // note this might require type conversion, handled here.
    cg_lua_emit_one_arg(arg, sem_type_param, sem_type_arg, output, results);
  }
}

// A call statement has several varieties:
//  * an external call to an unknown proc
//    * use the external call helper
//  * if the target is a dml proc
//    * add the _db_ argument, for sure we have it because if we call a DML proc
//      we are a DML proc so we, too, had such an arg.  Pass it along.
//    * capture the _rc_ return code and do the error processing.
//  * if the proc returns a relational result (see below) we use the given
//    cursor to capture it, or else we use the functions result argument
//    as indicated below
//
// There are a variety of call forms (we'll see the symmetric version of this
// in cg_lua_create_proc_stmt).  The first thing to consider is, does the procedure
// produce some kind of relational result, there are four ways it can do this:
//
//   1. It returns a statement (it used a loose SELECT)
//   2. It returns a single row (it used OUT)
//   3. It returns a result set (it used OUT UNION)
//   4. It returns no relational result, just out args maybe.
//
//  Now we have to consider this particular call, and the chief question is
//  are we capturing the relational result in a cursor? If we are then referring
//  to the above:
//
//   1a. The cursor will be a statement cursor, holding the SQLite statement
//   2a. The cursor will hold the row, it is a value cursor (you can't step it)
//   3a. The cursor will hold a pointer to the result set which can be indexed
//   4a. A cursor cannot be used if there is no relational result.
//
//  Note that the error case above has already been detected in semantic analysis
//  so we would not be here if it happened.  This is true of the other error cases
//  as well.  If we're doing code-gen we know we're good.
//
//  If the result is not captured in a cursor then we have the following outcomes
//
//  1b. The current procedure returns statement as a relational result
//      (just as though it had done the select)
//  2b. This is not allowed, the row must be captured by a cursor (error).
//  3b. The current procedure returns the result set (just as though it had done
//      the OUT UNION)
//  4b. This is a "normal" function call with just normal arguments
//
// Compounding the above, the procedure might use the database or not.  If it uses
// the database (dml_proc) we have to add that argument and we expect a success code.
// If it doesn't use the database it can still return a relational result with
// OUT or OUT UNION.  It can't have done a SELECT (no database) or could it have
// called a procedure that did a SELECT (again, no database).  So the statement
// cursor case is eliminated. This creates a fairly complex matrix but most of the
// logic is highly similar.
//
// In call cases we can use the arg helper method to emit each arg.  There are
// several rules for each kind of arg, described above in cg_lua_emit_one_arg.
static void cg_lua_call_stmt_with_cursor(ast_node *ast, CSTR cursor_name) {
  Contract(is_ast_call_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY(expr_list, ast->right);

  // check for call to unknown proc, use canonical calling convention for those
  ast_node *proc_stmt = find_proc(name);
  if (!proc_stmt) {
    cg_lua_call_external(ast);
    return;
  }

  ast_node *proc_name_ast = get_proc_name(proc_stmt);
  EXTRACT_STRING(proc_name, proc_name_ast);

  ast_node *params = get_proc_params(proc_stmt);
  bool_t dml_proc = is_dml_proc(proc_stmt->sem->sem_type);
  bool_t result_set_proc = has_result_set(ast);
  bool_t out_stmt_proc = has_out_stmt_result(ast);
  bool_t out_union_proc = has_out_union_stmt_result(ast);

  CSTR fetch_results = out_union_proc ? "_fetch_results" : "";

  CG_CHARBUF_OPEN_SYM(proc_sym, proc_name, fetch_results);
  CG_CHARBUF_OPEN_SYM(result_type, proc_name, "_row");
  CG_CHARBUF_OPEN_SYM(result_sym, proc_name, "_row", "_data");
  CG_CHARBUF_OPEN_SYM(result_set_ref, name, "_result_set_ref");
  CHARBUF_OPEN(args);
  CHARBUF_OPEN(returns);

  if (dml_proc) {
    bprintf(&returns, "_rc_");
    bprintf(&args, "_db_");
  }

  if (out_union_proc && !cursor_name) {
    // This is case 3b above.  The tricky bit here is that there might
    // be more than one such call.  The callee is not going to release
    // the out arg as it might be junk from the callee's perspective so
    // we have to release it in case this call is in a loop or if this
    // call is repeated in some other way
    if (returns.used > 1) {
      bprintf(&returns, ", ");
    }
    bprintf(&returns, "_result_set_");
  }
  else if (out_union_proc) {
    // this is case 3a above.
    Invariant(cursor_name); // either specified or the default _result_ variable
    if (returns.used > 1) {
      bprintf(&returns, ", ");
    }
    bprintf(&returns, "%s_result_set_", cursor_name);
  }
  else if (result_set_proc && !cursor_name) {
    // This is case 1b above, prop the result as our output.  As with case
    // 3b above we have to pre-release _result_stmt_ because of repetition.
    bprintf(cg_main_output, "cql_finalize_stmt(_result_stmt)\n");
    bprintf(cg_main_output, "_result_stmt = nil\n");
    if (returns.used > 1) {
      bprintf(&returns, ", ");
    }
    bprintf(&returns, "_result_stmt");
  }
  else if (result_set_proc) {
    // this is case 1a above
    Invariant(cursor_name); // either specified or the default _result_ variable
    if (returns.used > 1) {
      bprintf(&returns, ", ");
    }
    bprintf(&returns, "%s_stmt", cursor_name);
  }
  else if (out_stmt_proc) {
    Invariant(cursor_name);
    if (returns.used > 1) {
      bprintf(&returns, ", ");
    }
    bprintf(&returns, "%s", cursor_name);
  }

  // we don't need to manage the stack, we're always called at the top level
  // we're wiping it when we exit this function anyway
  Invariant(lua_stack_level == 0);

  // emit provided args, the param specs are needed for possible type conversions
  cg_lua_emit_proc_params(&args, &returns, params, expr_list);

  // For a fetch results proc we have to add the out argument here.

  if (returns.used > 1) {
    bprintf(cg_main_output, "%s = ", returns.ptr);
  }
  bprintf(cg_main_output, "%s(%s)\n", proc_sym.ptr, args.ptr);

  if (dml_proc) {
    // if there is an error code, check it, and cascade the failure
    cg_lua_error_on_not_sqlite_ok();
  }

  if (out_union_proc && cursor_name) {
    // note lua indexes are 1 based
    // case 3a, capturing the cursor, we set the row index to 0 (it will be pre-incremented)
    bprintf(cg_main_output, "%s_row_num_ = 0\n", cursor_name);
    bprintf(cg_main_output, "%s_row_count_ = #(%s_result_set_)\n", cursor_name, cursor_name);
  }

  CHARBUF_CLOSE(returns);
  CHARBUF_CLOSE(args);
  CHARBUF_CLOSE(result_set_ref);
  CHARBUF_CLOSE(result_sym);
  CHARBUF_CLOSE(result_type);
  CHARBUF_CLOSE(proc_sym);
}

// Straight up DDL invocation.  The ast has the statement, execute it!
// We don't minify the aliases because DDL can have views and the view column names
// can be referred to in users of the view.  Loose select statements can have
// no external references to column aliases.
static void cg_lua_any_ddl_stmt(ast_node *ast) {
  cg_lua_bound_sql_statement(NULL, ast, CG_EXEC|CG_NO_MINIFY_ALIASES);
}

// Straight up DML invocation.  The ast has the statement, execute it!
static void cg_lua_std_dml_exec_stmt(ast_node *ast) {
  cg_lua_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);
}

// DML with PREPARE.  The ast has the statement.
// Note: _result_ is the output variable for the sqlite3_stmt we generate
//       this was previously added when the stored proc params were generated.
static void cg_lua_std_dml_prep_stmt(ast_node *ast) {
  Contract(is_row_source(ast));
  cg_lua_bound_sql_statement("_result", ast, CG_PREPARE|CG_MINIFY_ALIASES);
}

static void cg_lua_insert_dummy_spec(ast_node *ast) {
  EXTRACT_ANY_NOTNULL(expr, ast->left); // the seed expr

  CSTR name = "_seed_";

  sem_t sem_type_var = SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL;
  sem_t sem_type_expr = expr->sem->sem_type;

  if (!lua_seed_declared) {
    cg_lua_var_decl(cg_declarations_output, sem_type_var, name);
    lua_seed_declared = true;
  }

  CG_LUA_PUSH_EVAL(expr, LUA_EXPR_PRI_ASSIGN);
  cg_lua_store(cg_main_output, name, sem_type_var, sem_type_expr, expr_value.ptr);
  CG_LUA_POP_EVAL(expr);
}

static void cg_lua_opt_seed_process(ast_node *ast) {
  Contract(is_ast_insert_stmt(ast));
  EXTRACT_ANY_NOTNULL(insert_type, ast->left);
  EXTRACT_ANY(insert_dummy_spec, insert_type->left);

  if (insert_dummy_spec) {
    cg_lua_insert_dummy_spec(insert_dummy_spec);
  }
}

// DML invocation but first set the seed variable if present
static void cg_lua_insert_stmt(ast_node *ast) {
  Contract(is_ast_insert_stmt(ast));

  cg_lua_opt_seed_process(ast);
  cg_lua_bound_sql_statement(NULL, ast, CG_EXEC | CG_NO_MINIFY_ALIASES);
}

// DML invocation but first set the seed variable if present
static void cg_lua_with_insert_stmt(ast_node *ast) {
  Contract(is_ast_with_insert_stmt(ast));
  EXTRACT_NOTNULL(insert_stmt, ast->right);
  cg_lua_opt_seed_process(insert_stmt);
  cg_lua_bound_sql_statement(NULL, ast, CG_EXEC | CG_NO_MINIFY_ALIASES);
}

// DML invocation but first set the seed variable if present
static void cg_lua_insert_returning_stmt(ast_node *ast) {
  Contract(is_ast_insert_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(inner, ast->left);
  inner = is_ast_with_insert_stmt(inner) ? inner->right : inner;
  Contract(is_ast_insert_stmt(inner));
  cg_lua_opt_seed_process(inner);
  cg_lua_bound_sql_statement("_result", ast, CG_PREPARE|CG_NO_MINIFY_ALIASES);
}

// DML invocation but first set the seed variable if present
static void cg_lua_with_upsert_stmt(ast_node *ast) {
  Contract(is_ast_with_upsert_stmt(ast));
  EXTRACT_NOTNULL(upsert_stmt, ast->right);
  EXTRACT_NOTNULL(insert_stmt, upsert_stmt->left);
  cg_lua_opt_seed_process(insert_stmt);
  cg_lua_bound_sql_statement(NULL, ast, CG_EXEC | CG_NO_MINIFY_ALIASES);
}

// DML invocation but first set the seed variable if present
static void cg_lua_upsert_stmt(ast_node *ast) {
  Contract(is_ast_upsert_stmt(ast));
  EXTRACT_NOTNULL(insert_stmt, ast->left);

  cg_lua_opt_seed_process(insert_stmt);
  cg_lua_bound_sql_statement(NULL, ast, CG_EXEC | CG_NO_MINIFY_ALIASES);
}

// Very little magic is needed to do try/catch in our context.  The error
// handlers for all the sqlite calls check _rc_ and if it's an error they
// "goto" the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.
// Inside the try block, the cleanup handler is changed to the catch block.
// The catch block puts it back.  Otherwise, generate nested statements as usual.
static void cg_lua_trycatch_helper(ast_node *try_list, ast_node *try_extras, ast_node *catch_list) {
  CHARBUF_OPEN(catch_start);
  CHARBUF_OPEN(catch_end);

  // We need unique labels for this block
  ++lua_catch_block_count;
  bprintf(&catch_start, "catch_start_%d", lua_catch_block_count);
  bprintf(&catch_end, "catch_end_%d", lua_catch_block_count);

  // Divert the error target.
  CSTR saved_lua_error_target = lua_error_target;
  bool_t saved_lua_error_target_used = lua_error_target_used;
  lua_error_target = catch_start.ptr;
  lua_error_target_used = false;

  // Emit the try code.
  bprintf(cg_main_output, "-- try\n\n");

  cg_lua_stmt_list(try_list);

  if (try_extras) {
    cg_lua_stmt_list(try_extras);
  }

  // If we get to the end, skip the catch block.
  bprintf(cg_main_output, "  goto %s\n\n", catch_end.ptr);

  // Emit the catch code, with labels at the start and the end.
  if (lua_error_target_used) {
    bprintf(cg_main_output, "::%s:: ", catch_start.ptr);
  }

  // Restore the error target, the catch block runs with the old error target
  lua_error_target = saved_lua_error_target;
  lua_error_target_used = saved_lua_error_target_used;
  CSTR lua_rcthrown_saved = lua_rcthrown_current;

  bprintf(cg_main_output, "\n");
  bprintf(cg_main_output, "do\n");

  CHARBUF_OPEN(rcthrown);

  bprintf(&rcthrown, "_rc_thrown_%d", ++lua_rcthrown_index);
  lua_rcthrown_current = rcthrown.ptr;
  bool_t lua_rcthrown_used_saved = lua_rcthrown_used;
  lua_rcthrown_used = false;

  CHARBUF_OPEN(catch_block);
    charbuf *main_saved = cg_main_output;
    cg_main_output = &catch_block;

    cg_lua_stmt_list(catch_list);

    cg_main_output = main_saved;

    if (lua_rcthrown_used) {
      bprintf(cg_main_output, "  local %s = _rc_\n", rcthrown.ptr);
    }

    bprintf(cg_main_output, "%s", catch_block.ptr);

  CHARBUF_CLOSE(catch_block);

  lua_rcthrown_current = lua_rcthrown_saved;
  lua_rcthrown_used = lua_rcthrown_used_saved;
  bprintf(cg_main_output, "end\n");

  bprintf(cg_main_output, "\n::%s::\n", catch_end.ptr);

  CHARBUF_CLOSE(rcthrown);
  CHARBUF_CLOSE(catch_end);
  CHARBUF_CLOSE(catch_start);
}

// the helper does all the work, see those notes
static void cg_lua_trycatch_stmt(ast_node *ast) {
  Contract(is_ast_trycatch_stmt(ast));
  EXTRACT_NAMED(try_list, stmt_list, ast->left);
  EXTRACT_NAMED(catch_list, stmt_list, ast->right);

  cg_lua_trycatch_helper(try_list, NULL, catch_list);
}

// this is just a special try/catch
static void cg_lua_proc_savepoint_stmt(ast_node *ast) {
  Contract(is_ast_proc_savepoint_stmt(ast));
  EXTRACT(stmt_list, ast->left);

  if (stmt_list) {
    AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
    ast_node *savepoint = new_ast_savepoint_stmt(new_ast_str(lua_current_proc_name()));
    ast_node *release1  = new_ast_release_savepoint_stmt(new_ast_str(lua_current_proc_name()));
    ast_node *release2  = new_ast_release_savepoint_stmt(new_ast_str(lua_current_proc_name()));
    ast_node *rollback  = new_ast_rollback_trans_stmt(new_ast_str(lua_current_proc_name()));
    ast_node *try_extra_stmts = new_ast_stmt_list(release1, NULL);
    ast_node *throw_stmt = new_ast_throw_stmt();
    ast_node *catch_stmts =
      new_ast_stmt_list(rollback,
      new_ast_stmt_list(release2,
      new_ast_stmt_list(throw_stmt, NULL)));
    AST_REWRITE_INFO_RESET();
    cg_lua_bound_sql_statement(NULL, savepoint, CG_EXEC);
    cg_lua_trycatch_helper(stmt_list, try_extra_stmts, catch_stmts);
  }
}

// Convert _rc_ into an error code.  If it already is one keep it.
// Then go to the current error target.
static void cg_lua_throw_stmt(ast_node *ast) {
  Contract(is_ast_throw_stmt(ast));

  bprintf(cg_main_output, "_rc_ = cql_best_error(%s)\n", lua_rcthrown_current);
  bprintf(cg_main_output, "cql_error_trace(_rc_, _db_)\n");
  bprintf(cg_main_output, "goto %s\n", lua_error_target);
  lua_error_target_used = true;
  lua_rcthrown_used = true;
}

// This is a special NO-OP we want to verify that it does nothing
// rather than ignore it in the tests.  We don't want it to blend
// with the next group so we explicity make a do nothing function
// just so that we get the test directives.
static void cg_lua_declare_group_stmt(ast_node *ast) {
  if (options.test) {
    bprintf(cg_main_output, "-- declare group emits no lua\n");
  }
}

// Emit group tells CQL to emit the variable definitions for the indicated groups into
// the current translation unit.  This should be done one time to avoid duplicate symbols
// at link time.  The indicated groups are enumerated and the definition form is emitted
// using the normal helpers.
static void cg_lua_emit_group_stmt(ast_node *ast) {
  Contract(is_ast_emit_group_stmt(ast));
  EXTRACT(name_list, ast->left);

  // Put a line marker in the header file in case we want a test suite that verifies that.
  // Note we have to do this only because this only generates declarations so the
  // normal logic for emitting these doesn't kick in.
  if (options.test) {
    bprintf(cg_declarations_output, "\n-- The statement ending at line %d\n", ast->lineno);
  }

  Contract(!lua_in_var_group_emit);
  lua_in_var_group_emit = true;
  while (name_list) {
    EXTRACT_NAME_AST(name_ast, name_list->left);
    EXTRACT_STRING(name, name_ast);

    ast_node *group = find_variable_group(name);
    Contract(is_ast_declare_group_stmt(group));

    EXTRACT_NAME_AST(group_name_ast, group->left);
    EXTRACT_STRING(group_name, group_name_ast);
    EXTRACT_NOTNULL(stmt_list, group->right);

    // In lua the normal output is all you need
    Invariant(!StrCaseCmp(name, group_name));
    cg_lua_stmt_list(stmt_list);

    name_list = name_list->right;
  }
  lua_in_var_group_emit = false;
}


static void cg_lua_emit_one_enum(ast_node *ast) {
  Contract(is_ast_declare_enum_stmt(ast));
  EXTRACT_NOTNULL(typed_name, ast->left);
  EXTRACT_NOTNULL(enum_values, ast->right);
  EXTRACT_ANY(name_ast, typed_name->left);
  EXTRACT_STRING(name, name_ast);

  bprintf(cg_main_output, "cql_emit_constants(\"enum\", \"%s\", {\n", name);

  while (enum_values) {
    EXTRACT_NOTNULL(enum_value, enum_values->left);
    EXTRACT_NAME_AST(enum_name_ast, enum_value->left);
    EXTRACT_STRING(enum_name, enum_name_ast);

    bprintf(cg_main_output, "  %s = ", enum_name);
    eval_format_number(enum_name_ast->sem->value, EVAL_FORMAT_FOR_LUA, cg_main_output);

    if (enum_values->right) {
      bputc(cg_main_output, ',');
    }

    bputc(cg_main_output, '\n');

    enum_values = enum_values->right;
  }

  bprintf(cg_main_output, "})\n");
}

// We emit the enums into the current file so that Lua code can
// use those values to call our procedures.  The generated code
// from CQL uses the evaluated constants so these symbols are
// for "others" to use.
static void cg_lua_emit_enums_stmt(ast_node *ast) {
  Contract(is_ast_emit_enums_stmt(ast));
  EXTRACT(name_list, ast->left);

  if (name_list) {
    // names specified: emit those
    while (name_list) {
      // names previously checked, we assert they are good here
      EXTRACT_STRING(name, name_list->left);
      EXTRACT_NOTNULL(declare_enum_stmt, find_enum(name));
      cg_lua_emit_one_enum(declare_enum_stmt);
      name_list = name_list->right;
    }
  }
  else {
    // none specified: emit all
    for (list_item *item = all_enums_list; item; item = item->next) {
      EXTRACT_NOTNULL(declare_enum_stmt, item->ast);
      cg_lua_emit_one_enum(declare_enum_stmt);
    }
  }
}

// This causes global constant declarations to go into the output file.
// Those constants are not even used in our codegen because the ast is
// rewritten to have the actual value rather than the name.  However this will
// make it possible to use the constant in callers from Lua.  The constant values are
// "public" in this sense.  This is a lot like the gen_sql code except it will be
// in Lua format.  Note that cql_emit_constants can be replaced to put the
// constants where they should be in your world

static void cg_lua_emit_one_const_group(ast_node *ast) {
  Contract(is_ast_declare_const_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(const_values, ast->right);
  EXTRACT_STRING(name, name_ast);

  bprintf(cg_main_output, "cql_emit_constants(\"const\", \"%s\", {\n", name);

  while (const_values) {
    EXTRACT_NOTNULL(const_value, const_values->left);
    EXTRACT_NAME_AST(const_name_ast, const_value->left);
    EXTRACT_STRING(const_name, const_name_ast);

    bprintf(cg_main_output, "  %s = ", const_name);

    if (is_numeric(const_value->sem->sem_type)) {
      eval_format_number(const_value->sem->value, EVAL_FORMAT_FOR_LUA, cg_main_output);
    }
    else {
      // we don't make a string object for string literals that are being emitted, just the lua literal
      CHARBUF_OPEN(quoted);

      EXTRACT_STRING(literal, const_value->right);
      cg_lua_requote_literal(literal, &quoted);
      bprintf(cg_main_output, "%s", quoted.ptr);

      CHARBUF_CLOSE(quoted);
    }

    if (const_values->right) {
      bputc(cg_main_output, ',');
    }

    bputc(cg_main_output, '\n');

    const_values = const_values->right;
  }

  bprintf(cg_main_output, "})\n");
}

// emit the declared constants into the output stream using cql_emit_constants
static void cg_lua_emit_constants_stmt(ast_node *ast) {
  Contract(is_ast_emit_constants_stmt(ast));
  EXTRACT_NOTNULL(name_list, ast->left);

  if (name_list) {
    // names specified: emit those
    while (name_list) {
      // names previously checked, we assert they are good here
      EXTRACT_STRING(name, name_list->left);
      EXTRACT_NOTNULL(declare_const_stmt, find_constant_group(name));
      cg_lua_emit_one_const_group(declare_const_stmt);
      name_list = name_list->right;
    }
  }
}

// Dispatch to one of the statement helpers using the symbol table.
// There are special rules for the DDL methods. If they appear in a
// global context (outside of any stored proc) they do not run, they
// are considered declarations only.
static void cg_lua_one_stmt(ast_node *stmt, ast_node *misc_attrs) {
  // we're going to compute the fragment name if needed but we always start clean

  // reset the temp stack
  lua_stack_level = 0;

  // There are special rules for some procedures, we avoid emiting them here
  // so that we don't generate the comments or anything for them.  Testing later
  // is more of a mess.

  if (is_ast_create_proc_stmt(stmt) && is_proc_shared_fragment(stmt)) {
    return;
  }

  symtab_entry *entry = symtab_find(cg_stmts, stmt->type);
  Contract(entry);

  if (!lua_in_proc) {
    // DDL operations not in a procedure are ignored
    // but they can declare schema during the semantic pass
    if (entry->val == cg_lua_any_ddl_stmt) {
       return;
    }

    // loose select statements also have no codegen, the global proc has no result type
    // TODO what to do about about loose insert returning...
    if (is_select_variant(stmt)) {
       return;
    }
  }

  CHARBUF_OPEN(tmp_header);
  CHARBUF_OPEN(tmp_declarations);
  CHARBUF_OPEN(tmp_main);
  CHARBUF_OPEN(tmp_scratch);

  charbuf *header_saved = cg_header_output;
  charbuf *declarations_saved = cg_declarations_output;
  charbuf *main_saved = cg_main_output;
  charbuf *scratch_saved = cg_scratch_vars_output;

  // Redirect all output to the temporary buffers so we can see how big it is
  // The comments need to go before this, so we save the output then check it
  // then emit the generated code.

  cg_main_output = &tmp_main;
  cg_declarations_output = &tmp_declarations;
  cg_header_output = &tmp_header;
  cg_scratch_vars_output = &tmp_scratch;

  // These are all the statements there are, we have to find it in this table
  // or else someone added a new statement and it isn't supported yet.
  Invariant(entry);
  ((void (*)(ast_node*))entry->val)(stmt);

  // safe to put it back now
  cg_main_output = main_saved;
  cg_header_output = header_saved;
  cg_declarations_output = declarations_saved;
  cg_scratch_vars_output = scratch_saved;

  // Emit a helpful comment for top level statements.
  if (stmt_nesting_level == 1) {
    charbuf *out = cg_main_output;
    if (is_ast_declare_vars_type(stmt) || is_proc(stmt) || is_ast_echo_stmt(stmt)) {
      out = cg_declarations_output;
    }

    bool_t skip_comment = false;

    // don't contaminate echo output with comments except in test, where we need it for verification
    skip_comment |= (!options.test && is_ast_echo_stmt(stmt));

    // If no code gen in the main buffer, don't add a comment, that will force a global proc
    // We used to have all kinds of special cases to detect the statements that don't generate code
    // and that was a bug farm.  So now instead we just look to see if it made code.  If it didn't make
    // code we will not force the global proc to exist because of the stupid comment...
    skip_comment |= (out == cg_main_output && tmp_main.used == 1);

    // put a line marker in the header file in case we want a test suite that verifies that
    if (options.test) {
      bprintf(cg_header_output, "\n-- The statement ending at line %d\n", stmt->lineno);
    }

    // emit comments for most statements: we do not want to require the global proc block
    // just because there was a comment so this is suppressed for "no code" things
    if (!skip_comment) {
      if (options.test) {
        if (!options.compress) {
          bprintf(out, "\n-- The statement ending at line %d\n", stmt->lineno);
        }
      }
      else {
        if (!options.compress) {
          bprintf(cg_declarations_output, "\n-- Generated from %s:%d\n", stmt->filename, stmt->lineno);
        }
      }
      if (!options.compress) {
        // emit source comment
        gen_sql_callbacks lua_escape = { .escape_attributes_for_lua = true };
        bprintf(out, "\n--[[\n");
        gen_stmt_level = 1;
        gen_set_output_buffer(out);
        if (misc_attrs) {
          gen_with_callbacks(misc_attrs, gen_misc_attrs, &lua_escape);
        }
        gen_with_callbacks(stmt, gen_one_stmt, &lua_escape);
        bprintf(out, ";\n--]]\n");
      }
    }
  }

  // and finally write what we saved
  bprintf(cg_main_output, "%s", tmp_main.ptr);
  bprintf(cg_header_output, "%s", tmp_header.ptr);
  bprintf(cg_scratch_vars_output, "%s", tmp_scratch.ptr);
  bprintf(cg_declarations_output, "%s", tmp_declarations.ptr);

  CHARBUF_CLOSE(tmp_scratch);
  CHARBUF_CLOSE(tmp_main);
  CHARBUF_CLOSE(tmp_declarations);
  CHARBUF_CLOSE(tmp_header);
}

// Emit the nested statements with one more level of indenting.
static void cg_lua_stmt_list(ast_node *head) {
  if (!head) {
    return;
  }

  stmt_nesting_level++;

  charbuf *saved_main = cg_main_output;
  CHARBUF_OPEN(temp);
  cg_main_output = &temp;

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);
    cg_lua_one_stmt(stmt, misc_attrs);
  }

  cg_main_output = saved_main;
  bindent(cg_main_output, &temp, 2);
  CHARBUF_CLOSE(temp);

  stmt_nesting_level--;
}

// All the data you need to make a getter or setter...
// there's a lot of it and most of it is the same for all cases
typedef struct lua_function_info {
  CSTR name;
  CSTR col;
  int32_t col_index;
  charbuf *defs;
  charbuf *headers;
  bool_t uses_out;
  sem_t ret_type;
  sem_t name_type;
  CSTR result_set_ref_type;
  CSTR row_struct_type;
  CSTR sym_suffix;
  CSTR value_suffix;
  uint32_t frag_type;
  bool_t is_private;
} lua_function_info;

// Write out the autodrop info into the stream.
static void cg_lua_one_autodrop(CSTR _Nonnull name, ast_node *_Nonnull misc_attr_value, void *_Nullable context) {
  Invariant(context);
  charbuf *output = (charbuf *)context;
  if (output->used > 1) {
    bprintf(output, ", ");
  }
  bprintf(output, "\"%s\"", name);
}

// If a stored proc is marked with the autodrop annotation when we automatically
// drop the indicated tables when the proc is finished running.  The attributes
// should look like this:
// [[autodrop=(table1, table2, ,...)]]
static void cg_lua_emit_autodrops(charbuf *output, ast_node *misc_attrs) {
  if (misc_attrs) {
    CHARBUF_OPEN(temp);
      find_autodrops(misc_attrs, cg_lua_one_autodrop, &temp);
      if (temp.used > 1) {
        bprintf(output, "  cql_autodrop(_db_, {%s})\n", temp.ptr);
      }
    CHARBUF_CLOSE(temp);
  }
}

// If a stored procedure generates a result set then we need to do some extra work
// to create the C friendly rowset creating and accessing helpers.  If stored
// proc "foo" creates a row set then we need to:
//  * emit a struct "foo_row" that has the shape of each row
//    * this isn't used by the client code but we use it in our code-gen
//  * emit a function "foo_fetch_results" that will call "foo" and read the rows
//    from the statement created by "foo".
//    * this method will construct a result set object via cql_result_create and store the data
//    * the remaining functions use cql_result_set_get_data and _get_count to get the data back out
//  * for each named column emit a function "foo_get_[column-name]" which
//    gets that column out of the rowset for the indicated row number.
//  * prototypes for the above go into the main output header file
static void cg_lua_proc_result_set(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  Contract(is_struct(ast->sem->sem_type));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT_STRING(name, ast->left);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  bool_t suppress_result_set = is_proc_suppress_result_set(ast);
  bool_t is_private = is_proc_private(ast);

  bool_t uses_out_union = has_out_union_stmt_result(ast);

  if (!uses_out_union && (suppress_result_set || is_private)) {
    return;
  }

  bool_t uses_out = has_out_stmt_result(ast);
  bool_t result_set_proc = has_result_set(ast);

  // exactly one of these
  Invariant(uses_out + uses_out_union + result_set_proc == 1);

  bool_t dml_proc = is_dml_proc(ast->sem->sem_type);

  // register the proc name if there is a callback, the particular result type will do whatever it wants
  if (rt->register_proc_name) rt->register_proc_name(name);

  charbuf *d = cg_declarations_output;
  charbuf *main_saved = cg_main_output;
  cg_main_output = d;

  CHARBUF_OPEN(data_types);
  CHARBUF_OPEN(result_set_create);
  CHARBUF_OPEN(temp);
  CG_CHARBUF_OPEN_SYM(getter_prefix, name);
  CG_CHARBUF_OPEN_SYM(proc_sym, name);
  CG_CHARBUF_OPEN_SYM(row_sym, name, "_row");
  CG_CHARBUF_OPEN_SYM(result_count_sym, name, "_result_count");
  CG_CHARBUF_OPEN_SYM(fetch_results_sym, name, "_fetch_results");


  // Emit foo_result_count, which is really just a proxy to cql_result_set_get_count,
  // but it is hiding the cql_result_set implementation detail from the API of the generated
  // code by providing a proc-scoped function for it with the typedef for the result set.

  // Generate fetch result function
  if (uses_out) {
    // Emit foo_fetch_results, it has the same signature as foo only with a result set
    // instead of a statement.

    bprintf(d, "\n");
    cg_lua_emit_fetch_results_prototype(dml_proc, params, name, d);

    bprintf(d, "  local result_set = nil\n");

    CHARBUF_OPEN(args);
    CHARBUF_OPEN(returns);

    // optional db arg and return code
    if (dml_proc) {
      bprintf(d, "  local _rc_\n");
      bprintf(&args, "_db_");
      bprintf(&returns, "_rc_, _result_");
    }
    else {
      bprintf(&returns, "_result_");
    }

    if (params) {
      cg_lua_params(params, &args, &returns);
    }

    bprintf(d, "  %s = %s(%s)\n", returns.ptr, proc_sym.ptr, args.ptr);
    bprintf(d, "  ");
    if (dml_proc) {
      cg_lua_error_on_not_sqlite_ok();
    }

    bprintf(d, "result_set = { _result_ }\n");

    bclear(&args);
    bclear(&returns);

    if (dml_proc) {
      bprintf(&returns, "_rc_, result_set");
    }
    else {
      bprintf(&returns, "result_set");
    }

    if (params) {
      cg_lua_params(params, &args, &returns);
    }

    bprintf(d, "\n::cql_cleanup::\n");
    bprintf(d, "  return %s\n", returns.ptr);
    bprintf(d, "end\n\n");

    CHARBUF_CLOSE(returns);
    CHARBUF_CLOSE(args);
  }
  else if (result_set_proc) {
      // Emit foo_fetch_results, it has the same signature as foo only with a result set
      // instead of a statement.
      Invariant(dml_proc);

      bprintf(d, "\n");
      cg_lua_emit_fetch_results_prototype(dml_proc, params, name, d);

      bprintf(d, "  local result_set = nil\n");
      bprintf(d, "  local _rc_\n");

      CHARBUF_OPEN(args);
      CHARBUF_OPEN(returns);

      // fixed db arg and return code
      bprintf(&args, "_db_");
      bprintf(&returns, "_rc_, stmt");

      if (params) {
        cg_lua_params(params, &args, &returns);
      }

      bprintf(d, "  %s = %s(%s)\n", returns.ptr, proc_sym.ptr, args.ptr);
      bprintf(d, "  ");
      cg_lua_error_on_not_sqlite_ok();

      bprintf(d, "  _rc_, result_set = cql_fetch_all_rows(stmt, ");
      cg_lua_emit_field_types(d, ast->sem->sptr);
      bprintf(d, ", ");
      cg_lua_emit_field_names(d, ast->sem->sptr);
      bprintf(d, ")\n");

      bclear(&args);
      bclear(&returns);

      bprintf(&returns, "_rc_, result_set");
      if (params) {
        cg_lua_params(params, &args, &returns);
      }

      bprintf(d, "\n::cql_cleanup::\n");
      bprintf(d, "  cql_finalize_stmt(stmt)\n");
      bprintf(d, "  stmt = nil\n");

      cg_lua_emit_autodrops(d, misc_attrs);

      bprintf(d, "  return %s\n", returns.ptr);
      bprintf(d, "end\n\n");

      CHARBUF_CLOSE(returns);
      CHARBUF_CLOSE(args);
    }

  CHARBUF_CLOSE(fetch_results_sym);
  CHARBUF_CLOSE(result_count_sym);
  CHARBUF_CLOSE(row_sym);
  CHARBUF_CLOSE(proc_sym);
  CHARBUF_CLOSE(getter_prefix);
  CHARBUF_CLOSE(temp);
  CHARBUF_CLOSE(result_set_create);
  CHARBUF_CLOSE(data_types);

  cg_main_output = main_saved;
}

// Main entry point for code-gen.  This will set up the buffers for the global
// variables and any loose calls or DML.  Any code that needs to run in the
// global scope will be added to the global_proc.  This is the only codegen
// error that is possible.  If you need global code and you don't have a global
// proc then you can't proceed.  Semantic analysis doÆ’esn't want to know that stuff.
// Otherwise all we do is set up the most general buffers for the global case and
// spit out a function with the correct name.
cql_noexport void cg_lua_main(ast_node *head) {
  cql_exit_on_semantic_errors(head);
  exit_on_validating_schema();

  CSTR body_file_name = options.file_names[0];

  cg_lua_init();

  cg_lua_scratch_masks global_scratch_masks;
  cg_lua_current_masks = &global_scratch_masks;
  cg_lua_zero_masks(cg_lua_current_masks);

  CHARBUF_OPEN(body_file);
  CHARBUF_OPEN(indent);

  bprintf(&body_file, "%s", rt->source_prefix);
  bprintf(&body_file, "%s", rt->source_wrapper_begin);
  bprintf(&body_file, rt->cqlrt_template, rt->cqlrt);

  cg_lua_stmt_list(head);

  bprintf(&body_file, "%s", cg_fwd_ref_output->ptr);
  bprintf(&body_file, "%s", cg_constants_output->ptr);
  bprintf(&body_file, "%s", cg_declarations_output->ptr);

  // main function after constants and decls (if needed)

  bool_t global_proc_needed = cg_main_output->used > 1 || cg_scratch_vars_output->used > 1;

  if (global_proc_needed) {
    exit_on_no_global_proc();

    bindent(&indent, cg_scratch_vars_output, 2);
    bprintf(&body_file, "\nfunction %s(_db_)\n", global_proc_name);
    cg_lua_emit_rc_vars(&body_file);

    bprintf(&body_file, "%s", indent.ptr);
    bprintf(&body_file, "%s", cg_main_output->ptr);
    bprintf(&body_file, "\n");
    if (lua_error_target_used) {
      bprintf(&body_file, "::%s::\n", lua_error_target);
    }
    bprintf(&body_file, "%s", cg_cleanup_output->ptr);
    bprintf(&body_file, "  return _rc_\n");
    bprintf(&body_file, "end\n");
  }

  bprintf(&body_file, "%s", rt->source_wrapper_end);


  CHARBUF_CLOSE(indent);


  cql_write_file(body_file_name, body_file.ptr);

  CHARBUF_CLOSE(body_file);

  cg_lua_cleanup();
}

cql_noexport void cg_lua_init(void) {
  cg_lua_cleanup(); // reset globals/statics
  cg_common_init();

  Contract(!lua_error_target_used);

  LUA_DDL_STMT_INIT(drop_table_stmt);
  LUA_DDL_STMT_INIT(drop_view_stmt);
  LUA_DDL_STMT_INIT(drop_index_stmt);
  LUA_DDL_STMT_INIT(drop_trigger_stmt);
  LUA_DDL_STMT_INIT(create_table_stmt);
  LUA_DDL_STMT_INIT(create_virtual_table_stmt);
  LUA_DDL_STMT_INIT(create_trigger_stmt);
  LUA_DDL_STMT_INIT(create_index_stmt);
  LUA_DDL_STMT_INIT(create_view_stmt);
  LUA_DDL_STMT_INIT(alter_table_add_column_stmt);

  LUA_NO_OP_STMT_INIT(expr_macro_def);
  LUA_NO_OP_STMT_INIT(stmt_list_macro_def);
  LUA_NO_OP_STMT_INIT(query_parts_macro_def);
  LUA_NO_OP_STMT_INIT(cte_tables_macro_def);
  LUA_NO_OP_STMT_INIT(select_expr_macro_def);
  LUA_NO_OP_STMT_INIT(select_core_macro_def);
  LUA_NO_OP_STMT_INIT(enforce_reset_stmt);
  LUA_NO_OP_STMT_INIT(enforce_normal_stmt);
  LUA_NO_OP_STMT_INIT(enforce_strict_stmt);
  LUA_NO_OP_STMT_INIT(enforce_push_stmt);
  LUA_NO_OP_STMT_INIT(enforce_pop_stmt);
  LUA_NO_OP_STMT_INIT(declare_schema_region_stmt);
  LUA_NO_OP_STMT_INIT(declare_deployable_region_stmt);
  LUA_NO_OP_STMT_INIT(begin_schema_region_stmt);
  LUA_NO_OP_STMT_INIT(end_schema_region_stmt);
  LUA_NO_OP_STMT_INIT(schema_upgrade_version_stmt);
  LUA_NO_OP_STMT_INIT(schema_upgrade_script_stmt);
  LUA_NO_OP_STMT_INIT(schema_ad_hoc_migration_stmt);
  LUA_NO_OP_STMT_INIT(declare_enum_stmt);
  LUA_NO_OP_STMT_INIT(declare_const_stmt);
  LUA_NO_OP_STMT_INIT(declare_named_type);
  LUA_NO_OP_STMT_INIT(declare_proc_no_check_stmt);
  LUA_NO_OP_STMT_INIT(schema_unsub_stmt);
  LUA_NO_OP_STMT_INIT(declare_interface_stmt);
  LUA_NO_OP_STMT_INIT(declare_select_func_no_check_stmt);
  LUA_NO_OP_STMT_INIT(declare_select_func_stmt);
  LUA_NO_OP_STMT_INIT(declare_func_stmt);
  LUA_NO_OP_STMT_INIT(declare_func_no_check_stmt);
  LUA_NO_OP_STMT_INIT(declare_proc_stmt);
  LUA_NO_OP_STMT_INIT(keep_table_name_in_aliases_stmt);
  LUA_NO_OP_STMT_INIT(op_stmt);

  LUA_STD_DML_STMT_INIT(begin_trans_stmt);
  LUA_STD_DML_STMT_INIT(commit_trans_stmt);
  LUA_STD_DML_STMT_INIT(rollback_trans_stmt);
  LUA_STD_DML_STMT_INIT(savepoint_stmt);
  LUA_STD_DML_STMT_INIT(release_savepoint_stmt);
  LUA_STD_DML_STMT_INIT(delete_stmt);
  LUA_STD_DML_STMT_INIT(with_delete_stmt);
  LUA_STD_DML_STMT_INIT(update_stmt);
  LUA_STD_DML_STMT_INIT(with_update_stmt);

  // these prepare and then execute
  LUA_STD_PREP_STMT_INIT(upsert_returning_stmt);
  LUA_STD_PREP_STMT_INIT(update_returning_stmt);
  LUA_STD_PREP_STMT_INIT(delete_returning_stmt);
  LUA_STD_PREP_STMT_INIT(explain_stmt);
  LUA_STD_PREP_STMT_INIT(select_stmt);
  LUA_STD_PREP_STMT_INIT(with_select_stmt);

  // insert forms have some special processing for the 'seed' case
  LUA_STMT_INIT(insert_stmt);
  LUA_STMT_INIT(insert_returning_stmt);
  LUA_STMT_INIT(with_insert_stmt);
  LUA_STMT_INIT(upsert_stmt);
  LUA_STMT_INIT(with_upsert_stmt);

  LUA_STMT_INIT(expr_stmt);
  LUA_STMT_INIT(if_stmt);
  LUA_STMT_INIT(ifdef_stmt);
  LUA_STMT_INIT(ifndef_stmt);
  LUA_STMT_INIT(switch_stmt);
  LUA_STMT_INIT(while_stmt);
  LUA_STMT_INIT(for_stmt);
  LUA_STMT_INIT(leave_stmt);
  LUA_STMT_INIT(continue_stmt);
  LUA_STMT_INIT(return_stmt);
  LUA_STMT_INIT(rollback_return_stmt);
  LUA_STMT_INIT(commit_return_stmt);
  LUA_STMT_INIT(call_stmt);
  LUA_STMT_INIT(declare_out_call_stmt);
  LUA_STMT_INIT(declare_vars_type);
  LUA_STMT_INIT(assign);
  LUA_STMT_INIT(let_stmt);
  LUA_STMT_INIT(const_stmt);
  LUA_STMT_INIT(set_from_cursor);
  LUA_STMT_INIT(create_proc_stmt);
  LUA_STMT_INIT(trycatch_stmt);
  LUA_STMT_INIT(proc_savepoint_stmt);
  LUA_STMT_INIT(throw_stmt);

  LUA_STMT_INIT(declare_cursor);
  LUA_STMT_INIT(declare_cursor_like_name);
  LUA_STMT_INIT(declare_cursor_like_select);
  LUA_STMT_INIT(declare_value_cursor);
  LUA_STMT_INIT(declare_cursor_like_typed_names);

  LUA_STMT_INIT(loop_stmt);
  LUA_STMT_INIT(fetch_stmt);
  LUA_STMT_INIT(fetch_values_stmt);
  LUA_STMT_INIT(update_cursor_stmt);
  LUA_STMT_INIT(fetch_call_stmt);

  LUA_STMT_INIT(close_stmt);
  LUA_STMT_INIT(out_stmt);
  LUA_STMT_INIT(out_union_stmt);
  LUA_STMT_INIT(echo_stmt);

  LUA_STMT_INIT(declare_group_stmt);
  LUA_STMT_INIT(emit_group_stmt);
  LUA_STMT_INIT(emit_enums_stmt);
  LUA_STMT_INIT(emit_constants_stmt);

  LUA_FUNC_INIT(sign);
  LUA_FUNC_INIT(abs);
  LUA_FUNC_INIT(sensitive);
  LUA_FUNC_INIT(nullable);
  LUA_FUNC_INIT(ifnull_throw);
  LUA_FUNC_INIT(ifnull_crash);
  LUA_FUNC_INIT(ifnull);
  LUA_FUNC_INIT(coalesce);
  LUA_FUNC_INIT(last_insert_rowid);
  LUA_FUNC_INIT(changes);
  LUA_FUNC_INIT(printf);
  LUA_FUNC_INIT(cql_get_blob_size);
  LUA_FUNC_INIT(cql_inferred_notnull);
  LUA_FUNC_INIT(cql_compressed);

  LUA_EXPR_INIT(num, cg_lua_expr_num, "num", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(str, cg_lua_expr_str, "STR", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(null, cg_lua_expr_null, "NULL", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(dot, cg_lua_expr_dot, "DOT", LUA_EXPR_PRI_ROOT);

  LUA_EXPR_INIT(lshift, cg_lua_binary, "<<", LUA_EXPR_PRI_SHIFT);
  LUA_EXPR_INIT(rshift, cg_lua_binary, ">>", LUA_EXPR_PRI_SHIFT);
  LUA_EXPR_INIT(bin_and, cg_lua_binary, "&", LUA_EXPR_PRI_BAND);
  LUA_EXPR_INIT(bin_or, cg_lua_binary, "|", LUA_EXPR_PRI_BOR);

  LUA_EXPR_INIT(mul, cg_lua_binary, "*", LUA_EXPR_PRI_MUL);
  LUA_EXPR_INIT(div, cg_lua_binary, "/", LUA_EXPR_PRI_MUL);
  LUA_EXPR_INIT(mod, cg_lua_binary, "%", LUA_EXPR_PRI_MUL);
  LUA_EXPR_INIT(add, cg_lua_binary, "+", LUA_EXPR_PRI_ADD);
  LUA_EXPR_INIT(sub, cg_lua_binary, "-", LUA_EXPR_PRI_ADD);
  LUA_EXPR_INIT(not, cg_lua_unary, "not", LUA_EXPR_PRI_UNARY);
  LUA_EXPR_INIT(tilde, cg_lua_unary, "~", LUA_EXPR_PRI_UNARY);
  LUA_EXPR_INIT(uminus, cg_lua_unary, "-", LUA_EXPR_PRI_UNARY);
  LUA_EXPR_INIT(eq, cg_lua_binary, "==", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(ne, cg_lua_binary, "~=", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(lt, cg_lua_binary, "<", LUA_EXPR_PRI_LT_GT);
  LUA_EXPR_INIT(gt, cg_lua_binary, ">", LUA_EXPR_PRI_LT_GT);
  LUA_EXPR_INIT(ge, cg_lua_binary, ">=", LUA_EXPR_PRI_LT_GT);
  LUA_EXPR_INIT(le, cg_lua_binary, "<=", LUA_EXPR_PRI_LT_GT);
  LUA_EXPR_INIT(call, cg_lua_expr_call, "CALL", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(between_rewrite, cg_lua_expr_between_rewrite, "BETWEEN", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(and, cg_lua_expr_and_or, "and", LUA_EXPR_PRI_LAND);
  LUA_EXPR_INIT(or, cg_lua_expr_and_or, "or", LUA_EXPR_PRI_LOR);
  LUA_EXPR_INIT(select_stmt, cg_lua_expr_select, "SELECT", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(select_if_nothing_expr, cg_lua_expr_select_if_nothing, "SELECT", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(select_if_nothing_throw_expr, cg_lua_expr_select_if_nothing_throw, "SELECT", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(select_if_nothing_or_null_expr, cg_lua_expr_select_if_nothing_or_null, "SELECT", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(select_if_nothing_or_null_throw_expr, cg_lua_expr_select_if_nothing_or_null_throw, "SELECT", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(with_select_stmt, cg_lua_expr_select, "WITH...SELECT", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(is, cg_lua_is_or_is_not, "==", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(is_not, cg_lua_is_or_is_not, "~=", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(is_not_true, cg_lua_expr_is_not_true, "IS NOT TRUE", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(is_not_false, cg_lua_expr_is_not_false, "IS NOT FALSE", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(is_true, cg_lua_expr_is_true, "IS TRUE", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(is_false, cg_lua_expr_is_false, "IS FALSE", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(like, cg_lua_binary, "like", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(not_like, cg_lua_binary, "not_like", LUA_EXPR_PRI_EQ_NE);
  LUA_EXPR_INIT(in_pred, cg_lua_expr_in_pred_or_not_in, "IN", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(not_in, cg_lua_expr_in_pred_or_not_in, "NOT IN", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(case_expr, cg_lua_expr_case, "CASE", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(cast_expr, cg_lua_expr_cast, "CAST", LUA_EXPR_PRI_ROOT);
  LUA_EXPR_INIT(type_check_expr, cg_lua_expr_type_check, "TYPE CHECK", LUA_EXPR_PRI_ROOT);
}

// To make sure we start at a zero state.  This is really necessary stuff
// because of the amalgam.  In the context of the amalgam the compiler
// might be run more than once without the process exiting. Hence we have
// to reset the globals and empty the symbol tables.
cql_noexport void cg_lua_cleanup() {
  cg_common_cleanup();

  SYMTAB_CLEANUP(lua_named_temporaries);

  lua_exports_output = NULL;
  lua_error_target = NULL;
  cg_lua_current_masks = NULL;

  lua_in_loop = false;
  lua_case_statement_count = 0;
  lua_catch_block_count = 0;
  lua_error_target = CQL_CLEANUP_DEFAULT_LABEL;
  lua_error_target_used = false;
  lua_rcthrown_current = CQL_LUA_RCTHROWN_DEFAULT;
  lua_rcthrown_used = false;
  lua_rcthrown_index = 0;
  lua_return_used = false;
  lua_seed_declared = false;
  lua_stack_level = 0;
  lua_temp_cstr_count = 0;
  lua_temp_statement_emitted = false;
  lua_continue_label_needed = false;
  lua_continue_label_number = 0;
  lua_continue_label_next = 0;
}


#endif


/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_QUERY_PLAN)

// stubs to avoid link errors
cql_noexport void cg_query_plan_main(ast_node *head) {}

#else


static void cg_qp_one_stmt(ast_node *stmt);

static charbuf *schema_stmts;
static charbuf *backed_tables;
static charbuf *query_plans;
static CSTR current_procedure_name;
static charbuf *current_ok_table_scan;
static symtab *virtual_tables;

// Count sql statement found in ast
static uint32_t sql_stmt_count = 0;

static gen_sql_callbacks *cg_qp_callbacks = NULL;

// When generating the query plan report there will be no referrence to
// virtual table. In case we encounter a virtual table call we replace
// it with a regular table call of the same name and we also emit the
// create statement of that table to avoid sqlite error.
//
// @see cg_qp_create_virtual_table_stmt()
static bool_t qp_table_function_callback(
  struct ast_node *_Nonnull ast,
  void *_Nullable context,
  charbuf *_Nonnull output)
{
  Contract(is_ast_table_function(ast));
  EXTRACT_STRING(name, ast->left);
  gen_printf("%s", name);

  if (!symtab_add(virtual_tables, name, NULL)) {
    // This virtual table is already created
    return true;
  }

  bprintf(schema_stmts, "CREATE TABLE %s (\n", name);

  sem_join *jptr = ast->sem->jptr;
  uint32_t size = jptr->tables[0]->count;
  for (uint32_t i = 0; i < size; i++) {
    if (i > 0) {
      bprintf(schema_stmts, ",\n");
    }

    CSTR type;
    sem_t core_type = core_type_of(jptr->tables[0]->semtypes[i]);
    switch (core_type) {
      case SEM_TYPE_OBJECT:
      case SEM_TYPE_BOOL:
      case SEM_TYPE_INTEGER:
      case SEM_TYPE_LONG_INTEGER:
        type = "INT";
        break;
      case SEM_TYPE_TEXT:
        type = "TEXT";
        break;
      case SEM_TYPE_BLOB:
        type = "BLOB";
        break;
      default :
        Contract(core_type == SEM_TYPE_REAL);
        type = "REAL";
    }
    bprintf(schema_stmts, "  %s %s", jptr->tables[0]->names[i], type);
  }

  bprintf(schema_stmts, "\n);\n");
  return true;
}

// emit a constant '1' in the appropriate type format for the expression
// this is used to replaced variables in queries with something that sqlite can
// evaluate so that the entire stream leading to the variable doesn't have
// to go into the output.  This is also used to replace native function calls
// that occur in query fragments.
static void qp_emit_constant_one(bool_t native_context, sem_t sem_type, charbuf *output)
{
  bool_t nullable = is_nullable(sem_type) && !is_inferred_notnull(sem_type);

  if (nullable) {
    gen_printf("nullable(");
  }

  if (is_bool(sem_type)) {
    gen_printf("true");
  }
  else if (is_long(sem_type)) {
    gen_printf("1L");
  }
  else if (is_real(sem_type)) {
    gen_printf("1.0");
  }
  else if (is_numeric(sem_type)) {
    gen_printf("1");
  }
  else if (is_text(sem_type)) {
    gen_printf("'1'");
  }
  else if (is_object(sem_type)) {
    if (native_context) {
       gen_printf("trivial_object()");
    }
    else {
       gen_printf("query_plan_trivial_object");
    }
  }
  else {
    Contract(is_blob(sem_type));
    if (native_context) {
       gen_printf("trivial_blob()");
    }
    else {
      gen_printf("query_plan_trivial_blob");
    }
  }

  if (nullable) {
    gen_printf(")");
  }
}

// When generating the query plan report there will be no actual
// variable values to use in the query.  To get around this
// we replace all variable references with a type-correct version
// of the constant "1".  This gives us a pretty good query plan
// even if there are parameters in the real query.
// Note: if the SQLite query processor were much more fancy this
// wouldn't work at all. Constants matter.
static bool_t qp_variables_callback(
  struct ast_node *_Nonnull ast,
  void *_Nullable context,
  charbuf *_Nonnull output)
{
  qp_emit_constant_one(false, ast->sem->sem_type, output);
  return true;
}

// Here we replace calls to native procedures or native functions with a constant
// just like we do with local variables.  This means we don't need native functions
// in the generated binary for the query plan helper and we won't try to call them
// in the wrong context.  These kinds of calls can only happen in the context
// of shared fragment arguments which are evaluated before execution of the query
// in the native context (i.e. SQLite sees them only as variables).  The QP output
// code has to match this by removing the native call.  It wouldn't be part of the
// plan anyway.
//
// Note that we leave "select functions" alone (i.e. declared UDFs) they are
// handled by generating a stub UDF for sqlite.  See also cg_qp_emit_udf_stubs.
// We also do not touch shared fragment expressions, in those
// cases the sproc body will be inlined as usual so there is no need to replace
// the call with a constant.
static bool_t qp_func_callback(
  struct ast_node *_Nonnull ast,
  void *_Nullable context,
  charbuf *_Nonnull output)
{
  Contract(is_ast_call(ast));
  EXTRACT_STRING(name, ast->left);

  // shared expression fragment will be inline expanded
  // we don't have to replace it
  if (is_inline_func_call(ast)) {
    return false;
  }

  ast_node *func = find_func(name);

  // note: ast_declare_select_func_stmt does NOT match, they stay
  if (func && is_ast_declare_func_stmt(func)) {
    qp_emit_constant_one(true, ast->sem->sem_type, output);
    return true;
  }

  // any inline proc call is proc as func except shared fragment
  // which we checked above
  ast_node *proc = find_proc(name);
  if (proc) {
    qp_emit_constant_one(true, ast->sem->sem_type, output);
    return true;
  }

  return false;
}

// For shared fragments with conditionals, choose one branch and discard the conditional.
// A one-indexed integer provided by "context" chooses the branch - default is 1 (first branch).
// Starting from 1 rather than 0 seems more intuitive for the use of [[query_plan_branch]]
static bool_t if_stmt_callback(
  struct ast_node *_Nonnull ast,
  void *_Nullable context,
  charbuf *_Nonnull output)
{
  Contract(is_ast_if_stmt(ast));
  EXTRACT_NOTNULL(if_alt, ast->right);
  EXTRACT(elseif, if_alt->left);
  EXTRACT_NAMED_NOTNULL(elsenode, else, if_alt->right);

  int64_t branch_to_keep_index = context ? *(int64_t*) context : 1;
  ast_node *stmt_list;

  if (branch_to_keep_index <= 1) {
    EXTRACT_NOTNULL(cond_action, ast->left);
    stmt_list = cond_action->right;
  }
  else {
    int64_t curr_index = 2;
    while (elseif && curr_index < branch_to_keep_index) {
      Contract(is_ast_elseif(elseif));
      elseif = elseif->right;
      curr_index++;
    }

    if (elseif) {
      EXTRACT(cond_action, elseif->left);
      stmt_list = cond_action->right;
    }
    else {
      stmt_list = elsenode->left;
    }
  }

  // This callback is only invoked within shared fragments.
  // So we can enforce there's only a single select statement
  Contract(is_ast_stmt_list(stmt_list));
  Contract(!stmt_list->right);
  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  if (is_ast_select_nothing_stmt(stmt)) {
    // If the selected branch contains SELECT NOTHING,
    // select a different branch instead for query plan generation.
    Contract(branch_to_keep_index > 1);
    branch_to_keep_index = 1;
    return if_stmt_callback(ast, (void *) &branch_to_keep_index, output);
  }

  Contract(is_ast_select_stmt(stmt) || is_ast_with_select_stmt(stmt));
  gen_one_stmt(stmt);

  return true;
}

// Emits an explain query plan statement for the given statement node
// the node could be any kind of DML including the select part of
// a nested select expression like:  let x:= (select etc.);
static void cg_qp_explain_query_stmt(ast_node *stmt) {
  sql_stmt_count++;
  CHARBUF_OPEN(proc);
  CHARBUF_OPEN(body);
  CHARBUF_OPEN(sql);
  CHARBUF_OPEN(json_str);
  CHARBUF_OPEN(c_str);

  gen_set_output_buffer(&sql);
  gen_statement_with_callbacks(stmt, cg_qp_callbacks);

  // the generated statement has to be encoded in different ways, it will go out directly
  // as an explain statement starting from the basic string computed above.  However,
  // we also want to store the text of the statement as a string.  So we have to quote
  // the statement.  That's all fine and well but actually the text we want is for the
  // JSON output we will create.  So we have to JSON encode the sql and then quote
  // the JSON as a C string.
  cg_encode_json_string_literal(sql.ptr, &json_str);

  // Now that we have the JSON string we need all of that in a C string, including the
  // quotes. So we use the single character helper to build a buffer with new quotes.  Note
  // that C string encoding is slightly differen than JSON, there are small escape differences.
  // So we're going to be quote careful to C encode the JSON encoding.  It's double encoded.
  // Howeve, there won't *be* any control characters to encode at this point because the JSON
  // encoding already removed them all.  We're doing json encoding followed by C encoding because
  // that's technically what we need but actually JSON encoding followed by another
  // round of JSON encoding necessarily produces the same output. This code once did two JSON
  // encodings it was only pedantically wrong.
  bprintf(&c_str, "\"");
  for (uint32_t i = 1; i < json_str.used - 2; i++) {
    // json_str can have no control characters, but it might have quotes and backslashes
    cg_encode_char_as_c_string_literal(json_str.ptr[i], &c_str);
  }
  bprintf(&c_str, "\"");

  bprintf(&body, "LET query_plan_trivial_object := trivial_object();\n");
  bprintf(&body, "LET query_plan_trivial_blob := trivial_blob();\n\n");

  // The properly stringified literal can now be safely stored in a local variable with no loss.
  // The C encoded will be unescaped when it is compiled and the JSON goes directly to the output
  // so that we correctly generate a JSON fragment as a result of running this code.  The JSON
  // string has escaped any quotes etc. that were in the original SQL.
  bprintf(&body, "DECLARE stmt TEXT!;\n");
  bprintf(&body, "SET stmt := %s;\n", c_str.ptr);

  bprintf(&body, "INSERT INTO sql_temp(id, sql) VALUES(%d, stmt);\n", sql_stmt_count);
  if (current_procedure_name && current_ok_table_scan && current_ok_table_scan->used > 1) {
    bprintf(
      &body,
      "INSERT INTO ok_table_scan(sql_id, proc_name, table_names) VALUES(%d, \"%s\", \"%s\");\n",
      sql_stmt_count,
      current_procedure_name,
      current_ok_table_scan->ptr
    );
  }
  bprintf(&body, "DECLARE C CURSOR FOR EXPLAIN QUERY PLAN\n");
  bprintf(&body, "%s;\n", sql.ptr);
  bprintf(&body, "LOOP FETCH C\n");
  bprintf(&body, "BEGIN\n");
  bprintf(&body, "  INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(%d, C.iselectid, C.iorder, C.ifrom, C.zdetail);\n", sql_stmt_count);
  bprintf(&body, "END;\n");

  bprintf(&proc, "PROC populate_query_plan_%d()\n", sql_stmt_count);
  bprintf(&proc, "BEGIN\n");
  bindent(&proc, &body, 2);
  bprintf(&proc, "END;\n\n");

  bprintf(query_plans, "%s", proc.ptr);

  CHARBUF_CLOSE(c_str);
  CHARBUF_CLOSE(json_str);
  CHARBUF_CLOSE(sql);
  CHARBUF_CLOSE(body);
  CHARBUF_CLOSE(proc);
}

// Emit a necessary piece of schema, preserve the backing table attributes if they are applicable.
// This code runs for all kinds of DDL.
static void cg_qp_sql_stmt(ast_node *ast) {
  // we only run if the item is not deleted (i.e. delete version == -1) and
  // it is not an aliased item.  That is if there are two copies of create table T1(...)
  // the 2nd identical copy should not be emitted. Same for indices, triggers, and views.
  if (ast->sem->delete_version <= 0 && !is_alias_ast(ast)) {
    charbuf *out = schema_stmts;
    if (is_backing(ast->sem->sem_type)) {
      bprintf(out, "[[backing_table]]\n");
    }
    if (is_backed(ast->sem->sem_type)) {
      out = backed_tables;

      EXTRACT_MISC_ATTRS(ast, misc_attrs);
      CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
      bprintf(out, "[[backed_by=%s]]\n", backing_table_name);
    }
    gen_set_output_buffer(out);
    gen_statement_with_callbacks(ast, cg_qp_callbacks);
    bprintf(out, ";\n");
  }
}

// We're assembling a simple string that has the tables that we are allowed to table scan without
// generating a warning in the JSON output. This is basically a simple allow list.
static void cg_qp_ok_table_scan_callback(
    CSTR _Nonnull name,
    ast_node* _Nonnull misc_attr_value,
    void* _Nullable context) {
  Contract(context && is_ast_str(misc_attr_value));

  charbuf *ok_table_scan_buf = (charbuf *)context;
  EXTRACT_STRING(table_name, misc_attr_value);
  if (ok_table_scan_buf->used > 1) {
    bprintf(ok_table_scan_buf, ",");
  }
  // The "#" around the name make it easier to do a whole-word
  // match on the table name later
  bprintf(ok_table_scan_buf, "#%s#", table_name);
}

// If we're processing a conditional fragment and there is an annotation
// that tells us which branch of the fragment to use then store it.
// Otherwise we'll analyze the first branch.
static void cg_qp_query_plan_branch_callback(
  CSTR _Nonnull name,
  ast_node* _Nonnull misc_attr_value,
  void* _Nullable context)
{
  Contract(context && is_ast_num(misc_attr_value));

  eval_node result = EVAL_NIL;
  eval(misc_attr_value, &result);

  Contract(result.sem_type != SEM_TYPE_ERROR && result.sem_type != SEM_TYPE_NULL);
  eval_cast_to(&result, SEM_TYPE_LONG_INTEGER);

  // the context had the integer that holds the branch number
  *(int64_t*)context = result.int64_value;
}

// There are now extract work to be done in create_proc_stmt substree.
// We need to associate the proc name and ok_table_scan's tables to all
// sql statement found in the proc.
// It's used later to establish the relationship between a statement and
// a proc name (but all "ok_table_scan" attribution). But also to detect
// whether or not scan table alert should be silent because of "ok_table_scan".
//
// The code in this function collect all the tables of "ok_table_scan" attr
// and associate them with the proc name and the statement ids in the proc.
//
// e.g: With the info below now available we can now figure out wheter or
// an alert of scan table can be made on a particular statement id.
// stmt(id) <-> proc_name <-> table_name (ok_table_scan)
static void cg_qp_create_proc_stmt(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  Contract(current_procedure_name == NULL);
  Contract(current_ok_table_scan == NULL);

  if (is_proc_shared_fragment(ast)) {
    EXTRACT_MISC_ATTRS(ast, misc_attrs);
    int64_t if_stmt_branch_context = 1;
    find_query_plan_branch(misc_attrs, cg_qp_query_plan_branch_callback, (void *) &if_stmt_branch_context);

    cg_qp_callbacks->if_stmt_callback = &if_stmt_callback;
    cg_qp_callbacks->if_stmt_context = &if_stmt_branch_context;

    // inside of a shared fragment, variables do not need to be remapped at all
    // they are only formals anyway.  Only the variables of "real" stored procs
    // need to be remapped.  If there are internal variables in blobs they will
    // flow from the outer variables.  This has the important side-effect of
    // making it so that no native call occurs inside the shared fragment in a sql context.
    gen_sql_callback _Nullable variables_callback_saved = cg_qp_callbacks->variables_callback;
    cg_qp_callbacks->variables_callback = NULL;

    bprintf(query_plans, "[[shared_fragment]]\n");

    if (if_stmt_branch_context > 1) {
      bprintf(query_plans, "[[query_plan_branch=%lld]]\n", (llint_t)if_stmt_branch_context);
    }

    gen_set_output_buffer(query_plans);
    gen_statement_with_callbacks(ast, cg_qp_callbacks);
    bprintf(query_plans, ";\n\n");

    // put the variables callback back in place
    cg_qp_callbacks->variables_callback = variables_callback_saved;

    // Don't apply callback outside of shared fragments
    cg_qp_callbacks->if_stmt_callback = NULL;
    cg_qp_callbacks->if_stmt_context = NULL;

    return;
  }

  CHARBUF_OPEN(ok_table_scan_buf);
  current_ok_table_scan = &ok_table_scan_buf;

  // The statement has attributions therefore we should collect the values
  // of "ok_table_scan" attribution if applicable. Otherwise we have nothing
  // record on this proc related to "ok_table_scan".
  if (is_ast_stmt_and_attr(ast->parent)) {
    EXTRACT_NOTNULL(stmt_and_attr, ast->parent);
    EXTRACT_NOTNULL(misc_attrs, stmt_and_attr->left);
    EXTRACT_STRING(table_name, ast->left);

    current_procedure_name = table_name;
    find_ok_table_scan(misc_attrs, cg_qp_ok_table_scan_callback, (void *) &ok_table_scan_buf);
  }

  cg_qp_one_stmt(ast->left);
  cg_qp_one_stmt(ast->right);

  current_procedure_name = NULL;
  current_ok_table_scan = NULL;
  CHARBUF_CLOSE(ok_table_scan_buf);
}

// Virtual tables requires DB set up otherwise query plan will fail on sql statement
// referring virtual tables.
// Getting cg_query_plan.c to codegen virtual table setup in DB requires a lot of boilerplate
// code. That is un-nessary work to do since virtual table does not impact query plan result
// because primary key and foreign key are not supported in virtual tables.
// The simples and stretchforward alternative is to rewrite virtual table to a regular table.
// That won't affect query plan results.
static void cg_qp_create_virtual_table_stmt(ast_node *node) {
  Contract(is_ast_create_virtual_table_stmt(node));
  EXTRACT_NOTNULL(create_table_stmt, node->right);
  cg_qp_sql_stmt(create_table_stmt);
}

// We're going to recurse the entire AST looking for matching node types
// These correspond to the nodes we care about for QP.  That's pretty much
// only DDL and query statements.  Most other things we keep digging in.
static void cg_qp_one_stmt(ast_node *stmt) {
  if (!stmt || is_primitive(stmt)) {
    return;
  }

  symtab_entry *entry = symtab_find(cg_stmts, stmt->type);
  if (entry) {
    ((void (*)(ast_node*))entry->val)(stmt);
  }
  else {
    cg_qp_one_stmt(stmt->left);
    cg_qp_one_stmt(stmt->right);
  }
}

// This is where we walk the root statement list.
static void cg_qp_stmt_list(ast_node *head) {
  Contract(is_ast_stmt_list(head));
  for (ast_node *stmt = head; stmt; stmt = stmt->right) {
    cg_qp_one_stmt(stmt->left);
  }
}

// Emit a procedure to load up the no_table_scan table with an insert statement.
// We use the multi-value form of insert to load all the rows we need.
static void emit_populate_no_table_scan_proc(charbuf *output) {
  CHARBUF_OPEN(no_scan_tables_buf);

  for (list_item *item = all_tables_list; item; item = item->next) {
    if (is_ast_create_table_stmt(item->ast)) {
      EXTRACT_MISC_ATTRS(item->ast, misc_attrs);
      if (misc_attrs != NULL) {
        EXTRACT_NOTNULL(create_table_name_flags, item->ast->left);
        EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
        EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
        EXTRACT_STRING(name, name_ast);

        if (exists_attribute_str(misc_attrs, "no_table_scan")) {
          if (no_scan_tables_buf.used > 1) {
            bprintf(&no_scan_tables_buf, ",\n");
          }
          bprintf(&no_scan_tables_buf, "    (\"");
          if (is_qid(name_ast)) {
            cg_unquote_encoded_qstr(&no_scan_tables_buf, name);
          }
          else {
             bprintf(&no_scan_tables_buf, "%s", name);
          }
          bprintf(&no_scan_tables_buf, "\")");
        }
      }
    }
  }

  bprintf(output, "PROC populate_no_table_scan()\n");
  bprintf(output, "BEGIN\n");

  if (no_scan_tables_buf.used > 1) {
    bprintf(output, "  INSERT OR IGNORE INTO no_table_scan(table_name) VALUES\n%s;\n", no_scan_tables_buf.ptr);
  }

  bprintf(output, "END;\n");

  CHARBUF_CLOSE(no_scan_tables_buf);
}

// Emit function declarations for "declare select function"
static void cg_qp_emit_declare_func(charbuf *output) {
  // Emit declare functions because it may be needed for schema and query validation
  gen_set_output_buffer(output);
  for (list_item *item = all_functions_list; item; item = item->next) {
    EXTRACT_ANY_NOTNULL(any_func, item->ast);
    bool_t is_select_func =
      is_ast_declare_select_func_stmt(any_func) ||
      is_ast_declare_select_func_no_check_stmt(any_func);
    Contract(is_select_func || is_ast_declare_func_stmt(any_func));

    if (is_select_func) {
      EXTRACT_MISC_ATTRS(any_func, misc_attrs);
      bool_t deterministic = misc_attrs && !!find_named_attr(misc_attrs, "deterministic");
      if (deterministic) {
        bprintf(output, "[[deterministic]]\n");
      }

      gen_statement_with_callbacks(any_func, cg_qp_callbacks);
      bprintf(output, ";\n");
    }
  }
}

// Generate a call to create a no-op stub for each declared UDF that we saw.
// The stub isn't actually called in the context of query plan creation
// so it doesn't have to do anything.  The runtime helper cql_create_udf_stub
// handles the particulars.
static void cg_qp_emit_udf_stubs(charbuf *output) {
  for (list_item *item = all_functions_list; item; item = item->next) {
    EXTRACT_ANY_NOTNULL(any_func, item->ast);
    bool_t is_select_func =
      is_ast_declare_select_func_stmt(any_func) ||
      is_ast_declare_select_func_no_check_stmt(any_func);

    Contract(is_select_func  || is_ast_declare_func_stmt(any_func));

    if (is_select_func) {
      EXTRACT_STRING(name, any_func->left);
      bprintf(output, "  call cql_create_udf_stub(\"%s\");\n", name);
    }
  }
}

// Generate the schema required by the procedures in this translation unit
// plus the standard schema for query plan storage and emit any UDF stubs
// at this time as well.  See above for the UDF stub code.
static void cg_qp_emit_create_schema_proc(charbuf *output) {
  bprintf(output, "PROC create_schema()\n");
  bprintf(output, "BEGIN\n");

  cg_qp_emit_udf_stubs(output);
  bindent(output, schema_stmts, 2);
  bprintf(output,
    "%s",
    "  CREATE TABLE sql_temp(\n"
    "    id INT! PRIMARY KEY,\n"
    "    sql TEXT!\n"
    "  ) WITHOUT ROWID;\n"
    "  CREATE TABLE plan_temp(\n"
    "    iselectid INT!,\n"
    "    iorder INT!,\n"
    "    ifrom INT!,\n"
    "    zdetail TEXT!,\n"
    "    sql_id INT!,\n"
    "    FOREIGN KEY (sql_id) REFERENCES sql_temp(id)\n"
    "  );\n"
    "  CREATE TABLE no_table_scan(\n"
    "    table_name TEXT! PRIMARY KEY\n"
    "  );\n"
    "  CREATE TABLE table_scan_alert(\n"
    "    info TEXT!\n"
    "  );\n"
    "  CREATE TABLE b_tree_alert(\n"
    "    info TEXT!\n"
    "  );\n"
    "  CREATE TABLE ok_table_scan(\n"
    "    sql_id INT! PRIMARY KEY,\n"
    "    proc_name TEXT!,\n"
    "    table_names TEXT!\n"
    "  ) WITHOUT ROWID;\n"
    "END;\n"
    "\n"
  );

  bprintf(output, "%s", backed_tables->ptr);
}

static void emit_populate_tables_proc(charbuf *output) {
  bprintf(output, "%s", query_plans->ptr);
}

static void emit_print_sql_statement_proc(charbuf *output) {
  bprintf(output,
    "%s",
    "PROC print_sql_statement(sql_id int!)\n"
    "BEGIN\n"
    "  DECLARE C CURSOR FOR SELECT * FROM sql_temp WHERE id = sql_id LIMIT 1;\n"
    "  FETCH C;\n"
    "  CALL printf(\"   \\\"query\\\" : \\\"%s\\\",\\n\", C.sql);\n"
    "END;\n"
    "\n"
  );
}

static void emit_populate_table_scan_alert_table_proc(charbuf *output) {
  bprintf(output,
    "%s",
    "PROC populate_table_scan_alert_table(table_ text!)\n"
    "BEGIN\n"
    "  INSERT OR IGNORE INTO table_scan_alert\n"
    "    SELECT upper(table_) || '(' || count(*) || ')' as info FROM plan_temp\n"
    "    WHERE ( zdetail GLOB ('*[Ss][Cc][Aa][Nn]* ' || table_) OR \n"
    "            zdetail GLOB ('*[Ss][Cc][Aa][Nn]* ' || table_ || ' *')\n"
    "          )\n"
    "    AND sql_id NOT IN (\n"
    "      SELECT sql_id from ok_table_scan\n"
    "        WHERE table_names GLOB ('*#' || table_ || '#*')\n"
    "    ) GROUP BY table_;\n"
    "END;\n"
    "\n"
  );
}

static void emit_populate_b_tree_alert_table_proc(charbuf *output) {
  bprintf(output,
    "%s",
    "PROC populate_b_tree_alert_table()\n"
    "BEGIN\n"
    "  INSERT OR IGNORE INTO b_tree_alert\n"
    "    SELECT '#' || sql_id || '(' || count(*) || ')' as info FROM plan_temp\n"
    "    WHERE zdetail LIKE '%temp b-tree%'\n"
    "    GROUP BY sql_id;\n"
    "END;\n"
    "\n"
  );
}

static void emit_print_query_violation_proc(charbuf *output) {
  bprintf(output,
    "%s",
    "PROC print_query_violation()\n"
    "BEGIN\n"
    "  CALL populate_b_tree_alert_table();\n"
    "  DECLARE C CURSOR FOR SELECT table_name FROM no_table_scan;\n"
    "  LOOP FETCH C\n"
    "  BEGIN\n"
    "    CALL populate_table_scan_alert_table(C.table_name);\n"
    "  END;\n\n"
    "  LET first := true;\n"
    "  CALL printf(\"\\\"alerts\\\" : {\\n\");\n"
    "  DECLARE C2 CURSOR FOR\n"
    "    SELECT 'tableScanViolation' AS key, group_concat(info, ', ') AS info_list FROM table_scan_alert\n"
    "    UNION ALL\n"
    "    SELECT 'tempBTreeViolation' AS key, group_concat(info, ', ') AS info_list FROM b_tree_alert;\n"
    "  LOOP FETCH C2\n"
    "  BEGIN\n"
    "    IF C2.info_list IS NOT NULL THEN\n"
    "      CALL printf(\"%s\", IIF(first, \"\", \",\\n\"));\n"
    "      CALL printf(\"  \\\"%s\\\" : \", C2.key);\n"
    "      CALL printf(\"\\\"%s\\\"\", C2.info_list);\n"
    "      SET first := false;\n"
    "    END IF;\n"
    "  END;\n"
    "  CALL printf(\"\\n},\\n\");\n"
    "END;\n"
    "\n"
  );
}

static void emit_print_query_plan_stat_proc(charbuf *output) {
  bprintf(output,
    "%s",
    "PROC print_query_plan_stat(id_ int!)\n"
    "BEGIN\n"
    "  CALL printf(\"   \\\"stats\\\" : {\\n\");\n"
    "  DECLARE Ca CURSOR FOR\n"
    "  WITH\n"
    "    scan(name, count, priority) AS (\n"
    "      SELECT 'scan', COUNT(*), 0 \n"
    "        FROM plan_temp \n"
    "        WHERE zdetail LIKE '%scan%' AND sql_id = id_\n"
    "    ),\n"
    "    b_tree(name, count, priority) AS (\n"
    "      SELECT 'tempBTree', COUNT(*), 1 \n"
    "        FROM plan_temp \n"
    "        WHERE zdetail LIKE '%temp b-tree%' AND sql_id = id_\n"
    "    ),\n"
    "    compound_subqueries(name, count, priority) AS (\n"
    "      SELECT 'compoundSubquery', COUNT(*), 2 \n"
    "        FROM plan_temp \n"
    "        WHERE zdetail LIKE '%compound subqueries%' AND sql_id = id_\n"
    "    ),\n"
    "    execute_scalar(name, count, priority) AS (\n"
    "      SELECT 'executeScalar', COUNT(*), 3 \n"
    "        FROM plan_temp \n"
    "        WHERE zdetail LIKE '%execute scalar%' AND sql_id = id_\n"
    "    ),\n"
    "    search(name, count, priority) AS (\n"
    "      SELECT 'search', COUNT(*), 4 \n"
    "        FROM plan_temp \n"
    "        WHERE zdetail LIKE '%search%' AND iselectid NOT IN (\n"
    "          SELECT iselectid \n"
    "          FROM plan_temp \n"
    "          WHERE zdetail LIKE '%search%using%covering%'\n"
    "        ) AND sql_id = id_\n"
    "    ),\n"
    "    search_fast(name, count, priority) AS (\n"
    "      SELECT 'searchUsingCovering', COUNT(*), 5 \n"
    "        FROM plan_temp \n"
    "        WHERE zdetail LIKE '%search%using%covering%' AND sql_id = id_\n"
    "    )\n"
    "  SELECT \n"
    "   '\"' || name || '\"' name,\n"
    "   count value\n"
    "   FROM (\n"
    "   SELECT * FROM scan\n"
    "   UNION ALL\n"
    "   SELECT * FROM search\n"
    "   UNION ALL\n"
    "   SELECT * FROM search_fast\n"
    "   UNION ALL\n"
    "   SELECT * FROM b_tree\n"
    "   UNION ALL\n"
    "   SELECT * FROM compound_subqueries\n"
    "   UNION ALL\n"
    "   SELECT * FROM execute_scalar\n"
    "  )\n"
    "  WHERE count > 0 ORDER BY priority ASC, count DESC;\n"
    "  LET first := true;\n"
    "  LOOP FETCH Ca\n"
    "  BEGIN\n"
    "    CALL printf(\"%s\", IIF(first, \"\", \",\\n\"));\n"
    "    CALL printf(\"      %s : %d\", Ca.name, Ca.value);\n"
    "    SET first := false;\n"
    "  END;\n"
    "  CALL printf(\"\\n    },\\n\");\n"
    "END;\n"
    "\n"
  );
}

static void emit_print_query_plan_graph_proc(charbuf *output) {
  bprintf(output,
    "%s",
    "PROC print_query_plan_graph(id_ int!)\n"
    "BEGIN\n"
    "  DECLARE C CURSOR FOR\n"
    "  WITH RECURSIVE\n"
    "    plan_chain(iselectid,  zdetail, level) AS (\n"
    "     SELECT 0 as  iselectid, 'QUERY PLAN' as  zdetail, 0 as level\n"
    "     UNION ALL\n"
    "     SELECT plan_temp.iselectid, plan_temp.zdetail, plan_chain.level+1 as level\n"
    "      FROM plan_temp JOIN plan_chain ON plan_temp.iorder=plan_chain.iselectid WHERE plan_temp.sql_id = id_\n"
    "     ORDER BY 3 DESC\n"
    "    )\n"
    "    SELECT\n"
    "     level,\n"
    "     substr('                              ', 1, max(level - 1, 0)*3) ||\n"
    "     substr('|.............................', 1, min(level, 1)*3) ||\n"
    "     zdetail as graph_line FROM plan_chain;\n"
    "\n"
    "  CALL printf(\"   \\\"plan\\\" : \\\"\");\n"
    "  LOOP FETCH C\n"
    "  BEGIN\n"
    "    CALL printf(\"%s%s\", IIF(C.level, \"\\\\n\", \"\"), C.graph_line);\n"
    "  END;\n"
    "  CALL printf(\"\\\"\\n\");\n"
    "END;\n"
    "\n"
  );
}

static void emit_print_query_plan(charbuf *output) {
  bprintf(output,
    "PROC print_query_plan(sql_id int!)\n"
    "BEGIN\n"
    "  CALL printf(\"  {\\n\");\n"
    "  CALL printf(\"   \\\"id\\\" : %%d,\\n\", sql_id);\n"
    "  CALL print_sql_statement(sql_id);\n"
    "  CALL print_query_plan_stat(sql_id);\n"
    "  CALL print_query_plan_graph(sql_id);\n"
    "  CALL printf(\"  }\");\n"
    "END;\n"
    "\n"
  );
}

#undef STMT_INIT
#define STMT_INIT(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_qp_ ## x)

#undef STMT_INIT_EXPL
#define STMT_INIT_EXPL(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_qp_explain_query_stmt)

#undef STMT_INIT_DDL
#define STMT_INIT_DDL(x) symtab_add(cg_stmts, k_ast_ ## x, (void *)cg_qp_sql_stmt)

cql_noexport void cg_query_plan_main(ast_node *head) {
  sql_stmt_count = 0; // reset statics

  Contract(options.file_names_count == 1);
  cql_exit_on_semantic_errors(head);
  exit_on_validating_schema();

  cg_stmts = symtab_new();
  virtual_tables = symtab_new();

  STMT_INIT(create_proc_stmt);

  STMT_INIT(create_virtual_table_stmt);

  // schema
  //  * note probably need to add declare select function to this list
  //    that can be needed to correctly parse the body of triggers or views (which might use the function)
  STMT_INIT_DDL(create_table_stmt);
  STMT_INIT_DDL(create_index_stmt);
  STMT_INIT_DDL(create_view_stmt);
  STMT_INIT_DDL(create_trigger_stmt);

  // dml
  STMT_INIT_EXPL(begin_trans_stmt);
  STMT_INIT_EXPL(commit_trans_stmt);
  STMT_INIT_EXPL(delete_returning_stmt);
  STMT_INIT_EXPL(delete_stmt);
  STMT_INIT_EXPL(drop_index_stmt);
  STMT_INIT_EXPL(drop_table_stmt);
  STMT_INIT_EXPL(drop_view_stmt);
  STMT_INIT_EXPL(insert_returning_stmt);
  STMT_INIT_EXPL(insert_stmt);
  STMT_INIT_EXPL(select_stmt);
  STMT_INIT_EXPL(update_returning_stmt);
  STMT_INIT_EXPL(update_stmt);
  STMT_INIT_EXPL(upsert_returning_stmt);
  STMT_INIT_EXPL(upsert_stmt);
  STMT_INIT_EXPL(with_delete_stmt);
  STMT_INIT_EXPL(with_insert_stmt);
  STMT_INIT_EXPL(with_select_stmt);
  STMT_INIT_EXPL(with_update_stmt);
  STMT_INIT_EXPL(with_upsert_stmt);

  CHARBUF_OPEN(query_plans_buf);
  query_plans = &query_plans_buf;
  CHARBUF_OPEN(schema_stmts_buf);
  schema_stmts = &schema_stmts_buf;
  CHARBUF_OPEN(backed_tables_buf);
  backed_tables = &backed_tables_buf;
  CHARBUF_OPEN(output_buf);

  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_no_annotations;
  callbacks.variables_callback = qp_variables_callback;
  callbacks.table_function_callback = qp_table_function_callback;
  callbacks.func_callback = qp_func_callback;
  cg_qp_callbacks = &callbacks;

  cg_qp_stmt_list(head);

  bprintf(&output_buf, "%s", rt->source_prefix);
  bprintf(&output_buf, "declare proc printf no check;\n");

  // Print special annotation that would rename any table name aliases in
  // SELECT queries to include table names. Makes query plans more informative.
  bprintf(&output_buf, "@keep_table_name_in_aliases;\n");

  if (!sql_stmt_count) {
    bprintf(&output_buf,
      "create proc query_plan()\n"
      "begin\n"
      "  -- Force the dml proc signature\n"
      "  let i := @rc;\n"
      "\n"
      "  -- No statements found: Print an empty query plan\n"
      "  call printf(\"{ \\\"plans\\\": [] }\\n\");\n"
      "end;\n"
    );

    cql_write_file(options.file_names[0], output_buf.ptr);

    goto cleanup;
  }

  bprintf(&output_buf, "declare proc cql_create_udf_stub(name TEXT!) using transaction;\n\n");

  bprintf(&output_buf,
    "proc trivial_object()\n"
    "begin\n"
    "  select 1 x;\n"
    "end;\n\n"
  );

  bprintf(&output_buf,
    "proc trivial_blob(out result blob not null)\n"
    "begin\n"
    "  set result := (select x'41');\n"
    "end;\n\n"
  );

  if (options.test) {
    while (head->right) {
      head = head->right;
    }
    bprintf(&output_buf, "-- The statement ending at line %d\n\n", head->left->lineno);
  }

  cg_qp_emit_declare_func(&output_buf);
  cg_qp_emit_create_schema_proc(&output_buf);
  emit_populate_no_table_scan_proc(&output_buf);
  emit_populate_tables_proc(&output_buf);
  emit_populate_table_scan_alert_table_proc(&output_buf);
  emit_populate_b_tree_alert_table_proc(&output_buf);
  emit_print_query_violation_proc(&output_buf);
  emit_print_sql_statement_proc(&output_buf);
  emit_print_query_plan_stat_proc(&output_buf);
  emit_print_query_plan_graph_proc(&output_buf);
  emit_print_query_plan(&output_buf);

  bprintf(&output_buf, "PROC query_plan()\n");
  bprintf(&output_buf, "BEGIN\n");
  bprintf(&output_buf, "  CALL create_schema();\n");
  bprintf(&output_buf, "  TRY\n");
  bprintf(&output_buf, "    CALL populate_no_table_scan();\n");
  bprintf(&output_buf, "  CATCH\n");
  bprintf(&output_buf, "    CALL printf(\"failed populating no_table_scan table\\n\");\n");
  bprintf(&output_buf, "    THROW;\n");
  bprintf(&output_buf, "  END;\n");

  for (uint32_t i = 1; i <= sql_stmt_count; i++) {
    bprintf(&output_buf, "  TRY\n");
    bprintf(&output_buf, "    CALL populate_query_plan_%d();\n", i);
    bprintf(&output_buf, "  CATCH\n");
    bprintf(&output_buf, "    CALL printf(\"failed populating query %d\\n\");\n", i);
    bprintf(&output_buf, "    THROW;\n");
    bprintf(&output_buf, "  END;\n");
  }

  bprintf(&output_buf, "  CALL printf(\"{\\n\");\n");
  bprintf(&output_buf, "  CALL print_query_violation();\n");
  bprintf(&output_buf, "  CALL printf(\"\\\"plans\\\" : [\\n\");\n");
  bprintf(&output_buf, "  LET q := 1;\n");
  bprintf(&output_buf, "  WHILE q <= %d\n", sql_stmt_count);
  bprintf(&output_buf, "  BEGIN\n");
  bprintf(&output_buf, "    CALL printf(\"%%s\", IIF(q == 1, \"\", \",\\n\"));\n");
  bprintf(&output_buf, "    CALL print_query_plan(q);\n");
  bprintf(&output_buf, "    SET q := q + 1;\n");
  bprintf(&output_buf, "  END;\n");
  bprintf(&output_buf, "  CALL printf(\"\\n]\\n\");\n");
  bprintf(&output_buf, "  CALL printf(\"}\");\n");

  bprintf(&output_buf, "END;\n");

  cql_write_file(options.file_names[0], output_buf.ptr);
  goto cleanup;

cleanup:
  CHARBUF_CLOSE(output_buf);
  CHARBUF_CLOSE(backed_tables_buf);
  CHARBUF_CLOSE(schema_stmts_buf);
  CHARBUF_CLOSE(query_plans_buf);
  SYMTAB_CLEANUP(cg_stmts);
  SYMTAB_CLEANUP(virtual_tables);

  // Force the globals to null state so that they do not look like roots to LeakSanitizer
  // all of these should have been freed already.  This is the final safety net to prevent
  // non-reporting of leaks.

  backed_tables = NULL;
  schema_stmts = NULL;
  query_plans = NULL;
  cg_qp_callbacks = NULL;
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_STATS)

// stubs to avoid link errors
cql_noexport void cg_stats_main(struct ast_node *root) {}

#else


static CSTR cg_stats_current_proc;
static symtab *stats_table;
static charbuf *stats_output;
static symtab *stats_stoplist;

// Recursively walk the AST and accumulate stats The stats are accumulated in a
// symtab where the key is the type of the node and the value is the count of
// that type of node. The stoplist is used to avoid accumulating stats for nodes
// that are present in large numbers.
static void cg_stats_accumulate(ast_node *node) {

  CSTR type = node->type;

  if (!symtab_find(stats_stoplist, type)) {
    symtab_entry *entry = symtab_find(stats_table, type);

    if (!entry) {
      symtab_add(stats_table, type, (void *)(intptr_t)1);
    }
    else {
      // swizzle an int out of the generic storage
      intptr_t val = (intptr_t)entry->val;
      val++;
      entry->val = (void *)val;
    }
  }

  // Check the left and right nodes.
  if (ast_has_left(node)) {
    cg_stats_accumulate(node->left);
  }

  if (ast_has_right(node)) {
    cg_stats_accumulate(node->right);
  }
}

// Create a CSV chunk with the stats for each procedure. The CSV chunk has the
// following format: "procedure_name","node_type",count. The CSV chunk is
// appended to the stats_output charbuf.  The rows are sorted by node type.
// The stats are accumulated in a symtab where the key is the type of the node
// and the value is the count of that type of node.
static void cg_stats_create_proc_stmt(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  // This is only interesting for debugging, in case of crash the name is useful
  // and can be dumped to the console.
  cg_stats_current_proc = name;

  stats_table = symtab_new();

  cg_stats_accumulate(ast);

  // we can get the size of the symtab without walking it, then we get the
  // sorted payload using the helper.  This makes a copy of the payload
  uint32_t count = stats_table->count;
  symtab_entry *stats = symtab_copy_sorted_payload(stats_table, default_symtab_comparator);

  for (uint32_t i = 0; i < count; i++) {
  // At this point we just walk the payload entries and write them out
    symtab_entry *entry = &stats[i];
    bprintf(stats_output, "\"%s\",\"%s\",%lld\n", name, entry->sym, (llint_t)entry->val);
  }

  // cleanup
  free(stats);
  symtab_delete(stats_table);

  // clear the current symbol table so that we don't accidentally use it
  // and so we detect any data that leaks from it in ASAN mode.
  stats_table = NULL;
}

// walk the main statement list looking for create proc statements, enter those
// and accumulate stats.
static void cg_stats_stmt_list(ast_node *head) {
  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_STMT(stmt, ast);

    if (is_ast_create_proc_stmt(stmt)) {
      cg_stats_create_proc_stmt(stmt);
    }
  }
}

// Create a stoplist of nodes that are not interesting for stats. The stoplist
// is a symtab where the key is the type of the node and the value is NULL.
// The stoplist is used to avoid accumulating stats for nodes that are present
// in large numbers and also for nodes that always come as part of a set of
// related nodes, e.g. "select_having" is always present when "select" is.
static void cg_stoplist() {
  stats_stoplist = symtab_new();

  symtab *s = stats_stoplist;

  // These are optional containers that are always present
  // their child is the interesting node, e.g. "opt_having" might be present
  // "select_having" is always present
  symtab_add(s, "select_having", NULL);
  symtab_add(s, "select_where", NULL);
  symtab_add(s, "select_offset", NULL);
  symtab_add(s, "select_groupby", NULL);
  symtab_add(s, "select_orderby", NULL);
  symtab_add(s, "select_limit", NULL);
  symtab_add(s, "select_from_etc", NULL);
  symtab_add(s, "table_or_subquery_list", NULL);
  symtab_add(s, "groupby_list", NULL);
  symtab_add(s, "name_list", NULL);
  symtab_add(s, "arg_list", NULL);
  symtab_add(s, "call_arg_list", NULL);
  symtab_add(s, "join_target_list", NULL);
  symtab_add(s, "insert_list", NULL);
  symtab_add(s, "case_list", NULL);
  symtab_add(s, "update_list", NULL);
  symtab_add(s, "col_key_list", NULL);
  symtab_add(s, "cte_binding_list", NULL);

  // These are list holders, the list isn't interesting, the items are
  symtab_add(s, "select_core_list", NULL);
  symtab_add(s, "select_expr_list_con", NULL);
  symtab_add(s, "select_expr_list", NULL);
  symtab_add(s, "expr_list", NULL);

  // These are just wrappers
  symtab_add(s, "proc_params_stmts", NULL);
}

// The main entry point for the stats code generation. This function is called
// from the main entry point of the compiler. The function first checks for
// semantic errors and then calls cg_stats_stmt_list to walk the AST and
// accumulate stats. The stats are then written to a file.
// * The file name is the first file name in the options struct.
// * The file is written in CSV format with the following columns:
//   * "procedure_name","node_type",count
// * The procedures are emitted in declaration order.
// * The nodes are sorted by node type for each procedure.
//
// Note that the global variables are reset after execution to ensure that leaks
// are reported accurately by ASAN.  Also, so that if this code runs more than
// once in a single process, we don't accidentally accumulate stats from the
// previous run.  This is possible in the alamgam case, the amlagamated code is
// linked into some harness and might run multiple times in the same process.
cql_noexport void cg_stats_main(struct ast_node *root) {
  Contract(options.file_names_count == 1);
  cql_exit_on_semantic_errors(root);
  exit_on_validating_schema();

  cg_stoplist();

  CHARBUF_OPEN(output);

  stats_output = &output;

  cg_stats_stmt_list(root);

  cql_write_file(options.file_names[0], output.ptr);

  CHARBUF_CLOSE(output);
  stats_output = NULL;

  symtab_delete(stats_stoplist);
  stats_stoplist = NULL;
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SCHEMA)

// stubs to avoid link errors
cql_noexport void cg_schema_main(ast_node *head) {}
cql_noexport void cg_schema_upgrade_main(ast_node *head) {}
cql_noexport void cg_schema_sqlite_main(ast_node *head) {}

#else

// Creates schema migration assets


static void cg_generate_schema_by_mode(charbuf *output, int32_t mode);
static void cg_generate_baseline_tables(charbuf *output);
static void cg_schema_emit_baseline_tables_proc(charbuf *output, charbuf *baseline);
static void cg_schema_manage_views(charbuf *output, int32_t *drops, int32_t *creates);
static void cg_schema_manage_triggers(charbuf *output, int32_t *drops, int32_t *creates);
static void cg_schema_manage_indices(charbuf *output, int32_t *drops, int32_t *creates);
static void cg_schema_manage_recreate_tables(charbuf *output, charbuf *decls, recreate_annotation *recreates, size_t count);

// We declare all schema we might depend on in this upgrade (this is the include list)
// e.g. we need all our dependent tables so that we can legally use them in an FK
#define SCHEMA_TO_DECLARE 1

// We only emit schema that we are actually updating (this is include - exclude)
// e.g. a table on the exclude list is assumed to be upgraded by its own script
// in a different run.
#define SCHEMA_TO_UPGRADE 2

// We get TEMP items IF and ONLY IF this bit is set
#define SCHEMA_TEMP_ITEMS 4

// We emit for SQLite in this mode
#define SCHEMA_FOR_SQLITE 8

// Supress virtual table output if this bit is set
#define SCHEMA_SUPRESS_VIRTUAL_TABLES 16

// Rather than burning a new flag bit for tables for this one purpose
// we can steal a bit that is useless on tables, tables can't be "notnull"
// we'll use this flag to remember if the table is presently in the unsubscribed
// state as we move through the upgrade process.
#define SCHEMA_FLAG_UNSUB SEM_TYPE_NOTNULL

static void cg_schema_name_as_cql_string(charbuf *output, ast_node *ast) {
  EXTRACT_STRING(name, ast);
  if (is_qid(ast)) {
    cg_decode_qstr(output, name);
  }
  else {
    bprintf(output, "%s", name);
  }
}

static void cg_schema_name_quoted(charbuf *output, ast_node *ast) {
  EXTRACT_STRING(name, ast);
  CHARBUF_OPEN(tmp);
  if (is_qid(ast)) {
    cg_unquote_encoded_qstr(&tmp, name);
  }
  else {
    bprintf(&tmp, "%s", name);
  }
  cg_encode_c_string_literal(tmp.ptr, output);
  CHARBUF_CLOSE(tmp);
}


// If the mode is SCHEMA_TO_DECLARE then we include all the regions we are upgrading
// and all their dependencies.
//
// If the mode is SCHEMA_TO_UPGRADE then we include the above but we reject
// anything on the exclude list.  That list corresponds to things that are upgraded
// elsewhere.
static bool_t include_from_region(CSTR region, int32_t mode) {

  // if the object is in no region then we only include it if included regions is unconstrained.
  // a no-region object can't be excluded, so this test is all we need for no region objects.
  if (region == NULL) {
    return included_regions == NULL;
  }

  // if included regions were specified and this region isn't in the list... it's out
  if (included_regions && !symtab_find(included_regions, region)) {
    return false;
  }

  // if we are making the "stuff we plan to upgrade list" then consider the excluded regions
  // if this region is on the list, it's out.
  if (mode & SCHEMA_TO_UPGRADE) {
    if (excluded_regions && symtab_find(excluded_regions, region)) {
      return false;
    }
  }

  return true;
}

// Sort the annotations in place: the order is:
//  * schema version
//  * annotation types (all creates before deletes)
//  * table name
//  * column ordinal
//  * there can be no ties, the above is a unique annotation key
// patternlint-disable-next-line prefer-sized-ints-in-msys
static int annotation_comparator(const void *v1, const void *v2) {
  const schema_annotation *a1 = (const schema_annotation *)v1;
  const schema_annotation *a2 = (const schema_annotation *)v2;

  if (a1->version < a2->version) return -1;
  if (a1->version > a2->version) return 1;
  if (a1->annotation_type < a2->annotation_type) return -1;
  if (a1->annotation_type > a2->annotation_type) return 1;

  // equality is not an option
  Invariant(a1->ordinal != a2->ordinal);

  switch (a1->annotation_type) {
    case SCHEMA_ANNOTATION_DELETE_TRIGGER:
    case SCHEMA_ANNOTATION_DELETE_VIEW:
    case SCHEMA_ANNOTATION_DELETE_INDEX:
    case SCHEMA_ANNOTATION_DELETE_COLUMN:
    case SCHEMA_ANNOTATION_DELETE_TABLE:
      // deletes need to happen in the opposite order from declaration
      return (a1->ordinal < a2->ordinal) ? 1 : -1;
  }

  // other operations happen in the order of declaration
  return (a1->ordinal < a2->ordinal) ? -1 : 1;
}

// Sort the @recreate annotations in place: the order is:
//  * group ordinal
//  * ordinal
//
//  We use topological order for groups. recreate_group_deps holds (parent->child) edges
//  and has no cycles. If we perform a topological sort where we assign smallest numbers
//  to the inner-most nodes, we can upgrade groups in the reverse order of these assignments.
//  That way we always have most parent-like groups running before any of their dependencies.
//
//  We sort with create order for table ordinal and pass in create order
//  table creation statements to cql_rebuild_recreate_groups. Inside this
//  function, we iterate the list in reverse to drop tables that are weak first and strong last.
//  That is the later tables may have FK to the earlier tables but not the reverse. We don't want
//  to cause FK action for no reason since the whole group is being dropped anyway.

// patternlint-disable-next-line prefer-sized-ints-in-msys
static int recreate_comparator(const void *v1, const void *v2) {
  const recreate_annotation *a1 = (const recreate_annotation *)v1;
  const recreate_annotation *a2 = (const recreate_annotation *)v2;

  // We need group ordinal to be in create order so that we blow away
  // strongest groups (groups that other groups depend on) first
  if (a1->group_ordinal != a2->group_ordinal) {
    return (a1->group_ordinal < a2->group_ordinal) ? 1 : -1;
  }

  // It can't be a tie! ordinal is unique!
  Invariant(a1->ordinal != a2->ordinal);

  return (a1->ordinal < a2->ordinal) ? -1 : 1;
}

// Emit the template for ending the upgrade to a particular schema version.
static void cg_schema_end_version(
  charbuf *output,
  charbuf *upgrade,
  charbuf *pending,
  uint32_t vers)
{
  if (pending->used > 1) {
    bprintf(upgrade, "    -- data migration procedures\n");
    bprintf(upgrade, "%s", pending->ptr);
    bprintf(upgrade, "\n");
  }

  if (upgrade->used > 1) {
    bprintf(output, "    ---- upgrade to schema version %d ----\n\n", vers);
  }

  if (upgrade->used > 1) {
    bprintf(output, "%s", upgrade->ptr);
  }

  bclear(pending);
  bclear(upgrade);
}

// This is the callback method handed to the gen_ method that creates SQL for us
// it will call us every time it a col definition to give us a chance to suppress it
static bool_t cg_suppress_new_col_def(ast_node *ast, void *context, charbuf *buffer) {
  Contract(is_ast_col_def(ast));
  Contract(ast->sem);

  // any column created in not the original schema is not emitted when creating the table during migration
  // later migration steps will add these columns
  return ast->sem->create_version != -1;
}

// This is the callback method handed to the gen_ method to force a
// IF NOT EXISTS qualifier on create table statements.
static bool_t cg_schema_force_if_not_exists(ast_node *ast, void *context, charbuf *output) {
  bprintf(output, "IF NOT EXISTS ");
  return true;
}

// Emit the helper procedures for the upgrade
static void cg_schema_helpers(charbuf *decls) {
  bprintf(decls, "-- facets table declaration --\n");
  bprintf(decls, "CREATE TABLE IF NOT EXISTS %s_cql_schema_facets(\n", global_proc_name);
  bprintf(decls, "  facet TEXT NOT NULL PRIMARY KEY,\n");
  bprintf(decls, "  version LONG INTEGER NOT NULL\n");
  bprintf(decls, ");\n\n");

  bprintf(decls, "-- rebuilt_tables table declaration --\n");
  bprintf(decls, "CREATE TEMP TABLE IF NOT EXISTS cql_schema_rebuilt_tables(\n");
  bprintf(decls, "  rebuild_facet TEXT NOT NULL \n");
  bprintf(decls, ");\n\n");

  // Note this procedure has to handle the case where the table doesn't exist yet for retro-version validation
  // (this happens in test code so it's validated)
  // We still use the IF NOTHING THEN -1 pattern so that it doesn't produce spurious errors when there is no row, that's not an error.

  bprintf(decls, "-- helper proc for getting the schema version of a facet\n");

  bprintf(decls, "PROC %s_cql_get_facet_version(_facet TEXT NOT NULL, out _version LONG INTEGER NOT NULL)\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  TRY\n");
  bprintf(decls, "    SET _version := (SELECT version FROM %s_cql_schema_facets WHERE facet = _facet LIMIT 1 IF NOTHING THEN -1);\n", global_proc_name);
  bprintf(decls, "  CATCH\n");
  bprintf(decls, "    SET _version := -1;\n"); // this is here to handle the case where the table doesn't exist
  bprintf(decls, "  END;\n");
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- saved facets table declaration --\n");
  bprintf(decls, "CREATE TEMP TABLE %s_cql_schema_facets_saved(\n", global_proc_name);
  bprintf(decls, "  facet TEXT NOT NULL PRIMARY KEY,\n");
  bprintf(decls, "  version LONG INTEGER NOT NULL\n");
  bprintf(decls, ");\n\n");

  bprintf(decls, "-- holds all the table definitions out of sqlite_master\n");
  bprintf(decls, "DECLARE %s_tables_dict_ OBJECT<cql_string_dictionary>;\n\n", global_proc_name);

  bprintf(decls, "-- helper proc for creating the dictionary of table defs from sqlite_master\n");
  bprintf(decls, "[[private]]\n");
  bprintf(decls, "PROC %s_get_table_defs()\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  DECLARE C CURSOR FOR SELECT name, sql from sqlite_master where type = 'table';\n");
  bprintf(decls, "  SET %s_tables_dict_ := cql_string_dictionary_create();\n", global_proc_name);
  bprintf(decls, "  LOOP FETCH C\n");
  bprintf(decls, "  BEGIN\n");
  bprintf(decls, "    IF C.sql IS NOT NULL THEN\n");
  bprintf(decls, "      LET added := cql_string_dictionary_add(%s_tables_dict_, C.name, C.sql);\n", global_proc_name);
  bprintf(decls, "    END IF;\n");
  bprintf(decls, "  END;\n");
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc for creating the schema version table\n");
  bprintf(decls, "[[private]]\n");
  bprintf(decls, "PROC %s_create_cql_schema_facets_if_needed()\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  CREATE TABLE IF NOT EXISTS %s_cql_schema_facets(\n", global_proc_name);
  bprintf(decls, "    facet TEXT NOT NULL PRIMARY KEY,\n");
  bprintf(decls, "    version LONG INTEGER NOT NULL\n");
  bprintf(decls, "  );\n");
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc for creating the rebuilt facets table\n");
  bprintf(decls, "[[private]]\n");
  bprintf(decls, "PROC %s_create_cql_schema_rebuilt_tables_if_needed()\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  CREATE TEMP TABLE IF NOT EXISTS cql_schema_rebuilt_tables(\n");
  bprintf(decls, "    rebuild_facet TEXT NOT NULL\n");
  bprintf(decls, "  );\n");
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc for saving the schema version table\n");
  bprintf(decls, "[[private]]\n");
  bprintf(decls, "PROC %s_save_cql_schema_facets()\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  DROP TABLE IF EXISTS %s_cql_schema_facets_saved;\n", global_proc_name);
  bprintf(decls, "  CREATE TEMP TABLE %s_cql_schema_facets_saved(\n", global_proc_name);
  bprintf(decls, "    facet TEXT NOT NULL PRIMARY KEY,\n");
  bprintf(decls, "    version LONG INTEGER NOT NULL\n");
  bprintf(decls, "  );\n");
  bprintf(decls, "  INSERT INTO %s_cql_schema_facets_saved\n",  global_proc_name);
  bprintf(decls, "    SELECT * FROM %s_cql_schema_facets;\n", global_proc_name);
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc for setting the schema version of a facet\n");
  bprintf(decls, "PROC %s_cql_set_facet_version(_facet TEXT NOT NULL, _version LONG INTEGER NOT NULL)\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  INSERT OR REPLACE INTO %s_cql_schema_facets (facet, version) VALUES(_facet, _version);\n", global_proc_name);
  bprintf(decls, "  LET added := cql_facet_upsert(%s_facets, _facet, _version);\n", global_proc_name);
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc for getting the schema version CRC for a version index\n");
  bprintf(decls, "[[private]]\n");
  bprintf(decls, "PROC %s_cql_get_version_crc(_v INTEGER NOT NULL, out _crc LONG INTEGER NOT NULL)\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  SET _crc := cql_facet_find(%s_facets, printf('cql_schema_v%%d', _v));\n", global_proc_name);
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc for setting the schema version CRC for a version index\n");
  bprintf(decls, "PROC %s_cql_set_version_crc(_v INTEGER NOT NULL, _crc LONG INTEGER NOT NULL)\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  INSERT OR REPLACE INTO %s_cql_schema_facets (facet, version) VALUES('cql_schema_v'||_v, _crc);\n", global_proc_name);
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc to reset any triggers that are on the old plan --\n");
  bprintf(decls, "DECLARE PROCEDURE cql_exec_internal(sql TEXT NOT NULL) USING TRANSACTION;\n\n");

  bprintf(decls, "PROC %s_drop_table_helper(table_name TEXT NOT NULL)\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  CALL cql_exec_internal(printf('DROP TABLE IF EXISTS [%%s]', table_name));\n");
  bprintf(decls, "  -- remove the table from our dictionary marking it dropped\n");
  bprintf(decls, "  IF %s_tables_dict_ IS NULL THROW;\n", global_proc_name);
  bprintf(decls, "  LET added := cql_string_dictionary_add(%s_tables_dict_, table_name, '');\n", global_proc_name);
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc to insert facet into cql_rebuilt_tables --\n");
  bprintf(decls, "PROC %s_rebuilt_tables_insert_helper(facet TEXT NOT NULL)\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  INSERT INTO cql_schema_rebuilt_tables VALUES(facet);\n");
  bprintf(decls, "END;\n\n");

  bprintf(decls, "-- helper proc to delete facet from cql_schema_facets_saved table --\n");
  bprintf(decls, "PROC %s_cql_schema_delete_saved_facet(delete_facet TEXT NOT NULL)\n", global_proc_name);
  bprintf(decls, "BEGIN\n");
  bprintf(decls, "  DELETE FROM %s_cql_schema_facets_saved WHERE facet = delete_facet;\n", global_proc_name);
  bprintf(decls, "END;\n\n");
}

// Emit the delcaration of the sqlite_master table so we can read from it.
static void cg_schema_emit_sqlite_master(charbuf *decls) {
  bprintf(decls, "-- declare sqlite_master -- \n");
  bprintf(decls, "CREATE TABLE sqlite_master (\n");
  bprintf(decls, "  type TEXT NOT NULL,\n");          // The type of database object such as table, index, trigger or view.
  bprintf(decls, "  name TEXT NOT NULL,\n");          // The name of the database object.
  bprintf(decls, "  tbl_name TEXT NOT NULL,\n");      // The table name that the database object is associated with.
  bprintf(decls, "  rootpage INTEGER NOT NULL,\n");   // Root page.
  bprintf(decls, "  sql TEXT\n);\n\n");      // the DDL to CREATE this object
}

static void cg_schema_emit_facet_functions(charbuf *decls) {
  bprintf(decls, "-- declare facet helpers-- \n");
  bprintf(decls, "DECLARE facet_data TYPE OBJECT<facet_data>;\n");
  bprintf(decls, "DECLARE %s_facets facet_data;\n", global_proc_name);
  bprintf(decls, "DECLARE FUNCTION cql_facets_create() create facet_data not null;\n");
  bprintf(decls, "DECLARE FUNCTION cql_facet_add(facets facet_data, facet TEXT NOT NULL, crc LONG NOT NULL) BOOL NOT NULL;\n");
  bprintf(decls, "DECLARE FUNCTION cql_facet_upsert(facets facet_data, facet TEXT NOT NULL, crc LONG NOT NULL) BOOL NOT NULL;\n");
  bprintf(decls, "DECLARE FUNCTION cql_facet_find(facets facet_data, facet TEXT NOT NULL) LONG NOT NULL;\n\n");
}

static void cg_schema_emit_recreate_update_functions(charbuf *decls) {
  bprintf(decls, "-- declare recreate update helpers-- \n");
  bprintf(decls, "DECLARE PROCEDURE cql_rebuild_recreate_group (tables TEXT NOT NULL, indices TEXT NOT NULL, deletes TEXT NOT NULL, out result BOOL NOT NULL) USING TRANSACTION;\n");
}

// Emit all tables versioned as they before modifications, just the original items
// Note these items correspond to create version -1 (no annotation)
// See cg_generate_baseline_tables for more details on which tables are included
// (e.g. not temp, not @recreate)
static void cg_schema_emit_baseline_tables_proc(charbuf *output, charbuf *baseline) {
  cg_generate_baseline_tables(baseline);

  if (baseline->used > 1 && options.min_schema_version == 0) {
    bprintf(output, "PROC %s_cql_install_baseline_schema()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bindent(output, baseline, 2);
    bprintf(output, "END;\n");
  }
}

// Emit all temp schema
static bool_t cg_schema_emit_temp_schema_proc(charbuf *output) {
  CHARBUF_OPEN(temp_schema);

  cg_generate_schema_by_mode(&temp_schema, SCHEMA_TO_UPGRADE | SCHEMA_TEMP_ITEMS);
  bool_t has_temp_schema = temp_schema.used > 1;

  if (has_temp_schema) {
    bprintf(output, "PROC %s_cql_install_temp_schema()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bindent(output, &temp_schema, 2);
    bprintf(output, "END;\n");
  }

  CHARBUF_CLOSE(temp_schema);

  return has_temp_schema;
}

// This handles any schema that has no version number associated with it.  That is
// all the things that were in the original schema before @create/@delete annotations
// started being used.  Once we're done with  the original items for the baseline,
// the normal processing of deltas for will take care of the rest.
//
// We emit create table statements for all non-temp tables that are
// are in the original version (version -1).  Note that any @created
// table is not on this list... Likewise @recreate tables are not here
// they are on their own plan.
//
// Note: we don't have to deal with indices, triggers, or views they are always
// on the @recreate plan.  So this is tables exclusively.
static void cg_generate_baseline_tables(charbuf *output) {
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.col_def_callback = cg_suppress_new_col_def;
  callbacks.if_not_exists_callback = cg_schema_force_if_not_exists;
  callbacks.mode = gen_mode_no_annotations;

  for (list_item *item = all_tables_list; item; item = item->next) {
    ast_node *ast = item->ast;
    ast_node *ast_output = ast;

    Invariant(is_ast_create_table_stmt(ast));

    if (is_virtual_ast(ast)) {
      // virtual tables are always on the recreate plan
      continue;
    }

    if (!include_from_region(ast->sem->region, SCHEMA_TO_UPGRADE)) {
      continue;
    }

    EXTRACT_NOTNULL(create_table_name_flags, ast->left);
    EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
    EXTRACT_OPTION(flags, table_flags_attrs->left);

    // the cases we might have to skip a table are pulled out to get better code coverage detail
    // the order was selected to give the best (i.e. most painful) test-detection

    if (ast->sem->create_version > 0) {
      continue;
    }

    if (ast->sem->delete_version > 0 ) {
      continue;
    }

    if (ast->sem->unsubscribed ) {
      continue;
    }

    bool_t temp = !!(flags & TABLE_IS_TEMP);
    if (temp) {
      continue;
    }

    bool_t is_non_physical = is_table_not_physical(ast);
    if (is_non_physical) {
      continue;
    }

    if (ast->sem->recreate) {
      continue;
    }

    gen_set_output_buffer(output);
    gen_statement_with_callbacks(ast_output, &callbacks);
    bprintf(output, ";\n\n");
  }
}

// We use this entry point to create the schema definitions we will
// CRC to see if there is an update.  We also use this to create the
// declarations we will need to have all schema objects available to the upgrade.
// Note that in an upgrade script there are loose declarations AND
// DDL inside of procs.  In schema upgrade mode we do not error on that.
// The normal situation is that there must be exactly one DDL fragment
// for one object.
static void cg_generate_schema_by_mode(charbuf *output, int32_t mode) {

  // non-null-callbacks will generate SQL for Sqlite (no attributes)
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_no_annotations;

  // If the mode is SCHEMA_TO_DECLARE then we include all the regions we are upgrading
  // and all their dependencies.  We do not exclude things that are upgraded elsewhere.
  // We do this because we need a logically consistent set of declarations.

  // If the mode is SCHEMA_TO_UPGRADE then we include the above but we reject
  // anything on the exclude list.  That list corresponds to things that are upgraded
  // elsewhere.  Here we do not need schema that has consistent declarations but rather
  // canonical schema that we can checksum for changes. SCHEMA_TO_UPGRADE won't compile
  // because it's missing dependencies.

  // If the mode includes SCHEMA_TEMP_ITEMS then we emit only temp items
  // otherwise we emit only NON temp items.
  bool_t temp_required = !!(mode & SCHEMA_TEMP_ITEMS);
  bool_t schema_declare = !!(mode & SCHEMA_TO_DECLARE);
  bool_t schema_upgrade = !!(mode & SCHEMA_TO_UPGRADE);
  bool_t schema_sqlite = !!(mode & SCHEMA_FOR_SQLITE);
  bool_t suppress_virtual_tables = !!(mode & SCHEMA_SUPRESS_VIRTUAL_TABLES);

  gen_sql_callbacks *use_callbacks = NULL;

  // full annotations for declarations, no annotations for temp items upgrade
  if (temp_required && schema_upgrade) {
    use_callbacks = &callbacks;
  }

  // sqlite form gets sqlite safe output
  if (schema_sqlite) {
    use_callbacks = &callbacks;
    callbacks.mode = gen_mode_sql;
    callbacks.long_to_int_conv = true;
  }

  // emit all the delare select function statements (they may appear in the SQL)
  if (!temp_required && schema_declare) {
    // select functions are never temp, they go in the main phase
    // we never upgrade them, so they don't go in the upgrade section only the declare section
    // they appear in the previous section and the normal section so on previous validation
    // runs the same declaration will be duplicated.  That's ok, we're tolerant to that now.
    for (list_item *item = all_select_functions_list; item; item = item->next) {
      EXTRACT_ANY_NOTNULL(ast, item->ast);
      Contract(ast && is_select_func(ast));
      gen_set_output_buffer(output);
      gen_statement_and_attributes_with_callbacks(ast, use_callbacks);
      bprintf(output, ";\n\n");
    }

    for (list_item *item = all_regions_list; item; item = item->next) {
      EXTRACT_ANY_NOTNULL(ast, item->ast);
      Contract(is_ast_declare_schema_region_stmt(ast) || is_ast_declare_deployable_region_stmt(ast));
      gen_set_output_buffer(output);
      gen_statement_with_callbacks(ast, use_callbacks);
      bprintf(output, ";\n\n");
    }
  }

  // emit all tables
  for (list_item *item = all_tables_list; item; item = item->next) {
    ast_node *ast = item->ast;
    ast_node *ast_output = ast;

    if (is_virtual_ast(ast)) {
      ast_output = ast->parent;
      Invariant(is_ast_create_virtual_table_stmt(ast_output));
    }

    Invariant(is_ast_create_table_stmt(ast));

    // Note that we do not filter out non-physical tables universally, their type might be mentioned
    // as part of the type descriminator in other parts of schema, so the declaration will stay.
    // They will get the usual region treatment for dependencies.  However, in no case will
    // SQLite ever see these tables.
    if (schema_sqlite && is_table_not_physical(ast)) {
      continue;
    }

    CSTR region = ast->sem->region;

    if (!include_from_region(region, mode)) {
      continue;
    }

    EXTRACT_NOTNULL(create_table_name_flags, ast->left);
    EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
    EXTRACT_OPTION(flags, table_flags_attrs->left);

    bool_t temp = !!(flags & TABLE_IS_TEMP);
    if (temp != temp_required) {
      continue;
    }

    if ( !(is_virtual_ast(ast) && suppress_virtual_tables)) {
      if (region && schema_declare) {
        bprintf(output, "@begin_schema_region %s;\n", region);
      }
      gen_set_output_buffer(output);
      gen_statement_and_attributes_with_callbacks(ast_output, use_callbacks);
      bprintf(output, ";\n");
      if (region && schema_declare) {
        bprintf(output, "@end_schema_region;\n");
      }
      bprintf(output, "\n");
    }
  }

  for (list_item *item = all_views_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_view_stmt(ast));

    CSTR region = ast->sem->region;

    if (!include_from_region(region, mode)) {
      continue;
    }

    EXTRACT_OPTION(flags, ast->left);
    bool_t temp = !!(flags & VIEW_IS_TEMP);
    if (temp != temp_required) {
      continue;
    }

    if (region && schema_declare) {
      bprintf(output, "@begin_schema_region %s;\n", region);
    }

    gen_set_output_buffer(output);
    gen_statement_with_callbacks(ast, use_callbacks);
    bprintf(output, ";\n");

    if (region && schema_declare) {
      bprintf(output, "@end_schema_region;\n");
    }
    bprintf(output, "\n");
  }

  // Indices are never TEMP in Sqlite, so if temp required then skip entirely
  if (!temp_required) {
    for (list_item *item = all_indices_list; item; item = item->next) {
      ast_node *ast = item->ast;
      Invariant(is_ast_create_index_stmt(ast));

      CSTR region = ast->sem->region;

      if (!include_from_region(region, mode)) {
        continue;
      }

      if (region && schema_declare) {
        bprintf(output, "@begin_schema_region %s;\n", region);
      }

      gen_set_output_buffer(output);
      gen_statement_with_callbacks(ast, use_callbacks);
      bprintf(output, ";\n");

      if (region && schema_declare) {
        bprintf(output, "@end_schema_region;\n");
      }
      bprintf(output, "\n");
    }
  }

  for (list_item *item = all_triggers_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_trigger_stmt(ast));

    CSTR region = ast->sem->region;

    if (!include_from_region(region, mode)) {
      continue;
    }

    EXTRACT_OPTION(flags, ast->left);
    bool_t temp = !!(flags & TRIGGER_IS_TEMP);
    if (temp != temp_required) {
      continue;
    }

    if (region && schema_declare) {
      bprintf(output, "@begin_schema_region %s;\n", region);
    }

    gen_set_output_buffer(output);
    gen_statement_with_callbacks(ast, use_callbacks);
    bprintf(output, ";\n");

    if (region && schema_declare) {
      bprintf(output, "@end_schema_region;\n");
    }
    bprintf(output, "\n");
  }

  // there are no "temp" migrations, so don't emit these at all if "temp required" is set
  // likewise if the output is for sqlite these are not processed by sqlite so they should be ignored
  if (!temp_required && !schema_sqlite) {
    for (list_item *item = all_ad_hoc_list; item; item = item->next) {
      ast_node *ast = item->ast;
      Invariant(is_ast_schema_ad_hoc_migration_stmt(ast));

      CSTR region = ast->sem->region;

      if (!include_from_region(region, mode)) {
        continue;
      }

      if (region && schema_declare) {
        bprintf(output, "@begin_schema_region %s;\n", region);
      }

      gen_set_output_buffer(output);
      gen_statement_with_callbacks(ast, use_callbacks);
      bprintf(output, ";\n");

      if (region && schema_declare) {
        bprintf(output, "@end_schema_region;\n");
      }
      bprintf(output, "\n");
    }
  }

  // there are no "temp" unsub, so don't emit these at all if "temp required" is set
  // likewise if the output is for sqlite these are not processed by sqlite so they should be ignored
  if (!temp_required && !schema_sqlite) {
    for (list_item *item = all_subscriptions_list; item; item = item->next) {
      ast_node *ast = item->ast;
      Invariant(is_ast_schema_unsub_stmt(ast));

      CSTR region = ast->sem->region;

      if (!include_from_region(region, mode)) {
        continue;
      }

      if (region && schema_declare) {
        bprintf(output, "@begin_schema_region %s;\n", region);
      }

      gen_set_output_buffer(output);
      gen_statement_with_callbacks(ast, use_callbacks);
      bprintf(output, ";\n");

      if (region && schema_declare) {
        bprintf(output, "@end_schema_region;\n");
      }
      bprintf(output, "\n");
    }
  }
}

static symtab *full_drop_funcs;

static void cg_schema_name_as_sql_string(charbuf *output, ast_node *ast) {
  CHARBUF_OPEN(tmp);
  EXTRACT_STRING(name, ast);
  if (is_qid(ast)) {
    bprintf(&tmp, "[");
    cg_unquote_encoded_qstr(&tmp, name);
    bprintf(&tmp, "]");
  }
  else {
    bprintf(&tmp, "%s", name);
  }

  // escape the string but don't put the surrounding quotes
  // it will be used inside of other strings
  const char *p = tmp.ptr;
  for ( ;*p; p++) {
    if (*p == '\'') bputc(output, *p);
    bputc(output, *p);
  }

  CHARBUF_CLOSE(tmp);
}

// When we are moving a table from the recreate plan to the create plan
// there is a chance that we will find an old version of the table in
// the database.  We want to delete it and anything it depends upon
// so that those things can be recreated on the create plan.  This
// basically means we have to do one last final delete of the table and
// its dependencies.   Here we generate a helper function that does
// this removal, recursively.  We have to also mark any indices so
// destroyed as needing recreation.  We only generate the function
// one time even though it might be called from several locations
// and recursively.
static void emit_full_drop(ast_node *target_ast, charbuf *decls) {
  ast_node *table_name_ast = sem_get_name_ast(target_ast);
  EXTRACT_STRING(target_name, table_name_ast);

  if (symtab_find(full_drop_funcs, target_name)) {
    return;
  }

  CHARBUF_OPEN(table_name_sql);
  cg_schema_name_as_sql_string(&table_name_sql, table_name_ast);

  symtab_add(full_drop_funcs, target_name, NULL);

  list_item *index_list = target_ast->sem->table_info->index_list;

  CHARBUF_OPEN(out);

  bprintf(&out, "\n[[private]]");
  bprintf(&out, "\nPROC %s_%s_full_drop()\n", global_proc_name, target_name);
  bprintf(&out, "BEGIN\n");

  bytebuf *buf = symtab_ensure_bytebuf(ref_sources_for_target_table, target_name);
  size_t ref_count = buf->used / sizeof(ast_node *);
  ast_node **sources = (ast_node **)buf->ptr;

  if (ref_count) {
    bprintf(&out, "  -- drop all dependent tables\n");
  }

  for (uint32_t iref = 0; iref < ref_count; iref++) {
    ast_node *src_ast = sources[iref];

    if (is_ast_create_table_stmt(src_ast)) {
      // we're only looking for FK references here, view references do not affect drop order
      // hence we ignore any non-table dependencies we find in the list

      CSTR src_name = sem_get_name(src_ast);

      // if self linking fk, do not emit
      if (StrCaseCmp(target_name, src_name)) {
        // recurse to get the new delete function, output does not interleave
        // as we are writing into a temp buffer "out"
        emit_full_drop(src_ast, decls);

        // call it...
        bprintf(&out, "  CALL %s_%s_full_drop();\n", global_proc_name, src_name);
      }
    }
  }

  if (ref_count) {
    bprintf(&out, "\n");
  }

  if (index_list) {
    bprintf(&out, "  -- mark indices as having been deleted\n");
  }

  // the indices are logically deleted, blow away the facet
  for (list_item *item = index_list; item; item = item->next) {
    ast_node *index = item->ast;

    EXTRACT_NOTNULL(create_index_on_list, index->left);
    EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);
    EXTRACT_STRING(index_name, index_name_ast);

    bprintf(&out, "  CALL %s_cql_set_facet_version(cql_compressed('%s_index_crc'), -1);\n", global_proc_name, index_name);
  }

  if (index_list) {
    bprintf(&out, "\n");
  }

  bprintf(&out, "  -- drop the target table and mark it dropped\n");
  bprintf(&out, "  CALL %s_drop_table_helper(cql_compressed('%s'));\n", global_proc_name, table_name_sql.ptr);
  bprintf(&out, "END;\n");

  bprintf(decls, "%s", out.ptr);

  CHARBUF_CLOSE(out);
  CHARBUF_CLOSE(table_name_sql);
}

// This entry point is for generating a full image of the declared schema
// this is used to create the "previous" schema for the next run.
cql_noexport void cg_schema_main(ast_node *head) {
  Invariant(options.file_names_count == 1);
  cql_exit_on_semantic_errors(head);

  // Here we're going to output all the necessary declarations for all the schema in the indicated regions.
  CHARBUF_OPEN(output_file);
  bprintf(&output_file, "%s", rt->source_prefix);
  cg_generate_schema_by_mode(&output_file, SCHEMA_TO_DECLARE);
  cql_write_file(options.file_names[0], output_file.ptr);
  CHARBUF_CLOSE(output_file);
}

// This entry point is for generating a full image of the declared schema with no CQL business
// this is used to create a schema declaration for SQLite
cql_noexport void cg_schema_sqlite_main(ast_node *head) {
  Invariant(options.file_names_count == 1);
  cql_exit_on_semantic_errors(head);

  // Here we're going to output all the necessary declarations for all the schema in the indicated regions.
  CHARBUF_OPEN(output_file);
  bprintf(&output_file, "%s", rt->source_prefix);
  cg_generate_schema_by_mode(&output_file, SCHEMA_TO_UPGRADE | SCHEMA_FOR_SQLITE);
  cg_generate_schema_by_mode(&output_file, SCHEMA_TO_UPGRADE | SCHEMA_FOR_SQLITE | SCHEMA_TEMP_ITEMS);
  cql_write_file(options.file_names[0], output_file.ptr);
  CHARBUF_CLOSE(output_file);
}

static void cg_schema_manage_triggers(charbuf *output, int32_t *drops, int32_t *creates) {
  Contract(creates);
  Contract(drops);
  CHARBUF_OPEN(create);
  CHARBUF_OPEN(drop);

  // non-null-callbacks will generate SQL for Sqlite (no attributes)
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_no_annotations;

  *creates = 0;
  *drops = 0;

  for (list_item *item = all_triggers_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_trigger_stmt(ast));

    if (!include_from_region(ast->sem->region, SCHEMA_TO_UPGRADE)) {
      continue;
    }

    EXTRACT_OPTION(flags, ast->left);
    EXTRACT_NOTNULL(trigger_body_vers, ast->right);
    EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
    EXTRACT_NAME_AST(trigger_name_ast, trigger_def->left);
    EXTRACT_STRING(name, trigger_name_ast);
    EXTRACT_NOTNULL(trigger_condition, trigger_def->right);
    EXTRACT_NOTNULL(trigger_op_target, trigger_condition->right);
    EXTRACT_NOTNULL(trigger_target_action, trigger_op_target->right);
    EXTRACT_STRING(table_name, trigger_target_action->left);

    if (flags & TRIGGER_IS_TEMP) {
      continue;
    }


    // We need the table ast for various checks so get it eagerly
    ast_node *table_ast = find_table_or_view_even_deleted(table_name);

    // This covers deleted or unsubscribed
    bool_t table_deleted = is_deleted(table_ast);

    bprintf(&drop, "  DROP TRIGGER IF EXISTS ");
    cg_schema_name_as_cql_string(&drop, trigger_name_ast);
    bprintf(&drop, ";\n");
    (*drops)++;

    // if not deleted, emit the create
    if (!table_deleted && ast->sem->delete_version < 0) {
      gen_set_output_buffer(&create);
      gen_statement_with_callbacks(ast, &callbacks);
      bprintf(&create, ";\n");
      (*creates)++;
    }
  }

  if (options.schema_exclusive) {
    bprintf(output, "\n-- get all the trigger names, store them in a result set\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_get_all_triggers()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "  DECLARE C CURSOR FOR SELECT name from sqlite_master where type = 'trigger';\n");
    bprintf(output, "  LOOP FETCH C\n");
    bprintf(output, "  BEGIN\n");
    bprintf(output, "    OUT UNION C;\n");
    bprintf(output, "  END;\n");
    bprintf(output, "END;\n\n");

    bprintf(output, "-- drop all the triggers using the fetched names\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_drop_all_triggers()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "  DECLARE C CURSOR FOR CALL %s_cql_get_all_triggers();\n", global_proc_name);
    bprintf(output, "  LOOP FETCH C\n");
    bprintf(output, "  BEGIN\n");
    bprintf(output, "    CALL cql_exec_internal(printf('DROP TRIGGER [%%s];', C.name));\n");
    bprintf(output, "  END;\n");
    bprintf(output, "END;\n\n");

    // we always behave as though we have some drops in exclusive mode
    *drops = 1;
  }
  else if (*drops) {
    bprintf(output, "-- drop all the triggers we know\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_drop_all_triggers()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "%s", drop.ptr);
    bprintf(output, "END;\n\n");
  }

  if (*creates) {
    bprintf(output, "-- create all the triggers we know\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_create_all_triggers()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bindent(output, &create, 2);
    bprintf(output, "END;\n\n");
  }

  CHARBUF_CLOSE(drop);
  CHARBUF_CLOSE(create);
}

static void cg_schema_manage_views(charbuf *output, int32_t *drops, int32_t *creates) {
  Contract(creates);
  Contract(drops);
  CHARBUF_OPEN(create);
  CHARBUF_OPEN(drop);

  // non-null-callbacks will generate SQL for Sqlite (no attributes)
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_no_annotations;

  *drops = *creates = 0;

  for (list_item *item = all_views_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_view_stmt(ast));

    if (!include_from_region(ast->sem->region, SCHEMA_TO_UPGRADE)) {
      continue;
    }

    EXTRACT_OPTION(flags, ast->left);
    EXTRACT_NOTNULL(view_and_attrs, ast->right);
    EXTRACT_NOTNULL(view_details_select, view_and_attrs->left);
    EXTRACT_NOTNULL(view_details, view_details_select->left);
    EXTRACT_NAME_AST(name_ast, view_details->left);

    if (flags & VIEW_IS_TEMP) {
      continue;
    }

    bprintf(&drop, "  DROP VIEW IF EXISTS ");
    cg_schema_name_as_cql_string(&drop, name_ast);
    bprintf(&drop, ";\n");
    (*drops)++;

    // This covers deleted or unsubscribed
    bool_t view_deleted = is_deleted(ast);

    if (!view_deleted) {
      gen_set_output_buffer(&create);
      gen_statement_with_callbacks(ast, &callbacks);
      bprintf(&create, ";\n");
      (*creates)++;
    }
  }

  if (options.schema_exclusive) {
    bprintf(output, "\n-- get all the view names, store them in a result set\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_get_all_views()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "  DECLARE C CURSOR FOR SELECT name from sqlite_master where type = 'view';\n");
    bprintf(output, "  LOOP FETCH C\n");
    bprintf(output, "  BEGIN\n");
    bprintf(output, "    OUT UNION C;\n");
    bprintf(output, "  END;\n");
    bprintf(output, "END;\n\n");

    bprintf(output, "-- drop all the views using the fetched names\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_drop_all_views()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "  DECLARE C CURSOR FOR CALL %s_cql_get_all_views();\n", global_proc_name);
    bprintf(output, "  LOOP FETCH C\n");
    bprintf(output, "  BEGIN\n");
    bprintf(output, "    CALL cql_exec_internal(printf('DROP VIEW [%%s];', C.name));\n");
    bprintf(output, "  END;\n");
    bprintf(output, "END;\n\n");

    // we always behave as though we have some drops in exclusive mode
    *drops = 1;
  }
  else if (*drops) {
    bprintf(output, "-- drop all the views we know\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_drop_all_views()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "%s", drop.ptr);
    bprintf(output, "END;\n\n");
  }

  if (*creates) {
    bprintf(output, "-- create all the views we know\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_create_all_views()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bindent(output, &create, 2);
    bprintf(output, "END;\n\n");
  }

  CHARBUF_CLOSE(drop);
  CHARBUF_CLOSE(create);
}

static void cg_schema_manage_indices(charbuf *output, int32_t *drops, int32_t *creates) {
  Contract(creates);
  Contract(drops);
  CHARBUF_OPEN(create);
  CHARBUF_OPEN(drop);
  CHARBUF_OPEN(names);

  // non-null-callbacks will generate SQL for Sqlite (no attributes)
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_no_annotations;

  *drops = *creates = 0;

  for (list_item *item = all_indices_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_index_stmt(ast));

    if (!include_from_region(ast->sem->region, SCHEMA_TO_UPGRADE)) {
      continue;
    }

    Contract(is_ast_create_index_stmt(ast));
    EXTRACT_NOTNULL(create_index_on_list, ast->left);
    EXTRACT_NOTNULL(flags_names_attrs, ast->right);
    EXTRACT_NOTNULL(connector, flags_names_attrs->right);
    EXTRACT_NOTNULL(index_names_and_attrs, connector->left);
    EXTRACT_NOTNULL(indexed_columns, index_names_and_attrs->left);
    EXTRACT(opt_where, index_names_and_attrs->right);
    EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);
    EXTRACT_STRING(index_name, index_name_ast);
    EXTRACT_NAME_AST(table_name_ast, create_index_on_list->right);
    EXTRACT_STRING(table_name, table_name_ast);

    if (names.used > 1) {
      bprintf(&names, ",\n      ");
    }
    else {
      bprintf(&names, "\n      ");
    }
    cg_schema_name_quoted(&names, index_name_ast);

    // We need the table ast for various checks so get it eagerly
    ast_node *table_ast = find_table_or_view_even_deleted(table_name);

    // This covers deleted or unsubscribed
    bool_t table_deleted = is_deleted(table_ast);

    if (table_deleted || ast->sem->delete_version > 0) {
      // delete only, we're done here
      bprintf(&drop, "  DROP INDEX IF EXISTS ");
      cg_schema_name_as_cql_string(&drop, index_name_ast);
      bprintf(&drop, ";\n");
      bprintf(&drop, "  CALL %s_cql_set_facet_version('%s_index_crc', -1);\n", global_proc_name, index_name);
      (*drops)++;
      continue;
    }

    // If this index is attached to a table marked @recreate then we recreate the index with the table
    // as a unit so there is nothing to do here.  The index will be in the same @recreate group as
    // the table if it has one.

    Invariant(table_ast);
    Invariant(table_ast->sem);
    if (table_ast->sem->recreate) {
      // recreate table ... skip it as above.
      continue;
    }

    // drop then recreate after other migrate steps

    CHARBUF_OPEN(make_index);

    gen_set_output_buffer(&make_index);
    gen_statement_with_callbacks(ast, &callbacks);
    bprintf(&make_index, ";\n");

    llint_t index_crc = (llint_t)crc_charbuf(&make_index);

    bprintf(&drop, "  IF cql_facet_find(%s_facets, '%s_index_crc') != %lld THEN\n", global_proc_name, index_name, index_crc);
    bprintf(&drop, "    DROP INDEX IF EXISTS ");
    cg_schema_name_as_cql_string(&drop, index_name_ast);
    bprintf(&drop, ";\n");
    bprintf(&drop, "  END IF;\n");

    bprintf(&create, "  IF cql_facet_find(%s_facets, '%s_index_crc') != %lld THEN\n", global_proc_name, index_name, index_crc);
    bindent(&create, &make_index, 4);
    bprintf(&create, "    CALL %s_cql_set_facet_version('%s_index_crc', %lld);\n", global_proc_name, index_name, index_crc);
    bprintf(&create, "  END IF;\n");

    CHARBUF_CLOSE(make_index);

    // we always have a mutation plan for potentially changed indices so
    // that means there is a drop and a create
    (*creates)++;
    (*drops)++;
  }

  if (options.schema_exclusive) {
    bprintf(output, "\n-- get all the unknown index names, store them in a result set\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_get_unknown_indices()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "  DECLARE C CURSOR FOR SELECT name from sqlite_master where type = 'index'\n");
    bprintf(output, "    AND name NOT LIKE 'sqlite%%'");
    if (names.used > 1) {
      bprintf(output, "\n    AND name NOT IN (%s)", names.ptr);
    }
    bprintf(output, ";\n");
    bprintf(output, "  LOOP FETCH C\n");
    bprintf(output, "  BEGIN\n");
    bprintf(output, "    OUT UNION C;\n");
    bprintf(output, "  END;\n");
    bprintf(output, "END;\n\n");

    bprintf(output, "-- drop all the indices using the fetched names\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_drop_unknown_indices()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "  DECLARE C CURSOR FOR CALL %s_cql_get_unknown_indices();\n", global_proc_name);
    bprintf(output, "  LOOP FETCH C\n");
    bprintf(output, "  BEGIN\n");
    bprintf(output, "    CALL cql_exec_internal(printf('DROP INDEX [%%s];', C.name));\n");
    bprintf(output, "  END;\n");
    bprintf(output, "END;\n\n");

    bprintf(&drop, "  CALL %s_cql_drop_unknown_indices();\n", global_proc_name);

    // we always behave as though we have some drops in exclusive mode
    *drops = 1;
  }

  if (*drops) {
    bprintf(output, "\n-- drop all the indices that are deleted or changing\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_drop_all_indices()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "%s", drop.ptr);
    bprintf(output, "END;\n\n");
  }

  if (*creates) {
    bprintf(output, "-- create all the indices we need\n");
    bprintf(output, "[[private]]\n");
    bprintf(output, "PROC %s_cql_create_all_indices()\n", global_proc_name);
    bprintf(output, "BEGIN\n");
    bprintf(output, "%s", create.ptr);
    bprintf(output, "END;\n\n");
  }

  CHARBUF_CLOSE(names);
  CHARBUF_CLOSE(drop);
  CHARBUF_CLOSE(create);
}

static void cg_schema_add_recreate_table(charbuf *buf, crc_t table_crc, charbuf facet, charbuf update_tables, CSTR table_key)
{
  bprintf(buf, "  IF cql_facet_find(%s_facets, '%s') != %lld THEN\n", global_proc_name,
        facet.ptr, (llint_t)table_crc);
  bprintf(buf, "%s", update_tables.ptr);
  bprintf(buf, "    IF %s_result THEN \n", table_key);
  bprintf(buf, "      CALL %s_rebuilt_tables_insert_helper(\"%s\");\n", global_proc_name, facet.ptr);
  bprintf(buf, "    END IF;\n");
  bprintf(buf, "    CALL %s_cql_set_facet_version('%s', %lld);\n", global_proc_name,
    facet.ptr, (llint_t)table_crc);
  bprintf(buf, "  END IF;\n");

}

// Helper function to emit all table drops from a given recreate group name
static void emit_recreate_group_drops(charbuf *drops_buf, CSTR gname, symtab* recreate_group_drops) {
  bytebuf *buf = symtab_ensure_bytebuf(recreate_group_drops, gname);
  size_t count = buf->used / sizeof(CSTR);
  CSTR *table_names_array = (CSTR *) (buf->ptr);
  // accumulate drops in reverse order because we want drop order and the symtab stored create order
  for (int32_t i = (int32_t)count-1; i >= 0; i--) {
    ast_node *table_ast = find_table_or_view_even_deleted(table_names_array[i]);
    Contract(is_ast_create_table_stmt(table_ast));
    ast_node *table_name_ast = sem_get_name_ast(table_ast);
    bprintf(drops_buf, "  DROP TABLE IF EXISTS ");
    cg_schema_name_as_cql_string(drops_buf, table_name_ast);
    bprintf(drops_buf, ";\n");
  }
}

// Set to keep track of which functions we have emitted group_drops functions for
static symtab *group_drop_funcs;

static void emit_group_drop(CSTR group_name, charbuf *decls, symtab *recreate_group_drops) {
  if (symtab_find(group_drop_funcs, group_name)) {
    return;
  }

  symtab_add(group_drop_funcs, group_name, NULL);

  CHARBUF_OPEN(out);

  bprintf(&out, "\n[[private]]");
  bprintf(&out, "\nPROC %s_%s_group_drop()\n", global_proc_name, group_name);
  bprintf(&out, "BEGIN\n");

  bytebuf *buf = symtab_ensure_bytebuf(recreate_group_deps, group_name);
  size_t ref_count = buf->used / sizeof(CSTR);
  CSTR *dependent_groups = (CSTR *)buf->ptr;

  if (ref_count) {
    bprintf(&out, "  -- drop all dependent tables\n");
  }

  for (uint32_t iref = 0; iref < ref_count; iref++) {
    CSTR src_group = dependent_groups[iref];
    // recurse to get the new delete function, output does not interleave
    // as we are writing into a temp buffer "out"
    emit_group_drop(src_group, decls, recreate_group_drops);

    // call it...
    bprintf(&out, "  CALL %s_%s_group_drop();\n", global_proc_name, src_group);
  }

  if (ref_count) {
    bprintf(&out, "\n");
  }

  emit_recreate_group_drops(&out, group_name, recreate_group_drops);
  bprintf(&out, "END;\n");

  bprintf(decls, "%s", out.ptr);

  CHARBUF_CLOSE(out);
}

static void cg_schema_manage_recreate_tables(
  charbuf *output,
  charbuf *decls,
  recreate_annotation *notes,
  size_t count)
{
  Contract(notes);
  Contract(count);
  // Precompute all recreate group drop table names into a symbol table
  symtab* recreate_group_drops = symtab_new();
  for (size_t i = 0; i < count; i++) {
    recreate_annotation *note = &notes[i];
    ast_node *ast = note->target_ast;
    CSTR table_name = sem_get_name(ast);
    CSTR gname = create_group_id(note->group_name, table_name);
    symtab_append_bytes(recreate_group_drops, gname, &table_name, sizeof(CSTR));
  }

  CHARBUF_OPEN(recreate_without_virtual_tables);
  CHARBUF_OPEN(recreate_only_virtual_tables);
  CHARBUF_OPEN(update_tables);
  CHARBUF_OPEN(update_indices);
  CHARBUF_OPEN(delete_tables);
  CHARBUF_OPEN(pending_table_creates);

  // non-null-callbacks will generate SQL for Sqlite (no attributes)
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_no_annotations;

  crc_t table_crc = 0;

  for (size_t i = 0; i < count; i++) {
    recreate_annotation *note = &notes[i];

    EXTRACT_NOTNULL(recreate_attr, note->annotation_ast);
    EXTRACT(delete_attr, recreate_attr->right);

    ast_node *ast = note->target_ast;
    ast_node *ast_output = ast;

    // this covers either deleted or unsubscribed
    bool_t deleted = is_deleted(ast);

    Invariant(is_ast_create_table_stmt(ast));

    bool_t is_eponymous = false;

    if (is_virtual_ast(ast)) {
      ast_output = ast->parent;
      Invariant(is_ast_create_virtual_table_stmt(ast_output));

      EXTRACT_NOTNULL(module_info, ast_output->left);
      EXTRACT_NOTNULL(create_table_name_flags, ast->left);
      EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
      EXTRACT_OPTION(flags, table_flags_attrs->left);
      is_eponymous = !!(flags & VTAB_IS_EPONYMOUS);
    }

    if (!include_from_region(ast->sem->region, SCHEMA_TO_UPGRADE)) {
      continue;
    }

    if (is_eponymous) {
      // eponymous virtual tables do not get created or deleted
      continue;
    }

    EXTRACT_NOTNULL(create_table_name_flags, ast->left);
    EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
    EXTRACT_STRING(table_name, create_table_name_flags->right);

    // recreate if needed

    CHARBUF_OPEN(make_table);
    if (!deleted) {
      callbacks.mode = gen_mode_sql;
      callbacks.long_to_int_conv = true;
      gen_set_output_buffer(&make_table);
      gen_statement_with_callbacks(ast_output, &callbacks);
      bprintf(&make_table, "; ");
      init_gen_sql_callbacks(&callbacks);
      callbacks.mode = gen_mode_no_annotations;
    }
    else {
      // explicitly drop only tables that are unsubscribed or deleted
      // others dropped inside cql_rebuild_recreate_group
      if (strlen(delete_tables.ptr) != 0) bprintf(&delete_tables, "\n");
      bprintf(&delete_tables, "DROP TABLE IF EXISTS %s;", table_name);
    }

    // if the table is deleted or unsubscribed don't restore its indices
    if (!deleted) {
      list_item *index_list = ast->sem->table_info->index_list;

      // now create the various indices but not the deleted ones
      for (list_item *item = index_list; item; item = item->next) {
        ast_node *index = item->ast;
        // deleted index, don't recreate it
        if (index->sem->delete_version > 0) {
          continue;
        }
        callbacks.mode = gen_mode_sql;
        callbacks.long_to_int_conv = true;
        if (strlen(update_indices.ptr) != 0) bprintf(&update_indices, "\n");
        gen_set_output_buffer(&update_indices);
        gen_statement_with_callbacks(index, &callbacks);
        bprintf(&update_indices, ";");
        init_gen_sql_callbacks(&callbacks);
        callbacks.mode = gen_mode_no_annotations;
      }
    }
    table_crc ^= crc_charbuf(&make_table);
    table_crc ^= crc_charbuf(&delete_tables);
    table_crc ^= crc_charbuf(&update_indices);

    bprintf(&pending_table_creates, "%s", make_table.ptr);
    CHARBUF_CLOSE(make_table);

    CSTR gname = note->group_name;

    // if there is a group and and this node can be merged with the next
    // then hold the update and accumulate the CRC
    if (i + 1 < count && gname[0] && !StrCaseCmp(gname, (note+1)->group_name)) {
      continue;
    }

    bprintf(&update_tables, "%s", pending_table_creates.ptr);
    bclear(&pending_table_creates);

    CHARBUF_OPEN(facet);

    CSTR migrate_key = NULL;

    if (gname[0]) {
      // we're updating the whole group
      bprintf(&facet, "%s_group_crc", gname);
      migrate_key = gname;
    }
    else {
      bprintf(&facet, "%s_table_crc", table_name);
      migrate_key = table_name;
    }
    CHARBUF_OPEN(update_proc);
    CHARBUF_OPEN(migrate_table);
    ast_node *migration = find_recreate_migrator(migrate_key);
    if (migration) {
      EXTRACT_STRING(proc, migration->right);
      bprintf(&migrate_table, "\n    -- recreate migration procedure required\n");
      bprintf(&migrate_table, "    CALL %s();\n\n", proc);

      bprintf(decls, "DECLARE PROC %s() USING TRANSACTION;\n", proc);

      table_crc ^= crc_charbuf(&migrate_table);
    }
    // Construct call to cql_rebuild_recreate_group with CQL compressed strings (with --compress compiler flag)
    // After the call to cql_rebuild_recreate_group() result will hold 1 if we rebuilt and 0 if we recreated the group.
    bprintf(&update_proc, "    LET %s_result := ", migrate_key);
    bprintf(&update_proc, "cql_rebuild_recreate_group(cql_compressed(");
    cg_pretty_quote_compressed_text(update_tables.ptr, &update_proc);
    bprintf(&update_proc, "),\n      cql_compressed(");
    cg_pretty_quote_compressed_text(update_indices.ptr, &update_proc);
    bprintf(&update_proc, "),\n      cql_compressed(");
    cg_pretty_quote_compressed_text(delete_tables.ptr, &update_proc);
    bprintf(&update_proc, "));\n");

    // Case on result to see whether this group recreated or rebuilt.
    // If recreated, then we emit drop statements for all recursive child
    // recreate groups (using recreate_group_deps symtab).
    CSTR group_name = create_group_id(gname, table_name);
    emit_group_drop(group_name, decls, recreate_group_drops);

    CHARBUF_OPEN(child_group_drops);

    bytebuf *drop_buf = symtab_ensure_bytebuf(recreate_group_deps, group_name);
    size_t drop_count = drop_buf->used / sizeof(CSTR);
    CSTR *neighbors = (CSTR *) (drop_buf->ptr);
    for (size_t j = 0; j < drop_count; j++) {
      bprintf(&child_group_drops, "        CALL %s_%s_group_drop();\n", global_proc_name, neighbors[j]);
    }

    if (strlen(child_group_drops.ptr) != 0 || strlen(migrate_table.ptr) != 0) {
      // Code in this if statement will only run for non-rebuilding recreate groups
      bprintf(&update_proc, "    IF NOT %s_result THEN \n", migrate_key);
      bprintf(&update_proc, "%s", child_group_drops.ptr);
      // Updating the CRC for any child group tables we dropped
      for (size_t j = 0; j < drop_count; j++) {
        bprintf(&update_proc, "        CALL %s_cql_set_facet_version('%s_crc', -1L);\n", global_proc_name, neighbors[j]);
        // Need to update initially saved facets table so that the facet table diff that is returned at the end of
        // schema upgrade captures that these child group table facets were recreated.
        bprintf(&update_proc, "        CALL %s_cql_schema_delete_saved_facet('%s_crc');\n", global_proc_name, neighbors[j]);
      }
      // We only want to run recreate group migration procs for non-rebuild cases (i.e. table drop is an assumed prerequisite)
      bindent(&update_proc, &migrate_table, 2);
      bprintf(&update_proc, "    END IF; \n");
    }
    CHARBUF_CLOSE(child_group_drops);

    CHARBUF_CLOSE(migrate_table);
    if (is_virtual_ast(ast)) {
      cg_schema_add_recreate_table(&recreate_only_virtual_tables, table_crc, facet, update_proc, migrate_key);
    }
    else {
      cg_schema_add_recreate_table(&recreate_without_virtual_tables, table_crc, facet, update_proc, migrate_key);
    }
    CHARBUF_CLOSE(update_proc);
    CHARBUF_CLOSE(facet);

    // once we emit, we reset the CRC we've been accumulating and reset the buffer of table recreates, index creates, and table drops
    table_crc = 0;
    bclear(&delete_tables);
    bclear(&update_indices);
    bclear(&update_tables);
  }

  crc_t all_virtual_tables_crc = crc_charbuf(&recreate_only_virtual_tables);
  crc_t all_nonvirtual_tables_crc = crc_charbuf(&recreate_without_virtual_tables);
  bprintf(output, "-- recreate all the non-virtual @recreate tables that might have changed\n");
  bprintf(output, "[[private]]\n");
  bprintf(output, "PROC %s_cql_recreate_non_virtual_tables()\n", global_proc_name);
  bprintf(output, "BEGIN\n");
  bprintf(output, "  IF cql_facet_find(%s_facets, 'all_nonvirtual_tables_crc') == %lld RETURN; \n",
    global_proc_name,
    (llint_t) all_nonvirtual_tables_crc);
  bprintf(output, "%s", recreate_without_virtual_tables.ptr);
  bprintf(output, "  CALL %s_cql_set_facet_version('all_nonvirtual_tables_crc', %lld);\n",
    global_proc_name,
    (llint_t) all_nonvirtual_tables_crc);
  bprintf(output, "END;\n\n");

  bprintf(output, "-- recreate all the virtual @recreate tables that might have changed\n");
  bprintf(output, "[[private]]\n");
  bprintf(output, "PROC %s_cql_recreate_virtual_tables()\n", global_proc_name);
  bprintf(output, "BEGIN\n");
  bprintf(output, "  IF cql_facet_find(%s_facets, 'all_virtual_tables_crc') == %lld RETURN; \n",
    global_proc_name,
    (llint_t) all_virtual_tables_crc);
  bprintf(output, "%s", recreate_only_virtual_tables.ptr);
  bprintf(output, "  CALL %s_cql_set_facet_version('all_virtual_tables_crc', %lld);\n",
    global_proc_name,
   (llint_t) all_virtual_tables_crc);
  bprintf(output, "END;\n\n");

  CHARBUF_CLOSE(pending_table_creates);
  CHARBUF_CLOSE(delete_tables);
  CHARBUF_CLOSE(update_indices);
  CHARBUF_CLOSE(update_tables);
  CHARBUF_CLOSE(recreate_only_virtual_tables);
  CHARBUF_CLOSE(recreate_without_virtual_tables);
  symtab_delete(recreate_group_drops);
}

static int32_t max_group_ordinal = 0;

static void topological_walk_recreate_group_deps_helper(symtab *recreate_group_ordinals, CSTR curr_gname)
{
  symtab_entry *entry = symtab_find(recreate_group_ordinals, curr_gname);
  bytebuf *buf = symtab_ensure_bytebuf(recreate_group_deps, curr_gname);
  size_t count = buf->used / sizeof(CSTR);
  CSTR *neighbors = (CSTR *) (buf->ptr);
  for (size_t i = 0; i < count; i++) {
    symtab_entry *neighbor_entry = symtab_find(recreate_group_ordinals, neighbors[i]);
    // Note: neighbor_entry != NULL
    int32_t neighbor_ordinal = neighbor_entry ? (int32_t) (int64_t) (neighbor_entry->val) : -1;
    // if group has not yet been visited
    if (neighbor_ordinal == -1) {
      topological_walk_recreate_group_deps_helper(recreate_group_ordinals, neighbors[i]);
    }
  }
  entry->val = (void*) (int64_t) (max_group_ordinal++);
}

static void topological_walk_recreate_group_deps(recreate_annotation** recreates, size_t recreate_items_count) {
  // Create temporary symbol table to hold all recreate groups and their ordinal assignments
  symtab *recreate_group_ordinals = symtab_new();
  // Clean out symbol table by initializing all groups to have ordinal = -1
  for (size_t i = 0; i < recreate_group_deps->capacity; i++) {
    symtab_entry entry = recreate_group_deps->payload[i];
    if (entry.sym) {
      symtab_add(recreate_group_ordinals, entry.sym, (void*)(-1));
    }
  }

  // Outer loop: walk all the groups and assign them an ordinal.
  // If they already have one: use it, else: call the recursive function to compute
  // ordinals for this subtree
  for (size_t i = 0; i < recreate_group_ordinals->capacity; i++) {
    symtab_entry entry = recreate_group_ordinals->payload[i];
    if (entry.sym) {
      int32_t ordinal = (int32_t)(int64_t)(entry.val);
      if (ordinal == -1) {
        topological_walk_recreate_group_deps_helper(recreate_group_ordinals, entry.sym);
      }
    }
  }

  // We now assign ordinals to recreate tables based on the symbol table we populated.
  // The value is either already computed, or we compute it now (with max_group_ordinal)
  for (size_t i = 0; i < recreate_items_count; i++) {
    CSTR gname = (*recreates)[i].group_name;
    CSTR table_name = sem_get_name((*recreates)[i].target_ast);
    gname = create_group_id(gname, table_name);
    // We find using the group_name (or if singleton group, table_name)
    symtab_entry *entry = symtab_find(recreate_group_ordinals, gname);
    // Groups without dependencies would not have entries inside this symbol table
    // But these can be recreated in any order, so we can just assign them the next available
    // ordinal value
    if (entry == NULL) {
      (*recreates)[i].group_ordinal = max_group_ordinal;
      symtab_add(recreate_group_ordinals, gname, (void*)(int64_t)max_group_ordinal++);
    }
    else {
      (*recreates)[i].group_ordinal = (int32_t)(int64_t)entry->val;
    }
  }

  // Dispose the symbol table
  symtab_delete(recreate_group_ordinals);
}

static llint_t cg_schema_compute_crc(
    schema_annotation** notes,
    size_t* schema_items_count,
    recreate_annotation** recreates,
    size_t* recreate_items_count,
    int32_t* max_schema_version,
    llint_t * _Nullable schema_crc_non_virtual) {
  // first sort the schema annotations according to version, type etc.
  // we want to process these in an orderly fashion and the upgrade rules
  // are nothing like the declared order.
  void *base = schema_annotations->ptr;
  size_t schema_items_size = sizeof(schema_annotation);
  *schema_items_count = schema_annotations->used / schema_items_size;
  *notes = (schema_annotation*)base;
  *max_schema_version = 0;

  // number them all now that we have the full list, there's no more growing etc.
  // this is the original order of the lists which is declaration order
  // this is used to ensure deletes/creates respect the dependency order
  for (size_t i = 0; i < *schema_items_count; i++) {
    (*notes)[i].ordinal = (int32_t)i;
  }

  if (*schema_items_count) {
     qsort(base, *schema_items_count, schema_items_size, annotation_comparator);
     *max_schema_version = (*notes)[*schema_items_count - 1].version;
  }

  // number recreate groups based on topological order of the recreate FK dependency DAG.
  // "Innermost" recreate groups (leaf nodes in recreate_group_deps) will have the smallest
  // values with this ordering, so they will be recreated first as desired because these
  // tables do not FK to any other tables.


  base = recreate_annotations->ptr;
  size_t recreate_items_size = sizeof(recreate_annotation);
  *recreate_items_count = recreate_annotations->used / recreate_items_size;
  *recreates = (recreate_annotation *)base;
  topological_walk_recreate_group_deps(recreates, *recreate_items_count);

  if (*recreate_items_count) {
    qsort(base, *recreate_items_count, recreate_items_size, recreate_comparator);
  }

  CHARBUF_OPEN(all_schema);
  // emit canonicalized schema for everything we will upgrade
  // this will include the schema declarations for the ad hoc migrations, too;
  cg_generate_schema_by_mode(&all_schema, SCHEMA_TO_UPGRADE);

  // compute the master CRC using schema and migration scripts
  llint_t schema_crc = (llint_t) crc_charbuf(&all_schema);
  CHARBUF_CLOSE(all_schema);

  // compute the non virtual CRC
  if (schema_crc_non_virtual != NULL) {
    CHARBUF_OPEN(all_schema_no_virtual_tables);
    cg_generate_schema_by_mode(&all_schema_no_virtual_tables, SCHEMA_TO_UPGRADE | SCHEMA_SUPRESS_VIRTUAL_TABLES);
    *schema_crc_non_virtual = (llint_t) crc_charbuf(&all_schema_no_virtual_tables);
    CHARBUF_CLOSE(all_schema_no_virtual_tables);
  }
  return schema_crc;
}

// Main entry point for schema upgrade code-gen.
cql_noexport void cg_schema_upgrade_main(ast_node *head) {
  Contract(options.file_names_count == 1);

  cql_exit_on_semantic_errors(head);
  exit_on_no_global_proc();

  schema_annotation* notes;
  size_t schema_items_count;
  recreate_annotation* recreates;
  size_t recreate_items_count;
  int32_t max_schema_version;
  llint_t schema_crc_no_virtual;

  llint_t schema_crc = cg_schema_compute_crc(
    &notes,
    &schema_items_count,
    &recreates,
    &recreate_items_count,
    &max_schema_version,
    &schema_crc_no_virtual);

  full_drop_funcs = symtab_new();

  group_drop_funcs = symtab_new();

  CHARBUF_OPEN(preamble);
  CHARBUF_OPEN(main);
  CHARBUF_OPEN(decls);
  CHARBUF_OPEN(pending);
  CHARBUF_OPEN(upgrade);
  CHARBUF_OPEN(baseline);
  CHARBUF_OPEN(drops);

  bprintf(&decls, "%s", rt->source_prefix);
  bprintf(&decls, "-- no columns will be considered hidden in this script\n");
  bprintf(&decls, "-- DDL in procs will not count as declarations\n");
  bprintf(&decls, "@SCHEMA_UPGRADE_SCRIPT;\n\n");
  bprintf(&decls, "-- schema crc %lld\n\n", schema_crc);

  cg_schema_emit_facet_functions(&decls);
  cg_schema_emit_recreate_update_functions(&decls);
  cg_schema_emit_sqlite_master(&decls);
  bprintf(&decls, "-- declare full schema of tables and views to be upgraded and their dependencies -- \n");
  cg_generate_schema_by_mode(&decls, SCHEMA_TO_DECLARE);
  cg_schema_helpers(&decls);

  bprintf(&decls, "-- declared upgrade procedures if any\n");

  cg_schema_emit_baseline_tables_proc(&preamble, &baseline);

  int32_t view_creates = 0, view_drops = 0;
  cg_schema_manage_views(&preamble, &view_drops, &view_creates);

  int32_t index_creates = 0, index_drops = 0;
  cg_schema_manage_indices(&preamble, &index_drops, &index_creates);

  int32_t trigger_creates = 0, trigger_drops = 0;
  cg_schema_manage_triggers(&preamble, &trigger_drops, &trigger_creates);

  if (recreate_items_count) {
    cg_schema_manage_recreate_tables(&preamble, &decls, recreates, recreate_items_count);
  }

  bool_t has_temp_schema = cg_schema_emit_temp_schema_proc(&preamble);

  // code to read the facets into the hash table

  bprintf(&preamble, "[[private]]\n");
  bprintf(&preamble, "PROC %s_setup_facets()\n", global_proc_name);
  bprintf(&preamble, "BEGIN\n");
  bprintf(&preamble, "  TRY\n");
  bprintf(&preamble, "    SET %s_facets := cql_facets_create();\n", global_proc_name);
  bprintf(&preamble, "    DECLARE C CURSOR FOR SELECT * from %s_cql_schema_facets;\n", global_proc_name);
  bprintf(&preamble, "    LOOP FETCH C\n");
  bprintf(&preamble, "    BEGIN\n");
  bprintf(&preamble, "      LET added := cql_facet_add(%s_facets, C.facet, C.version);\n", global_proc_name);
  bprintf(&preamble, "    END;\n");
  bprintf(&preamble, "  CATCH\n");
  bprintf(&preamble, "    -- if table doesn't exist we just have empty facets, that's ok\n");
  bprintf(&preamble, "  END;\n");
  bprintf(&preamble, "END;\n\n");

  bprintf(&preamble, "DECLARE FUNCTION _cql_contains_column_def(needle TEXT, haystack TEXT) BOOL NOT NULL;\n");

  bprintf(&preamble, "[[private]]\n");
  bprintf(&preamble, "PROC %s_column_exists(table_ TEXT NOT NULL, col_info TEXT NOT NULL, OUT exists_ BOOL NOT NULL)\n", global_proc_name);
  bprintf(&preamble, "BEGIN\n");
  bprintf(&preamble, "  IF %s_tables_dict_ IS NULL THROW;\n", global_proc_name);
  bprintf(&preamble, "  LET table_str := cql_string_dictionary_find(%s_tables_dict_, table_);\n", global_proc_name);
  bprintf(&preamble, "  SET exists_ := _cql_contains_column_def(table_str, col_info);\n");
  bprintf(&preamble, "END;\n\n");

  bprintf(&preamble, "[[private]]\n");
  bprintf(&preamble, "PROC %s_table_exists(table_ TEXT NOT NULL, OUT exists_ BOOL NOT NULL)\n", global_proc_name);
  bprintf(&preamble, "BEGIN\n");
  bprintf(&preamble, "  IF %s_tables_dict_ IS NULL THROW;\n", global_proc_name);
  bprintf(&preamble, "  LET result := cql_string_dictionary_find(%s_tables_dict_, table_);\n", global_proc_name);
  bprintf(&preamble, "  SET exists_ := result IS NOT NULL and result IS NOT '';\n");
  bprintf(&preamble, "END;\n\n");

  // the main upgrade worker

  bprintf(&main, "\n[[private]]\n");
  bprintf(&main, "PROC %s_perform_upgrade_steps(include_virtual_tables BOOL NOT NULL)\n", global_proc_name);
  bprintf(&main, "BEGIN\n");
  bprintf(&main, "  LET facet := cql_compressed('cql_schema_crc_no_virtual');\n");
  bprintf(&main, "  IF cql_facet_find(%s_facets, facet) <> %lld THEN\n", global_proc_name, (llint_t) schema_crc_no_virtual);
  bprintf(&main, "    DECLARE schema_version LONG INTEGER NOT NULL;\n");

  if (view_drops) {
    bprintf(&main, "    -- dropping all views --\n");
    bprintf(&main, "    CALL %s_cql_drop_all_views();\n\n", global_proc_name);
  }

  if (index_drops) {
    bprintf(&main, "    -- dropping condemned or changing indices --\n");
    bprintf(&main, "    CALL %s_cql_drop_all_indices();\n\n", global_proc_name);
  }

  if (trigger_drops) {
    bprintf(&main, "    -- dropping condemned or changing triggers --\n");
    bprintf(&main, "    CALL %s_cql_drop_all_triggers();\n\n", global_proc_name);
  }

  if (options.min_schema_version == 0) {
    if (baseline.used > 1) {
      llint_t baseline_crc = (llint_t)crc_charbuf(&baseline);
      bprintf(&main, "    ---- install baseline schema if needed ----\n\n");
      bprintf(&main, "    CALL %s_cql_get_version_crc(0, schema_version);\n", global_proc_name);
      bprintf(&main, "    IF schema_version != %lld THEN\n", baseline_crc);
      bprintf(&main, "      CALL %s_cql_install_baseline_schema();\n", global_proc_name);
      bprintf(&main, "      CALL %s_cql_set_version_crc(0, %lld);\n", global_proc_name, baseline_crc);
      bprintf(&main, "    END IF;\n\n");
    }
    else {
      // set the baseline schema CRC to -1;  We do this in case full unsub causes baseline
      // to go to nothing and subsequent removal of some unsubs needs to see that it changed.
      bprintf(&main, "      CALL %s_cql_set_version_crc(0, -1);\n", global_proc_name);
    }
  }

  bprintf(&main, "    CALL %s_get_table_defs();\n\n", global_proc_name);

  uint32_t prev_version = 0;

  for (uint32_t i = 0; i < schema_items_count; i++) {
    schema_annotation *note = &notes[i];

    ast_node *version_annotation = note->annotation_ast;

    uint32_t type = note->annotation_type;
    Contract(type >= SCHEMA_ANNOTATION_FIRST && type <= SCHEMA_ANNOTATION_LAST);

    Contract(is_ast_version_annotation(version_annotation));
    EXTRACT_OPTION(vers, version_annotation->left);

    Invariant(note->version == vers);
    Invariant(vers > 0);  // already verified to be positive

    if (vers < options.min_schema_version) {
      continue;
    }

    if (prev_version != vers) {
      cg_schema_end_version(&main, &upgrade, &pending, prev_version);
      prev_version = (uint32_t)vers;
    }

    CSTR target_name = note->target_name;

    Invariant(type >= SCHEMA_ANNOTATION_FIRST && type <= SCHEMA_ANNOTATION_LAST);

    // if the target is out of scope we ignore this directive
    bool_t directive_not_in_scope = !include_from_region(note->target_ast->sem->region, SCHEMA_TO_UPGRADE);

    bool_t subscription_management = type == SCHEMA_ANNOTATION_UNSUB;

    // for unsub the region of the directive must also be in scope
    directive_not_in_scope |= subscription_management && !include_from_region(version_annotation->parent->sem->region, SCHEMA_TO_UPGRADE);

    if (directive_not_in_scope) {
      continue;
    }

    switch (type) {
      case SCHEMA_ANNOTATION_CREATE_COLUMN: {

        // This covers deleted or unsubscribed
        bool_t table_deleted = is_deleted(note->target_ast);

        if (table_deleted) {
          // do not emit the alter table add column if we are currently unsubscribed, or deleted
          continue;
        }

        CHARBUF_OPEN(table_name_sql);
        CHARBUF_OPEN(col_name_sql);
        CHARBUF_OPEN(table_name_cql);
        CHARBUF_OPEN(col_name_cql);

        ast_node *table = note->target_ast;
        Contract(is_ast_create_table_stmt(table));
        ast_node *table_name_ast = sem_get_name_ast(table);

        cg_schema_name_as_sql_string(&table_name_sql, table_name_ast);
        cg_schema_name_as_cql_string(&table_name_cql, table_name_ast);

        ast_node *def = note->column_ast;
        Contract(is_ast_col_def(def));
        ast_node *col_name_ast = sem_get_name_ast(def);

        cg_schema_name_as_sql_string(&col_name_sql, col_name_ast);
        cg_schema_name_as_cql_string(&col_name_cql, col_name_ast);

        CSTR col_type = coretype_string(def->sem->sem_type);
        gen_sql_callbacks callbacks;
        init_gen_sql_callbacks(&callbacks);
        callbacks.mode = gen_mode_no_annotations;

        CHARBUF_OPEN(sql_out);
        gen_set_output_buffer(&sql_out);
        // no-op callbacks still suppress @create/@delete which is not legal in alter table
        gen_col_def_with_callbacks(def, &callbacks);

        bprintf(&upgrade, "    -- altering table %s to add column %s %s;\n\n",
          table_name_sql.ptr,
          col_name_sql.ptr,
          col_type);
        bprintf(&upgrade, "    IF NOT %s_column_exists(cql_compressed('%s'), cql_compressed('%s %s')) THEN \n",
          global_proc_name,
          table_name_sql.ptr,
          col_name_sql.ptr,
          col_type);
        bprintf(&upgrade, "      ALTER TABLE %s ADD COLUMN %s;\n",
          table_name_cql.ptr,
          sql_out.ptr);
        bprintf(&upgrade, "    END IF;\n\n");

        CHARBUF_CLOSE(sql_out);
        CHARBUF_CLOSE(col_name_cql);
        CHARBUF_CLOSE(table_name_cql);
        CHARBUF_CLOSE(col_name_sql);
        CHARBUF_CLOSE(table_name_sql);
        break;
      }

      case SCHEMA_ANNOTATION_DELETE_COLUMN: {
        ast_node *table = note->target_ast;
        Contract(is_ast_create_table_stmt(table));
        ast_node *table_name_ast = sem_get_name_ast(table);

        ast_node *def = note->column_ast;
        Contract(is_ast_col_def(def));
        ast_node *col_name_ast = sem_get_name_ast(def);

        CHARBUF_OPEN(table_name_sql);
        CHARBUF_OPEN(col_name_sql);

        cg_schema_name_as_sql_string(&table_name_sql, table_name_ast);
        cg_schema_name_as_sql_string(&col_name_sql, col_name_ast);

        bprintf(&upgrade, "    -- logical delete of column %s from %s; -- no ddl\n\n",
            col_name_sql.ptr, table_name_sql.ptr);

        CHARBUF_CLOSE(col_name_sql);
        CHARBUF_CLOSE(table_name_sql);
        break;
      }

      case SCHEMA_ANNOTATION_CREATE_TABLE: {
        // check for one time drop

        CHARBUF_OPEN(table_name_sql);

        ast_node *table = note->target_ast;
        Contract(is_ast_create_table_stmt(table));
        ast_node *table_name_ast = sem_get_name_ast(table);

        cg_schema_name_as_sql_string(&table_name_sql, table_name_ast);

        EXTRACT_ANY(dot, version_annotation->right);
        if (dot && is_ast_dot(dot)) {
          EXTRACT_STRING(lhs, dot->left);
          EXTRACT_STRING(rhs, dot->right);

          if (!StrCaseCmp(lhs, "cql") && !StrCaseCmp(rhs, "from_recreate")) {
            emit_full_drop(note->target_ast, &decls);

            bprintf(&upgrade, "    -- one time drop moving to create from recreate %s\n\n", table_name_sql.ptr);
            bprintf(&upgrade, "    SET facet := cql_compressed('1_time_drop_%s');\n", table_name_sql.ptr);
            bprintf(&upgrade, "    IF cql_facet_find(%s_facets, facet) != %d THEN\n", global_proc_name, vers);
            bprintf(&upgrade, "      CALL %s_%s_full_drop();\n", global_proc_name, target_name);
            bprintf(&upgrade, "      CALL %s_cql_set_facet_version(facet, %d);\n", global_proc_name, vers);
            bprintf(&upgrade, "    END IF;\n\n");
          }
        }

        bprintf(&upgrade, "    IF NOT %s_table_exists(cql_compressed('%s')) THEN\n",
                                 global_proc_name, table_name_sql.ptr);
        bprintf(&upgrade, "      -- creating table %s\n\n", table_name_sql.ptr);

        gen_sql_callbacks callbacks;
        init_gen_sql_callbacks(&callbacks);
        callbacks.col_def_callback = cg_suppress_new_col_def;
        callbacks.if_not_exists_callback = cg_schema_force_if_not_exists;
        callbacks.mode = gen_mode_no_annotations;

        CHARBUF_OPEN(sql_out);
        gen_set_output_buffer(&sql_out);
        gen_statement_with_callbacks(note->target_ast, &callbacks);  // only the original columns

        bindent(&upgrade, &sql_out, 6);
        bprintf(&upgrade, ";\n");
        bprintf(&upgrade, "    END IF;\n\n");

        CHARBUF_CLOSE(sql_out);
        CHARBUF_CLOSE(table_name_sql);
        break;
      }

      case SCHEMA_ANNOTATION_DELETE_TABLE: {
        ast_node *table = note->target_ast;
        Contract(is_ast_create_table_stmt(table));
        ast_node *table_name_ast = sem_get_name_ast(table);
        bprintf(&drops, "  DROP TABLE IF EXISTS ");
        cg_schema_name_as_cql_string(&drops, table_name_ast);
        bprintf(&drops, "; --@delete\n");
        break;
      }

      // Note: @create is invalid for INDEX/VIEW/TRIGGER so there can be no such annotation

      case SCHEMA_ANNOTATION_DELETE_INDEX:
      case SCHEMA_ANNOTATION_DELETE_VIEW:
      case SCHEMA_ANNOTATION_DELETE_TRIGGER:
        // no annotation based actions other than migration proc (handled below
        Contract(version_annotation->right);
        bprintf(&upgrade, "      -- delete migration proc for %s will run\n\n", target_name);
        break;

      case SCHEMA_ANNOTATION_UNSUB:
        // @recreate tables do not need unsub, they will just delete like they usually do
        // annotation not generated for such cases as it would be a no-op anyway
        Invariant(!note->target_ast->sem->recreate);

        // current status: unsubscribed this will cause a drop later
        note->target_ast->sem->sem_type |= SCHEMA_FLAG_UNSUB;
        break;

      case SCHEMA_ANNOTATION_AD_HOC:
        // no annotation based actions other than migration proc (handled below)
        Contract(version_annotation->right);
        bprintf(&upgrade, "    -- ad hoc migration proc %s will run\n\n", target_name);
        break;
    }

    // handle any migration proc for any annotation
    if (!subscription_management && version_annotation->right) {
      // call any non-builtin migrations the generic way, builtins get whatever special handling they need
      if (!is_ast_dot(version_annotation->right)) {
        EXTRACT_STRING(proc, version_annotation->right);
        bprintf(&pending, "    IF cql_facet_find(%s_facets, '%s') = -1 THEN\n", global_proc_name, proc);
        bprintf(&pending, "      CALL %s();\n", proc);
        bprintf(&pending, "      CALL %s_cql_set_facet_version('%s', %d);\n", global_proc_name, proc, vers);
        bprintf(&pending, "    END IF;\n");
        bprintf(&decls, "DECLARE PROC %s() USING TRANSACTION;\n", proc);
      }
    }
  }

  cg_schema_end_version(&main, &upgrade, &pending, prev_version);


  // compute additional drops due to net unsubscription

  // we want the tables in DROP order
  reverse_list(&all_tables_list);

  for (list_item *item = all_tables_list; item; item = item->next) {
    ast_node *ast = item->ast;

    Invariant(is_ast_create_table_stmt(ast));

    // note that we do not have to check all of these guys for region and so forth
    // we only set the UNSUB flag on the tables that were in scope for this upgrade anyway.

    EXTRACT_NOTNULL(create_table_name_flags, ast->left);
    EXTRACT_NAME_AST(table_name_ast, create_table_name_flags->right);

    if (ast->sem->sem_type & SCHEMA_FLAG_UNSUB) {
      bprintf(&drops, "  DROP TABLE IF EXISTS ");
      cg_schema_name_as_cql_string(&drops, table_name_ast);
      bprintf(&drops, "; --@unsub\n");
    }
  }

  // put the list back in original order, this is redundant but in case some later code ends
  // up using it, they will be very suprised if this isn't done
  reverse_list(&all_tables_list);

  if (drops.used > 1) {
    bprintf(&main, "    CALL %s_cql_drop_tables();\n", global_proc_name);

    bprintf(&preamble, "[[private]]\n");
    bprintf(&preamble, "PROC %s_cql_drop_tables()\n", global_proc_name);
    bprintf(&preamble, "BEGIN\n");
    bprintf(&preamble, "%s", drops.ptr);
    bprintf(&preamble, "END;\n");
  }

  if (recreate_items_count) {
    bprintf(&main, "    CALL %s_cql_recreate_non_virtual_tables();\n", global_proc_name);
  }

  if (view_creates) {
    bprintf(&main, "    CALL %s_cql_create_all_views();\n", global_proc_name);
  }

  if (index_creates) {
    bprintf(&main, "    CALL %s_cql_create_all_indices();\n", global_proc_name);
  }

  if (trigger_creates) {
    bprintf(&main, "    CALL %s_cql_create_all_triggers();\n", global_proc_name);
  }

  bprintf(&main, "\n    CALL %s_cql_set_facet_version('cql_schema_version', %d);\n", global_proc_name, prev_version);
  bprintf(&main, "    CALL %s_cql_set_facet_version('cql_schema_crc_no_virtual', %lld);\n", global_proc_name, schema_crc_no_virtual);
  bprintf(&main, "  END IF;\n");
  bprintf(&main, "  IF include_virtual_tables THEN\n");

  if (recreate_items_count) {
    bprintf(&main, "    CALL %s_cql_recreate_virtual_tables();\n", global_proc_name);
  }
  bprintf(&main, "    CALL %s_cql_set_facet_version('cql_schema_crc', %lld);\n", global_proc_name, schema_crc);
  bprintf(&main, "  END IF;\n");
  bprintf(&main, "END;\n\n");

  bprintf(&main, "PROC %s_get_current_and_proposed_versions(\n", global_proc_name);
  bprintf(&main, "    out current long not null,\n");
  bprintf(&main, "    out proposed long not null\n");
  bprintf(&main, "    )\n");
  bprintf(&main, "BEGIN\n");
  bprintf(&main, "    SET current := %s_cql_get_facet_version('cql_schema_version');\n", global_proc_name);
  bprintf(&main, "    SET proposed := %d;\n", max_schema_version);
  bprintf(&main, "END;\n\n");

  bprintf(&main, "PROC %s_fetch_changed_facets()\n", global_proc_name);
  bprintf(&main, "BEGIN\n");
  bprintf(&main, "    SELECT T1.facet FROM\n");
  bprintf(&main, "      %s_cql_schema_facets T1\n", global_proc_name);
  bprintf(&main, "      LEFT OUTER JOIN %s_cql_schema_facets_saved T2\n", global_proc_name);
  bprintf(&main, "        ON T1.facet = T2.facet\n");
  bprintf(&main, "      WHERE T1.version is not T2.version;\n");
  bprintf(&main, "END;\n\n");

  bprintf(&main, "PROC %s_fetch_rebuilt_facets()\n", global_proc_name);
  bprintf(&main, "BEGIN\n");
  bprintf(&main, "    SELECT rebuild_facet FROM cql_schema_rebuilt_tables;\n");
  bprintf(&main, "END;\n\n");

  bprintf(&main, "[[private]]\n");
  bprintf(&main, "PROC %s_perform_needed_upgrades(include_virtual_tables BOOL NOT NULL)\n", global_proc_name);
  bprintf(&main, "BEGIN\n");
  bprintf(&main, "  -- check for downgrade --\n");
  bprintf(&main, "  IF cql_facet_find(%s_facets, 'cql_schema_version') > %d THEN\n", global_proc_name, max_schema_version);
  bprintf(&main, "    SELECT 'downgrade detected' facet;\n");
  bprintf(&main, "  ELSE\n");
  bprintf(&main, "    -- save the current facets so we can diff them later --\n");
  bprintf(&main, "    CALL %s_save_cql_schema_facets();\n", global_proc_name);
  bprintf(&main, "    CALL %s_perform_upgrade_steps(include_virtual_tables);\n\n", global_proc_name);
  bprintf(&main, "    -- finally produce the list of differences\n");
  bprintf(&main, "    CALL %s_fetch_changed_facets();\n", global_proc_name);
  bprintf(&main, "  END IF;\n");
  bprintf(&main, "END;\n\n");

  bprintf(&main, "[[private]]\n");
  bprintf(&main, "PROC %s_helper(include_virtual_tables BOOL NOT NULL)\n", global_proc_name);
  bprintf(&main, "BEGIN\n");
  bprintf(&main, "  DECLARE schema_crc LONG INTEGER NOT NULL;\n");
  bprintf(&main, "\n");
  bprintf(&main, "  -- create schema facets information table --\n");
  bprintf(&main, "  CALL %s_create_cql_schema_facets_if_needed();\n\n", global_proc_name);
  bprintf(&main, "  -- create rebuilt facets table --\n");
  bprintf(&main, "  CALL %s_create_cql_schema_rebuilt_tables_if_needed();\n\n", global_proc_name);
  bprintf(&main, "  -- fetch the last known schema crc, if it's different do the upgrade --\n");
  bprintf(&main, "  CALL %s_cql_get_facet_version('cql_schema_crc', schema_crc);\n\n", global_proc_name);
  bprintf(&main, "  IF schema_crc <> %lld THEN\n", (llint_t)schema_crc);
  bprintf(&main, "    TRY\n");
  bprintf(&main, "      CALL %s_setup_facets();\n", global_proc_name);
  bprintf(&main, "      CALL %s_perform_needed_upgrades(include_virtual_tables);\n", global_proc_name);
  bprintf(&main, "    CATCH\n");
  bprintf(&main, "      SET %s_facets := NULL;\n", global_proc_name);
  bprintf(&main, "      SET %s_tables_dict_ := NULL;\n", global_proc_name);
  bprintf(&main, "      THROW;\n");
  bprintf(&main, "    END;\n");
  bprintf(&main, "    SET %s_facets := NULL;\n", global_proc_name);
  bprintf(&main, "    SET %s_tables_dict_ := NULL;\n", global_proc_name);
  bprintf(&main, "  ELSE\n");
  bprintf(&main, "    -- some canonical result for no differences --\n");
  bprintf(&main, "    SELECT 'no differences' facet;\n");
  bprintf(&main, "  END IF;\n");

  if (has_temp_schema) {
    bprintf(&main, "  ---- install temp schema after upgrade is complete ----\n");
    bprintf(&main, "  CALL %s_cql_install_temp_schema();\n\n", global_proc_name);
  }

  bprintf(&main, "END;\n\n");

  bprintf(&main, "PROC %s()\n", global_proc_name);
  bprintf(&main, "BEGIN\n");
  bprintf(&main, "  CALL %s_helper(TRUE);\n", global_proc_name);
  bprintf(&main, "END;\n\n");

  bprintf(&main, "PROC %s_no_virtual_tables()\n", global_proc_name);
  bprintf(&main, "BEGIN\n");
  bprintf(&main, "  CALL %s_helper(FALSE);\n", global_proc_name);
  bprintf(&main, "END;\n\n");

  CHARBUF_OPEN(output_file);

  // Enable these lines to force error tracing in the generated upgrader, useful for debugging
  //
  // bprintf(&output_file, "@echo c,\"#undef cql_error_trace\\n\";\n");
  // bprintf(&output_file, "@echo c,\"#define cql_error_trace() ");
  // bprintf(&output_file, "fprintf(stderr, \\\"Error at %%s:%%d in %%s: %%d %%s\\\\n\\\",");
  // bprintf(&output_file, " __FILE__, __LINE__, _PROC_, _rc_, sqlite3_errmsg(_db_))\";\n");
  // bprintf(&output_file, "@echo c,\"\\n\\n\";\n\n");

  bprintf(&output_file, "%s\n", decls.ptr);
  bprintf(&output_file, "%s", preamble.ptr);
  bprintf(&output_file, "%s", main.ptr);

  cql_write_file(options.file_names[0], output_file.ptr);

  CHARBUF_CLOSE(output_file);

  CHARBUF_CLOSE(drops);
  CHARBUF_CLOSE(baseline);
  CHARBUF_CLOSE(upgrade);
  CHARBUF_CLOSE(pending);
  CHARBUF_CLOSE(decls);
  CHARBUF_CLOSE(main);
  CHARBUF_CLOSE(preamble);

  SYMTAB_CLEANUP(full_drop_funcs);
  SYMTAB_CLEANUP(group_drop_funcs);
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_TEST_HELPERS)

// stubs to avoid link errors
cql_noexport void cg_test_helpers_main(ast_node *head) {}

#else

// Given a procedure, we can create a temp table that has the exact shape as the proc
// We can then insert and select from the temp table to fake a result set
// This file performs codegen for those procedures



#define DUMMY_TABLE           1 // dummy_table attribute flag
#define DUMMY_INSERT          2 // dummy_insert attribute flag
#define DUMMY_SELECT          4 // dummy_select attribute flag
#define DUMMY_RESULT_SET      8 // dummy_result_set attribute flag
#define DUMMY_TEST         0x10 // dummy_test attribute flag

#define DUMMY_TEST_INSERT_ROWS  2 // minimum number of rows inserted in table for dummy_test attribution

static charbuf *cg_th_output;
static charbuf *cg_th_decls;
static charbuf* cg_th_procs;

// dummy_test utility variable used to emit statements.
static charbuf *gen_create_triggers;
static charbuf *gen_drop_triggers;

// All triggers per tables. This is used as part of dummy_test to help look up
// all the triggers to emit
static symtab *all_tables_with_triggers;

// All indexes per tables. This is used as part of dummy_test to help look up
// all the indexes to emit
static symtab *all_tables_with_indexes;

// We use this table to track which proc declarations we've already emitted
static symtab *test_helper_decls_emitted;

// Record the autotest attribute processed. This is used to figure out if there
// will be code gen to write to the output file
static int32_t helper_flags = 0;

// hold all the table name, column name and column values provided by dummy_test node
static symtab *dummy_test_infos = NULL;

typedef struct dummy_test_info {
  list_item *found_tables;
  list_item *found_views;
  CSTR table_current;
  struct table_callbacks *callbacks;
  symtab *found_triggers;
  list_item *pending_triggers;
} dummy_test_info;

static void find_all_table_nodes(dummy_test_info *info, ast_node *node);

static void cg_dummy_test_populate(charbuf *gen_insert_tables, ast_node *table_ast, int32_t *dummy_value_seed);

// The dummy_table, dummy_insert, dummy_select and dummy_result_set attributions
// will reference the original procedure by name in a LIKE clause.  In order to get its
// result type, we need to emit a declaration for the proc because its body will not be
// in the test helper file.  This function tells us if we need to emit that declaration.
static bool is_declare_proc_needed() {
  int32_t needed = DUMMY_TABLE | DUMMY_INSERT | DUMMY_SELECT | DUMMY_RESULT_SET;
  return !!(helper_flags & needed);
}

// Emit a declaration for the proc so that the signature is known by
// the generated dummy procs.  See above.
static void cg_test_helpers_declare_proc(ast_node *ast) {
  bprintf(cg_th_decls, "\n");
  gen_set_output_buffer(cg_th_decls);
  gen_declare_proc_closure(ast, test_helper_decls_emitted);
}

static bool_t cg_test_helpers_force_if_not_exists(
  ast_node *_Nonnull ast,
  void *_Nullable context,
  charbuf *_Nonnull output)
{
  bprintf(output, "IF NOT EXISTS ");
  return true;
}

// Emit an open proc which creates a temp table in the form of the original proc
// Emit a close proc which drops the temp table
static void cg_test_helpers_dummy_table(CSTR name) {
  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC open_%s()\n", name);
  bprintf(cg_th_procs, "BEGIN\n");
  bprintf(cg_th_procs, "  CREATE TEMP TABLE test_%s(LIKE %s);\n", name, name);
  bprintf(cg_th_procs, "END;\n");

  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC close_%s()\n", name);
  bprintf(cg_th_procs, "BEGIN\n");
  bprintf(cg_th_procs, "  DROP TABLE test_%s;\n", name);
  bprintf(cg_th_procs, "END;\n");
}

// Emit a dummy insert to the temp table using FROM ARGUMENTS
static void cg_test_helpers_dummy_insert(CSTR name) {
  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC insert_%s(LIKE %s)\n", name, name);
  bprintf(cg_th_procs, "BEGIN\n");
  bprintf(cg_th_procs, "  INSERT INTO test_%s FROM ARGUMENTS;\n", name);
  bprintf(cg_th_procs, "END;\n");
}

// Emit a dummy select from the temp table which will have a result set
// that matches that of the original proc
static void cg_test_helpers_dummy_select(CSTR name) {
  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC select_%s()\n", name);
  bprintf(cg_th_procs, "BEGIN\n");
  bprintf(cg_th_procs, "  SELECT * FROM test_%s;\n", name);
  bprintf(cg_th_procs, "END;\n");
}

// Emit a procedure that takes in arguments by the shape of the procedure
// and produces a result set
static void cg_test_helpers_dummy_result_set(CSTR name) {
  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC generate_%s_row(LIKE %s)\n", name, name);
  bprintf(cg_th_procs, "BEGIN\n");
  bprintf(cg_th_procs, "  DECLARE curs CURSOR LIKE %s;\n", name);
  bprintf(cg_th_procs, "  FETCH curs FROM ARGUMENTS;\n");
  bprintf(cg_th_procs, "  OUT curs;\n");
  bprintf(cg_th_procs, "END;\n");
}

// triggers have to go after all else because their dependencies are in any order
// and we do not want to alter the table create order by processing a trigger
static void enqueue_all_triggers_node(dummy_test_info *info, CSTR table_or_view_name) {
  symtab_entry *triggers_entry = symtab_find(all_tables_with_triggers, table_or_view_name);

  if (triggers_entry) {
    // We collect this table as having triggers. Later we'll use this datastructure to emit
    // those triggers.
    bytebuf *buf = (bytebuf *)triggers_entry->val;
    ast_node **items = (ast_node **)buf->ptr;
    uint32_t count = buf->used / sizeof(*items);

    for (uint32_t i = 0; i < count; i++) {
      EXTRACT_ANY_NOTNULL(create_trigger_stmt, items[i]);
      EXTRACT_NOTNULL(trigger_body_vers, create_trigger_stmt->right);
      EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
      EXTRACT_NAME_AST(trigger_name_ast, trigger_def->left);
      EXTRACT_STRING(trigger_name, trigger_name_ast);

      if (symtab_add(info->found_triggers, trigger_name, NULL)) {
        add_item_to_list(&info->pending_triggers, create_trigger_stmt);
      }
    }
  }
}

// process all the pending triggers
static void process_pending_triggers(void *_Nullable context) {
  dummy_test_info *info = (dummy_test_info *)context;

  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.if_not_exists_callback = cg_test_helpers_force_if_not_exists;
  callbacks.mode = gen_mode_no_annotations;

  // note that we might get more triggers as a result of processing these triggers
  while (info->pending_triggers) {
    // We can safely visit all the triggers because we know we visit any given table only once
    list_item *trigger_list = info->pending_triggers;
    info->pending_triggers = NULL;

    while (trigger_list) {
      EXTRACT_ANY_NOTNULL(create_trigger_stmt, trigger_list->ast);

      // emit create trigger stmt
      gen_set_output_buffer(gen_create_triggers);
      gen_statement_with_callbacks(create_trigger_stmt, &callbacks);
      bprintf(gen_create_triggers, ";\n");

      // emit drop trigger stmt
      gen_set_output_buffer(gen_drop_triggers);
      EXTRACT_NOTNULL(trigger_body_vers, create_trigger_stmt->right);
      EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
      EXTRACT_NAME_AST(trigger_name_ast, trigger_def->left);
      bprintf(gen_drop_triggers, "DROP TRIGGER IF EXISTS ");
      cg_emit_name_ast(gen_drop_triggers, trigger_name_ast);
      bprintf(gen_drop_triggers, ";\n");

      // Now we need to find all the tables referenced in the triggers, because those tables
      // should also to be part of tables emit by dummy_test. Otherwise the triggers statement
      // will be referencing non existent table in dummy_test.
      continue_find_table_node(info->callbacks, create_trigger_stmt);

      trigger_list = trigger_list->next;
    }
  }
}

//  - looks up all table relationships instead of just tables reference in a proc (follows the FKs)
//  - looks up drop table statements
//  - looks up triggers, and then the tables referenced in those triggers
static void found_table_or_view(CSTR _Nonnull table_or_view_name, ast_node *_Nonnull table_or_view, void *_Nullable context) {
  Contract(table_or_view);

  dummy_test_info *info = (dummy_test_info *)context;

  bool deleted = table_or_view->sem->delete_version > 0;

  // tables/views that are deleted have no business appearing in the dummy test output
  if (!deleted) {
    // Now let's walk through the new found table (table_or_view_name) to find all the tables it
    // depends on.  This is to find the FKs inside it.  Note that we don't have to check for
    // cycles because the walker driving all of this already does that, we just go.
    continue_find_table_node(info->callbacks, table_or_view);

    // Items will naturally be inserted at the front of the list because add_item_to_list always adds
    // at the head.  We don't want duplicates so we need to check.  We do want newly found items to
    // go to the head because as visit things we always want it to be the case that dependencies we
    // visit later end up at the front.  So if A depends on B then B will be first in the list.

    // Note tables do not directly depend on views so what's going to happen here is that
    // we will follow the FK chain and the deepest table will emitted first, hence be at the tail of the list.
    // Now the thing is one of those tables might have a trigger...the trigger itself could have
    // additional dependencies such as views.  This is ok, this is sort of an indirect table to view
    // dependency but the thing is in this case the view must be created AFTER the tables not before
    // to manage this we keep a view list and a table list which we will stitch together at the end
    // so that all the views are after all the tables

    // This callback is invoked exactly once per table/view by the walker so we already know we
    // have to add the item to the list, we don't need to keep our own state.

    // Find all triggers on the table "table_or_view_name" then find all of the tables and triggers
    // referenced by them.  These must come after the table itself has been analyzed.  We
    // process these much later.
    enqueue_all_triggers_node(info, table_or_view_name);

    // note by now we've already visited and added things inside us so our dependencies are already in the list
    if (is_ast_create_view_stmt(table_or_view)) {
      add_item_to_list(&info->found_views, table_or_view);
    }
    else {
      add_item_to_list(&info->found_tables, table_or_view);
    }
  }
}

static void find_all_table_nodes(dummy_test_info *info, ast_node *node) {
  table_callbacks callbacks = {
    .callback_any_table = found_table_or_view,
    .callback_any_view = found_table_or_view,
    .callback_context = info,
    .notify_table_or_view_drops = true,
    .notify_fk = true,
    .notify_triggers = true,
    .callback_final_processing = process_pending_triggers
  };

  info->callbacks  = &callbacks;
  find_table_refs(&callbacks, node);

  // stitch the views to the tables to make one list, views first
  for (list_item *item = info->found_views; item; item = item->next) {
     if (!item->next) {
       item->next = info->found_tables;
       info->found_tables = info->found_views;
       break;
     }
  }
  // this shouldn't be used after it's been linked in
  info->found_views = NULL;
}

// Format the value in node accordingly to the node type. The semantic analysis
// has already made sure the ast node type matches the column type in the table
static void cg_dummy_test_column_value(charbuf *output, ast_node *value) {
  if (is_ast_uminus(value)) {
    Contract(is_ast_num(value->left));
    bprintf(output, "%s", "-");
    value = value->left;
  }

  if (is_ast_str(value)) {
    EXTRACT_STRING(lit, value);
    bprintf(output, "%s", lit);
  }
  else if (is_ast_num(value)) {
    EXTRACT_NUM_VALUE(lit, value);
    bprintf(output, "%s", lit);
  }
  else if (is_ast_null(value)) {
    bprintf(output, "NULL");
  }
  else {
    Contract(is_ast_blob(value));
    EXTRACT_BLOBTEXT(lit, value);
    bprintf(output, "%s", lit);
  }
}

// Find the parent column referenced in the foreign key statement by child table
// "table_name" and column "column_name". We use this function to find parent
// column to do some validation to avoid foreign key violations in insert statement
// we emit.
static void find_parent_column(
  ast_node *_Nullable *_Nonnull referenced_table_ast,
  CSTR _Nullable *_Nonnull referenced_column,
  CSTR table_name,
  CSTR column_name)
{
  ast_node *table_ast = find_table_or_view_even_deleted(table_name);
  Contract(is_ast_create_table_stmt(table_ast));
  EXTRACT_NOTNULL(col_key_list, table_ast->right);
  *referenced_table_ast = NULL;
  *referenced_column = NULL;

  for (ast_node *col_keys = col_key_list; col_keys; col_keys = col_keys->right) {
    if (is_ast_col_def(col_keys->left)) {
      // the column might be marked as an FK by the form col REFERENCES ref_table(ref_col)
      // to verify this we need to know that:
      // 1. col matches the required name
      // 2. there is an fk column attribute
      // if so we can get the referenced name and column from that attribute

      EXTRACT_NOTNULL(col_def, col_keys->left);
      EXTRACT_NOTNULL(col_def_type_attrs, col_def->left);
      EXTRACT_ANY(attrs, col_def_type_attrs->right);
      EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
      EXTRACT_STRING(name, col_def_name_type->left);

      if (!StrCaseCmp(name, column_name)) {
        for (ast_node *attr = attrs; attr; attr = attr->right) {
          if (is_ast_col_attrs_fk(attr)) {
            EXTRACT_NOTNULL(fk_target_options, attr->left);
            EXTRACT_NOTNULL(fk_target, fk_target_options->left);
            EXTRACT_STRING(ref_table_name, fk_target->left);
            EXTRACT_NAMED_NOTNULL(ref_list, name_list, fk_target->right);
            EXTRACT_STRING(ref_col_name, ref_list->left);
            Contract(!ref_list->right); // it must be a list of one because its attribute form

            *referenced_table_ast = find_table_or_view_even_deleted(ref_table_name);
            *referenced_column = ref_col_name;
            return;
          }
        }
      }
    }
    else if (is_ast_fk_def(col_keys->left)) {
      // In the general case we're looking for an FK constraint that has this column
      // if we find such a constraint (ast_fk_def) then we look at the name list
      // for the required column, if present we extract the referenced table
      // and the corresponding referenced column.

      EXTRACT_NOTNULL(fk_def, col_keys->left);
      EXTRACT_NOTNULL(fk_info, fk_def->right);
      EXTRACT_NOTNULL(name_list, fk_info->left);
      int32_t column_index = 0;
      bool_t found = 0;
      for (ast_node *list = name_list; list; list = list->right) {
        EXTRACT_STRING(name, list->left);
        if (!StrCaseCmp(name, column_name)) {
          found = 1;
          break;
        }
        column_index++;
      }

      if (found) {
        // All we need to do now is find the referenced name list
        // and skip to the column_index entry to get the corresponding
        // referenced name.  The table name is sitting there for us
        // on a silver platter.
        EXTRACT_NOTNULL(fk_target_options, fk_info->right);
        EXTRACT_NOTNULL(fk_target, fk_target_options->left);
        EXTRACT_STRING(referenced_table, fk_target->left);
        EXTRACT_ANY_NOTNULL(fk_name_list, fk_target->right);
        int32_t index = 0;
        while (index < column_index) {
          fk_name_list = fk_name_list->right;
          index++;
        }
        Invariant(fk_name_list);
        EXTRACT_STRING(fk_col_name, fk_name_list->left);
        *referenced_table_ast = find_table_or_view_even_deleted(referenced_table);
        *referenced_column = fk_col_name;
        return;
      }
    }
  }
}

// make sure a value is within 1 and DUMMY_TEST_INSERT_ROWS
static int32_t cg_validate_value_range(int32_t value) {
  if (1 <= value && value <= DUMMY_TEST_INSERT_ROWS) {
    return value;
  }
  else {
    return (value % DUMMY_TEST_INSERT_ROWS) + 1;
  }
}

// Emit a value of a parent column referenced by child column "column_name".
// It allows the insert statement of a child table to include the column value
// from the parent table.
// This is useful to make sure a value provided by the user in dummy_test info
// is actually included.
// the parent column might have multiple values available. We use "index" to specify
// the index of the one we want to emit.
// e.g: Foo table has a foreign key column 'A' referencing column 'B' on the table Bar.
// If a value for column 'B' of table Bar was specified in dummy_test info then that
// value will be populated to column 'B' of table Foo
static void cg_parent_column_value(charbuf *output, CSTR table_name, CSTR column_name, int32_t index) {
  ast_node *referenced_table_ast;
  CSTR referenced_column;
  find_parent_column(&referenced_table_ast, &referenced_column, table_name, column_name);

  if (referenced_table_ast) {
    CSTR referenced_table_name = referenced_table_ast->sem->sptr->struct_name;
    symtab_entry *referenced_table_entry = symtab_find(dummy_test_infos, referenced_table_name);

    if (referenced_table_entry) {
      symtab *fk_col_name_buf = (symtab *)referenced_table_entry->val;
      symtab_entry *fk_column_values_entry = symtab_find(fk_col_name_buf, referenced_column);

      if (fk_column_values_entry) {
        bytebuf *fk_column_values = (bytebuf *)fk_column_values_entry->val;
        ast_node **list = (ast_node **)fk_column_values->ptr;
        int32_t size = fk_column_values->used / sizeof(void *);
        cg_dummy_test_column_value(output, list[index % size]);
        return;
      }
    }
  }
}

// Emit a literal using an integer value base on the sem type.  e.g. quote it, cast it to blog, etc.
static void cg_dummy_test_emit_integer_value(charbuf *output, sem_t col_type, int32_t value) {
  if (is_numeric(col_type)) {
    bprintf(output, "%d", value);
  }
  else if (is_blob(col_type)) {
    bprintf(output, "CAST(\'%d\' as blob)", value);
  }
  else {
    bprintf(output, "\'%d\'", value);
  }
}

// Emit INSERT statement for a table by using @dummy_seed to generated dummy data
// but also info in dummy_test attribute. If column's values are provided in
// dummy_test info for the table, it'll be used otherwise @dummy_seed is used to
// populated seed value into table.
static void cg_dummy_test_populate(charbuf *gen_insert_tables, ast_node *table_ast, int32_t *dummy_value_seed) {
  Contract(is_ast_create_table_stmt(table_ast));

  // do not emit populate for backing tables, let backed tables do the job
  if (is_backing(table_ast->sem->sem_type)) {
    return;
  }

  sem_struct *sptr = table_ast->sem->sptr;
  ast_node *table_name_ast = sem_get_name_ast(table_ast);
  EXTRACT_STRING(table_name, table_name_ast);
  bool_t add_row;
  int32_t row_index = -1;
  symtab_entry *table_entry = symtab_find(dummy_test_infos, table_name);
  do {
    row_index++;
    add_row = 0;
    CHARBUF_OPEN(names);
    CHARBUF_OPEN(values);
    CSTR comma = "";
    symtab *col_syms = symtab_new();

    // extract column values for insert statement from dummy_test info and emit
    // the insert statement
    if (table_entry) {
      symtab *table = (symtab *)table_entry->val;
      for (uint32_t j = 0; j < table->capacity; j++) {
        symtab_entry column_entry = table->payload[j];

        if (column_entry.sym) {
          CSTR column_name = column_entry.sym;
          bytebuf *column_values_entry = (bytebuf *)column_entry.val;
          ast_node **column_values = (ast_node **)column_values_entry->ptr;
          int32_t size = column_values_entry->used/sizeof(void **);
          if (row_index < size) {
            CHARBUF_OPEN(str_val);
            cg_dummy_test_column_value(&str_val, column_values[row_index]);

            bprintf(&values, "%s%s", comma, str_val.ptr);
            bprintf(&names, "%s", comma);

            int32_t icol = sem_column_index(sptr, column_name);
            Invariant(icol >= 0);
            cg_emit_sptr_index(&names, sptr, (uint32_t)icol);
            comma = ", ";

            symtab_add(col_syms, column_name, NULL);
            add_row = 1;
            CHARBUF_CLOSE(str_val);
          }
        }
      }
    }

    // we make sure that we add at least DUMMY_TEST_INSERT_ROWS rows per table
    if (row_index < DUMMY_TEST_INSERT_ROWS) {
      add_row = 1;
    }

    if (add_row) {
      // provide specific values for primary and foreign column to avoid foreign key violation.
      for (uint32_t i = 0; i < sptr->count; i++) {
        sem_t col_type = sptr->semtypes[i];
        CSTR column_name = sptr->names[i];

        // We find primary and foreign key column that are missing values in the
        // insert statement and add those values to avoid sql foreign key violation eror.
        if (!symtab_find(col_syms, column_name)) {
          if (is_referenceable_by_foreign_key(table_ast, column_name) || is_foreign_key(col_type)) {
            CHARBUF_OPEN(str_val);
            // we do +1 because index value start at zero and we don't want to insert zero as primary key
            int32_t index_value = row_index + 1;
            if (is_foreign_key(col_type)) {
              cg_parent_column_value(&str_val, table_name, column_name, row_index);
              if (str_val.used <= 1) {
                // The parent table does not have explicit dummy info on this column.
                // In this case the parent table key referenced here was created with default value
                // between 1 and DUMMY_TEST_INSERT_ROWS. We just need to select one of these default
                // value.
                cg_dummy_test_emit_integer_value(&str_val, col_type, cg_validate_value_range(index_value));
              }
            }
            bprintf(&names, "%s", comma);
            cg_emit_sptr_index(&names, sptr, i);
            bprintf(&values, "%s", comma);
            comma = ", ";

            if (str_val.used > 1) {
              bprintf(&values, "%s", str_val.ptr);
            }
            else {
              cg_dummy_test_emit_integer_value(&values, col_type, index_value);
            }
            CHARBUF_CLOSE(str_val);
          }
        }
      }

      bprintf(gen_insert_tables, "INSERT OR IGNORE INTO ");
      cg_emit_name_ast(gen_insert_tables, table_name_ast);
      bprintf(gen_insert_tables, "(%s) VALUES(%s) @dummy_seed(%d)%s;\n",
              names.ptr,
              values.ptr,
              (*dummy_value_seed)++,
              row_index % 2 == 0 ? "" : " @dummy_nullables @dummy_defaults");
    }

    CHARBUF_CLOSE(values);
    CHARBUF_CLOSE(names);
    symtab_delete(col_syms);
  } while (add_row);
}

// Walk through all triggers and create a dictionnary of triggers per tables.
static void init_all_trigger_per_table() {
  Contract(all_tables_with_triggers == NULL);
  all_tables_with_triggers = symtab_new();

  for (list_item *item = all_triggers_list; item; item = item->next) {
    EXTRACT_NOTNULL(create_trigger_stmt, item->ast);
    EXTRACT_NOTNULL(trigger_body_vers, create_trigger_stmt->right);
    EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
    EXTRACT_NOTNULL(trigger_condition, trigger_def->right);
    EXTRACT_NOTNULL(trigger_op_target, trigger_condition->right);
    EXTRACT_NOTNULL(trigger_target_action, trigger_op_target->right);
    EXTRACT_NAME_AST(table_name_ast, trigger_target_action->left);
    EXTRACT_STRING(table_name, table_name_ast);

    if (create_trigger_stmt->sem->delete_version > 0) {
      // dummy_test should not emit deleted trigger
      continue;
    }

    symtab_append_bytes(all_tables_with_triggers, table_name, &create_trigger_stmt, sizeof(create_trigger_stmt));
  }
}

static void init_all_indexes_per_table() {
  Contract(all_tables_with_indexes == NULL);
  all_tables_with_indexes = symtab_new();

  for (list_item *item = all_indices_list; item; item = item->next) {
    EXTRACT_NOTNULL(create_index_stmt, item->ast);
    EXTRACT_NOTNULL(create_index_on_list, create_index_stmt->left);
    EXTRACT_NAME_AST(table_name_ast, create_index_on_list->right);
    EXTRACT_STRING(table_name, table_name_ast);

    if (create_index_stmt->sem->delete_version > 0) {
      // dummy_test should not emit deleted indexes
      continue;
    }

    symtab_append_bytes(all_tables_with_indexes, table_name, &create_index_stmt, sizeof(create_index_stmt));
  }
}

// Emit create and drop index statement for all indexes on a table.
static void cg_emit_index_stmt(
  ast_node *table_name_ast,
  charbuf *gen_create_indexes,
  charbuf *gen_drop_indexes,
  gen_sql_callbacks *callback)
{
  EXTRACT_STRING(table_name, table_name_ast);
  symtab_entry *indexes_entry = symtab_find(all_tables_with_indexes, table_name);
  bytebuf *buf = indexes_entry ? (bytebuf *)indexes_entry->val : NULL;
  ast_node **indexes_ast = buf ? (ast_node **)buf->ptr : NULL;
  uint32_t count = buf ? buf->used / sizeof(*indexes_ast) : 0;
  gen_set_output_buffer(gen_create_indexes);

  for (uint32_t i = 0; i < count; i++) {
    ast_node *index_ast = indexes_ast[i];
    EXTRACT_NOTNULL(create_index_stmt, index_ast);
    EXTRACT_NOTNULL(create_index_on_list, create_index_stmt->left);
    EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);

    gen_statement_with_callbacks(index_ast, callback);
    bprintf(gen_create_indexes, ";\n");
    bprintf(gen_drop_indexes, "DROP INDEX IF EXISTS ");
    cg_emit_name_ast(gen_drop_indexes, index_name_ast);
    bprintf(gen_drop_indexes, ";\n");
  }
}

// Emit procedure for dummy_test attribution. This is the entry point that emit
// generated code for dummy_test attribution.
// This function will generated stored procedures to :
//  - Create all the tables referenced in the create proc statement.
//  - Populate data into all the tables referenced in the create proc statement.
//  - Drop all the tables referenced in the create proc statement.
//  - Read tables reference in the create proc statement.
// The tables are created, populated and drop in an specific order to avoid foreign key violation or table not existing errors.
// But also the data populated in the foreign key columns of these tables do not violate the foreign key constraint.
static void cg_test_helpers_dummy_test(ast_node *stmt) {
  Contract(is_ast_create_proc_stmt(stmt));
  EXTRACT_STRING(proc_name, stmt->left);

  CHARBUF_OPEN(create_triggers);
  CHARBUF_OPEN(drop_triggers);
  gen_create_triggers = &create_triggers;
  gen_drop_triggers = &drop_triggers;

  dummy_test_info info = {
    .table_current = NULL,
    .found_tables = NULL,
    .found_views = NULL,
    .found_triggers = symtab_new(),
    .pending_triggers = NULL,
  };

  // First thing we have to do is gather all the tables that are used transitively by the procedure
  // that needs dummy_test helpers.
  find_all_table_nodes(&info, stmt);

  symtab_delete(info.found_triggers);
  info.found_triggers = NULL;

  // If the create proc statement does not reference any tables, there is nothing to emit
  if (info.found_tables == NULL) {
    CHARBUF_CLOSE(drop_triggers);
    CHARBUF_CLOSE(create_triggers);
    return;
  }

  // There are some tables, so we've work to do, there are several types of functions emitted
  // by this helper type, we're going to need them all.

  int32_t value_seed = 123;

  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.if_not_exists_callback = cg_test_helpers_force_if_not_exists;
  callbacks.mode = gen_mode_no_annotations;

  CHARBUF_OPEN(gen_declare_backed);
  CHARBUF_OPEN(gen_create_tables);
  CHARBUF_OPEN(gen_drop_tables);
  CHARBUF_OPEN(gen_populate_tables);
  CHARBUF_OPEN(gen_read_tables);
  CHARBUF_OPEN(gen_declare_funcs);
  CHARBUF_OPEN(gen_drop_indexes);

  // Here we record that we actually emitted some dummy test stuff for this proc, this helps us
  // decide if we need the test markers in test mode.
  helper_flags |= DUMMY_TEST;

  // The found tables list begins in an order that is correct for dropping (i.e. the "leaf" tables/views are first)
  // do that now...

  for (list_item *item = info.found_tables; item; item = item->next) {
    EXTRACT_ANY_NOTNULL(table_or_view, item->ast);
    Invariant(is_ast_create_table_stmt(table_or_view) || is_ast_create_view_stmt(table_or_view));
    ast_node *name_ast = sem_get_name_ast(table_or_view);

    // backed tables are not to be dropped, they don't exist physically
    if (!is_backed(table_or_view->sem->sem_type)) {
      bprintf(&gen_drop_tables, "DROP %s IF EXISTS ", is_ast_create_table_stmt(table_or_view) ? "TABLE" : "VIEW");
      cg_emit_name_ast(&gen_drop_tables, name_ast);
      bprintf(&gen_drop_tables, ";\n");
    }
  }

  // Reverse the list to get the tables back into a safe-to-declare order that we can loop over
  // to emit table creation of parent tables before child tables.
  reverse_list(&info.found_tables);

  // For each found table we're going to do some table specific things

  for (list_item *item = info.found_tables; item; item = item->next) {
    EXTRACT_ANY_NOTNULL(table_or_view, item->ast);

    ast_node *ast_to_emit = table_or_view;

    // the virtual table ast in the symbol table points to the table decl part of the virtual table create
    // we want the whole statement so we have to back up one notch up the tree.
    bool_t is_virtual_table = table_or_view->parent && is_ast_create_virtual_table_stmt(table_or_view->parent);
    if (is_virtual_table) {
      ast_to_emit = table_or_view->parent;
    }

    // backing tables need their attribute
    if (is_backing(ast_to_emit->sem->sem_type)) {
      bprintf(&gen_create_tables, "[[backing_table]]\n");
    }

    // backed tables are declared not created, emit them into their own stream

    charbuf *out = &gen_create_tables;
    if (is_backed(ast_to_emit->sem->sem_type)) {
      EXTRACT_MISC_ATTRS(ast_to_emit, misc_attrs);
      out = &gen_declare_backed;
      CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
      bprintf(out, "[[backed_by=%s]]\n", backing_table_name);
    }

    // First thing we need is the CREATE DDL for the item in question, make that now
    gen_set_output_buffer(out);
    gen_statement_with_callbacks(ast_to_emit, &callbacks);
    bprintf(out, ";\n");

    // Next we need the DDL for any indices that may be on the table, we'll generate
    // the CREATE for those indices and a DROP for the indices.  The CREATE goes with
    // the table creates.  The indices may be dropped seperately so the DROP goes
    // in its own buffer
    ast_node *name_ast = sem_get_name_ast(table_or_view);
    cg_emit_index_stmt(name_ast, &gen_create_tables, &gen_drop_indexes, &callbacks);

    // Next we generate a fragment to populate data for this table using the current seed value
    // We don't do this for views or virtual tables
    if (is_ast_create_table_stmt(table_or_view) && !is_virtual_table) {
      cg_dummy_test_populate(&gen_populate_tables, table_or_view, &value_seed);
    }

    // Finally, there is a helper procedure for each table or view that just reads all that
    // data out of it.  Most tests don't use all of them but it's only test code so size doesn't
    // matter so much and it's super easy to have them all handy so we aren't picky.

    EXTRACT_STRING(table_name, name_ast);

    bprintf(&gen_read_tables, "\n");
    bprintf(&gen_read_tables, "PROC test_%s_read_%s()\n", proc_name, table_name);
    bprintf(&gen_read_tables, "BEGIN\n");
    bprintf(&gen_read_tables, "  SELECT * FROM ");
    cg_emit_name_ast(&gen_read_tables, name_ast);
    bprintf(&gen_read_tables, ";\n");
    bprintf(&gen_read_tables, "END;\n");
  }

  // At this point we're done with all the tables, we're ready to generate the main methods
  // plus do the rest of the housekeeping

  // Emit declare functions because they may be needed for schema and query validation
  // We don't try to guess which functions were used, we just emit the correct declarations for them all.
  // We could in principle do this one time for the entire translation unit but duplicates don't hurt anyway.
  gen_set_output_buffer(&gen_declare_funcs);
  bprintf(&gen_declare_funcs, "\n");
  for (list_item *item = all_functions_list; item; item = item->next) {
    EXTRACT_ANY_NOTNULL(any_func, item->ast);
    bool_t select_func = is_select_func(any_func);
    bool_t non_select_func = is_non_select_func(any_func);
    Contract(select_func || non_select_func);
    if (select_func) {
      EXTRACT_MISC_ATTRS(any_func, misc_attrs);
      bool_t deterministic = misc_attrs && !!find_named_attr(misc_attrs, "deterministic");
      if (deterministic) {
        bprintf(&gen_declare_funcs, "[[deterministic]]\n");
      }
      gen_one_stmt(any_func);
      bprintf(&gen_declare_funcs, ";\n");
    }
  }

  // declare functions
  bprintf(cg_th_procs, "%s", gen_declare_funcs.ptr);

  // create tables proc
  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC test_%s_create_tables()\n", proc_name);
  bprintf(cg_th_procs, "BEGIN\n");
  bindent(cg_th_procs, &gen_create_tables, 2);
  bprintf(cg_th_procs, "END;\n");

  // declare the backed tables only (i.e. keep them out of the proc)
  if (gen_declare_backed.used > 1) {
    bprintf(cg_th_procs, "\n%s", gen_declare_backed.ptr);
  }


  // Create the triggers proc.
  //
  // We emit the trigger creation code in its own proc for two reasons:
  //
  // 1. If the code is part of the create table proc it might have unwanted
  //    effects on the dummy data populated later. Some dummy data in the table
  //    will likely be altered because of the triggers and the DB will end up in
  //    an unexpected state. Generally the dummy data is considered authoritative
  //    of the desire end state, it isn't transactions to be applied.
  //
  // 2. We want to give the engineer control of if/when the triggers are applied.
  //
  // We create the create/drop triggers helpers even for procs that don't use any
  // tables with triggers. Otherwise callsites might have to change when triggers
  // are added/removed from the schema.
  if (gen_drop_triggers->used <= 1) {
    // Similarly, to avoid the procs signature changing based on triggers being
    // added/removed we use the below snippet to force the procedure to use the
    // db-using signature, even if no triggers are actually created.
    bprintf(gen_create_triggers, "IF @rc THEN END IF;\n");
  }
  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC test_%s_create_triggers()\n", proc_name);
  bprintf(cg_th_procs, "BEGIN\n");
  bindent(cg_th_procs, gen_create_triggers, 2);
  bprintf(cg_th_procs, "END;\n");

  // populate tables proc
  if (gen_populate_tables.used > 1) {
    bprintf(cg_th_procs, "\n");
    bprintf(cg_th_procs, "PROC test_%s_populate_tables()\n", proc_name);
    bprintf(cg_th_procs, "BEGIN\n");
    bindent(cg_th_procs, &gen_populate_tables, 2);
    bprintf(cg_th_procs, "END;\n");
  }

  // drop tables proc
  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC test_%s_drop_tables()\n", proc_name);
  bprintf(cg_th_procs, "BEGIN\n");
  bindent(cg_th_procs, &gen_drop_tables, 2);
  bprintf(cg_th_procs, "END;\n");

  // drop trigger proc
  if (gen_drop_triggers->used <= 1) {
    bprintf(gen_drop_triggers, "IF @rc THEN END IF;\n");
  }
  bprintf(cg_th_procs, "\n");
  bprintf(cg_th_procs, "PROC test_%s_drop_triggers()\n", proc_name);
  bprintf(cg_th_procs, "BEGIN\n");
  bindent(cg_th_procs, gen_drop_triggers, 2);
  bprintf(cg_th_procs, "END;\n");

  // read tables procedures
  bprintf(cg_th_procs, "%s", gen_read_tables.ptr);

  // drop indexes proc
  if (gen_drop_indexes.used > 1) {
    bprintf(cg_th_procs, "\n");
    bprintf(cg_th_procs, "PROC test_%s_drop_indexes()\n", proc_name);
    bprintf(cg_th_procs, "BEGIN\n");
    bindent(cg_th_procs, &gen_drop_indexes, 2);
    bprintf(cg_th_procs, "END;\n");
  }

  CHARBUF_CLOSE(gen_drop_indexes);
  CHARBUF_CLOSE(gen_declare_funcs);
  CHARBUF_CLOSE(gen_read_tables);
  CHARBUF_CLOSE(gen_populate_tables);
  CHARBUF_CLOSE(gen_drop_tables);
  CHARBUF_CLOSE(gen_create_tables);
  CHARBUF_CLOSE(gen_declare_backed);
  CHARBUF_CLOSE(drop_triggers);
  CHARBUF_CLOSE(create_triggers);
}

// check whether "value" already exist in "column_values". This is used to avoid
// having the same value repeated in a column. It can only happens if the value
// explicitely added to dummy_test info match values from @dummy_seed.
static bool_t is_column_value_present(bytebuf *column_values, sem_t column_type, ast_node *value) {
  bool_t exist = 0;
  ast_node **list = (ast_node **)column_values->ptr;
  int32_t size = column_values->used / sizeof(ast_node *);
  for (int32_t i = 0; i < size; i++) {
    ast_node *l = list[i];
    sem_t col_type = core_type_of(column_type);
    ast_node *r = value;

    // The numbers get some special treatment because unary minus might be in the node
    // if it's present we peel it off and compare what's left.  Remember all numerics
    // are represented as positive numbers with possibly a negation operator if needed.
    // It has to be this way so that 1-5 doesn't parse as 1 and -5 with no operator.
    if (col_type == SEM_TYPE_LONG_INTEGER ||
        col_type == SEM_TYPE_INTEGER ||
        col_type == SEM_TYPE_REAL ||
        col_type == SEM_TYPE_BOOL) {

      bool_t minus_l = is_ast_uminus(l);
      if (minus_l) {
        Contract(is_ast_num(l->left));
        l = l->left;
      }

      bool_t minus_r = is_ast_uminus(r);
      if (minus_r) {
        Contract(is_ast_num(r->left));
        r = r->left;
      }

      EXTRACT_NUM_VALUE(lv, l);
      EXTRACT_NUM_VALUE(rv, r);
      exist = minus_l == minus_r && !StrCaseCmp(lv, rv);
    }
    else if (col_type == SEM_TYPE_TEXT) {
      EXTRACT_STRING(lv, l);
      EXTRACT_STRING(rv, r);
      exist = !StrCaseCmp(lv, rv);
    }

    if (exist) {
      return true;
    }
  }
  return false;
}

// Insert the column value from a child table to the parent table to make sure
// the row in child table references a row in then parent table when we emit
// insert statement for both tables. This function is only called from foreign key columns.
// e.g: Suppose you have table "Foo" with column "id" which is a foreign key reference to
//      "id" in table "Bar". If the user has manually added a value for the column "id" in
//      the table "Foo" in dummy_test info then this method will add the same value
//      to column "id" of the table "Bar" into its dummy_test info.
static void add_value_to_referenced_table(
  CSTR table_name,
  CSTR column_name,
  sem_t column_type,
  ast_node *column_value)
{
  // if the data column is "NULL" then it doesn't actually have to go into the parent at all
  if (is_ast_null(column_value)) {
    return;
  }

  ast_node *referenced_table_ast;
  CSTR referenced_column;
  find_parent_column(&referenced_table_ast, &referenced_column, table_name, column_name);
  CSTR referenced_table_name = referenced_table_ast->sem->sptr->struct_name;

  symtab *fk_col_syms = symtab_ensure_symtab(dummy_test_infos, referenced_table_name);
  bytebuf *fk_column_values = symtab_ensure_bytebuf(fk_col_syms, referenced_column);

  // We want to avoid adding the same value to multiple rows in the same table.

  // Note this is imperfect:  if the FK relationship is multi-columnar then we're going
  // to have a bug here.  e.g.  if the FK columns are (a,b) and we have already added
  // (1,2) to the fk table we could get into trouble when try to add (1,3) because
  // then "1" will look like it's already there.  We live with this limitation
  // because this is only a test helper...  it's entirely optional anyway and if you
  // really want full control you can always write your own data inserter.

  if (!is_column_value_present(fk_column_values, column_type, column_value)) {
    bytebuf_append_var(fk_column_values, column_value);
  }
}

// Walk through the dummy_test attributes collecting this information.  This
// is a set of columns and values which will later be used in the generated
// data insertion procedure.  This is entirely optional but if you want specific
// data to be inserted you can put it in the attribute.
static void collect_dummy_test_info(
  ast_node *_Nullable misc_attr_value_list,
  void *_Nullable context)
{
  EXTRACT_STRING(autotest_attr_name, misc_attr_value_list->left);

  if (is_autotest_dummy_test(autotest_attr_name)) {
    // walkthrough dummy_test tree and retreive the table name then the column name
    // of the table name and then the column values of the column names. We repeat
    // it for the next table info.
    for (ast_node *dummy_attr = misc_attr_value_list->right; dummy_attr; dummy_attr = dummy_attr->right) {
      bytebuf col_data_buf;
      bytebuf col_type_buf;
      bytebuf col_name_buf;

      bytebuf_open(&col_data_buf);
      bytebuf_open(&col_type_buf);
      bytebuf_open(&col_name_buf);

      // the data attribute looks kind of like this:
      // @attribute(cql:autotest = (
      //   .. other auto test attributes
      //   (dummy_test,
      //     (table_name1, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),
      //     (table_name2, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),
      //     ...
      //   )
      //   .. other auto test attributes
      // ))
      //
      // we're concerned with the dummy_test entries here, they have a very specific format
      // i.e. first the table then the column names, and then a list of matching columns and values

      // note that sem.c has already verified the correct shape, see error CQL0277

      // collect table name from dummy_test info
      ast_node *table_list = dummy_attr->left;
      EXTRACT_STRING(table_name, table_list->left);
      symtab *col_syms = symtab_ensure_symtab(dummy_test_infos, table_name);

      // collect column names from dummy_test info
      ast_node *column_name_list = table_list->right;
      for (ast_node *list = column_name_list->left; list; list = list->right) {
        EXTRACT_STRING(column_name, list->left);
        sem_t col_type = find_column_type(table_name, column_name);

        bytebuf *column_values = symtab_ensure_bytebuf(col_syms, column_name);

        // store the column meta data, create space to hold values in databuf
        bytebuf_append_var(&col_data_buf, column_values);
        bytebuf_append_var(&col_type_buf, col_type);
        bytebuf_append_var(&col_name_buf, column_name);
      }

      // collect column value from dummy_test info. We can have multiple rows of column value
      for (ast_node *values_ast = column_name_list->right; values_ast; values_ast = values_ast->right) {

        int32_t column_index = 0;

        // collect one row of column value
        for (ast_node *list = values_ast->left; list; list = list->right) {
          ast_node *misc_attr_value = list->left;
          Contract(col_data_buf.used);
          bytebuf *column_values = ((bytebuf **) col_data_buf.ptr)[column_index];
          sem_t column_type = ((sem_t *) col_type_buf.ptr)[column_index];
          CSTR column_name = ((CSTR *) col_name_buf.ptr)[column_index];

          bytebuf_append_var(column_values, misc_attr_value);
          column_index++;

          // If a column value is added to dummy_test info for a foreign key column then
          // we need to make sure that same column value is also added as a value in the
          // the referenced table's dummy_test info.
          // e.g.
          //   create table A(id integer primary key);
          //   create table B(id integer primary key references A(id));
          //
          // If there is sample data provided for B.id then we must also ensure that
          // the value provided for B.id is also add as a sample row in A with the same
          // value for id.
          if (is_foreign_key(column_type)) {
            add_value_to_referenced_table(table_name, column_name, column_type, misc_attr_value);
          }
        }
      }

      bytebuf_close(&col_data_buf);
      bytebuf_close(&col_type_buf);
      bytebuf_close(&col_name_buf);
    }
  }
}

// This is invoked for every misc attribute on every create proc statement
// in this translation unit.  We're looking for attributes of the form cql:autotest=(...)
// and we ignore anything else.
static void test_helpers_find_ast_misc_attr_callback(
  CSTR _Nullable misc_attr_prefix,
  CSTR _Nonnull misc_attr_name,
  ast_node *_Nullable ast_misc_attr_value_list,
  void *_Nullable context)
{
  ast_node *stmt = (ast_node *)context;
  Contract(is_ast_create_proc_stmt(stmt));

  if (misc_attr_prefix &&
      misc_attr_name &&
      !StrCaseCmp(misc_attr_prefix, "cql") &&
      !StrCaseCmp(misc_attr_name, "autotest")) {

    // We're actually using intermediate buffers here only so that
    // we can test if they were used (non-empty) at the end so that
    // we can emit the test delimeters if and only if they are needed
    // these are otherwise going to pass through to gh_th_decls and _procs
    // as they came in.
    CHARBUF_OPEN(decls_temp);
    CHARBUF_OPEN(procs_temp);

    charbuf *decls_saved = cg_th_decls;
    charbuf *procs_saved = cg_th_procs;

    cg_th_decls = &decls_temp;
    cg_th_procs = &procs_temp;

    EXTRACT_STRING(proc_name, stmt->left);

    for (ast_node *list = ast_misc_attr_value_list; list; list = list->right) {
      ast_node *misc_attr_value = list->left;
      // We found a nested list which should be nested dummy_test with info
      // [[autotest=(..., (dummy_test, ...), ...)]]
      if (is_ast_misc_attr_value_list(misc_attr_value)) {
        collect_dummy_test_info(misc_attr_value, context);
        cg_test_helpers_dummy_test(stmt);
      }
      // we found autotest attribution
      // [[autotest=(dummy_table, dummy_test, dummy_insert, dummy_select, dummy_result_set)]]
      else {
        // In principle, any option can be combined with any other but some only make sense for procs with
        // a result.

        EXTRACT_STRING(autotest_attr_name, misc_attr_value);
        if (is_autotest_dummy_test(autotest_attr_name)) {
          cg_test_helpers_dummy_test(stmt);
        }

        // these options are only for procs that return a result set
        if (has_result_set(stmt) || has_out_stmt_result(stmt) || has_out_union_stmt_result(stmt)) {
          if (is_autotest_dummy_table(autotest_attr_name)) {
            helper_flags |= DUMMY_TABLE;
            cg_test_helpers_dummy_table(proc_name);
          }
          else if (is_autotest_dummy_insert(autotest_attr_name)) {
            helper_flags |= DUMMY_INSERT;
            cg_test_helpers_dummy_insert(proc_name);
          }
          else if (is_autotest_dummy_select(autotest_attr_name)) {
            helper_flags |= DUMMY_SELECT;
            cg_test_helpers_dummy_select(proc_name);
          }
          else if (is_autotest_dummy_result_set(autotest_attr_name)) {
            helper_flags |= DUMMY_RESULT_SET;
            cg_test_helpers_dummy_result_set(proc_name);
          }
        }
      }
    }

    if (is_declare_proc_needed()) {
      // if we emitted one of the helpers above that sets helper_flags it tells us that we
      // need to emit a declaration for the procedure that had the attribute (i.e. the thing
      // we are trying to mock).  The generated code uses the name of that procedure in a LIKE
      // clause and it won't otherwise be in our output so we emit a declaration for it here.
      cg_test_helpers_declare_proc(stmt);
    }

    cg_th_decls = decls_saved;
    cg_th_procs = procs_saved;

    // generate test delimiters only if needed

    if (decls_temp.used > 1) {
      if (options.test) {
        bprintf(cg_th_decls, "\n-- The statement ending at line %d", stmt->lineno);
      }
      bprintf(cg_th_decls, "%s", decls_temp.ptr);
    }

    // We always generate a marker in the procs section, because there are cases
    // where we need to verify that we generated nothing.
    if (options.test) {
      bprintf(cg_th_procs, "\n-- The statement ending at line %d", stmt->lineno);
      if (procs_temp.used == 1) {
        // this gives us a nice clear message in the output
        bprintf(cg_th_procs, "\n-- no output generated --\n");
      }
    }

    bprintf(cg_th_procs, "%s", procs_temp.ptr);

    CHARBUF_CLOSE(procs_temp);
    CHARBUF_CLOSE(decls_temp);
  }
}

// Having found a create proc statement, we set up to get the attributes on it.
// The find_misc_attrs callback will be invoked for every attribute on the procedure.
// test_helpers_find_ast_misc_attr_callback() will look for the relevant ones.
static void cg_test_helpers_create_proc_stmt(ast_node *stmt, ast_node *misc_attrs) {
  Contract(is_ast_create_proc_stmt(stmt));

  if (misc_attrs) {
    helper_flags = 0;
    dummy_test_infos = symtab_new();

    find_misc_attrs(misc_attrs, test_helpers_find_ast_misc_attr_callback, stmt);

    symtab_delete(dummy_test_infos);
    dummy_test_infos = NULL;
  }
}

// Iterate through statement list
static void cg_test_helpers_stmt_list(ast_node *head) {
  Contract(is_ast_stmt_list(head));
  init_all_trigger_per_table();
  init_all_indexes_per_table();
  CHARBUF_OPEN(procs_buf);
  CHARBUF_OPEN(decls_buf);
  cg_th_procs = &procs_buf;
  cg_th_decls = &decls_buf;
  test_helper_decls_emitted = symtab_new();

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, ast);

    if (is_ast_create_proc_stmt(stmt)) {
      EXTRACT_STRING(proc_name, stmt->left);
      cg_test_helpers_create_proc_stmt(stmt, misc_attrs);
    }
  }

  bprintf(cg_th_output, "%s", decls_buf.ptr);
  bprintf(cg_th_output, "\n");
  bprintf(cg_th_output, "%s", procs_buf.ptr);

  CHARBUF_CLOSE(decls_buf);
  CHARBUF_CLOSE(procs_buf);
  symtab_delete(all_tables_with_triggers);
  all_tables_with_triggers = NULL;
  symtab_delete(all_tables_with_indexes);
  all_tables_with_indexes = NULL;
  symtab_delete(test_helper_decls_emitted);
  test_helper_decls_emitted = NULL;
}

// Force the globals to null state so that they do not look like roots to LeakSanitizer
// all of these should have been freed already.  This is the final safety net to prevent
// non-reporting of leaks.
static void cg_test_helpers_reset_globals() {
  gen_create_triggers = NULL;
  gen_drop_triggers = NULL;
  all_tables_with_triggers = NULL;
  all_tables_with_indexes = NULL;
  test_helper_decls_emitted = NULL;
  dummy_test_infos = NULL;
  cg_th_output = NULL;
  cg_th_decls = NULL;
  cg_th_procs = NULL;
  helper_flags = 0;
}

// Main entry point for test_helpers
cql_noexport void cg_test_helpers_main(ast_node *head) {
  Contract(options.file_names_count == 1);
  cql_exit_on_semantic_errors(head);
  exit_on_validating_schema();
  cg_test_helpers_reset_globals();

  CHARBUF_OPEN(output_buf);

  cg_th_output = &output_buf;

  bprintf(cg_th_output, "%s", rt->source_prefix);
  cg_test_helpers_stmt_list(head);
  cql_write_file(options.file_names[0], cg_th_output->ptr);

  CHARBUF_CLOSE(output_buf);
  cg_test_helpers_reset_globals();
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


cql_data_defn( int32_t charbuf_open_count );
cql_data_defn( pending_charbuf *__charbufs_in_flight; )

//
cql_noexport void release_open_charbufs() {
  while (__charbufs_in_flight) {
    bclose(__charbufs_in_flight->buf);
    __charbufs_in_flight = __charbufs_in_flight->prev;
  }
}

// Initialize the buffer, it will be empty and have no memory allocated. It
// points to the internal buffer.  We track open and closes so we can detect
// leaks.
cql_noexport void bopen(charbuf* b) {
  b->max = CHARBUF_INTERNAL_SIZE;
  b->ptr = &b->internal[0];
  bclear(b);
  charbuf_open_count++;
}

// Free the buffer if it was allocated.  Note that we assume that
// the charbuf itself s on the stack or some such.  The caller
// is responsible for ensuring that the charbuf is released.
cql_noexport void bclose(charbuf *b) {
  if (b->ptr != &b->internal[0]) {
    free(b->ptr);
  }
  b->ptr = NULL;
  b->max = 0;
  b->used = 0;
  charbuf_open_count--;
}

// Clear the buffer, it will be empty but the memory will still be allocated.
cql_noexport void bclear(charbuf *b) {
  // an empty buffer has the null terminator
  b->used = 1;
  b->ptr[0] = 0;
}

// Append a string to the buffer.  The buffer will grow as needed.
// We have to do two passes because we need to know how much space
// to allocate for what we are going to append and the format and arg
// count is arbitrary. We use vsnprintf twice to get the size and then
// to do the actual append.
cql_noexport void vbprintf(charbuf *b, const char *format, va_list args) {
  va_list pass1, pass2;
  va_copy(pass1, args);
  va_copy(pass2, args);

  // invariant is that there is already a null in the buffer
  // we can re-use that one.
  uint32_t avail = b->max - b->used;

  // does not include the trailing null
  uint32_t needed = (uint32_t)vsnprintf(NULL, 0, format, pass1);

  if (needed > avail) {
    b->max += needed + CHARBUF_GROWTH_SIZE;
    char *newptr = _new_array(char, b->max);

    // note that b->used includes the current null terminator
    memcpy(newptr, b->ptr, b->used);
    if (b->ptr != &b->internal[0]) {
      free(b->ptr);
    }
    avail = b->max - b->used;
    b->ptr = newptr;
  }

  // clobber starting from the current null, there is one more byte
  // than avail available to vsnprintf because we're backing off to
  // globber the old null.  The result is always null terminated.
  vsnprintf(b->ptr + b->used - 1, avail + 1, format, pass2);
  b->used += needed;

  va_end(pass1);
  va_end(pass2);
}

// this wraps the above with a va_list, this is the normal entry point
cql_noexport void bprintf(charbuf *b, const char *format, ...) {
  va_list args;
  va_start(args, format);
  vbprintf(b, format, args);
  va_end(args);
}

// this uses a temporary buffer to format the string and then
// duplicates it onto the heap with Strdup.  Note that this
// particular Strdup uses our allocation pools that are bulk
// deallocated at the end of the run. This string is durable.
cql_noexport CSTR dup_printf(const char *format, ...) {
  CSTR result;
  va_list args;
  va_start(args, format);
  CHARBUF_OPEN(tmp);
  vbprintf(&tmp, format, args);
  result = Strdup(tmp.ptr);
  CHARBUF_CLOSE(tmp);
  va_end(args);
  return result;
}

// Writes one character into the buffer, the buffer will grow as needed.
cql_noexport void bputc(charbuf *b, char c) {
  // invariant is that there is already a null in the buffer
  // we can re-use that one.
  uint32_t avail = b->max - b->used;

  if (avail < 1) {
    b->max += CHARBUF_GROWTH_SIZE;
    char *newptr = _new_array(char, b->max);

    // note that b->used includes the current null terminator
    memcpy(newptr, b->ptr, b->used);
    if (b->ptr != &b->internal[0]) {
      free(b->ptr);
    }
    avail = b->max - b->used;
    b->ptr = newptr;
  }

  b->ptr[b->used-1] = c; // clobber the previous null
  b->ptr[b->used++] = 0; // put a new null in place, for sure room for this
}

// Indents the input buffer by the specified number of spaces
// and puts the result into the output buffer.  This is used to format
// source code with unindented fragments getting indended after they are
// created and put into the main buffer.  For instance a statement list
// might get formatted with no indentation, once the whole list is done
// it can be indented as a block and inserted into the main buffer.
cql_noexport void bindent(charbuf *output, charbuf *input, int32_t indent) {
  if (indent == 0) {
    bprintf(output, "%s", input->ptr);
    return;
  }

  CHARBUF_OPEN(spaces);
  for (int32_t i = 0; i < indent; i++) bputc(&spaces, ' ');

  const char *p = input->ptr;

  for (;;) {
    if (!*p) break;

    // skip indenting blank lines
    if (*p != '\n') {
      bprintf(output, "%s", spaces.ptr);
    }

    while (*p) {
      char ch = *p++;
      bputc(output, ch);
      if (ch == '\n') break;
    }
  }

  CHARBUF_CLOSE(spaces);
}

// "Reads" a line from the incoming CSTR modifying it to the
// point to the start of the next line. The output buffer
// is cleared first and ends with a copy of the one line.
cql_noexport bool_t breadline(charbuf *output, CSTR *data) {
  // clean buffer
  bclear(output);

  CSTR p = *data;

  // no more lines
  if (p[0] == '\0') {
    return false;
  }

  // emit up to the next linefeed or end of the buffer, whichever comes first
  for (; *p != '\n' && *p != '\0'; p++) {
    bputc(output, *p);
  }

  // if we ended at a linefeed, skip over that
  if (p[0] == '\n') {
    p++;
  }

  *data = p;
  return true;
}/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


// duplicate a string into the string pool, these live until the end of the run
cql_noexport char *_Nonnull Strdup(CSTR _Nonnull s) {
  uint32_t length = (uint32_t)(strlen(s) + 1);
  void *result = minipool_alloc(str_pool, length);
  Invariant(result);
  return (char *)memcpy(result, s, length);
}

// Portable case-insensitive string comparison
cql_noexport int32_t StrCaseCmp(
  CSTR _Nonnull s1,
  CSTR _Nonnull s2)
{
  CSTR p1 = s1;
  CSTR p2 = s2;
  int32_t result;
  if (p1 == p2)
    return 0;

  while ((result = ToLower(*p1) - ToLower(*p2++)) == 0)
    if (*p1++ == '\0')
      break;

  return result;
}

// Portable case-insensitive string comparison with length
cql_noexport int32_t StrNCaseCmp(
  CSTR _Nonnull s1,
  CSTR _Nonnull s2,
  size_t n)
{
  CSTR p1 = s1;
  CSTR p2 = s2;
  int32_t result = 0;

  for (; n != 0; --n) {
    if ((result = ToLower(*p1) - ToLower(*p2++)) != 0) {
        return result;
    }
    if (*p1++ == '\0')
        return 0;
  }

  return result;
}

// Portable case-insensitive string comparison at end
cql_noexport bool_t StrEndsWith(
  CSTR _Nonnull haystack,
  CSTR _Nonnull needle)
{
  size_t haystack_len = strlen(haystack);
  size_t needle_len = strlen(needle);

  return (haystack_len >= needle_len) &&
         (!StrNCaseCmp(haystack + haystack_len - needle_len, needle, needle_len));
}

// Portable versions of the character classification functions They are
// PascalCased to avoid conflict with the standard C library functions if they
// exist.

cql_noexport bool_t IsLower(char c) {
  return c >= 'a' && c <= 'z';
}

cql_noexport bool_t IsUpper(char c) {
  return c >= 'A' && c <= 'Z';
}

cql_noexport bool_t IsAlpha(char c) {
  return IsLower(c) || IsUpper(c);
}

cql_noexport bool_t IsDigit(char c) {
  return c >= '0' && c <= '9';
}

cql_noexport bool_t IsXDigit(char c) {
  return IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}

cql_noexport char ToLower(char c) {
  return IsUpper(c) ? c + ('a' - 'A') : c;
}

cql_noexport char ToUpper(char c) {
  return IsLower(c) ? c - ('a' - 'A') : c;
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * \file
 * Functions and types for CRC checks.
 *
 * Generated on Wed Jun  5 12:56:10 2019
 * by pycrc v0.9.2, https://pycrc.org
 * using the configuration:
 *  - Width         = 64
 *  - Poly          = 0x42f0e1eba9ea3693
 *  - XorIn         = 0xffffffffffffffff
 *  - ReflectIn     = True
 *  - XorOut        = 0xffffffffffffffff
 *  - ReflectOut    = True
 *  - Algorithm     = table-driven
 */


/**
 * Static table used for the table_driven implementation.
 */
static const crc_t crc_table[256] = {
    0x0000000000000000, 0xb32e4cbe03a75f6f, 0xf4843657a840a05b, 0x47aa7ae9abe7ff34,
    0x7bd0c384ff8f5e33, 0xc8fe8f3afc28015c, 0x8f54f5d357cffe68, 0x3c7ab96d5468a107,
    0xf7a18709ff1ebc66, 0x448fcbb7fcb9e309, 0x0325b15e575e1c3d, 0xb00bfde054f94352,
    0x8c71448d0091e255, 0x3f5f08330336bd3a, 0x78f572daa8d1420e, 0xcbdb3e64ab761d61,
    0x7d9ba13851336649, 0xceb5ed8652943926, 0x891f976ff973c612, 0x3a31dbd1fad4997d,
    0x064b62bcaebc387a, 0xb5652e02ad1b6715, 0xf2cf54eb06fc9821, 0x41e11855055bc74e,
    0x8a3a2631ae2dda2f, 0x39146a8fad8a8540, 0x7ebe1066066d7a74, 0xcd905cd805ca251b,
    0xf1eae5b551a2841c, 0x42c4a90b5205db73, 0x056ed3e2f9e22447, 0xb6409f5cfa457b28,
    0xfb374270a266cc92, 0x48190ecea1c193fd, 0x0fb374270a266cc9, 0xbc9d3899098133a6,
    0x80e781f45de992a1, 0x33c9cd4a5e4ecdce, 0x7463b7a3f5a932fa, 0xc74dfb1df60e6d95,
    0x0c96c5795d7870f4, 0xbfb889c75edf2f9b, 0xf812f32ef538d0af, 0x4b3cbf90f69f8fc0,
    0x774606fda2f72ec7, 0xc4684a43a15071a8, 0x83c230aa0ab78e9c, 0x30ec7c140910d1f3,
    0x86ace348f355aadb, 0x3582aff6f0f2f5b4, 0x7228d51f5b150a80, 0xc10699a158b255ef,
    0xfd7c20cc0cdaf4e8, 0x4e526c720f7dab87, 0x09f8169ba49a54b3, 0xbad65a25a73d0bdc,
    0x710d64410c4b16bd, 0xc22328ff0fec49d2, 0x85895216a40bb6e6, 0x36a71ea8a7ace989,
    0x0adda7c5f3c4488e, 0xb9f3eb7bf06317e1, 0xfe5991925b84e8d5, 0x4d77dd2c5823b7ba,
    0x64b62bcaebc387a1, 0xd7986774e864d8ce, 0x90321d9d438327fa, 0x231c512340247895,
    0x1f66e84e144cd992, 0xac48a4f017eb86fd, 0xebe2de19bc0c79c9, 0x58cc92a7bfab26a6,
    0x9317acc314dd3bc7, 0x2039e07d177a64a8, 0x67939a94bc9d9b9c, 0xd4bdd62abf3ac4f3,
    0xe8c76f47eb5265f4, 0x5be923f9e8f53a9b, 0x1c4359104312c5af, 0xaf6d15ae40b59ac0,
    0x192d8af2baf0e1e8, 0xaa03c64cb957be87, 0xeda9bca512b041b3, 0x5e87f01b11171edc,
    0x62fd4976457fbfdb, 0xd1d305c846d8e0b4, 0x96797f21ed3f1f80, 0x2557339fee9840ef,
    0xee8c0dfb45ee5d8e, 0x5da24145464902e1, 0x1a083bacedaefdd5, 0xa9267712ee09a2ba,
    0x955cce7fba6103bd, 0x267282c1b9c65cd2, 0x61d8f8281221a3e6, 0xd2f6b4961186fc89,
    0x9f8169ba49a54b33, 0x2caf25044a02145c, 0x6b055fede1e5eb68, 0xd82b1353e242b407,
    0xe451aa3eb62a1500, 0x577fe680b58d4a6f, 0x10d59c691e6ab55b, 0xa3fbd0d71dcdea34,
    0x6820eeb3b6bbf755, 0xdb0ea20db51ca83a, 0x9ca4d8e41efb570e, 0x2f8a945a1d5c0861,
    0x13f02d374934a966, 0xa0de61894a93f609, 0xe7741b60e174093d, 0x545a57dee2d35652,
    0xe21ac88218962d7a, 0x5134843c1b317215, 0x169efed5b0d68d21, 0xa5b0b26bb371d24e,
    0x99ca0b06e7197349, 0x2ae447b8e4be2c26, 0x6d4e3d514f59d312, 0xde6071ef4cfe8c7d,
    0x15bb4f8be788911c, 0xa6950335e42fce73, 0xe13f79dc4fc83147, 0x521135624c6f6e28,
    0x6e6b8c0f1807cf2f, 0xdd45c0b11ba09040, 0x9aefba58b0476f74, 0x29c1f6e6b3e0301b,
    0xc96c5795d7870f42, 0x7a421b2bd420502d, 0x3de861c27fc7af19, 0x8ec62d7c7c60f076,
    0xb2bc941128085171, 0x0192d8af2baf0e1e, 0x4638a2468048f12a, 0xf516eef883efae45,
    0x3ecdd09c2899b324, 0x8de39c222b3eec4b, 0xca49e6cb80d9137f, 0x7967aa75837e4c10,
    0x451d1318d716ed17, 0xf6335fa6d4b1b278, 0xb199254f7f564d4c, 0x02b769f17cf11223,
    0xb4f7f6ad86b4690b, 0x07d9ba1385133664, 0x4073c0fa2ef4c950, 0xf35d8c442d53963f,
    0xcf273529793b3738, 0x7c0979977a9c6857, 0x3ba3037ed17b9763, 0x888d4fc0d2dcc80c,
    0x435671a479aad56d, 0xf0783d1a7a0d8a02, 0xb7d247f3d1ea7536, 0x04fc0b4dd24d2a59,
    0x3886b22086258b5e, 0x8ba8fe9e8582d431, 0xcc0284772e652b05, 0x7f2cc8c92dc2746a,
    0x325b15e575e1c3d0, 0x8175595b76469cbf, 0xc6df23b2dda1638b, 0x75f16f0cde063ce4,
    0x498bd6618a6e9de3, 0xfaa59adf89c9c28c, 0xbd0fe036222e3db8, 0x0e21ac88218962d7,
    0xc5fa92ec8aff7fb6, 0x76d4de52895820d9, 0x317ea4bb22bfdfed, 0x8250e80521188082,
    0xbe2a516875702185, 0x0d041dd676d77eea, 0x4aae673fdd3081de, 0xf9802b81de97deb1,
    0x4fc0b4dd24d2a599, 0xfceef8632775faf6, 0xbb44828a8c9205c2, 0x086ace348f355aad,
    0x34107759db5dfbaa, 0x873e3be7d8faa4c5, 0xc094410e731d5bf1, 0x73ba0db070ba049e,
    0xb86133d4dbcc19ff, 0x0b4f7f6ad86b4690, 0x4ce50583738cb9a4, 0xffcb493d702be6cb,
    0xc3b1f050244347cc, 0x709fbcee27e418a3, 0x3735c6078c03e797, 0x841b8ab98fa4b8f8,
    0xadda7c5f3c4488e3, 0x1ef430e13fe3d78c, 0x595e4a08940428b8, 0xea7006b697a377d7,
    0xd60abfdbc3cbd6d0, 0x6524f365c06c89bf, 0x228e898c6b8b768b, 0x91a0c532682c29e4,
    0x5a7bfb56c35a3485, 0xe955b7e8c0fd6bea, 0xaeffcd016b1a94de, 0x1dd181bf68bdcbb1,
    0x21ab38d23cd56ab6, 0x9285746c3f7235d9, 0xd52f0e859495caed, 0x6601423b97329582,
    0xd041dd676d77eeaa, 0x636f91d96ed0b1c5, 0x24c5eb30c5374ef1, 0x97eba78ec690119e,
    0xab911ee392f8b099, 0x18bf525d915feff6, 0x5f1528b43ab810c2, 0xec3b640a391f4fad,
    0x27e05a6e926952cc, 0x94ce16d091ce0da3, 0xd3646c393a29f297, 0x604a2087398eadf8,
    0x5c3099ea6de60cff, 0xef1ed5546e415390, 0xa8b4afbdc5a6aca4, 0x1b9ae303c601f3cb,
    0x56ed3e2f9e224471, 0xe5c372919d851b1e, 0xa26908783662e42a, 0x114744c635c5bb45,
    0x2d3dfdab61ad1a42, 0x9e13b115620a452d, 0xd9b9cbfcc9edba19, 0x6a978742ca4ae576,
    0xa14cb926613cf817, 0x1262f598629ba778, 0x55c88f71c97c584c, 0xe6e6c3cfcadb0723,
    0xda9c7aa29eb3a624, 0x69b2361c9d14f94b, 0x2e184cf536f3067f, 0x9d36004b35545910,
    0x2b769f17cf112238, 0x9858d3a9ccb67d57, 0xdff2a94067518263, 0x6cdce5fe64f6dd0c,
    0x50a65c93309e7c0b, 0xe388102d33392364, 0xa4226ac498dedc50, 0x170c267a9b79833f,
    0xdcd7181e300f9e5e, 0x6ff954a033a8c131, 0x28532e49984f3e05, 0x9b7d62f79be8616a,
    0xa707db9acf80c06d, 0x14299724cc279f02, 0x5383edcd67c06036, 0xe0ada17364673f59
};


cql_export crc_t crc_update(crc_t crc, const void *data, size_t data_len)
{
    const unsigned char *d = (const unsigned char *)data;
    unsigned int tbl_idx;

    while (data_len--) {
        tbl_idx = (crc ^ *d) & 0xff;
        crc = (crc_table[tbl_idx] ^ (crc >> 8)) & 0xffffffffffffffff;
        d++;
    }
    return crc & 0xffffffffffffffff;
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


// This converts from SQL string literal format to plain output
// Note that SQL string literal have no escapes except for double quote
cql_noexport void cg_decode_string_literal(CSTR str, charbuf *output) {
  const char quote = '\'';
  CSTR p = str+1;  // the first character is the quote itself

  while (p[0]) {
    if (p[0] == quote && p[1] == quote) {
      bputc(output, quote);
      p++;
    }
    else if (p[0] == quote) {
      break;
    }
    else {
      bputc(output, p[0]);
    }
    p++;
  }
}

// This converts from a plain string to sql string literal
// Note SQL string literals have no escape sequences other than '' -> '
cql_noexport void cg_encode_string_literal(CSTR str, charbuf *output) {
  const char quote = '\'';
  const char *p = str;

  bputc(output, quote);

  for ( ;p[0]; p++) {
    if (p[0] == quote) bputc(output, quote);
    bputc(output, p[0]);
  }

  bputc(output, quote);
}

static void emit_hex_digit(uint32_t ch, charbuf *output) {
  Contract(ch >= 0 && ch <= 15);
  if (ch < 10) {
    bputc(output, (char)(ch + '0'));
  }
  else {
    bputc(output, (char)(ch - 10 + 'a'));
  }
}

// This converts from a plain string to C string literal
cql_noexport void cg_encode_char_as_c_string_literal(char c, charbuf *output) {
  const char quote = '"';
  const char backslash = '\\';

  switch (c) {
    case '\"':  bputc(output, backslash); bputc(output, quote); break;
    case '\a':  bputc(output, backslash); bputc(output, 'a'); break;
    case '\b':  bputc(output, backslash); bputc(output, 'b'); break;
    case '\f':  bputc(output, backslash); bputc(output, 'f'); break;
    case '\n':  bputc(output, backslash); bputc(output, 'n'); break;
    case '\r':  bputc(output, backslash); bputc(output, 'r'); break;
    case '\t':  bputc(output, backslash); bputc(output, 't'); break;
    case '\v':  bputc(output, backslash); bputc(output, 'v'); break;
    case '\\':  bputc(output, c); bputc(output, c); break;
    default  :
      // note: 0x80 - 0xff will be negative and are hence covered by this test
      if (c < 32) {
        uint32_t ch = (uint32_t)c;
        ch &= 0xff;
        bprintf(output, "\\x");
        emit_hex_digit(ch >> 4, output);
        emit_hex_digit(ch & 0xf, output);
      }
      else {
        bputc(output, c);
      }
  }
}

// This converts from a plain string to json string literal (fewer escapes available/needed)
//
// From the spec, the valid single escape characters are
// SingleEscapeCharacter :: one of
//      ' " \ b f n r t v
//
// \v should be legal but it is avoided because the python validator
// doesn't support it. We generate all of the others if needed
// but \' is never needed as we always use double quotes.
//
// likewise the spec says:
//
// UnicodexEscapeSequence ::
//      u HexDigit HexDigit HexDigit HexDigit
//
cql_noexport void cg_encode_char_as_json_string_literal(char c, charbuf *output) {
  const char quote = '"';
  const char backslash = '\\';

  switch (c) {
    case '\"':  bputc(output, backslash); bputc(output, quote); break;
    case '\\':  bputc(output, c); bputc(output, c); break;
    case '\b':  bputc(output, backslash); bputc(output, 'b'); break;
    case '\f':  bputc(output, backslash); bputc(output, 'f'); break;
    case '\n':  bputc(output, backslash); bputc(output, 'n'); break;
    case '\r':  bputc(output, backslash); bputc(output, 'r'); break;
    case '\t':  bputc(output, backslash); bputc(output, 't'); break;
    default  :
      // note: 0x80 - 0xff will be negative and are hence covered by this test
      if (c < 32) {
        uint32_t ch = (uint32_t)c;
        ch &= 0xff;
        bprintf(output, "\\u00");
        emit_hex_digit(ch >> 4, output);
        emit_hex_digit(ch & 0xf, output);
      }
      else {
        bputc(output, c);
      }
  }
}

// This converts from a plain string to C string literal
cql_noexport void cg_encode_c_string_literal(CSTR str, charbuf *output) {
  const char quote = '"';
  const char *p = str;

  bputc(output, quote);

  for ( ;p[0]; p++) {
    cg_encode_char_as_c_string_literal(p[0], output);
  }
  bputc(output, quote);
}

// This converts from a plain string to JSON string literal
cql_noexport void cg_encode_json_string_literal(CSTR str, charbuf *output) {
  const char quote = '"';
  const char *p = str;

  bputc(output, quote);

  for ( ;p[0]; p++) {
    cg_encode_char_as_json_string_literal(p[0], output);
  }
  bputc(output, quote);
}


// convert a single hex character to an integer
static uint32_t hex_to_int(char c) {
  uint32_t ch = (uint32_t)(unsigned char)c;
  if (ch >= '0' && ch <= '9')
    return ch - '0';

  if (ch >= 'a' && ch <= 'f')
     return ch - 'a' + 10;

  // this is all that's left
  Contract(ch >= 'A' && ch <= 'F');
  return ch - 'A' + 10;
}

static void decode_hex_escape(CSTR *pstr, charbuf *output) {
  Contract(pstr);
  Contract(**pstr == 'x' || **pstr == 'X');
  CSTR p = *pstr;
  p++; // skip the 'x'

  // the escape sequence is not interpreted as hex if not well formed
  if (IsXDigit(p[0]) && IsXDigit(p[1])) {
    char ch = (char)(hex_to_int(p[0]) * 16 + hex_to_int(p[1]));

    // No embedded nulls, all the strings are null terminated so this will just screw everything up.
    if (ch != 0) {
      bputc(output, ch);
    }
    // note, the main loop will skip an additional character as a matter of course
    // so the second byte we do not pass over
    p++;

    // the input will be left on the 'x' if it wasn't well formed, which is the skipped as usual
    *pstr = p;
  }
}

cql_noexport void cg_decode_c_string_literal(CSTR str, charbuf *output) {
  // don't call me with strings that are not properly "" delimited
  const char quote = '"';
  const char backslash = '\\';

  Contract(str[0] == quote);
  CSTR p = str + 1;

  for ( ;p[0]; p++) {
    if (p[0] == quote) {
      break;
    }

    if (p[0] != backslash) {
      bputc(output, p[0]);
      continue;
    }

    p++;
    switch (p[0]) {
      case 'a': bputc(output, '\a'); break;
      case 'b': bputc(output, '\b'); break;
      case 'f': bputc(output, '\f'); break;
      case 'n': bputc(output, '\n'); break;
      case 'r': bputc(output, '\r'); break;
      case 't': bputc(output, '\t'); break;
      case 'v': bputc(output, '\v'); break;
      case 'x': decode_hex_escape(&p, output); break;
      default : bputc(output, p[0]); break;
    }
  }

  // don't call me with strings that are not properly "" delimited
  Contract(p[0] == quote);
}

// When we need to execute SQL, we get the text of the SQL from the gen_ functions.
// Those functions return plaintext.  We need to quote that text so it can appear
// in a C string literal.  To do this we need to:
//  * put quotes around it
//  * do C string processing
//  * turn linefeeds into spaces (we break the string here for readability)
//    * or remove the unquoted linefeeds and indentation
cql_noexport void cg_pretty_quote_plaintext(CSTR str, charbuf *output, uint32_t flags) {
  Contract(str);

  const char squote = '\'';
  bool_t atStart = 1;
  bool_t inQuote = 0;
  bool_t multi_line = !!(flags & PRETTY_QUOTE_MULTI_LINE);
  bool_t for_json = !!(flags & PRETTY_QUOTE_JSON);

  bputc(output, '"');
  for (CSTR p = str; p[0]; p++) {
    // trim leading spaces down to one
    if (atStart && p[0] == ' ' && p[1] == ' ') {
       continue;
    }
    atStart = 0;
    // figure out if we're in quoted sql text, if we are then any newlines we see
    // are part of the string not part of our multi-line formatting.  They have to be escaped.
    if (!inQuote && p[0] == squote) {
      inQuote = 1;
      bprintf(output, "'");
    }
    else if (inQuote && p[0] == squote && p[1] == squote) {
      // escaped '' is escaped quote, stay in quoted mode
      bprintf(output, "''");
      // gobble the second quote since we just emitted it already
      // this way it has no way to fool us into leaving quoted mode (a previous bug)
      p++;
    }
    else if (inQuote && p[0] == squote) {
      inQuote = 0;
      bprintf(output, "'");
    }
    else if (!inQuote && p[0] == '\n') {
      if (multi_line) {
        // convert the newline to a space, break the string into multi-part literal
        bprintf(output, " \"\n  ");

        // use the embedded spaces to indent the string literal not to make the string fatter
        while (p[1] == ' ') {
          p++;
          bputc(output, ' ');
        }
        bputc(output, '"');
      }
      else {
        // emit the newline as a single space
        bputc(output, ' ');

        // eat any spaces that follow the newline
        while (p[1] == ' ') {
          p++;
        }
      }
    }
    else {
      if (for_json) {
        cg_encode_char_as_json_string_literal(p[0], output);
      }
      else {
        cg_encode_char_as_c_string_literal(p[0], output);
      }
    }
  }
  bputc(output, '"');
}

// This removes any "*/" and "/*" that happens in the buffer
// by converting them into "+/" and "/+" respectively.
//
// This is used for two purposes:
//
//   - To prevent prematurely ending a comment in an emitted
//     comment block.
//   - To prevent certain compiler under some compilation
//     flags from failing when they see an opening comment
//     marker inside a comment.
//
// You can only use this function on text that is going
// into a comment block.
cql_noexport void cg_remove_slash_star_and_star_slash(charbuf *_Nonnull b) {
  char *p = b->ptr;
  for (uint32_t i = 0; i < b->used - 2; i++) {
    if (p[i] == '*' && p[i+1] == '/') {
      p[i] = '+';
    }
    else if (p[i] == '/' && p[i+1] == '*') {
      p[i+1] = '+';
    }
  }
}

// Helper to case on string arguments to cql_compressed() and output
// readable multi-line strings when necessary.
cql_noexport void cg_pretty_quote_compressed_text(CSTR _Nonnull str, charbuf *_Nonnull output) {
  // In the case of an empty compressed string - cql_compressed("") we do not want
  // extra newlines
  if (strlen(str) == 0) {
    cg_pretty_quote_plaintext(str, output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);
    return;
  }

  // Otherwise, we want the SQL string to be new-line separated and indented for readability
  CHARBUF_OPEN(temp_output);
  bprintf(&temp_output, "\n  ");
  cg_pretty_quote_plaintext(str, &temp_output, PRETTY_QUOTE_C | PRETTY_QUOTE_MULTI_LINE);
  bindent(output, &temp_output, 6);
  bclear(&temp_output);
  bprintf(&temp_output, "\n      ");
  bprintf(output, "%s", temp_output.ptr);
  CHARBUF_CLOSE(temp_output);
}

cql_noexport void cg_encode_qstr(charbuf *_Nonnull output, CSTR _Nonnull qstr) {
  Contract(qstr);
  Contract(qstr[0] == '`');
  uint32_t len = (uint32_t)strlen(qstr);
  Contract(len >= 3);  // `a` is the smallest legal string
  Contract(qstr[len-1] == '`');
  uint32_t used = output->used;

  bool_t used_hex = false;
  len--;
  uint32_t i;
  for (i = 1; i < len; i++) {
    uint8_t ch = (uint8_t)qstr[i];
    if (
      (ch >= 'a' && ch <= 'z') ||
      (ch >= 'A' && ch <= 'Z' && ch != 'X') ||
      (ch >= '0' && ch <= '9') ||
      ch == '_') {
        bputc(output, qstr[i]);
        continue;
    }

    if (qstr[i] == '`') {
      // the string is known to be well formed!
      // skip the second ` of the series
      Contract(qstr[i+1] == '`');
      i++;
    }

    bputc(output, 'X');
    emit_hex_digit(ch >> 4, output);
    emit_hex_digit(ch & 0xf, output);
    used_hex = true;
  }

  if (used_hex) {
    // place holders to make space
    bputc(output, '$');
    bputc(output, '$');
    // shift the string up two characters
    memmove(output->ptr + used + 1, output->ptr + used - 1, output->used - used - 2);
    // add the X_ prefix
    output->ptr[used-1] = 'X';
    output->ptr[used] = '_';
  }
}

cql_noexport void cg_decode_qstr(charbuf *_Nonnull output, CSTR _Nonnull qstr) {
  Contract(qstr);

  // The string was quoted but didn't require escapes, just put the original back-quotes back
  if (qstr[0] != 'X' || qstr[1] != '_') {
    bprintf(output, "`%s`", qstr);
    return;
  }

  bputc(output, '`');
  qstr += 2;
  for (; *qstr; qstr++) {
    if (*qstr != 'X') {
      bputc(output, *qstr);
    }
    else {
      decode_hex_escape(&qstr, output);
      if (output->ptr[output->used - 2] == '`') {
        bputc(output, '`');
      }
    }
  }
  bputc(output, '`');
}

cql_noexport void cg_unquote_encoded_qstr(charbuf *_Nonnull output, CSTR _Nonnull qstr) {
  Contract(qstr);

  // The string was quoted but didn't require escapes, just put the original back-quotes back
  if (qstr[0] != 'X' || qstr[1] != '_') {
    bprintf(output, "%s", qstr);
    return;
  }

  qstr += 2;
  for (; *qstr; qstr++) {
    if (*qstr != 'X') {
      bputc(output, *qstr);
    }
    else {
      decode_hex_escape(&qstr, output);
    }
  }
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// stubs to avoid link errors (none needed)

#else

// Performs evaluation of the const(...) node
// this is logically part of the semantic analysis phase but
// the code is hoisted out for clarity


// This is the symbol table with the ast dispatch when we get to an ast node
// we look it up here and call the appropriate function whose name matches the ast
// node type.
static symtab *evals;

// The signature of the various evaluation functions
typedef void (*eval_dispatch)(ast_node *expr, eval_node *result);

// Null literal
static void eval_null(ast_node *expr, eval_node *result) {
  result->sem_type = SEM_TYPE_NULL;
}

// A number; it could be any of the numeric types with or without a hex prefix
// It's already in string for for us.
static void eval_num_str(CSTR lit, int32_t num_type, eval_node *result) {
  result->sem_type = SEM_TYPE_ERROR;

  switch (num_type) {
  case NUM_BOOL:
    result->bool_value = (bool_t)!!strtol(lit, NULL, 10);
    result->sem_type = SEM_TYPE_BOOL;
    break;

  case NUM_INT:
    result->int32_value = (int32_t)strtol(lit, NULL, has_hex_prefix(lit) ? 16 : 10);
    result->sem_type = SEM_TYPE_INTEGER;
    break;

  case NUM_LONG:
    result->int64_value = (int64_t)strtoll(lit, NULL, has_hex_prefix(lit) ? 16 : 10);
    result->sem_type = SEM_TYPE_LONG_INTEGER;
    break;

  default:
    Invariant(num_type == NUM_REAL);  // nothing else left
    result->real_value = atof(lit);
    result->sem_type = SEM_TYPE_REAL;
    break;
  }

  Invariant(result->sem_type != SEM_TYPE_ERROR);
}

// A number; it could be any of the numeric types with or without a hex prefix
static void eval_num(ast_node *expr, eval_node *result) {
  EXTRACT_NUM_TYPE(num_type, expr);
  EXTRACT_NUM_VALUE(lit, expr);

  eval_num_str(lit, num_type, result);
}

// Used for explicit casts but also for numeric conversions when
// a free promotion is allowed.  This will convert between
// any of the numeric types.  There are twelve possible conversions
// since a type never converts to itself.  This only works on
// numeric types.  Any errors and null stuff must be pre-checked.
cql_noexport void eval_cast_to(eval_node *result, sem_t sem_type) {
  sem_t core_type_source = core_type_of(result->sem_type);
  sem_t core_type_target = core_type_of(sem_type);

  Contract(core_type_source != SEM_TYPE_NULL);
  Contract(core_type_target != SEM_TYPE_NULL);
  Contract(core_type_source != SEM_TYPE_ERROR);
  Contract(core_type_target != SEM_TYPE_ERROR);

  if (core_type_source == core_type_target) {
    return;
  }

  switch (core_type_target) {
    case SEM_TYPE_REAL:
      switch (core_type_source) {
        case SEM_TYPE_INTEGER:
          result->real_value = (double)result->int32_value;
          break;
        case SEM_TYPE_BOOL:
          result->real_value = (double)!!result->bool_value;
          break;
        default:
          Invariant(core_type_source == SEM_TYPE_LONG_INTEGER); // nothing else left
          result->real_value = (double)result->int64_value;
          break;
      }
      break;
    case SEM_TYPE_LONG_INTEGER:
      switch (core_type_source) {
        case SEM_TYPE_REAL:
          result->int64_value = (int64_t)result->real_value;
          break;
        case SEM_TYPE_BOOL:
          result->int64_value = (int64_t)!!result->bool_value;
          break;
        default:
          Invariant(core_type_source == SEM_TYPE_INTEGER); // nothing else left
          result->int64_value = (int64_t)result->int32_value;
          break;
      }
      break;
    case SEM_TYPE_INTEGER:
      switch (core_type_source) {
        case SEM_TYPE_REAL:
          result->int32_value = (int32_t)result->real_value;
          break;
        case SEM_TYPE_BOOL:
          result->int32_value = (int32_t)!!result->bool_value;
          break;
        default:
          Invariant(core_type_source == SEM_TYPE_LONG_INTEGER); // nothing else left
          result->int32_value = (int32_t)result->int64_value;
          break;
      }
      break;
    default:
      Invariant(core_type_target == SEM_TYPE_BOOL); // nothing else left
      switch (core_type_source) {
        case SEM_TYPE_REAL:
           result->bool_value = (result->real_value != 0);
          break;
        case SEM_TYPE_INTEGER:
          result->bool_value = (result->int32_value != 0);
          break;
        default:
          Invariant(core_type_source == SEM_TYPE_LONG_INTEGER); // nothing else left
          result->bool_value = (result->int64_value != 0);
          break;
      }
      break;
  }
  result->sem_type = core_type_target;
}

static void eval_format_real(double real, charbuf *output) {
  CHARBUF_OPEN(tmp);
  bprintf(&tmp, "%*e", DECIMAL_DIG, real);
  CSTR p = tmp.ptr;
  while (*p == ' ') p++;
  bprintf(output, "%s", p);
  CHARBUF_CLOSE(tmp);
}

// In order to use the eval logic to replace expression trees we need to be able
// to make a new ast node that represents the result of a calculation.  This
// function takes such a result and creates a node.  The incoming expression is
// harvested for file and line info and then replaced in the tree.  It's value
// is otherwise irrelevant because the computation has already been done.
// The incoming evaluation result must not be an error node.
cql_noexport ast_node *eval_set(ast_node *expr, eval_node *result) {
  Contract(result);
  sem_t core_type = core_type_of(result->sem_type);
  Contract(core_type != SEM_TYPE_ERROR);

  AST_REWRITE_INFO_SET(expr->lineno, expr->filename);

  ast_node *new_num = NULL;

  switch (core_type) {
  case SEM_TYPE_INTEGER:
    new_num = new_ast_num(NUM_INT, dup_printf("%d", result->int32_value));
    break;

  case SEM_TYPE_LONG_INTEGER:
    // we have to special case for MIN_LONG
    if  (result->int64_value == -9223372036854775807LL - 1) {
      // later stages of the compiler are looking for this case and will rewrite
      // it as "_64(-9223372036854775807) - 1" we encode it this way because
      // that's how its appears for users
      new_num = new_ast_uminus(new_ast_num(NUM_LONG, dup_printf("9223372036854775808")));
    }
    else {
      // other cases, don't need special treatment so we use the most economical encoding
      new_num = new_ast_num(NUM_LONG, dup_printf("%lld", (llint_t)result->int64_value));
    }
    break;

  case SEM_TYPE_BOOL:
    new_num = new_ast_num(NUM_BOOL, dup_printf("%d", !!result->bool_value));
    break;

  case SEM_TYPE_REAL:
    {
    CHARBUF_OPEN(tmp);
    eval_format_real(result->real_value, &tmp);
    new_num = new_ast_num(NUM_REAL, dup_printf("%s", tmp.ptr));
    CHARBUF_CLOSE(tmp);
    break;
    }

  default:
    Invariant(core_type == SEM_TYPE_NULL); // nothing else left
    new_num = new_ast_null();
    break;
  }

  // now replace the incoming expression in its tree

  Invariant(new_num);
  ast_node *parent = expr->parent;

  if (parent->left == expr) {
    ast_set_left(parent, new_num);
  }
  else {
    ast_set_right(parent, new_num);
  }

  AST_REWRITE_INFO_RESET();
  return new_num;
}

// This finds the best type for a numeric operation. We use the "biggest"
// numeric type that can hold the result. Errors and nulls must have already
// been handled, they have no business showing up here.
static sem_t eval_combined_type(eval_node *left, eval_node *right) {
  sem_t core_type_left = core_type_of(left->sem_type);
  sem_t core_type_right = core_type_of(right->sem_type);

  Contract(core_type_left != SEM_TYPE_ERROR);
  Contract(core_type_right != SEM_TYPE_ERROR);
  Contract(core_type_left != SEM_TYPE_NULL);
  Contract(core_type_right != SEM_TYPE_NULL);

  sem_t result = SEM_TYPE_ERROR;

  if (core_type_left == SEM_TYPE_REAL || core_type_right == SEM_TYPE_REAL) {
    result = SEM_TYPE_REAL;
  }
  else if (core_type_left == SEM_TYPE_LONG_INTEGER || core_type_right == SEM_TYPE_LONG_INTEGER) {
    result =  SEM_TYPE_LONG_INTEGER;
  }
  else if (core_type_left == SEM_TYPE_INTEGER || core_type_right == SEM_TYPE_INTEGER) {
    result = SEM_TYPE_INTEGER;
  }
  else {
    Invariant(core_type_left == SEM_TYPE_BOOL && core_type_right == SEM_TYPE_BOOL);
    result = SEM_TYPE_BOOL;
  }

  Invariant(result != SEM_TYPE_ERROR);
  return result;
}

#define DIV_TEST(x)

// All the normal binary operators are handled the same way, only the operator
// actually varies. The thing is the operator has to be lexically substituted in
// so that we get the correct math type so much as this much macro is a code
// smell, the alternative is open coding this for every binary operator which is
// worse.  The steps are:
//   * any error in the operands results in an error
//   * any null operand results in a null result
//   * find the smallest numeric type that will hold the answer
//   * convert to that type if needed
//   * apply the operator on that type
//
// NOTE: logical AND/OR cannot be on this plan because of their short circuit
//       behavior. for bitwise operators, see the _NO_REAL version of this macro
//       for comparisons likewise see below for a slightly different version.
#define BINARY_OP(op) \
  eval_node left = EVAL_NIL; \
  eval_node right = EVAL_NIL; \
  eval(expr->left, &left); \
  eval(expr->right, &right); \
  \
  if (left.sem_type == SEM_TYPE_ERROR || right.sem_type == SEM_TYPE_ERROR) { \
    result->sem_type = SEM_TYPE_ERROR; \
    return; \
  } \
  \
  if (left.sem_type == SEM_TYPE_NULL || right.sem_type == SEM_TYPE_NULL) { \
    result->sem_type = SEM_TYPE_NULL; \
    return; \
  } \
  \
  DIV_TEST( \
    if ((#op)[0] == '/' && result_is_false(&right)) { \
      /* special case to prevent divide by zero */ \
      result->sem_type = SEM_TYPE_ERROR; \
      return; \
    } \
  ) \
  \
  sem_t core_type = eval_combined_type(&left, &right); \
  eval_cast_to(&left, core_type); \
  eval_cast_to(&right, core_type); \
  result->sem_type = SEM_TYPE_ERROR; \
  \
  switch (core_type) { \
  case SEM_TYPE_INTEGER: \
    result->sem_type = SEM_TYPE_INTEGER; \
    result->int32_value = (left.int32_value op right.int32_value); \
    break; \
  \
  case SEM_TYPE_LONG_INTEGER: \
    result->sem_type = SEM_TYPE_LONG_INTEGER; \
    result->int64_value = (left.int64_value op right.int64_value); \
    break; \
  \
  case SEM_TYPE_BOOL: \
    result->sem_type = SEM_TYPE_BOOL; \
    result->bool_value = 0 != (left.bool_value op right.bool_value); \
    break; \
  \
  default: \
    /* this is all that's left */ \
    Invariant(core_type == SEM_TYPE_REAL); \
    result->sem_type = SEM_TYPE_REAL; \
    result->real_value = (left.real_value op right.real_value); \
    break; \
  } \
  \
  Invariant(result->sem_type == core_type)

// This is exactly like the standard binary operator macro except it is for the
// operators that are not allowed to apply to real numbers.  e.g. bitwise and/or
// and left/right shift.
#define BINARY_OP_NO_REAL(op) \
  eval_node left = EVAL_NIL; \
  eval_node right = EVAL_NIL; \
  eval(expr->left, &left); \
  eval(expr->right, &right); \
  \
  if (left.sem_type == SEM_TYPE_ERROR || right.sem_type == SEM_TYPE_ERROR) { \
    result->sem_type = SEM_TYPE_ERROR; \
    return; \
  } \
  \
  if (left.sem_type == SEM_TYPE_NULL || right.sem_type == SEM_TYPE_NULL) { \
    result->sem_type = SEM_TYPE_NULL; \
    return; \
  } \
  \
  DIV_TEST( \
    if ((#op)[0] == '%' && result_is_false(&right)) { \
      /* special case to prevent divide by zero */ \
      result->sem_type = SEM_TYPE_ERROR; \
      return; \
    } \
  ) \
  sem_t core_type = eval_combined_type(&left, &right); \
  \
  eval_cast_to(&left, core_type); \
  eval_cast_to(&right, core_type); \
  result->sem_type = SEM_TYPE_ERROR; \
  \
  switch (core_type) { \
  case SEM_TYPE_INTEGER: \
    result->sem_type = SEM_TYPE_INTEGER; \
    result->int32_value = (left.int32_value op right.int32_value); \
    break; \
  \
  case SEM_TYPE_LONG_INTEGER: \
    result->sem_type = SEM_TYPE_LONG_INTEGER; \
    result->int64_value = (left.int64_value op right.int64_value); \
    break; \
  \
  default: \
    /* this is all that's left */ \
    Invariant(core_type == SEM_TYPE_BOOL); \
    result->sem_type = SEM_TYPE_BOOL; \
    result->bool_value = 0 != (left.bool_value op right.bool_value); \
    break; \
  } \
  \
  Invariant(result->sem_type == core_type)

// The final large class of operators are the comparisons. These have similar
// rules to the normal operators but the return type is bool/null/error.  The
// flow is pretty similar though
//   * any error in the operands results in an error
//   * any null operand results in a null result
//   * find the smallest numeric type that will hold the answer
//   * convert to that type if needed
//   * apply the operator on that type
//   * return the resulting bool
//
// NOTE:  is and is_not cannot be on this plan because of their null semantics,
//        they are similar, see below.
#define COMPARE_BINARY_OP(op) \
  eval_node left = EVAL_NIL; \
  eval_node right = EVAL_NIL; \
  eval(expr->left, &left); \
  eval(expr->right, &right); \
  \
  if (left.sem_type == SEM_TYPE_ERROR || right.sem_type == SEM_TYPE_ERROR) { \
    result->sem_type = SEM_TYPE_ERROR; \
    return; \
  } \
  \
  if (left.sem_type == SEM_TYPE_NULL || right.sem_type == SEM_TYPE_NULL) { \
    result->sem_type = SEM_TYPE_NULL; \
    return; \
  } \
  \
  sem_t core_type = eval_combined_type(&left, &right); \
  eval_cast_to(&left, core_type); \
  eval_cast_to(&right, core_type); \
  result->sem_type = SEM_TYPE_ERROR; \
  \
  switch (core_type) { \
  case SEM_TYPE_INTEGER: \
    result->sem_type = SEM_TYPE_BOOL; \
    result->bool_value = (left.int32_value op right.int32_value); \
    break; \
  \
  case SEM_TYPE_LONG_INTEGER: \
    result->sem_type = SEM_TYPE_BOOL; \
    result->bool_value = (left.int64_value op right.int64_value); \
    break; \
  \
  case SEM_TYPE_BOOL: \
    result->sem_type = SEM_TYPE_BOOL; \
    result->bool_value = 0 != (left.bool_value op right.bool_value); \
    break; \
  \
  default: \
    /* this is all that's left */ \
    Invariant(core_type == SEM_TYPE_REAL); \
    result->sem_type = SEM_TYPE_BOOL; \
    result->bool_value = (left.real_value op right.real_value); \
    break; \
  } \
  \
  Invariant(result->sem_type == SEM_TYPE_BOOL);

// True if the node is a zero; not err, not NULL, an actual zero
static bool_t result_is_false(eval_node *result) {
  Contract(result->sem_type != SEM_TYPE_ERROR);

  // null is not false
  if (result->sem_type == SEM_TYPE_NULL) {
    return false;
  }

  eval_node temp = *result;
  eval_cast_to(&temp, SEM_TYPE_BOOL);
  return !temp.bool_value;
}

// True if the node is not zero; not err, not NULL, an actual non-zero
static bool_t result_is_true(eval_node *result) {
  Contract(result->sem_type != SEM_TYPE_ERROR);

  // null/error is not true
  if (result->sem_type == SEM_TYPE_NULL) {
    return false;
  }

  eval_node temp = *result;
  eval_cast_to(&temp, SEM_TYPE_BOOL);
  return temp.bool_value;
}

// Having defined the helper macros all of the normal operators
// are now just one of the standard expansions

static void eval_add(ast_node *expr, eval_node *result) {
  BINARY_OP(+);
}

static void eval_sub(ast_node *expr, eval_node *result) {
  BINARY_OP(-);
}

static void eval_mul(ast_node *expr, eval_node *result) {
  BINARY_OP(*);
}

// add the divide by zero logic for / and %
#undef DIV_TEST
#define DIV_TEST(x) x

// note: BINARY_OP has divide by zero logic
static void eval_div(ast_node *expr, eval_node *result) {
  BINARY_OP(/);
}

// note: BINARY_OP_NO_REAL has divide by zero logic
static void eval_mod(ast_node *expr, eval_node *result) {
  BINARY_OP_NO_REAL(%);
}

#undef DIV_TEST
#define DIV_TEST(x)

static void eval_eq(ast_node *expr, eval_node *result) {
  COMPARE_BINARY_OP(==);
}

static void eval_ne(ast_node *expr, eval_node *result) {
  COMPARE_BINARY_OP(!=);
}

static void eval_le(ast_node *expr, eval_node *result) {
  COMPARE_BINARY_OP(<=);
}

static void eval_ge(ast_node *expr, eval_node *result) {
  COMPARE_BINARY_OP(>=);
}

static void eval_lt(ast_node *expr, eval_node *result) {
  COMPARE_BINARY_OP(<);
}

static void eval_gt(ast_node *expr, eval_node *result) {
  COMPARE_BINARY_OP(>);
}

static void eval_lshift(ast_node *expr, eval_node *result) {
  BINARY_OP_NO_REAL(<<);
}

static void eval_rshift(ast_node *expr, eval_node *result) {
  BINARY_OP_NO_REAL(>>);
}

static void eval_bin_and(ast_node *expr, eval_node *result) {
  BINARY_OP_NO_REAL(&);
}

static void eval_bin_or(ast_node *expr, eval_node *result) {
  BINARY_OP_NO_REAL(|);
}

// The 'is' form is very similar to the others but the null handling is
// different so there's an early out for that;  The logic is:
// * any error in left or right yields an error
// * if either left or right is null, the result is true iff both are null
// * at this point all the error/null cases are handled so it's just like the
//   back end of the BINARY_OP case;  the args have arleady been evaluated so:
//   * compute the smallest type that holds both values
//   * convert to that type
//   * return true if and only if the values are equal as that type
static void eval_is(ast_node *expr, eval_node *result) {
  eval_node left = EVAL_NIL;
  eval_node right = EVAL_NIL;
  eval(expr->left, &left);
  eval(expr->right, &right);

  if (left.sem_type == SEM_TYPE_ERROR || right.sem_type == SEM_TYPE_ERROR) {
    result->sem_type = SEM_TYPE_ERROR;
    return;
  }

  if (left.sem_type == SEM_TYPE_NULL || right.sem_type == SEM_TYPE_NULL) {
    result->sem_type = SEM_TYPE_BOOL;
    result->bool_value = (left.sem_type == SEM_TYPE_NULL && right.sem_type == SEM_TYPE_NULL);
    return;
  }

  sem_t core_type = eval_combined_type(&left, &right);
  eval_cast_to(&left, core_type);
  eval_cast_to(&right, core_type);

  result->sem_type = SEM_TYPE_ERROR;

  switch (core_type) {
    case SEM_TYPE_INTEGER:
      result->sem_type = SEM_TYPE_BOOL;
      result->bool_value = (left.int32_value == right.int32_value);
      break;

    case SEM_TYPE_LONG_INTEGER:
      result->sem_type = SEM_TYPE_BOOL;
      result->bool_value = (left.int64_value == right.int64_value);
      break;

    case SEM_TYPE_BOOL:
      result->sem_type = SEM_TYPE_BOOL;
      result->bool_value = 0 != (left.bool_value == right.bool_value);
      break;

    default:
      Invariant(core_type == SEM_TYPE_REAL);  // nothing else left
      result->sem_type = SEM_TYPE_BOOL;
      result->bool_value = (left.real_value == right.real_value);
      break;
  }

  Invariant(result->sem_type == SEM_TYPE_BOOL);
}

// We can use the 'is' logic to do this, we simply run "is", if the result
// was a bool (i.e. not an error) then we simply invert the bool.
static void eval_is_not(ast_node *expr, eval_node *result) {
  eval_is(expr, result);
  if (result->sem_type == SEM_TYPE_BOOL) {
     result->bool_value = !result->bool_value;
  }
}

// Not has simple rules;  If the operand is an error or null it is unchanged
// any other operator is converted to a bool and then inverted.
static void eval_not(ast_node *expr, eval_node *result) {
  eval(expr->left, result);
  if (result->sem_type == SEM_TYPE_ERROR || result->sem_type == SEM_TYPE_NULL) {
    return;
  }

  eval_cast_to(result, SEM_TYPE_BOOL);
  Invariant(result->sem_type == SEM_TYPE_BOOL);  // set by the above
  result->bool_value = !result->bool_value;
}

// Is false has simple rules;  If the operand is an error it is unchanged
// null becomes FALSE any other is converted to a bool and inverted
static void eval_is_false(ast_node *expr, eval_node *result) {
  eval(expr->left, result);
  if (result->sem_type == SEM_TYPE_ERROR) {
    return;
  }

  result->bool_value = result_is_false(result);
  result->sem_type = SEM_TYPE_BOOL;
}

// Is true has simple rules;  If the operand is an error it is unchanged
// null becomes FALSE any other is converted to a bool.
static void eval_is_true(ast_node *expr, eval_node *result) {
  eval(expr->left, result);
  if (result->sem_type == SEM_TYPE_ERROR) {
    return;
  }

  result->bool_value = result_is_true(result);
  result->sem_type = SEM_TYPE_BOOL;
}

// Is not true has simple rules;  If the operand is an error it is unchanged
// null becomes TRUE any other is converted to a bool and inverted
static void eval_is_not_true(ast_node *expr, eval_node *result) {
  eval(expr->left, result);
  if (result->sem_type == SEM_TYPE_ERROR) {
    return;
  }

  if (result->sem_type == SEM_TYPE_NULL) {
    result->bool_value = 1;
  }
  else {
    result->bool_value = !result_is_true(result);
  }

  result->sem_type = SEM_TYPE_BOOL;
}

// Is not false has simple rules;  If the operand is an error it is unchanged
// null becomes TRUE any other is converted to a bool
static void eval_is_not_false(ast_node *expr, eval_node *result) {
  eval(expr->left, result);
  if (result->sem_type == SEM_TYPE_ERROR) {
    return;
  }

  if (result->sem_type == SEM_TYPE_NULL) {
    result->bool_value = 1;
  }
  else {
    result->bool_value = !result_is_false(result);
  }

  result->sem_type = SEM_TYPE_BOOL;
}

// The bitwise not operator is rather like the normal not with a few twists:
//  * an error or null argument is returned unchanged
//  * integers and long_integers are bitwise inverted with ~
//  * bool is promoted to integer so the only possible result values are:
//    -1 for ~0, and -2 for ~1;  This is also what SQLite does.
static void eval_tilde(ast_node *expr, eval_node *result) {
  eval(expr->left, result);
  if (result->sem_type == SEM_TYPE_ERROR || result->sem_type == SEM_TYPE_NULL) {
    return;
  }

  // only the integer numeric cases are possible (~real is a semantic error)

  switch (result->sem_type) {
    case SEM_TYPE_INTEGER:
      result->int32_value = ~result->int32_value;
      break;

    case SEM_TYPE_LONG_INTEGER:
      result->int64_value = ~result->int64_value;
      break;

    default:
      Invariant(result->sem_type == SEM_TYPE_BOOL); //nothing else left
      result->sem_type = SEM_TYPE_INTEGER;
      // use ternary in case bool has a true value other than 1
      // this is clearer than writing ~!!result->bool_value I think...
      result->int32_value = result->bool_value ? ~1 : ~0;
      break;
  }
}

// Unary minus (negation) is very much like bitwise not:
// * error or null are unchanged
// * all others are negated
// * bool promotes to an integer and is negated so the valid results are 0 and -1
static void eval_uminus(ast_node *expr, eval_node *result) {

  if (is_ast_num(expr->left)) {
    EXTRACT_NUM_TYPE(num_type, expr->left);
    EXTRACT_NUM_VALUE(lit, expr->left);


    if (num_type == NUM_LONG && !strcmp("9223372036854775808", lit)) {
      result->sem_type = SEM_TYPE_LONG_INTEGER;
      result->int64_value = (int64_t)(-9223372036854775807LL - 1);
      return;
    }
  }

  eval(expr->left, result);
  if (result->sem_type == SEM_TYPE_ERROR || result->sem_type == SEM_TYPE_NULL) {
    return;
  }

  // only the numeric cases left

  switch (result->sem_type) {
    case SEM_TYPE_INTEGER:
      result->int32_value = -result->int32_value;
      break;

    case SEM_TYPE_LONG_INTEGER:
      result->int64_value = -result->int64_value;
      break;

    case SEM_TYPE_REAL:
      result->real_value = -result->real_value;
      break;

    default:
      Invariant(result->sem_type == SEM_TYPE_BOOL); //nothing else left
      result->sem_type = SEM_TYPE_INTEGER;
      // use ternary in case bool has a true value other than 1
      // this is clearer than writing -!!result->bool_value I think...
      result->int32_value = result->bool_value ? -1 : 0;
      break;
  }
}

// logical AND is tricky because it has to follow the truth table and also
// short circuit.
//   * if the left arg is an error the result is an error
//   * if the left result is false the answer is false and the right are is
//     not evaluated.
//   * if the right arg is an error the result is an error
//   * if the right arg is false the answer is false
//   * if either are null the answer is null
//   * otherwise the answer is true.
static void eval_and(ast_node *expr, eval_node *result) {
  eval_node left = EVAL_NIL;
  eval(expr->left, &left);

  if (left.sem_type == SEM_TYPE_ERROR) {
    result->sem_type = SEM_TYPE_ERROR;
    return;
  }

  if (result_is_false(&left)) {
    result->sem_type = SEM_TYPE_BOOL;
    result->bool_value = 0;
    return;
  }

  eval_node right = EVAL_NIL;
  eval(expr->right, &right);
  if (right.sem_type == SEM_TYPE_ERROR) {
    result->sem_type = SEM_TYPE_ERROR;
    return;
  }

  if (result_is_false(&right)) {
    result->sem_type = SEM_TYPE_BOOL;
    result->bool_value = 0;
    return;
  }

  if (right.sem_type == SEM_TYPE_NULL || left.sem_type == SEM_TYPE_NULL) {
    result->sem_type = SEM_TYPE_NULL;
    return;
  }

  result->sem_type = SEM_TYPE_BOOL;
  result->bool_value = 1;
}

// logical OR is tricky because it has to follow the truth table and also
// short circuit.
//   * if the left arg is an error the result is an error
//   * if the left result is true the answer is true and the right are is
//     not evaluated.
//   * if the right arg is an error the result is an error
//   * if the right arg is true the answer is true
//   * if either are null the answer is null
//   * otherwise the answer is false.
static void eval_or(ast_node *expr, eval_node *result) {
  eval_node left = EVAL_NIL;
  eval(expr->left, &left);

  if (left.sem_type == SEM_TYPE_ERROR) {
    result->sem_type = SEM_TYPE_ERROR;
    return;
  }

  if (result_is_true(&left)) {
    result->sem_type = SEM_TYPE_BOOL;
    result->bool_value = 1;
    return;
  }

  eval_node right = EVAL_NIL;
  eval(expr->right, &right);
  if (right.sem_type == SEM_TYPE_ERROR) {
    result->sem_type = SEM_TYPE_ERROR;
    return;
  }

  if (result_is_true(&right)) {
    result->sem_type = SEM_TYPE_BOOL;
    result->bool_value = 1;
    return;
  }

  if (right.sem_type == SEM_TYPE_NULL || left.sem_type == SEM_TYPE_NULL) {
    result->sem_type = SEM_TYPE_NULL;
    return;
  }

  result->sem_type = SEM_TYPE_BOOL;
  result->bool_value = 0;
}

// Cast is super easy because we arleady have the eval_cast_to helper
// we just do the evaluation it and early out on error or null
static void eval_cast_expr(ast_node *expr, eval_node *result) {
  eval(expr->left, result);

  if (result->sem_type == SEM_TYPE_ERROR) {
    return;
  }

  if (result->sem_type == SEM_TYPE_NULL) {
    return;
  }

  // known to be numeric, eval_cast_to can do the job now.
  eval_cast_to(result, core_type_of(expr->sem->sem_type));
}

// This helper is used in the evaluation of case expressions
// it's very much like the "==" operator.  Errors have already
// been handled in the caller.
//  * null is not equal to anything
//  * convert to the smallest type that can hold left or right
//  * compare using that type
static bool eval_are_equal(eval_node *_left, eval_node *_right) {
  eval_node left = *_left;
  eval_node right = *_right;

  Contract(right.sem_type != SEM_TYPE_ERROR);
  Contract(left.sem_type != SEM_TYPE_ERROR);

  // null isn't equal to anything
  if (right.sem_type == SEM_TYPE_NULL || left.sem_type == SEM_TYPE_NULL) {
    return false;
  }

  sem_t core_type = eval_combined_type(&left, &right);
  eval_cast_to(&left, core_type);
  eval_cast_to(&right, core_type);

  // there must be a conversion or semantic would have stopped us and both
  // are now promoted... we just compare the values
  Invariant(left.sem_type == right.sem_type);

  int32_t result = -1;

  switch (left.sem_type) {
    case SEM_TYPE_INTEGER:
      result = left.int32_value == right.int32_value;
      break;

    case SEM_TYPE_LONG_INTEGER:
      result = left.int64_value == right.int64_value;
      break;

    case SEM_TYPE_REAL:
      result = left.real_value == right.real_value;
      break;

    default:
      Invariant(left.sem_type == SEM_TYPE_BOOL); //nothing else left
      result = left.bool_value == right.bool_value;
      break;
  }

  Invariant(result == 0 || result == 1);
  return result;
}

// Case expression evaluation is fairly complex with the two cases outlined below.
// In short:
//   * evaluate the test expression if there is one
//   * visit the WHEN expressions and use equality or truth
//     to pick the correct THEN expression
//   * use the else expression if there is one, else use NULL
//   * any errors encountered yield an error
//   * the usual null equality rules apply
static void eval_case_expr(ast_node *ast, eval_node *result) {
  EXTRACT_ANY(expr, ast->left);
  EXTRACT_NOTNULL(connector, ast->right);
  EXTRACT_NOTNULL(case_list, connector->left);
  EXTRACT_ANY(else_expr, connector->right);

  // Case can have expression or just when clauses
  if (expr) {
    // This branch has a test expression, save its value
    eval_node test_result = EVAL_NIL;
    eval(expr, &test_result);
    if (test_result.sem_type == SEM_TYPE_ERROR) {
      result->sem_type = SEM_TYPE_ERROR;
      return;
    }

    // now walk through the case list, and choose the matching THEN
    ast = case_list;
    while (ast) {
      EXTRACT_NOTNULL(when, ast->left);
      EXTRACT_ANY_NOTNULL(case_expr, when->left);
      EXTRACT_ANY_NOTNULL(then_expr, when->right);

      eval_node case_result = EVAL_NIL;
      eval(case_expr, &case_result);
      if (case_result.sem_type == SEM_TYPE_ERROR) {
        result->sem_type = SEM_TYPE_ERROR;
        return;
      }

      if (eval_are_equal(&test_result, &case_result)) {
        eval(then_expr, result);
        return;
      }
      ast = ast->right;
    }
  }
  else {
    // This is the case where we're looking for the first true expressions
    // walk through the case list, and choose the matching THEN
    ast = case_list;
    while (ast) {
      EXTRACT_NOTNULL(when, ast->left);
      EXTRACT_ANY_NOTNULL(case_expr, when->left);
      EXTRACT_ANY_NOTNULL(then_expr, when->right);

      eval_node case_result = EVAL_NIL;
      eval(case_expr, &case_result);
      if (case_result.sem_type == SEM_TYPE_ERROR) {
        result->sem_type = SEM_TYPE_ERROR;
        return;
      }

      if (result_is_true(&case_result)) {
        eval(then_expr, result);
        return;
      }

      ast = ast->right;
    }
  }

  // if we get this far, there's no match, use the else clause if there is one
  if (else_expr) {
    eval(else_expr, result);
  }
  else {
    result->sem_type = SEM_TYPE_NULL;
  }
}

cql_noexport void eval_add_one(eval_node *result) {
  Contract(result->sem_type != SEM_TYPE_ERROR);
  Contract(result->sem_type != SEM_TYPE_NULL);

  switch (result->sem_type) {
    case SEM_TYPE_INTEGER:
      result->int32_value++;
      break;

    case SEM_TYPE_LONG_INTEGER:
      result->int64_value++;
      break;

    case SEM_TYPE_REAL:
      result->real_value++;
      break;

    default:
      Invariant(result->sem_type == SEM_TYPE_BOOL); //nothing else left
      result->bool_value = !result->bool_value;
      break;
  }
}

cql_noexport void eval_format_number(eval_node *result, int32_t format_mode, charbuf *output) {
  Contract(result->sem_type != SEM_TYPE_ERROR);
  Contract(result->sem_type != SEM_TYPE_NULL);

  uint32_t used = output->used;

  switch (result->sem_type) {
    case SEM_TYPE_INTEGER:
      bprintf(output, "%d", result->int32_value);
      break;

    case SEM_TYPE_LONG_INTEGER:
      if (format_mode == EVAL_FORMAT_FOR_C) {
         if  (result->int64_value == -9223372036854775807LL - 1) {
           // if outputing to C you cannot emit the constant -9223372036854775808
           // you have to do it with an expression like so:
           bprintf(output, "(_64(-9223372036854775807) - 1)");
         }
         else {
           bprintf(output, "_64(%lld)", (llint_t)result->int64_value);
         }
      }
      else if (format_mode == EVAL_FORMAT_FOR_LUA) {
         if  (result->int64_value == -9223372036854775807LL - 1) {
           // if outputing to LUA you cannot emit the constant -9223372036854775808
           // you have to do it with an expression like so:
           bprintf(output, "(-9223372036854775807 - 1)");
         }
         else {
           bprintf(output, "%lld", (llint_t)result->int64_value);
         }
      }
      else {
         bprintf(output, "%lld", (llint_t)result->int64_value);
      }

      break;

    case SEM_TYPE_REAL:
      eval_format_real(result->real_value, output);
      break;

    default:
      Invariant(result->sem_type == SEM_TYPE_BOOL); //nothing else left
      bprintf(output, "%d", !!result->bool_value);
      break;
  }

  // verify we wrote something
  Invariant(output->used > used);
}

static eval_node err_result = { .sem_type = SEM_TYPE_ERROR };

// Dispatch to the worker function using the token string in the ast and the symbol table
// any unknown symbols are evaluation errors due to unsupported const expression form.
cql_noexport void eval(ast_node *expr, eval_node *result) {
  // this saves us a whole lot of string compares...
  symtab_entry *entry = symtab_find(evals, expr->type);
  if (!entry) {
    *result = err_result;
    return;
  }

  eval_dispatch disp = (eval_dispatch)entry->val;
  disp(expr, result);
  if (result->sem_type == SEM_TYPE_ERROR) {
    *result = err_result;  // blast any state that may be in there leaving just the error
  }
}

#undef EXPR_INIT
#define EXPR_INIT(x) symtab_add(evals, #x, (void *)eval_ ## x)

// This method loads up the global symbol table and cleans any pending state we had
cql_noexport void eval_init() {
  // restore all globals and statics we own
  eval_cleanup();

  evals = symtab_new();

  EXPR_INIT(null);
  EXPR_INIT(num);
  EXPR_INIT(add);
  EXPR_INIT(mul);
  EXPR_INIT(div);
  EXPR_INIT(mod);
  EXPR_INIT(sub);
  EXPR_INIT(lshift);
  EXPR_INIT(rshift);
  EXPR_INIT(bin_and);
  EXPR_INIT(bin_or);
  EXPR_INIT(eq);
  EXPR_INIT(lt);
  EXPR_INIT(gt);
  EXPR_INIT(ne);
  EXPR_INIT(ge);
  EXPR_INIT(le);
  EXPR_INIT(and);
  EXPR_INIT(or);
  EXPR_INIT(is);
  EXPR_INIT(is_not);
  EXPR_INIT(is_true);
  EXPR_INIT(is_false);
  EXPR_INIT(is_not_true);
  EXPR_INIT(is_not_false);
  EXPR_INIT(cast_expr);
  EXPR_INIT(not);
  EXPR_INIT(tilde);
  EXPR_INIT(uminus);
  EXPR_INIT(case_expr);
}

// the only global state we have is the symbol table, clean that up
cql_noexport void eval_cleanup() {
  SYMTAB_CLEANUP(evals);
}


#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



// Indicates whether a history item resulted from setting a flag or unsetting a
// flag. The values associated with each enum case allow a series of deltas to
// be totalled up to determine an overall effect when popping a branch group.
typedef enum {
  FLOW_HISTORY_DELTA_UNSET = -1,
  FLOW_HISTORY_DELTA_SET = 1
} flow_history_delta;

// Records a call to `flow_set_flag_for_type` or `flow_unset_flag_for_type`.
// These form a linked list referred to as a "history".
typedef struct history_item {
  struct history_item *next;
  sem_t *type;
  sem_t flag;
  flow_history_delta delta;
} flow_history_item;

// A list of `history_item` values.
typedef flow_history_item *flow_history;

// There are different types of flow contexts, each of which is indicated by its
// `flow_context_kind`.
typedef enum {
  // Normal flow contexts simply revert all improvements set within them when
  // they are popped.
  FLOW_CONTEXT_KIND_NORMAL,

  // Branch group contexts contain zero or more branch contexts. Branch group
  // contexts perform extra steps to merge the effects of their branches.
  FLOW_CONTEXT_KIND_BRANCH_GROUP,

  // Branch contexts are contexts that are only entered into if some condition
  // is true. They must only be created within a branch group context. They are
  // special in that they completely reverse all effects within them when they
  // are popped so that subsequent branches are unaffected.
  FLOW_CONTEXT_KIND_BRANCH,

  // Jump contexts are pessimistic contexts that assume, after the context has
  // ended, that all possible un-sets within it happened and all sets within it
  // did not happen. They can be used to ensure safety for TRY blocks, loops,
  // and other blocks containing statement lists that may not be executed in
  // full due to one statement within them jumping to the end of the context (or
  // to the end of an enclosing jump context).
  //
  // NOTE: Jump contexts do not take the locations of control statements within
  // them, if any, into account, and thus are presently more conservative than
  // is necessary. Experience with previous versions of CQL that treated *all*
  // contexts this pessimistically strongly suggests that this is not a problem
  // in practice.
  FLOW_CONTEXT_KIND_JUMP
} flow_context_kind;

// A flow context is used to encapsulate a region of a program so that effects
// within it (e.g., nullability improvements, variable initialization
// improvements, row check improvements, et cetera) can be managed
// appropriately.
typedef struct flow_context {
  // The parent of the context, if any.
  struct flow_context *parent;

  // The kind of the context. The value of `kind` indicates which of the
  // anonymous structs within the union below may be accessed, if any.
  flow_context_kind kind;

  // The history of sets and un-sets made within the context. This does not
  // necessarily include *all* sets and un-sets as branch group contexts merge
  // the effects of their branches.
  flow_history history;

  union {
    // Only used when `kind` is `FLOW_CONTEXT_KIND_BRANCH`.
    struct {
      // `true` when the branch always jumps to the end of an enclosing jump
      // context or some statement beyond it.
      bool_t always_jumps;
    } branch;

    // Only used when `kind` is `FLOW_CONTEXT_KIND_BRANCH_GROUP`.
    struct {
      // The concatenated histories of all of the branches created directly
      // within the branch group.
      flow_history branch_histories;

      // The number of branches directly within the branch group.
      uint32_t branch_count;

      // `true` if the branch group includes (or will include) a catch-all
      // branch (e.g., ELSE) or otherwise covers all possible cases.
      bool_t covers_all_cases;
    } branch_group;

    // Only used when `kind` is `FLOW_CONTEXT_KIND_JUMP`.
    struct {
      // The nearest enclosing context with kind `FLOW_CONTEXT_KIND_JUMP`, if
      // any. This is used to update `top_jump_context` when a jump context is
      // popped.
      struct flow_context *nearest_jump_context;

      // The histories of *all* un-sets made within the jump context's
      // subcontexts.
      flow_history unset_histories;
    } jump;
  };
} flow_context;

// The global that holds all control flow information managed within this file.
static flow_context *current_context;

// The topmost jump context, if any. This exists merely to avoid the need to
// search upwards from the current context for this every time an improvement is
// unset: It provides no additional information beyond what is already available
// in `current_context`.
static flow_context *top_jump_context;

// Given a pointer to `history`, sets its tail to `history_to_append`.
static void append_history(flow_history *history, flow_history history_to_append) {
  flow_history *tail = history;

  while (*tail) {
    tail = &(*tail)->next;
  }

  *tail = history_to_append;
}

// Given `history`, returns an array that points to each item within it and sets
// `*count` to the total number of items.
static flow_history_item **array_from_history(flow_history history, uint32_t *count) {
  Contract(count);

  uint32_t length = 0;
  for (flow_history_item *item = history; item; item = item->next) {
    length++;
  }

  flow_history_item **array = _ast_pool_new_array(flow_history_item *, length);

  uint32_t i = 0;
  for (flow_history_item *item = history; item; item = item->next, i++) {
    array[i] = item;
  }

  *count = length;

  return array;
}

// Compares two history items by their type addresses (which, in this instance,
// constitute a unique identifier), followed by their flags. This is used to
// allow `qsort` to group together effects across a group of branches in order
// to be able to produce the total set of effects for the enclosing branch
// group.
static int history_item_comparator(const void *a, const void *b) {
  flow_history_item *item_a = *(flow_history_item **)a;
  flow_history_item *item_b = *(flow_history_item **)b;

  if (item_a->type < item_b->type) {
    return -1;
  }

  if (item_a->type > item_b->type) {
    return 1;
  }

#if 0
  // We'll never enter either of these branches because, at the moment, there
  // are only two types of improvements, and no type can have both its
  // nullability improved and its initialization improved: Only nonnull types
  // may require initialization, and only nullable types may have improved
  // nullability. This is, therefore, disabled for the sake of code coverage.
  if (item_a->flag < item_b->flag) {
    return -1;
  }

  if (item_a->flag > item_b->flag) {
    return 1;
  }
#else
  // Until additional improvement types are added, this will always be true.
  Invariant(item_a->flag == item_b->flag);
#endif

  return 0;
}

// Returns a new history item given initial values.
static flow_history_item *history_item_new(sem_t *type, sem_t flag, flow_history_delta delta) {
  Contract(type);
  Contract(is_single_flag(flag));

  flow_history_item *item = _ast_pool_new(flow_history_item);
  item->next = NULL;
  item->type = type;
  item->flag = flag;
  item->delta = delta;

  return item;
}

// Reverses a history in place.
static void reverse_history(flow_history *history) {
  flow_history_item *current = *history;
  flow_history_item *previous = NULL;
  flow_history_item *next = NULL;

  while (current) {
    next = current->next;
    current->next = previous;
    previous = current;
    current = next;
  }

  *history = previous;
}

// Clones a history and returns the new copy.
static flow_history clone_history(flow_history history) {
  flow_history new_history = NULL;

  for (flow_history_item *item = history; item; item = item->next) {
    flow_history_item *new_item = history_item_new(item->type, item->flag, item->delta);
    new_item->next = new_history;
    new_history = new_item;
  }

  reverse_history(&new_history);

  return new_history;
}

// Given a pointer to a history, adds a new history item to it with the initial
// values provided.
static void record_in_history(flow_history *history, sem_t *type, sem_t flag, flow_history_delta delta) {
  Contract(history);
  Contract(type);
  Contract(is_single_flag(flag));

  flow_history_item *item = history_item_new(type, flag, delta);
  item->next = *history;
  *history = item;
}

// Sets `flag` on `*type` and records it in the history of the the current
// context. This must never be called if the flag is already set.
cql_noexport void flow_set_flag_for_type(sem_t flag, sem_t *type) {
  Contract(current_context);
  Contract(is_single_flag(flag));
  Contract(type);
  Contract(!(*type & flag));

  *type |= flag;

  record_in_history(&current_context->history, type, flag, FLOW_HISTORY_DELTA_SET);
}

// Un-sets `flag` on `*type` and records it in the history of the the current
// context. This must never be called unless the flag is already set.
cql_noexport void flow_unset_flag_for_type(sem_t flag, sem_t *type) {
  Contract(current_context);
  Contract(is_single_flag(flag));
  Contract(type);
  Contract(*type & flag);

  *type &= sem_not(flag);

  record_in_history(&current_context->history, type, flag, FLOW_HISTORY_DELTA_UNSET);

  // If we're within a jump context, record the unset there too so we can
  // re-unset it later. We can skip this if the current context is a jump
  // context as the unset was just recorded in its history above directly.
  if (top_jump_context && current_context != top_jump_context) {
    record_in_history(&top_jump_context->jump.unset_histories, type, flag, FLOW_HISTORY_DELTA_UNSET);
  }
}

// Creates a new context with the kind provided and adds it to the current
// context. This does NOT initialize any kind-specific members.
static void push_context_with_kind(flow_context_kind kind) {
  flow_context *context = _ast_pool_new(flow_context);
  context->parent = current_context;
  context->kind = kind;
  context->history = NULL;

  current_context = context;
}

// Given a history, iterates over it and calls `func` with the delta sum of each
// type/flag combination.
static void with_delta_sums_of_history(flow_history history, void func(sem_t *type, sem_t flag, int32_t delta_sum)) {
  Contract(func);

  uint32_t item_count;
  flow_history_item **item_array = array_from_history(history, &item_count);

  if (item_count == 0) {
    return;
  }

  // Sort the total history by type, then by flag.
  qsort(item_array, item_count, sizeof(flow_history_item *), history_item_comparator);

  // Iterate over the branch histories, calling `func` the `delta_sum` of each
  // type/flag combination.
  int32_t delta_sum = item_array[0]->delta;
  for (uint32_t i = 1; i < item_count; i++) {
    flow_history_item *previous_item = item_array[i - 1];
    flow_history_item *current_item = item_array[i];
    if (previous_item->type != current_item->type || previous_item->flag != current_item->flag) {
      func(previous_item->type, previous_item->flag, delta_sum);
      delta_sum = 0;
    }
    delta_sum += current_item->delta;
  }
  func(item_array[item_count - 1]->type, item_array[item_count - 1]->flag, delta_sum);
}

// Asserts that the `delta_sum` calculated for a particular type/flag
// combination present in some context's history is within [-1, 1] as is
// required for `merge_effects` to work properly.
static void invariant_delta_sum(sem_t *type, sem_t flag, int32_t delta_sum) {
  Invariant(delta_sum >= -1 && delta_sum <= 1);
}

// Moves the history of the current context to the start of the history of the
// parent context (if any) so that it can manage it however it chooses.
static void move_history_to_parent() {
  Contract(current_context);

  if (current_context->parent) {
    append_history(&current_context->history, current_context->parent->history);
    current_context->parent->history = current_context->history;
  }

  // In order for `merge_effects` to work properly, the history field of every
  // context must contain a history that, for every type/flag combination, has a
  // delta sum of -1, 0, or 1. We enforce that invariant here.
  with_delta_sums_of_history(
    // If we have a parent context, we check that (purely for the sake of
    // checking more things rather than fewer) as it now also contains the
    // history of the current context.
    (current_context->parent ? current_context->parent : current_context)->history,
    invariant_delta_sum
  );

  // This is no longer valid.
  current_context->history = NULL;
}

// Pushes a normal context. Unless one is pushing a context for a group of
// branches (e.g., within an IF or CASE) or pushing a branch itself, one should
// simply push a normal context.
cql_noexport void _flow_push_context_normal() {
  push_context_with_kind(FLOW_CONTEXT_KIND_NORMAL);
}

// Un-sets all of the improvements in the current history while leaving the
// history itself unchanged.
static void unset_all_improvements() {
  for (flow_history_item *item = current_context->history; item; item = item->next) {
    switch (item->delta) {
      case FLOW_HISTORY_DELTA_UNSET:
        break;
      case FLOW_HISTORY_DELTA_SET:
        if (*item->type & item->flag) {
          flow_unset_flag_for_type(item->flag, item->type);
        }
    }
  }
}

// Pops a normal context, unsetting all improvements made within it.
cql_noexport void _flow_pop_context_normal() {
  Contract(current_context);
  Contract(current_context->kind == FLOW_CONTEXT_KIND_NORMAL);

  unset_all_improvements();

  move_history_to_parent();

  current_context = current_context->parent;
}

// Pushes a new branch group context. Only branch contexts may be created within
// it.
cql_noexport void _flow_push_context_branch_group() {
  push_context_with_kind(FLOW_CONTEXT_KIND_BRANCH_GROUP);

  current_context->branch_group.branch_histories = NULL;
  current_context->branch_group.branch_count = 0;
  current_context->branch_group.covers_all_cases = false;
}

// Merges the effects of the branches of the current branch group context for a
// particular type and flag to produce the overall effect.
//
// For a given type and flag combination, each branch could have ultimately
// unset a flag that was initially set, set a flag that was initially unset, or
// been neutral with respect to the flag (e.g., by setting it, then unsetting it
// when it was initially unset, or by simply not affecting it at all). Each
// branch, therefore, can be assigned a value of -1, 1, or 0 respectively. These
// are totalled up and represent the `delta_sum`.
static void merge_effects(sem_t *type, sem_t flag, int32_t delta_sum) {
  Contract(current_context);
  Contract(current_context->kind == FLOW_CONTEXT_KIND_BRANCH_GROUP);
  Contract(current_context->branch_group.branch_count > 0);
  Contract(type);
  Contract(is_single_flag(flag));

  // If the delta sum is positive, it must have been the case that the flag
  // began unset otherwise no branches could have set it.
  Invariant(delta_sum <= 0 || !(*type & flag));

  // If the delta sum is negative, it must have been the case that the flag
  // began set otherwise no branches could have unset it.
  Invariant(delta_sum >= 0 || *type & flag);

  uint32_t branch_count = current_context->branch_group.branch_count;

  // If all branches set a flag, `delta_sum` will equal `branch_count`.
  // Likewise, if all branches unset it, `abs(delta_sum)` will equal
  // `branch_count`.
  Invariant((uint32_t)abs(delta_sum) <= branch_count);

  // Indicates whether or not the branches cover all possible cases.
  bool_t covers_all_cases = current_context->branch_group.covers_all_cases;

  if (covers_all_cases && delta_sum == branch_count) {
    // The branches cover all possible cases and `delta_sum` is equal to the
    // number of branches (which means every branch made the same improvement),
    // so we can consider the entire branch group to have made the improvement.
    flow_set_flag_for_type(flag, type);
  }
  else if (delta_sum < 0) {
    // The delta sum is negative, so at least one of the branches unset the
    // flag. We must, therefore, consider the entire branch group as having
    // unset the flag.
    flow_unset_flag_for_type(flag, type);
  }
  else {
    // If `delta_sum` is 0, that means all branches were neutral with respect to
    // the flag. If `delta_sum` is positive, but less than `branch_count`, that
    // means some branches improved it and the rest were netural. Since all
    // branches were at least neutral, it's safe to do nothing here and allow
    // things to remain as they are.
    //
    // The reason we know this is that we only set something when it is unset
    // and only unset something when it is set, and so all branches must have
    // the same overall effect if they are to have any effect at all. For
    // example, if a variable is nullable before an IF, branches can either
    // leave it as it is or improve it. Likewise, if a variable is already
    // inferred to be nonnull before an IF, branches can either leave it as it
    // is or un-improve it. Since it is not possible for one branch to improve
    // something if another un-improved it and vice versa, we know any
    // non-negative delta sum implies all branches were at least neutral, and so
    // no unset is required.
  }
}

// Records whether or not the current branch group context has a catch-all
// branch or otherwise covers all possible cases.
cql_noexport void flow_set_context_branch_group_covers_all_cases(bool_t covers_all_cases) {
  Contract(current_context);
  Contract(current_context->kind == FLOW_CONTEXT_KIND_BRANCH_GROUP);

  current_context->branch_group.covers_all_cases = covers_all_cases;
}

// Records the presence of an empty branch within the branch group. This is
// equivalent to calling `_flow_push_context_branch` immediately followed by
// `_flow_pop_context_branch` and exists only for the sake of convenience.
cql_noexport void flow_context_branch_group_add_empty_branch() {
  Contract(current_context);
  Contract(current_context->kind == FLOW_CONTEXT_KIND_BRANCH_GROUP);

  current_context->branch_group.branch_count++;
}

// Pops the current branch group, calculating the total effect of all of its
// branches in the process.
cql_noexport void _flow_pop_context_branch_group() {
  Contract(current_context);
  Contract(current_context->kind == FLOW_CONTEXT_KIND_BRANCH_GROUP);

  // Unset all of the negative improvements made within the branch group itself.
  // Negative improvements are those made because the condition of a previous
  // branch must have been false if a later branch was taken.
  unset_all_improvements();

  // Zero out the current history. We will rebuild it based on what occurred in
  // the branches via `merge_effects`.
  current_context->history = NULL;

  // Merge the effects of all of the branches.
  with_delta_sums_of_history(current_context->branch_group.branch_histories, merge_effects);

  // The history we move to the parent contains only the result of the
  // `unset_all_improvements` call above and the result of merging the effects:
  // The full histories of the branches are completely discarded. This is
  // critical for the delta sum approach that `merge_effects` uses: If N
  // branches within a branch group all improve the same type/flag combination,
  // we need that to count as a single improvement, not N+1 improvements, for
  // any further effect merging that might take place in enclosing branch groups
  // to work correctly.
  move_history_to_parent();

  current_context = current_context->parent;
}

// Pushes a new branch context. This must only be done within a branch group
// context. It is critical that this be done for ALL branches of a given
// conditional, including any "else" or catch-all branch, otherwise
// `_flow_pop_context_branch_group` may improve something too optimistically due
// to a lack of sufficient information.
cql_noexport void _flow_push_context_branch() {
  Contract(current_context);
  Contract(current_context->kind == FLOW_CONTEXT_KIND_BRANCH_GROUP);

  push_context_with_kind(FLOW_CONTEXT_KIND_BRANCH);

  current_context->branch.always_jumps = false;

  // Clone the current history of (typically negative) improvements within the
  // branch group itself and add it to the accumulated history of its branches.
  // The reason we do this is so that we can calculate the correct delta sum
  // later on.
  //
  // Consider the following code:
  //
  // IF x IS NULL THEN
  //   SET x := 42;
  // ELSE IF y THEN
  //   -- do nothing
  // ELSE
  //   -- do nothing
  // END IF;
  //
  // Here, even though the second and third branches have not improved the type
  // of `x` to be nonnull themselves, it is still the case that x is nonnull
  // at the end of the second and third branches due to the condition of the
  // first branch. It is therefore safe and appropriate to treat the branches as
  // though they each made the improvement themselves so that x can be treated
  // as nonnull after END IF.
  //
  // To put it more plainly, we want a delta sum of 3 for the improvement to x.
  // If we didn't perform this step, it would only be 1.
  flow_history branch_group_history = clone_history(current_context->parent->history);
  append_history(&branch_group_history, current_context->parent->branch_group.branch_histories);
  current_context->parent->branch_group.branch_histories = branch_group_history;

  // Increment the branch count of the parent branch group so that it can be
  // later compared against delta sums.
  current_context->parent->branch_group.branch_count++;
}

// Sets whether or not the current context always jumps to the end of the
// nearest enclosing jump context or some statement beyond it.
cql_noexport void flow_set_context_always_jumps(bool_t always_jumps) {
  Contract(current_context);

  if (current_context->kind != FLOW_CONTEXT_KIND_BRANCH) {
    // Knowledge that the current context always jumps is only useful if the
    // current context is a branch context.
    return;
  }

  current_context->branch.always_jumps = always_jumps;
}

// Pop a branch context, reverting the history within it such that it will be as
// though nothing ever happened.
cql_noexport void _flow_pop_context_branch() {
  Contract(current_context);
  Contract(current_context->kind == FLOW_CONTEXT_KIND_BRANCH);

  Invariant(current_context->parent);
  Invariant(current_context->parent->kind == FLOW_CONTEXT_KIND_BRANCH_GROUP);

  // Revert the history by interating over it, starting with the most recent
  // item, and doing the opposite of what was originally done. We only adjust
  // the flags and do not record the changes: The parent branch group will
  // handle the recording when it merges the effects of all of its branches.
  for (flow_history_item *item = current_context->history; item; item = item->next) {
    switch (item->delta) {
      case FLOW_HISTORY_DELTA_UNSET:
        *item->type |= item->flag;
        break;
      case FLOW_HISTORY_DELTA_SET:
        *item->type &= sem_not(item->flag);
        break;
    }
  }

  if (current_context->branch.always_jumps) {
    // Since the current context always jumps, we actually do not want to count
    // it as a branch at all when merging effects. By simply eliding the branch,
    // an improvement that is merely set in all branches that do not always jump
    // is sufficient for the improvement to persist after the branch group ends
    // (assuming the branches cover all possible cases).
    //
    // By discarding the branch, we technically do a bit worse in one case: If
    // *all* branches always jump and the branches cover all possibilities, no
    // improvements will persist after the branch group ends because all
    // branches will have been elided. This is not a problem in practice,
    // however, since if all branches jump and the branches cover all cases, no
    // code could execute until after the end of the nearest enclosing jump
    // context, and no improvements set within a jump context are allowed to
    // persist beyond it anyway.
    //
    // NOTE: Discarding the branch now is not the same as the branch never
    // having existed. The reason for this is that any improvements unset within
    // the branch have already been added to the nearest enclosing jump context
    // and will remain there to be re-unset later. This must be the case
    // because, even though we know this context always jumps, we do not know at
    // what point it might jump, and so we must remain sufficiently pessimistic.
    //
    // NOTE: We could do better by keeping a separate count of the number of
    // branches that always jump. If we did that, when popping a branch group,
    // if the number of branches that always jumped equaled the total number of
    // branches, then the branch group could itself be considered to always jump
    // and we could propagate that knowledge upwards. This would allow us to
    // handle cases like the following:
    //
    //   DECLARE x INT;
    //   IF 0 THEN
    //     IF 0 THEN
    //       THROW;
    //     ELSE
    //       RETURN;
    //     END IF;
    //     -- the fact that this always jumps is presently not understood
    //   ELSE
    //     SET x := 1;
    //   END IF;
    //   -- x could be safely considered nonnull here
    current_context->parent->branch_group.branch_count--;
  }
  else {
    // Add the history of the branch to the total set of branch histories for
    // the current branch group.
    append_history(&current_context->history, current_context->parent->branch_group.branch_histories);
    current_context->parent->branch_group.branch_histories = current_context->history;
  }

  current_context = current_context->parent;
}

// Pushes a jump context such that `current_context` will be identical to
// `top_jump_context`.
cql_noexport void _flow_push_context_jump() {
  push_context_with_kind(FLOW_CONTEXT_KIND_JUMP);

  current_context->jump.nearest_jump_context = top_jump_context;
  current_context->jump.unset_histories = NULL;

  top_jump_context = current_context;
}

// Pops the current jump context and updates `top_jump_context` accordingly.
cql_noexport void _flow_pop_context_jump() {
  Contract(current_context);
  Contract(current_context->kind == FLOW_CONTEXT_KIND_JUMP);

  // Re-unset all un-sets made anywhere within the jump context's subcontexts.
  // This is done to remain safe in the presence of code like the following:
  //
  //   DECLARE x INT;
  //   -- improve x
  //   SET x := 42;
  //   WHILE some_condition
  //   BEGIN
  //     -- use an IF/ELSE to trigger effect merging in the branch group; this
  //     -- is critical to this example as we'd be safe otherwise!
  //     IF another_condition THEN
  //       -- un-improve x
  //       SET x := NULL;
  //       IF yet_another_condition THEN
  //         -- jump before re-improving x
  //         LEAVE;
  //       END IF;
  //       -- re-improve x
  //       SET x := 100;
  //     ELSE
  //       -- neutral; do nothing
  //     END IF;
  //     -- the branch group context considers the one un-improvement of 'x' and
  //     -- the one improvement of 'x' in the first branch to be neutral and
  //     -- thus cancels out their effects since the ELSE is also netural
  //   END;
  //   -- if the body of the WHILE were analyzed within a normal flow context,
  //   -- x would be unsafely treated as nonnull here due to the cancelling
  //   -- mentioned above
  //
  // NOTE: The approach taken here is more conservative than is necessary and
  // may be revisited in the future.
  for (flow_history_item *item = current_context->jump.unset_histories; item; item = item->next) {
    Invariant(item->delta == FLOW_HISTORY_DELTA_UNSET);
    if (*item->type & item->flag) {
      flow_unset_flag_for_type(item->flag, item->type);
    }
  }

  // This un-sets improvements initially made within the jump context itself, of
  // course, but it also propagates any un-sets made in the previous step to the
  // nearest enclosing jump context, if any. This is important because all of
  // the unsetting we're doing now may be reverted by a branch context in
  // between this context and the nearest enclosing jump context.
  unset_all_improvements();

  move_history_to_parent();

  top_jump_context = current_context->jump.nearest_jump_context;
  current_context = current_context->parent;
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_GEN_SQL)

// stubs to avoid link errors,

cql_noexport void gen_init() {}
cql_export void gen_cleanup() {}
cql_noexport void gen_misc_attrs_to_stdout(ast_node *ast) {}
cql_noexport void gen_to_stdout(ast_node *ast, gen_func fn) {}
cql_noexport void gen_one_stmt_to_stdout(ast_node *ast) {}
cql_noexport void gen_stmt_list_to_stdout(ast_node *ast) {}

#else

// (re)generate equivalent SQL to what we parsed
// validate the tree shape in painful detail as we go


// for dispatching expression types
typedef struct gen_expr_dispatch {
  void (*func)(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new);
  CSTR str;
  int32_t pri_new;
} gen_expr_dispatch;

static symtab *gen_stmts;
static symtab *gen_exprs;
static symtab *gen_macros;
static charbuf *gen_output;
static gen_sql_callbacks *gen_callbacks = NULL;
static symtab *used_alias_syms = NULL;

// forward references for things that appear out of order or mutually call each other
static void gen_select_core_list(ast_node *ast);
static void gen_groupby_list(ast_node *_Nonnull ast);
static void gen_orderby_list(ast_node *_Nonnull ast);
static void gen_stmt_list(ast_node *_Nullable ast);
static void gen_expr(ast_node *_Nonnull ast, int32_t pri);
static void gen_version_attrs(ast_node *_Nullable ast);
static void gen_col_def(ast_node *_Nonnull ast);
static void gen_query_parts(ast_node *ast);
static void gen_select_stmt(ast_node *_Nonnull ast);
static void gen_opt_where(ast_node *ast);
static void gen_opt_orderby(ast_node *ast);
static void gen_shape_arg(ast_node *ast);
static void gen_insert_list(ast_node *_Nullable ast);
static void gen_column_spec(ast_node *ast);
static void gen_from_shape(ast_node *ast);
static void gen_opt_filter_clause(ast_node *ast);
static void gen_if_not_exists(ast_node *ast, bool_t if_not_exist);
static void gen_shape_def(ast_node *ast);
static void gen_expr_names(ast_node *ast);
static void gen_conflict_clause(ast_node *ast);
static void gen_call_stmt(ast_node *ast);
static void gen_shared_cte(ast_node *ast);
static bool_t gen_found_set_kind(ast_node *ast, void *context, charbuf *buffer);
static void gen_cte_table(ast_node *ast);
static void gen_cte_tables(ast_node *ast, CSTR prefix);
static void gen_select_expr_list(ast_node *ast);
static void gen_expr_at_id(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new);
static void gen_select_expr(ast_node *ast);
static void gen_arg_list(ast_node *ast);
static void gen_any_macro_ref(ast_node *ast);
static void gen_stmt_list_flat(ast_node *root);

static int32_t gen_indent = 0;
static int32_t pending_indent = 0;

#define GEN_BEGIN_INDENT(name, level) \
  int32_t name##_level = gen_indent; \
  gen_indent += level; \
  pending_indent = gen_indent;

#define GEN_END_INDENT(name) \
  gen_indent = name##_level; \
  if (pending_indent > gen_indent) pending_indent = gen_indent;

cql_noexport void gen_printf(const char *format, ...) {
 CHARBUF_OPEN(tmp);
 va_list args;
 va_start(args, format);
 vbprintf(&tmp, format, args);
 va_end(args);

 for (CSTR p = tmp.ptr; *p; p++) {
    if (*p != '\n') {
      for (int32_t i = 0; i < pending_indent; i++) bputc(gen_output, ' ');
      pending_indent = 0;
    }
    bputc(gen_output, *p);
    if (*p == '\n') {
      pending_indent = gen_indent;
    }
 }
 CHARBUF_CLOSE(tmp);
}

void bprint_maybe_qname(charbuf *output, CSTR subject) {
  if (is_qname(subject)) {
    cg_decode_qstr(output, subject);
  }
  else {
    bprintf(output, "%s", subject);
  }
}

static void gen_literal(CSTR literal) {
  for (int32_t i = 0; i < pending_indent; i++) bputc(gen_output, ' ');
  pending_indent = 0;
  bprintf(gen_output, "%s", literal);
}

cql_noexport void gen_to_stdout(ast_node *ast, gen_func fn) {
  gen_callbacks = NULL;
  charbuf *gen_saved = gen_output;
  CHARBUF_OPEN(sql_out);
  gen_set_output_buffer(&sql_out);
  (*fn)(ast);
  cql_output("%s", sql_out.ptr);
  CHARBUF_CLOSE(sql_out);
  gen_output = gen_saved;
}

static bool_t suppress_attributes() {
  return gen_callbacks && (gen_callbacks->mode == gen_mode_sql || gen_callbacks->mode == gen_mode_no_annotations);
}

static bool_t for_sqlite() {
  return gen_callbacks && gen_callbacks->mode == gen_mode_sql;
}

cql_noexport void gen_stmt_list_to_stdout(ast_node *ast) {
  gen_to_stdout(ast, gen_stmt_list);
}

cql_noexport void gen_one_stmt_to_stdout(ast_node *ast) {
  gen_to_stdout(ast, gen_one_stmt);
  bool_t prep = is_ast_ifdef_stmt(ast) || is_ast_ifndef_stmt(ast);
  if (prep) cql_output("\n"); else cql_output(";\n");
}

cql_noexport void gen_misc_attrs_to_stdout(ast_node *ast) {
  gen_to_stdout(ast, gen_misc_attrs);
}

cql_noexport void gen_with_callbacks(ast_node *ast, gen_func fn, gen_sql_callbacks *_callbacks) {
  gen_callbacks = _callbacks;
  (*fn)(ast);
  gen_callbacks = NULL;
}

cql_noexport void gen_col_def_with_callbacks(ast_node *ast, gen_sql_callbacks *_callbacks) {
  gen_with_callbacks(ast, gen_col_def, _callbacks);
}

cql_noexport void gen_statement_with_callbacks(ast_node *ast, gen_sql_callbacks *_callbacks) {
  // works for statements or statement lists
  if (is_ast_stmt_list(ast)) {
    gen_stmt_level = -1;  // the first statement list does not indent
    gen_with_callbacks(ast, gen_stmt_list, _callbacks);
  }
  else {
    gen_stmt_level = 0;  // nested statement lists will indent
    gen_with_callbacks(ast, gen_one_stmt, _callbacks);
  }
}

cql_noexport void gen_statement_and_attributes_with_callbacks(ast_node *ast, gen_sql_callbacks *_callbacks) {
  gen_stmt_level = 0;  // nested statement lists will indent
  gen_with_callbacks(ast, gen_one_stmt_and_misc_attrs, _callbacks);
}

cql_noexport void gen_set_output_buffer(struct charbuf *buffer) {
  gen_output = buffer;
}

static void gen_name_ex(CSTR name, bool_t is_qid) {
  CHARBUF_OPEN(tmp);
  if (is_qid) {
    if (!for_sqlite()) {
      cg_decode_qstr(&tmp, name);
      gen_printf("%s", tmp.ptr);
    }
    else {
      cg_unquote_encoded_qstr(&tmp, name);
      gen_printf("[%s]", tmp.ptr);
    }
  }
  else {
    gen_printf("%s", name);
  }
  CHARBUF_CLOSE(tmp);
}

static void gen_name(ast_node *ast) {
  if (is_ast_at_id(ast)) {
    gen_expr_at_id(ast, "", 0, 0);
    return;
  }

  EXTRACT_STRING(name, ast);
  gen_name_ex(name, is_qid(ast));
}

cql_noexport void gen_name_for_msg(ast_node *name_ast, charbuf *output) {
  charbuf *saved = gen_output;
  gen_output = output;
  gen_name(name_ast);
  gen_output = saved;
}

static void gen_sptr_name(sem_struct *sptr, uint32_t i) {
  gen_name_ex(sptr->names[i], !!(sptr->semtypes[i] & SEM_TYPE_QID));
}

static void gen_constraint_name(ast_node *ast) {
  EXTRACT_NAME_AST(name_ast, ast);
  gen_printf("CONSTRAINT ");
  gen_name(name_ast);
  gen_printf(" ");
}

static void gen_name_list(ast_node *list) {
  Contract(is_ast_name_list(list));

  for (ast_node *item = list; item; item = item->right) {
    gen_name(item->left);
    if (item->right) {
      gen_printf(", ");
    }
  }
}

cql_noexport void gen_misc_attr_value_list(ast_node *ast) {
  Contract(is_ast_misc_attr_value_list(ast));
  for (ast_node *item = ast; item; item = item->right) {
    gen_misc_attr_value(item->left);
    if (item->right) {
      gen_printf(", ");
    }
  }
}

cql_noexport void gen_misc_attr_value(ast_node *ast) {
  if (is_ast_misc_attr_value_list(ast)) {
    gen_printf("(");
    gen_misc_attr_value_list(ast);
    gen_printf(")");
  }
  else {
    gen_root_expr(ast);
  }
}

static void gen_misc_attr(ast_node *ast) {
  Contract(is_ast_misc_attr(ast));

  bool_t is_cql =
    is_ast_dot(ast->left) &&
    is_ast_str(ast->left->left) &&
    !StrCaseCmp("cql", ((str_ast_node *)(ast->left->left))->value);

  CSTR attr_open = "[[";
  CSTR attr_close = "]]";

  if (gen_callbacks && gen_callbacks->escape_attributes_for_lua) {
    // in Lua comments ]] ends a comment, so we need the attribute to not match that
    // fortunately "[ [ builtin ] ]" is also valid syntax but in any case it's
    // just a comment
    attr_open = "[ [ ";
    attr_close = " ] ]";
  }

  if (is_cql) {
    gen_printf("%s", attr_open);
    gen_name(ast->left->right);
  }
  else {
    gen_printf("@ATTRIBUTE(");
    if (is_ast_dot(ast->left)) {
      gen_name(ast->left->left);
      gen_printf(":");
      gen_name(ast->left->right);
    }
    else {
      gen_name(ast->left);
    }
  }
  if (ast->right) {
    gen_printf("=");
    gen_misc_attr_value(ast->right);
  }
  if (is_cql) {
    gen_printf("%s\n", attr_close);
  }
  else {
    gen_printf(")\n");
  }
}

cql_noexport void gen_misc_attrs(ast_node *list) {
  Contract(is_ast_misc_attrs(list));

  // misc attributes don't go into the output if we are writing for Sqlite
  if (suppress_attributes()) {
    return;
  }

  for (ast_node *item = list; item; item = item->right) {
    gen_misc_attr(item->left);
  }
}

static void gen_type_kind(CSTR name) {
  // we don't always have an ast node for this, we make a fake one for the callback
  str_ast_node sast = {
    .type = k_ast_str,
    .value = name,
    .filename = "none"
  };

  ast_node *ast = (ast_node *)&sast;

  bool_t suppress = false;
  if (gen_callbacks) {
    gen_sql_callback callback = gen_callbacks->set_kind_callback;
    if (callback && ends_in_set(name)) {
      CHARBUF_OPEN(buf);
      suppress = callback(ast, gen_callbacks->set_kind_context, &buf);
      gen_printf("%s", buf.ptr);
      CHARBUF_CLOSE(buf);
    }
  }

  if (!suppress) {
    gen_printf("<%s>", name);
  }
}

static void gen_not_null() {
  if (for_sqlite()) {
    gen_printf(" NOT NULL");
  }
  else {
    gen_printf("!");
  }
}

void gen_data_type(ast_node *ast) {
  if (is_ast_create_data_type(ast)) {
    gen_printf("CREATE ");
    gen_data_type(ast->left);
    return;
  }
  else if (is_ast_notnull(ast)) {
    gen_data_type(ast->left);
    gen_not_null();
    return;
  }
  else if (is_ast_sensitive_attr(ast)) {
    gen_data_type(ast->left);
    if (!for_sqlite()) {
      gen_printf(" @SENSITIVE");
    }
    return;
  }
  else if (is_ast_type_int(ast)) {
    if (for_sqlite()) {
      // we could use INT here but there is schema out
      // there that won't match if we do, seems risky
      // to change the canonical SQL output
      gen_printf("INTEGER");
    }
    else {
      gen_printf("INT");
    }
  }
  else if (is_ast_type_text(ast)) {
    gen_printf("TEXT");
  }
  else if (is_ast_type_blob(ast)) {
    gen_printf("BLOB");
  }
  else if (is_ast_type_object(ast)) {
    gen_printf("OBJECT");
  }
  else if (is_ast_type_long(ast)) {
    if (for_sqlite()) {
      // we could use INT here but there is schema out
      // there that won't match if we do, seems risky
      // to change the canonical SQL output
      gen_printf("LONG_INT");
    }
    else {
      gen_printf("LONG");
    }
  }
  else if (is_ast_type_real(ast)) {
    gen_printf("REAL");
  }
  else if (is_ast_type_bool(ast)) {
    gen_printf("BOOL");
  }
  else if (is_ast_type_cursor(ast)) {
    gen_printf("CURSOR");
  }
  else {
    bool_t suppress = false;
    if (gen_callbacks) {
      gen_sql_callback callback = gen_callbacks->named_type_callback;
      if (callback) {
        CHARBUF_OPEN(buf);
        suppress = callback(ast, gen_callbacks->named_type_context, &buf);
        gen_printf("%s", buf.ptr);
        CHARBUF_CLOSE(buf);
        return;
      }
    }
    if (!suppress) {
      EXTRACT_NAME_AST(name_ast, ast);
      gen_name(name_ast);
    }
    return;
  }

  if (!for_sqlite()) {
    if (ast->left) {
      EXTRACT_STRING(name, ast->left);
      gen_type_kind(name);
    }
  }
}

static void gen_indexed_column(ast_node *ast) {
  Contract(is_ast_indexed_column(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  gen_root_expr(expr);
  if (is_ast_asc(ast->right)) {
    gen_printf(" ASC");
  }
  else if (is_ast_desc(ast->right)) {
    gen_printf(" DESC");
  }
}

static void gen_indexed_columns(ast_node *ast) {
  Contract(is_ast_indexed_columns(ast));
  for (ast_node *item = ast; item; item = item->right) {
    gen_indexed_column(item->left);
    if (item->right) {
      gen_printf(", ");
    }
  }
}

static void gen_create_index_stmt(ast_node *ast) {
  Contract(is_ast_create_index_stmt(ast));
  EXTRACT_NOTNULL(create_index_on_list, ast->left);
  EXTRACT_NOTNULL(flags_names_attrs, ast->right);
  EXTRACT_NOTNULL(connector, flags_names_attrs->right);
  EXTRACT_NOTNULL(index_names_and_attrs, connector->left);
  EXTRACT_OPTION(flags, flags_names_attrs->left);
  EXTRACT_NOTNULL(indexed_columns, index_names_and_attrs->left);
  EXTRACT(opt_where, index_names_and_attrs->right);
  EXTRACT_ANY(attrs, connector->right);
  EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);
  EXTRACT_NAME_AST(table_name_ast, create_index_on_list->right);

  gen_printf("CREATE ");
  if (flags & INDEX_UNIQUE) {
    gen_printf("UNIQUE ");
  }
  gen_printf("INDEX ");
  gen_if_not_exists(ast, !!(flags & INDEX_IFNE));
  gen_name(index_name_ast);
  gen_printf(" ON ");
  gen_name(table_name_ast);
  gen_printf(" (");
  gen_indexed_columns(indexed_columns);
  gen_printf(")");
  if (opt_where) {
    gen_printf("\n");
    gen_opt_where(opt_where);
  }
  gen_version_attrs(attrs);
}

static void gen_unq_def(ast_node *def) {
  Contract(is_ast_unq_def(def));
  EXTRACT_NOTNULL(indexed_columns_conflict_clause, def->right);
  EXTRACT_NOTNULL(indexed_columns, indexed_columns_conflict_clause->left);
  EXTRACT_ANY(conflict_clause, indexed_columns_conflict_clause->right);

  if (def->left) {
    gen_constraint_name(def->left);
  }

  gen_printf("UNIQUE (");
  gen_indexed_columns(indexed_columns);
  gen_printf(")");
  if (conflict_clause) {
    gen_conflict_clause(conflict_clause);
  }
}

static void gen_check_def(ast_node *def) {
  Contract(is_ast_check_def(def));
  if (def->left) {
    gen_constraint_name(def->left);
  }

  EXTRACT_ANY_NOTNULL(expr, def->right);
  gen_printf("CHECK (");
  gen_root_expr(expr);
  gen_printf(")");
}

cql_noexport void gen_fk_action(int32_t action) {
  switch (action) {
    case FK_SET_NULL:
      gen_printf("SET NULL");
      break;
    case FK_SET_DEFAULT:
      gen_printf("SET DEFAULT");
      break;
    case FK_CASCADE:
      gen_printf("CASCADE");
      break;
    case FK_RESTRICT:
      gen_printf("RESTRICT");
      break;
    default:
      // this is all that's left, it better be this...
      Contract(action == FK_NO_ACTION);
      gen_printf("NO ACTION");
      break;
  }
}

static void gen_fk_flags(int32_t flags) {
  if (flags) {
    gen_printf(" ");
  }

  int32_t action = (flags & FK_ON_UPDATE) >> 4;

  if (action) {
    gen_printf("ON UPDATE ");
    gen_fk_action(action);
    if (flags & (FK_ON_DELETE|FK_DEFERRABLES)) {
      gen_printf(" ");
    }
  }

  action = (flags & FK_ON_DELETE);
  if (action) {
    gen_printf("ON DELETE ");
    gen_fk_action(action);
    if (flags & FK_DEFERRABLES) {
      gen_printf(" ");
    }
  }

  if (flags & FK_DEFERRABLES) {
    Contract(flags & (FK_DEFERRABLE|FK_NOT_DEFERRABLE));
    if (flags & FK_DEFERRABLE) {
      Contract(!(flags & FK_NOT_DEFERRABLE));
      gen_printf("DEFERRABLE");
    }
    else {
      gen_printf("NOT DEFERRABLE");
    }
    if (flags & FK_INITIALLY_IMMEDIATE) {
      Contract(!(flags & FK_INITIALLY_DEFERRED));
      gen_printf(" INITIALLY IMMEDIATE");
    }
    else if (flags & FK_INITIALLY_DEFERRED) {
      gen_printf(" INITIALLY DEFERRED");
    }
  }
}

static void gen_fk_target_options(ast_node *ast) {
  Contract(is_ast_fk_target_options(ast));
  EXTRACT_NOTNULL(fk_target, ast->left);
  EXTRACT_OPTION(flags, ast->right);
  EXTRACT_NAME_AST(table_name_ast, fk_target->left);
  EXTRACT_NAMED_NOTNULL(ref_list, name_list, fk_target->right);

  gen_printf("REFERENCES ");
  gen_name(table_name_ast);
  gen_printf(" (");
  gen_name_list(ref_list);
  gen_printf(")");
  gen_fk_flags(flags);
}

static void gen_fk_def(ast_node *def) {
  Contract(is_ast_fk_def(def));
  EXTRACT(fk_info, def->right);
  EXTRACT_NAMED_NOTNULL(src_list, name_list, fk_info->left);
  EXTRACT_NOTNULL(fk_target_options, fk_info->right);

  if (def->left) {
    gen_constraint_name(def->left);
  }

  gen_printf("FOREIGN KEY (");
  gen_name_list(src_list);
  gen_printf(") ");
  gen_fk_target_options(fk_target_options);
}

static void gen_conflict_clause(ast_node *ast) {
  Contract(is_ast_int(ast));
  EXTRACT_OPTION(conflict_clause_opt, ast);

  gen_printf(" ON CONFLICT ");
  switch (conflict_clause_opt) {
    case ON_CONFLICT_ROLLBACK:
      gen_printf("ROLLBACK");
      break;
    case ON_CONFLICT_ABORT:
      gen_printf("ABORT");
      break;
    case ON_CONFLICT_FAIL:
      gen_printf("FAIL");
      break;
    case ON_CONFLICT_IGNORE:
      gen_printf("IGNORE");
      break;
    case ON_CONFLICT_REPLACE:
      gen_printf("REPLACE");
      break;
  }
}

static void gen_pk_def(ast_node *def) {
  Contract(is_ast_pk_def(def));
  EXTRACT_NOTNULL(indexed_columns_conflict_clause, def->right);
  EXTRACT_NOTNULL(indexed_columns, indexed_columns_conflict_clause->left);
  EXTRACT_ANY(conflict_clause, indexed_columns_conflict_clause->right);

  if (def->left) {
    gen_constraint_name(def->left);
  }

  gen_printf("PRIMARY KEY (");
  gen_indexed_columns(indexed_columns);
  gen_printf(")");
  if (conflict_clause) {
    gen_conflict_clause(conflict_clause);
  }
}

static void gen_version_and_proc(ast_node *ast)
{
  Contract(is_ast_version_annotation(ast));
  EXTRACT_OPTION(vers, ast->left);
  gen_printf("%d", vers);
  if (ast->right) {
    if (is_ast_dot(ast->right)) {
      EXTRACT_NOTNULL(dot, ast->right);
      EXTRACT_STRING(lhs, dot->left);
      EXTRACT_STRING(rhs, dot->right);

      gen_printf(", %s:%s", lhs, rhs);
    }
    else
    {
      EXTRACT_STRING(name, ast->right);
      gen_printf(", %s", name);
    }
  }
}

static void gen_recreate_attr(ast_node *attr) {
  Contract (is_ast_recreate_attr(attr));
  if (!suppress_attributes()) {
    // attributes do not appear when writing out commands for Sqlite
    gen_printf(" @RECREATE");
    if (attr->left) {
      EXTRACT_STRING(group_name, attr->left);
      gen_printf("(%s)", group_name);
    }
  }
}

static void gen_create_attr(ast_node *attr) {
  Contract (is_ast_create_attr(attr));
  if (!suppress_attributes()) {
    // attributes do not appear when writing out commands for Sqlite
    gen_printf(" @CREATE(");
    gen_version_and_proc(attr->left);
    gen_printf(")");
  }
}

static void gen_delete_attr(ast_node *attr) {
  Contract (is_ast_delete_attr(attr));

  // attributes do not appear when writing out commands for Sqlite
  if (!suppress_attributes()) {
    gen_printf(" @DELETE");
    if (attr->left) {
      gen_printf("(");
      gen_version_and_proc(attr->left);
      gen_printf(")");
    }
  }
}

static void gen_sensitive_attr(ast_node *attr) {
  Contract (is_ast_sensitive_attr(attr));
  if (!for_sqlite()) {
    // attributes do not appear when writing out commands for Sqlite
    gen_printf(" @SENSITIVE");
  }
}

static void gen_col_attrs(ast_node *_Nullable attrs) {
  for (ast_node *attr = attrs; attr; attr = attr->right) {
    if (is_ast_create_attr(attr)) {
      gen_create_attr(attr);
    }
    else if (is_ast_sensitive_attr(attr)) {
      gen_sensitive_attr(attr);
    }
    else if (is_ast_delete_attr(attr)) {
      gen_delete_attr(attr);
    }
    else if (is_ast_col_attrs_not_null(attr)) {
      gen_not_null();
      EXTRACT_ANY(conflict_clause, attr->left);
      if (conflict_clause) {
        gen_conflict_clause(conflict_clause);
      }
    }
    else if (is_ast_col_attrs_pk(attr)) {
      EXTRACT_NOTNULL(autoinc_and_conflict_clause, attr->left);
      EXTRACT(col_attrs_autoinc, autoinc_and_conflict_clause->left);
      EXTRACT_ANY(conflict_clause, autoinc_and_conflict_clause->right);

      gen_printf(" PRIMARY KEY");
      if (conflict_clause) {
        gen_conflict_clause(conflict_clause);
      }
      if (col_attrs_autoinc) {
        gen_printf(" AUTOINCREMENT");
      }
    }
    else if (is_ast_col_attrs_unique(attr)) {
      gen_printf(" UNIQUE");
      if (attr->left) {
        gen_conflict_clause(attr->left);
      }
    }
    else if (is_ast_col_attrs_hidden(attr)) {
      gen_printf(" HIDDEN");
    }
    else if (is_ast_col_attrs_fk(attr)) {
      gen_printf(" ");
      gen_fk_target_options(attr->left);
    }
    else if (is_ast_col_attrs_check(attr)) {
      gen_printf(" CHECK(");
      gen_root_expr(attr->left);
      gen_printf(") ");
    }
    else if (is_ast_col_attrs_collate(attr)) {
      gen_printf(" COLLATE ");
      gen_root_expr(attr->left);
    }
    else {
      Contract(is_ast_col_attrs_default(attr));
      gen_printf(" DEFAULT ");
      gen_root_expr(attr->left);
    }
  }
}

static void gen_col_def(ast_node *def) {
  Contract(is_ast_col_def(def));
  EXTRACT_NOTNULL(col_def_type_attrs, def->left);
  EXTRACT(misc_attrs, def->right);
  EXTRACT_ANY(attrs, col_def_type_attrs->right);
  EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
  EXTRACT_NAME_AST(name_ast, col_def_name_type->left);
  EXTRACT_ANY_NOTNULL(data_type, col_def_name_type->right);

  if (misc_attrs) {
    gen_misc_attrs(misc_attrs);
  }

  gen_name(name_ast);
  gen_printf(" ");

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)
  // with no SEM we can't do this conversion, we're just doing vanilla echos
  gen_data_type(data_type);
#else
  if (gen_callbacks && gen_callbacks->long_to_int_conv && def->sem && (def->sem->sem_type & SEM_TYPE_AUTOINCREMENT)) {
    // semantic checking must have already validated that this is either an integer or long_integer
    sem_t core_type = core_type_of(def->sem->sem_type);
    Contract(core_type == SEM_TYPE_INTEGER || core_type == SEM_TYPE_LONG_INTEGER);
    gen_printf("INTEGER");
  }
  else {
    gen_data_type(data_type);
  }
#endif
  gen_col_attrs(attrs);
}

cql_noexport bool_t eval_column_callback(ast_node *ast) {
  Contract(is_ast_col_def(ast));
  bool_t suppress = 0;

  if (gen_callbacks && gen_callbacks->col_def_callback && ast->sem) {
    CHARBUF_OPEN(buf);
    suppress = gen_callbacks->col_def_callback(ast, gen_callbacks->col_def_context, &buf);
    gen_printf("%s", buf.ptr);
    CHARBUF_CLOSE(buf);
  }

  return suppress;
}

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// if SEM isn't in the picture there are no "variables"
bool_t eval_variables_callback(ast_node *ast) {
  return false;
}

#else

bool_t eval_variables_callback(ast_node *ast) {
  bool_t suppress = 0;
  if (gen_callbacks && gen_callbacks->variables_callback && ast->sem && is_variable(ast->sem->sem_type)) {
    CHARBUF_OPEN(buf);
    suppress = gen_callbacks->variables_callback(ast, gen_callbacks->variables_context, &buf);
    gen_printf("%s", buf.ptr);
    CHARBUF_CLOSE(buf);
  }
  return suppress;
}
#endif

cql_noexport void gen_col_or_key(ast_node *def) {
  if (is_ast_col_def(def)) {
    gen_col_def(def);
  }
  else if (is_ast_pk_def(def)) {
    gen_pk_def(def);
  }
  else if (is_ast_fk_def(def)) {
    gen_fk_def(def);
  }
  else if (is_ast_shape_def(def)) {
    gen_shape_def(def);
  }
  else if (is_ast_check_def(def)) {
    gen_check_def(def);
  }
  else {
    Contract(is_ast_unq_def(def));
    gen_unq_def(def);
  }
}

cql_noexport void gen_col_key_list(ast_node *list) {
  Contract(is_ast_col_key_list(list));
  bool_t need_comma = 0;

  GEN_BEGIN_INDENT(coldefs, 2);

  for (ast_node *item = list; item; item = item->right) {
    EXTRACT_ANY_NOTNULL(def, item->left);

    // give the callback system a chance to suppress columns that are not in this version
    if (is_ast_col_def(def) && eval_column_callback(def)) {
      continue;
    }

    if (need_comma) {
      gen_printf(",\n");
    }
    need_comma = 1;

    gen_col_or_key(def);
  }
  GEN_END_INDENT(coldefs);
}

static void gen_select_opts(ast_node *ast) {
  Contract(is_ast_select_opts(ast));
  EXTRACT_ANY_NOTNULL(opt, ast->left);

  if (is_ast_all(opt)) {
    gen_printf(" ALL");
  }
  else if (is_ast_distinct(opt)) {
    gen_printf(" DISTINCT");
  }
  else {
    Contract(is_ast_distinctrow(opt));
    gen_printf(" DISTINCTROW");
  }
}

static void gen_binary_no_spaces(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf("%s", op);
  if (is_ast_reverse_apply_poly_args(ast)) {
    gen_printf("(");
    gen_arg_list(ast->right);
    gen_printf(")");
  }
  else {
    gen_expr(ast->right, pri_new + 1);
  }
  if (pri_new < pri) gen_printf(")");
}

static void gen_binary(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {

  // We add parens if our priority is less than the parent priority
  // meaning something like this:
  // * we're a + node, our parent is a * node
  // * we need parens because the tree specifies that the + happens before the *
  //
  // Also, grouping of equal operators is left to right
  // so for so if our right child is the same precedence as us
  // that means there were parens there in the original expression
  // e.g.  3+(4+7);
  // effectively it's like we're one binding strength higher for our right child
  // so we call it with pri_new + 1.  If it's equal to us it must emit parens

  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" %s ", op);
  gen_expr(ast->right, pri_new + 1);
  if (pri_new < pri) gen_printf(")");
}

static void gen_unary(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  if (pri_new < pri) gen_printf("(");
  gen_printf("%s", op);
  gen_expr(ast->left, pri_new);
  if (pri_new < pri) gen_printf(")");
}

static void gen_postfix(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" %s", op);
  if (pri_new < pri) gen_printf(")");
}

static void gen_expr_const(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  gen_printf("CONST(");
  gen_expr(ast->left, pri_new);
  gen_printf(")");
}

static void gen_uminus(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  if (pri_new < pri) gen_printf("(");
  gen_printf("%s", op);

  // we don't ever want -- in the output because that's a comment
  CHARBUF_OPEN(tmp);
  charbuf *saved = gen_output;
  gen_output = &tmp;
  gen_expr(ast->left, pri_new);
  gen_output = saved;

  if (tmp.ptr[0] == '-') {
    gen_printf(" ");
  }

  gen_printf("%s", tmp.ptr);
  CHARBUF_CLOSE(tmp);

  if (pri_new < pri) gen_printf(")");
}

static void gen_concat(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_concat(ast));

  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" %s ", op);
  gen_expr(ast->right, pri_new);
  if (pri_new < pri) gen_printf(")");
}

static void gen_jex1(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_jex1(ast));

  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" %s ", op);
  gen_expr(ast->right, pri_new);
  if (pri_new < pri) gen_printf(")");
}

static void gen_jex2(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_jex2(ast));

  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" %s ", op);
  if (!for_sqlite()) {
    gen_printf("~");
    gen_data_type(ast->right->left);
    gen_printf("~ ");
  }
  gen_expr(ast->right->right, pri_new);
  if (pri_new < pri) gen_printf(")");
}

static void gen_arg_expr(ast_node *ast) {
  if (is_ast_star(ast)) {
    gen_printf("*");
  }
  else if (is_ast_from_shape(ast)) {
    gen_shape_arg(ast);
  }
  else {
    gen_root_expr(ast);
  }
}

static void gen_expr_exists(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_exists_expr(ast));
  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);

  gen_printf("EXISTS (");
  GEN_BEGIN_INDENT(sel, 2);
    pending_indent = 0;
    gen_select_stmt(select_stmt);
  GEN_END_INDENT(sel);
  gen_printf(")");
}

static void gen_arg_list(ast_node *ast) {
  while (ast) {
    gen_arg_expr(ast->left);
    if (ast->right) {
      gen_printf(", ");
    }
    ast = ast->right;
  }
}

static void gen_expr_list(ast_node *ast) {
  while (ast) {
    gen_root_expr(ast->left);
    if (ast->right) {
      gen_printf(", ");
    }
    ast = ast->right;
  }
}

static void gen_shape_arg(ast_node *ast) {
  Contract(is_ast_from_shape(ast));
  EXTRACT_STRING(shape, ast->left);
  gen_printf("FROM %s", shape);
  if (ast->right) {
    gen_printf(" ");
    gen_shape_def(ast->right);
  }
}

static void gen_case_list(ast_node *ast) {
  Contract(is_ast_case_list(ast));

  while (ast) {
    EXTRACT_NOTNULL(when, ast->left);
    EXTRACT_ANY_NOTNULL(case_expr, when->left);
    EXTRACT_ANY_NOTNULL(then_expr, when->right);

    // additional parens never needed because WHEN/THEN act like parens
    gen_printf("WHEN ");
    gen_root_expr(case_expr);
    gen_printf(" THEN ");
    gen_root_expr(then_expr);
    gen_printf("\n");

    ast = ast->right;
  }
}

static void gen_expr_table_star(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_table_star(ast));
  gen_name(ast->left);
  gen_printf(".*");
}

static void gen_expr_star(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_star(ast));
  gen_printf("*");
}

static void gen_expr_num(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_num(ast));
  EXTRACT_NUM_VALUE(val, ast);
  EXTRACT_NUM_TYPE(num_type, ast);
  Contract(val);

  if (has_hex_prefix(val) && gen_callbacks && gen_callbacks->convert_hex) {
    int64_t v = strtol(val, NULL, 16);
    gen_printf("%lld", (llint_t)v);
  }
  else {
    if (for_sqlite() || num_type != NUM_BOOL) {
      gen_printf("%s", val);
    }
    else {
      if (!strcmp(val, "0")) {
        gen_printf("FALSE");
      }
      else {
        gen_printf("TRUE");
      }
    }
  }

  if (for_sqlite()) {
    return;
  }

  if (num_type == NUM_LONG) {
    gen_printf("L");
  }
}

static void gen_expr_blob(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_blob(ast));
  EXTRACT_BLOBTEXT(str, ast);

  // blob literals are easy, we just emit them, there's no conversion or anything like that
  gen_printf("%s", str);
}

static void gen_macro_args(ast_node *ast) {
  for ( ; ast; ast = ast->right) {
    EXTRACT_ANY_NOTNULL(arg, ast->left);
    if (is_any_macro_ref(arg->left)) {
      gen_any_macro_ref(arg->left);
    }
    else if (is_ast_expr_macro_arg(arg)) {
      gen_root_expr(arg->left);
    }
    else if (is_ast_query_parts_macro_arg(arg)) {
      gen_printf("FROM(");
      gen_query_parts(arg->left);
      gen_printf(")");
    }
    else if (is_ast_select_core_macro_arg(arg)) {
      gen_printf("ROWS(");
      gen_select_core_list(arg->left);
      gen_printf(")");
    }
    else if (is_ast_select_expr_macro_arg(arg)) {
      gen_printf("SELECT(");
      gen_select_expr_list(arg->left);
      gen_printf(")");
    }
    else if (is_ast_cte_tables_macro_arg(arg)) {
      gen_printf("WITH(\n");
      GEN_BEGIN_INDENT(tables, 2);
        gen_cte_tables(arg->left, "");
      GEN_END_INDENT(tables);
      gen_printf(")");
    }
    else {
      Contract(is_ast_stmt_list_macro_arg(arg));
      gen_printf("\nBEGIN\n");
      gen_stmt_list(arg->left);
      gen_printf("END");
    }
    if (ast->right) {
      gen_printf(", ");
    }
  }
}

static void gen_text_args(ast_node *ast) {
  for (; ast; ast = ast->right) {
    Contract(is_ast_text_args(ast));
    EXTRACT_ANY_NOTNULL(txt, ast->left);

    if (is_any_macro_ref(txt)) {
      gen_any_macro_ref(txt);
    }
    else {
      gen_root_expr(txt);
    }
    if (ast->right) {
      gen_printf(", ");
    }
  }
}

static void gen_expr_macro_text(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(ast->left);

  gen_printf("@TEXT(");
  gen_text_args(ast->left);
  gen_printf(")");
}

cql_noexport void gen_any_text_arg(ast_node *ast) {
  if (is_ast_cte_tables(ast)) {
    gen_cte_tables(ast, "");
  }
  else if (is_ast_table_or_subquery_list(ast) || is_ast_join_clause(ast)) {
    gen_query_parts(ast);
  }
  else if (is_ast_stmt_list(ast)) {
    gen_stmt_list(ast);
  }
  else if (is_ast_select_core_list(ast)) {
    gen_select_core_list(ast);
  }
  else if (is_ast_select_expr_list(ast)) {
    gen_select_expr_list(ast);
  }
  else {
    gen_root_expr(ast);
  }
}

// this is used to token paste an identifier
static void gen_expr_at_id(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_at_id(ast));
  EXTRACT_NOTNULL(text_args, ast->left);

  if (is_ast_str(text_args->left)) {
    EXTRACT_STRING(arg1, text_args->left);
    if (!strcmp("@TMP", arg1)) {
       gen_printf("@TMP(");
       gen_text_args(text_args->right);
       gen_printf(")");
       return;
    }
  }

  gen_printf("@ID(");
  gen_text_args(ast->left);
  gen_printf(")");
}

static void gen_expr_str(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_str(ast));
  EXTRACT_STRING(str, ast);

  if (is_strlit(ast)) {
    str_ast_node *asts = (str_ast_node *)ast;
    if (asts->str_type != STRING_TYPE_C || for_sqlite()) {
      // Note: str is the lexeme, so it is either still quoted and escaped
      // or if it was a c string literal it was already normalized to SQL form.
      // In both cases we can just print.
      gen_literal(str);
    }
    else {
      // If was originally a c string literal re-encode it for echo output
      // so that it looks the way it was given to us.  This is so that when we
      // echo the SQL back for say test output C string literal forms come out
      // just as they were given to us.
      CHARBUF_OPEN(decoded);
      CHARBUF_OPEN(encoded);
      cg_decode_string_literal(str, &decoded);
      cg_encode_c_string_literal(decoded.ptr, &encoded);

      gen_literal(encoded.ptr);
      CHARBUF_CLOSE(encoded);
      CHARBUF_CLOSE(decoded);
    }
  }
  else {
    if (!eval_variables_callback(ast)) {
      // an identifier
      gen_name(ast);
    }
  }
}

static void gen_expr_null(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_null(ast));
  gen_printf("NULL");
}

static void gen_expr_dot(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_dot(ast));

  // the general case is not variables tables etc. the notifications do not fire
  // these are rewritten away so they won't survive in the tree for later codegen
  // to use these callbacks anyway.
  if (!is_id(ast->left) || !is_id(ast->right)) {
    gen_binary_no_spaces(ast, op, pri, pri_new);
    return;
  }

  // the "_select_" scope is special name of a nested select table
  // expression that was not aliased.  This name is useless. Either
  // the columns will be unambiguous without it or it's an error
  // in any case. No point in emitting it.  It's included in the semantic
  // expansion to disambiguate any column name that matches from the same
  // local name, but it's not needed in the SQLite output.
  EXTRACT_STRING(left_name, ast->left);
  if (!strcmp("_select_", left_name) && for_sqlite()) {
    gen_name(ast->right);
    return;
  }

  EXTRACT_ANY_NOTNULL(left, ast->left);
  EXTRACT_ANY_NOTNULL(right, ast->right);

  if (eval_variables_callback(ast)) {
    return;
  }

  bool_t has_table_rename_callback = gen_callbacks && gen_callbacks->table_rename_callback;
  bool_t handled = false;

  if (has_table_rename_callback) {
    handled = gen_callbacks->table_rename_callback(left, gen_callbacks->table_rename_context, gen_output);
  }

  if (handled) {
    // the scope name has already been written by table_rename_callback
    // this is a case like:
    //
    // [[shared_fragment]]
    // proc transformer()
    // begin
    //   with
    //   source(*) like xy
    //   select source.x + 1 x, source.y + 20 y from source;
    // end;
    //
    // with T(x,y) as (call transformer() using xy as source) select T.* from T;
    //
    // In the above source.x must become xy.x and source.y must become xy.y
    //
    // At this point the correct table name is already in the stream, so left is
    // now useless. So we just throw it away.

    left = NULL;
  }

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)
  // simple case if SEM is not available
  if (left) {
     gen_name(left);
  }
  gen_printf(".");
  gen_name(right);
#else
  bool_t is_arguments = false;

  if (is_id(left)) {
    EXTRACT_STRING(lname, left);
    is_arguments = !strcmp("ARGUMENTS", lname) && ast->sem && ast->sem->name;
  }

  if (is_arguments) {
    // special case for rewritten arguments, hide the "ARGUMENTS." stuff
    gen_printf("%s", ast->sem->name);
  }
  else if (keep_table_name_in_aliases && get_inserted_table_alias_string_override(ast)) {
    gen_printf("%s.", get_inserted_table_alias_string_override(ast));
    gen_name(right);
  }
  else {
    if (left) {
      gen_name(left);
    }
    gen_printf(".");
    gen_name(right);
  }
#endif
}

static void gen_expr_in_pred(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_in_pred(ast));
  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" IN (");
  if (ast->right == NULL) {
    /* nothing */
  }
  else if (is_ast_expr_list(ast->right)) {
    EXTRACT_NOTNULL(expr_list, ast->right);
    gen_expr_list(expr_list);
  }
  else {
    EXTRACT_ANY_NOTNULL(select_stmt, ast->right);
    gen_select_stmt(select_stmt);
  }
  gen_printf(")");

  if (pri_new < pri) gen_printf(")");
}

static void gen_expr_not_in(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_not_in(ast));
  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" NOT IN (");
  if (ast->right == NULL) {
    /* nothing */
  }
  else if (is_ast_expr_list(ast->right)) {
    EXTRACT_NOTNULL(expr_list, ast->right);
    gen_expr_list(expr_list);
  }
  else {
    EXTRACT_ANY_NOTNULL(select_stmt, ast->right);
    gen_select_stmt(select_stmt);
  }
  gen_printf(")");

  if (pri_new < pri) gen_printf(")");
}

// Append field name and type to the buffer.  Canonicalize column name to camel case.
// Many languages use camel case property names and we want to make it easy
// for them to bind to fields and generate hashes.  We have to pick some
// canonical thing so we canonicalize to camelCase.  It's not perfect but it seems
// like the best trade-off. Lots of languages wrap SQLite columns.
static void gen_append_field_desc(charbuf *tmp, CSTR c_name, sem_t sem_type) {
  cg_sym_name(cg_symbol_case_camel, tmp, "", c_name, NULL); // no prefix camel
  bputc(tmp, ':');

  if (is_nullable(sem_type)) {
    bputc(tmp, '?');
  }

  switch (core_type_of(sem_type)) {
    case SEM_TYPE_BOOL:
      bprintf(tmp, "Bool");
      break;
    case SEM_TYPE_INTEGER:
      bprintf(tmp, "Int32");
      break;
    case SEM_TYPE_LONG_INTEGER:
      bprintf(tmp, "Int64");
      break;
    case SEM_TYPE_TEXT:
      bprintf(tmp, "String");
      break;
    case SEM_TYPE_REAL:
      bprintf(tmp, "Float64");
      break;
    case SEM_TYPE_BLOB:
      bprintf(tmp, "Blob");
      break;
  }
}

// This is the same as the standard field hash but it doesn't emit it
// to an output stream and it takes ad hoc parameters, suitable for external
// callers but otherwise the same.  They could be folded but there's nothing
// to fold really other than the sha256 stuff which is already folded...
cql_noexport CSTR get_field_hash(CSTR name, sem_t sem_type) {
  CHARBUF_OPEN(tmp);
  gen_append_field_desc(&tmp, name, sem_type);
  int64_t hash = sha256_charbuf(&tmp);
  CSTR result = dup_printf("%lld", (llint_t)hash);
  CHARBUF_CLOSE(tmp);
  return result;
}

// This is only called when doing for_sqlite output which
// presumes that semantic analysis has already happened. Its
// otherwise meaningless.  There must also be live blob mappings
// again all this would be screen out much earlier if it was otherwise.
static void gen_field_hash(ast_node *ast) {
  Contract(is_ast_dot(ast));
  Contract(ast->sem);
  EXTRACT_STRING(c_name, ast->right);

  CHARBUF_OPEN(tmp);
  gen_append_field_desc(&tmp, c_name, ast->sem->sem_type);
  int64_t hash = sha256_charbuf(&tmp);
  gen_printf("%lld", (llint_t)hash);
  CHARBUF_CLOSE(tmp);
}


// patternlint-disable-next-line prefer-sized-ints-in-msys
// get CSTR out of the array and compare case insensitively
static int case_cmp(void *p1, void *p2) {
  CSTR c1 = *(CSTR*)p1;
  CSTR c2 = *(CSTR*)p2;
  // case sensitive compare for the hash canonicalization
  return strcmp(c1, c2);
}

// The type hash considers all of the not null fields plus the type name
// as the core identity of the type.
cql_noexport CSTR gen_type_hash(ast_node *ast) {
  Contract(ast);
  Contract(ast->sem);
  Contract(ast->sem->sptr);
  Contract(ast->sem->table_info);

  table_node *table_info = ast->sem->table_info;

  int64_t hash = 0;

  if (table_info->type_hash != 0) {
    // if we are so unlucky that the hash is zero, nothing bad happens
    // we just compute it every time
    hash = table_info->type_hash;
    goto cache_hit;
  }

  sem_struct *sptr = ast->sem->sptr;

  CHARBUF_OPEN(tmp);

  // Canonicalize to pascal
  cg_sym_name(cg_symbol_case_pascal, &tmp, "", sptr->struct_name, NULL); // no prefix pascal

  // we need an array of the field descriptions, first we need the count of mandatory fields
  uint32_t count = (uint32_t)table_info->notnull_count;

  // there must be a pk and it is not null so count is > 0
  Invariant(count > 0);

  // make our temporary array
  CSTR *ptrs = calloc(count, sizeof(CSTR));

  // now compute the fields we need
  for (uint32_t i = 0; i < count; i++) {
    int16_t icol = table_info->notnull_cols[i];
    CSTR c_name = sptr->names[icol];
    sem_t sem_type = sptr->semtypes[icol];

    CHARBUF_OPEN(field);
      gen_append_field_desc(&field, c_name, sem_type);
      ptrs[i] = Strdup(field.ptr);
    CHARBUF_CLOSE(field);
  }

  qsort(ptrs, count, sizeof(CSTR), (void*)case_cmp);

  // assemble the fields into one big string to hash
  bool_t first = true;
  for (uint32_t i = 0; i < count; i++) {
     bputc(&tmp, first ? ':' : ',');
     bprintf(&tmp, "%s", ptrs[i]);
     first = false;
  }

  free(ptrs);

  // printf("hashing: %s\n", tmp.ptr); -- for debugging
  hash = sha256_charbuf(&tmp);
  CHARBUF_CLOSE(tmp);

  ast->sem->table_info->type_hash = hash;

cache_hit:

  return dup_printf("%lld", (llint_t)hash);
}

static void gen_cql_blob_get_type(ast_node *ast) {
  Contract(is_ast_call(ast));
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_STRING(t_name, first_arg(arg_list));

  cg_blob_mappings_t *map = find_backing_info(t_name);
  Contract(map);

  // special case json and jsonb, we use the extraction operator
  if (map->use_json || map->use_jsonb) {
    gen_printf("((");
    gen_root_expr(second_arg(arg_list));
    gen_printf(")->>0)");
    return;
  }

  CSTR func = map->get_key_type;
  gen_printf("%s(", func);
  gen_root_expr(second_arg(arg_list));
  gen_printf(")");
}

#define CQL_SEARCH_COL_KEYS true
#define CQL_SEARCH_COL_VALUES false

static int32_t get_table_col_offset(ast_node *create_table_stmt, CSTR name, bool_t search_for_keys) {
  // this can only be used after semantic analysis
  Contract(is_ast_create_table_stmt(create_table_stmt));
  Contract(create_table_stmt->sem);
  Contract(create_table_stmt->sem->sptr);
  Contract(create_table_stmt->sem->table_info);

  table_node *table_info = create_table_stmt->sem->table_info;
  sem_struct *sptr = create_table_stmt->sem->sptr;

  int16_t count;
  int16_t *columns;

  if (search_for_keys) {
    count = table_info->key_count;
    columns = table_info->key_cols;
  }
  else {
    count = table_info->value_count;
    columns = table_info->value_cols;
  }

  Invariant(count > 0);
  Invariant(columns);

  for (int16_t i = 0; i < count; i++) {
    int16_t icol = columns[i];
    Invariant(icol >= 0);
    Invariant((uint32_t)icol < sptr->count);

    if (!StrCaseCmp(name, sptr->names[icol])) {
      return i;
    }
  }

  return -1;
}

static void gen_cql_blob_get(ast_node *ast) {
  Contract(is_ast_call(ast));
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  ast_node *table_expr = second_arg(arg_list);

  EXTRACT_STRING(t_name, table_expr->left);
  EXTRACT_STRING(c_name, table_expr->right);

  cg_blob_mappings_t *map = find_backing_info(t_name);

  // table known to exist (and not deleted) already
  ast_node *table_ast = find_table_or_view_even_deleted(t_name);
  Invariant(table_ast);

  int32_t pk_col_offset = get_table_col_offset(table_ast, c_name, CQL_SEARCH_COL_KEYS);

  // special case json and jsonb
  if (map->use_json || map->use_jsonb) {
    if (pk_col_offset >= 0) {
      gen_printf("((");
      gen_root_expr(first_arg(arg_list));
      gen_printf(")->>%d)", pk_col_offset+1);
    }
    else {
      gen_printf("((");
      gen_root_expr(first_arg(arg_list));
      gen_printf(")->>'$.%s')", c_name);
    }
    return;
  }

  CSTR func = pk_col_offset >= 0 ? map->get_key : map->get_val;

  bool_t offsets = pk_col_offset >= 0 ? map->key_use_offsets : map->val_use_offsets;

  gen_printf("%s(", func);
  gen_root_expr(first_arg(arg_list));

  if (offsets) {
    int32_t offset = pk_col_offset;
    if (offset < 0) {
      // if column not part of the key then we need to index the value, not the key
      offset = get_table_col_offset(table_ast, c_name, CQL_SEARCH_COL_VALUES);
      // we know it's a valid column so it's either a key or it isn't
      // since it isn't a key it must be a value
      Invariant(offset >= 0);
      Invariant(offset < table_ast->sem->table_info->value_count);
    }
    else {
      Invariant(offset < table_ast->sem->table_info->key_count);
    }
    gen_printf(", %d)", offset);
  }
  else {
    gen_printf(", ");
    gen_field_hash(table_expr);
    gen_printf(")");
  }
}

// These align directly with the sem types but they are offset by 1
// Note that these should never change because we expect there are
// backing tables with these values in them.
#define CQL_BLOB_TYPE_BOOL   0
#define CQL_BLOB_TYPE_INT32  1
#define CQL_BLOB_TYPE_INT64  2
#define CQL_BLOB_TYPE_FLOAT  3
#define CQL_BLOB_TYPE_STRING 4
#define CQL_BLOB_TYPE_BLOB   5
#define CQL_BLOB_TYPE_ENTITY 6  // this is reserved for future use

// This effectively subtracts one but it makes it clear there is a mapping
// The output values of this mapping should never change, we have to assume
// there are blobs "out there" that have these values hard coded in them
// for column type info.  That is allowed and even expected.
// In contrast, the sem_type values could be reordered, and have been.
// If they are, then this mapping must "fix" that so that the new sem_type ordering
// (which is not fixed forever) matches the blob column types (which is fixed).
static int32_t sem_type_to_blob_type[] = {
   -1, // NULL
  CQL_BLOB_TYPE_BOOL,
  CQL_BLOB_TYPE_INT32,
  CQL_BLOB_TYPE_INT64,
  CQL_BLOB_TYPE_FLOAT,
  CQL_BLOB_TYPE_STRING,
  CQL_BLOB_TYPE_BLOB,
  CQL_BLOB_TYPE_ENTITY
};

static void gen_cql_blob_create(ast_node *ast) {
  Contract(is_ast_call(ast));
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  ast_node *table_name_ast = first_arg(arg_list);

  EXTRACT_STRING(t_name, table_name_ast);
  cg_blob_mappings_t *map = find_backing_info(t_name);

  bool_t is_pk = false;

  // If there is no third arg then this is a create for a value column for sure
  // only the value blob can be devoid of data, the key column has at least
  // one not null column.  The degenerate form insert backed(id) values(1)
  // leads to only one arg so is_pk will stay false.
  if (arg_list->right && arg_list->right->right) {
    ast_node *arg3 = third_arg(arg_list);
    sem_t sem_type3 = arg3->sem->sem_type;
    is_pk = is_primary_key(sem_type3) || is_partial_pk(sem_type3);
  }

  CSTR func = is_pk ? map->create_key : map->create_val;

  // table known to exist (and not deleted) already
  ast_node *table_ast = find_table_or_view_even_deleted(t_name);
  Invariant(table_ast);

  if (map->use_json || map->use_jsonb) {
    if (is_pk) {
      gen_printf("json%s_array(%s", map->use_jsonb ? "b" : "", gen_type_hash(table_ast));
      for (ast_node *args = arg_list->right; args; args = args->right->right) {
        ast_node *val = first_arg(args);
        gen_printf(", ");
        gen_root_expr(val);
      }
      gen_printf(")");
    }
    else {
      gen_printf("json%s_object(", map->use_jsonb ? "b" : "");
      for (ast_node *args = arg_list->right; args; args = args->right->right) {
        ast_node *val = first_arg(args);
        ast_node *col = second_arg(args);
        EXTRACT_STRING(c_name, col->right);
        gen_printf("'%s', ", c_name);
        gen_root_expr(val);
        if (args->right->right) {
          gen_printf(",  ");
        }
      }
      gen_printf(")");
    }
    return;
  }

  bool_t use_offsets = is_pk ? map->key_use_offsets : map->val_use_offsets;
  gen_printf("%s(%s", func, gen_type_hash(table_ast));

  // 2n+1 args already confirmed, safe to do this
  for (ast_node *args = arg_list->right; args; args = args->right->right) {
     ast_node *val = first_arg(args);
     ast_node *col = second_arg(args);
     if (use_offsets) {
       // when creating a key blob all columns are present in order, so no need to
       // emit the offsets, they are assumed.  However, value blobs can have
       // some or all of the values and might skip some
       if (!is_pk) {
         EXTRACT_STRING(c_name, col->right);
         int32_t offset = get_table_col_offset(table_ast, c_name, CQL_SEARCH_COL_VALUES);
         gen_printf(", %d", offset);
       }
     }
     else {
       gen_printf(", ");
       gen_field_hash(col);
     }

     gen_printf(", ");
     gen_root_expr(val);

     gen_printf(", %d", sem_type_to_blob_type[core_type_of(col->sem->sem_type)]);
  }

  gen_printf(")");
}

static void gen_cql_blob_update(ast_node *ast) {
  Contract(is_ast_call(ast));
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // known to be dot operator and known to have a table
  EXTRACT_NOTNULL(dot, third_arg(arg_list));
  EXTRACT_STRING(t_name, dot->left);
  cg_blob_mappings_t *map = find_backing_info(t_name);

  sem_t sem_type_dot = dot->sem->sem_type;
  bool_t is_pk = is_primary_key(sem_type_dot) || is_partial_pk(sem_type_dot);

  CSTR func = is_pk ? map->update_key : map->update_val;

  bool_t use_offsets = is_pk ? map->key_use_offsets : map->val_use_offsets;

  // table known to exist (and not deleted) already
  ast_node *table_ast = find_table_or_view_even_deleted(t_name);
  Invariant(table_ast);

  if (map->use_json || map->use_jsonb) {
    gen_printf("json%s_set(", map->use_jsonb ? "b" : "");
    gen_root_expr(first_arg(arg_list));
    for (ast_node *args = arg_list->right; args; args = args->right->right) {
      ast_node *val = first_arg(args);
      ast_node *col = second_arg(args);
      EXTRACT_STRING(c_name, col->right);
      if (is_pk) {
        int32_t offset = get_table_col_offset(table_ast, c_name, CQL_SEARCH_COL_KEYS);
        Invariant(offset >= 0);
        gen_printf(",  '$[%d]', ", offset + 1);  // the type is offset 0
      }
      else {
        gen_printf(",  '$.%s', ", c_name);
      }
      gen_root_expr(val);
    }
    gen_printf(")");
    return;
  }

  gen_printf("%s(", func);
  gen_root_expr(first_arg(arg_list));

  // 2n+1 args already confirmed, safe to do this
  for (ast_node *args = arg_list->right; args; args = args->right->right) {
     ast_node *val = first_arg(args);
     ast_node *col = second_arg(args);
     EXTRACT_STRING(c_name, col->right);
     if (use_offsets) {
      // we know it's a valid column
      int32_t offset = get_table_col_offset(table_ast, c_name,
         is_pk ? CQL_SEARCH_COL_KEYS : CQL_SEARCH_COL_VALUES);
      Invariant(offset >= 0);
      gen_printf(", %d", offset);
     }
     else {
       gen_printf(", ");
       gen_field_hash(col);
     }
     gen_printf(", ");
     gen_root_expr(val);
     if (!is_pk) {
       // you never need the item types for the key blob becasue it always has all the fields
       gen_printf(", %d", sem_type_to_blob_type[core_type_of(col->sem->sem_type)]);
     }
  }

  gen_printf(")");
}

static void gen_array(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_array(ast));
  EXTRACT_ANY_NOTNULL(array, ast->left);
  EXTRACT_NOTNULL(arg_list, ast->right);

  if (pri_new < pri) gen_printf("(");
  gen_expr(array, pri_new);
  if (pri_new < pri) gen_printf(")");
  gen_printf("[");
  gen_arg_list(arg_list);
  gen_printf("]");
}

static void gen_expr_call(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT_NOTNULL(call_filter_clause, call_arg_list->left);
  EXTRACT(distinct, call_filter_clause->left);
  EXTRACT(opt_filter_clause, call_filter_clause->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (is_ast_str(name_ast)) {
    EXTRACT_STRING(name, name_ast);

    // We never want this to appear. Calls to `cql_inferred_notnull` exist only as
    // the product of a rewrite rule and should not be visible to users.
    if (!StrCaseCmp("cql_inferred_notnull", name)) {
      gen_arg_list(arg_list);
      return;
    }

    if (for_sqlite()) {
      if (!StrCaseCmp("cql_blob_get", name)) {
        gen_cql_blob_get(ast);
        return;
      }
      else if (!StrCaseCmp("cql_blob_get_type", name)) {
        gen_cql_blob_get_type(ast);
        return;
      }
      else if (!StrCaseCmp("cql_blob_create", name)) {
        gen_cql_blob_create(ast);
        return;
      }
      else if (!StrCaseCmp("cql_blob_update", name)) {
        gen_cql_blob_update(ast);
        return;
      }
    }

    if (for_sqlite()) {
      // These functions are all no-ops in SQL and must not be emitted if we're
      // doing codegen: They're only present within queries in source programs for
      // the purpose of manipulating types.

      if (!StrCaseCmp("nullable", name)) {
        gen_arg_list(arg_list);
        return;
      }

      if (!StrCaseCmp("ptr", name)) {
        gen_arg_list(arg_list);
        return;
      }

    if (!StrCaseCmp("sensitive", name)) {
        gen_arg_list(arg_list);
        return;
      }
    }
  }

  bool_t has_func_callback = gen_callbacks && gen_callbacks->func_callback;

  if (has_func_callback) {
    bool_t handled = gen_callbacks->func_callback(ast, gen_callbacks->func_context, gen_output);

    if (handled) {
      return;
    }
  }

  gen_name(name_ast);
  gen_printf("(");
  if (distinct) {
    gen_printf("DISTINCT ");
  }
  gen_arg_list(arg_list);
  gen_printf(")");

  if (opt_filter_clause) {
    gen_opt_filter_clause(opt_filter_clause);
  }
}

static void gen_opt_filter_clause(ast_node *ast) {
  Contract(is_ast_opt_filter_clause(ast));
  EXTRACT_NOTNULL(opt_where, ast->left);

  gen_printf(" FILTER (");
  gen_opt_where(opt_where);
  gen_printf(")");
}

static void gen_opt_partition_by(ast_node *ast) {
  Contract(is_ast_opt_partition_by(ast));
  EXTRACT_NOTNULL(expr_list, ast->left);

  gen_printf("PARTITION BY ");
  gen_expr_list(expr_list);
}

static void gen_frame_spec_flags(int32_t flags) {
  if (flags & FRAME_TYPE_RANGE) {
    gen_printf("RANGE");
  }
  if (flags & FRAME_TYPE_ROWS) {
    gen_printf("ROWS");
  }
  if (flags & FRAME_TYPE_GROUPS) {
    gen_printf("GROUPS");
  }
  if (flags & FRAME_BOUNDARY_UNBOUNDED || flags & FRAME_BOUNDARY_START_UNBOUNDED) {
    gen_printf("UNBOUNDED PRECEDING");
  }
  if (flags & FRAME_BOUNDARY_PRECEDING ||
      flags & FRAME_BOUNDARY_START_PRECEDING ||
      flags & FRAME_BOUNDARY_END_PRECEDING) {
    gen_printf("PRECEDING");
  }
  if (flags & FRAME_BOUNDARY_CURRENT_ROW ||
      flags & FRAME_BOUNDARY_START_CURRENT_ROW ||
      flags & FRAME_BOUNDARY_END_CURRENT_ROW) {
    gen_printf("CURRENT ROW");
  }
  if (flags & FRAME_BOUNDARY_START_FOLLOWING ||
      flags & FRAME_BOUNDARY_END_FOLLOWING) {
    gen_printf("FOLLOWING");
  }
  if (flags & FRAME_BOUNDARY_END_UNBOUNDED) {
    gen_printf("UNBOUNDED FOLLOWING");
  }
  if (flags & FRAME_EXCLUDE_NO_OTHERS) {
    gen_printf("EXCLUDE NO OTHERS");
  }
  if (flags & FRAME_EXCLUDE_CURRENT_ROW) {
    gen_printf("EXCLUDE CURRENT ROW");
  }
  if (flags & FRAME_EXCLUDE_GROUP) {
    gen_printf("EXCLUDE GROUP");
  }
  if (flags & FRAME_EXCLUDE_TIES) {
    gen_printf("EXCLUDE TIES");
  }
}

static void gen_frame_type(int32_t flags) {
  Invariant(flags == (flags & FRAME_TYPE_FLAGS));
  gen_frame_spec_flags(flags);
  gen_printf(" ");
}

static void gen_frame_exclude(int32_t flags) {
  Invariant(flags == (flags & FRAME_EXCLUDE_FLAGS));
  if (flags != FRAME_EXCLUDE_NONE) {
    gen_printf(" ");
  }
  gen_frame_spec_flags(flags);
}

static void gen_frame_boundary(ast_node *ast, int32_t flags) {
  EXTRACT_ANY(expr, ast->left);
  Invariant(flags == (flags & FRAME_BOUNDARY_FLAGS));

  if (expr) {
    gen_root_expr(expr);
    gen_printf(" ");
  }
  gen_frame_spec_flags(flags);
}

static void gen_frame_boundary_start(ast_node *ast, int32_t flags) {
  Contract(is_ast_expr_list(ast));
  EXTRACT_ANY(expr, ast->left);
  Invariant(flags == (flags & FRAME_BOUNDARY_START_FLAGS));

  gen_printf("BETWEEN ");
  if (expr) {
    gen_root_expr(expr);
    gen_printf(" ");
  }
  gen_frame_spec_flags(flags);
}

static void gen_frame_boundary_end(ast_node *ast, int32_t flags) {
  Contract(is_ast_expr_list(ast));
  EXTRACT_ANY(expr, ast->right);
  Invariant(flags == (flags & FRAME_BOUNDARY_END_FLAGS));

  gen_printf(" AND ");
  if (expr) {
    gen_root_expr(expr);
    gen_printf(" ");
  }
  gen_frame_spec_flags(flags);
}

static void gen_opt_frame_spec(ast_node *ast) {
  Contract(is_ast_opt_frame_spec(ast));
  EXTRACT_OPTION(flags, ast->left);
  EXTRACT_NOTNULL(expr_list, ast->right);

  int32_t frame_type_flags = flags & FRAME_TYPE_FLAGS;
  int32_t frame_boundary_flags = flags & FRAME_BOUNDARY_FLAGS;
  int32_t frame_boundary_start_flags = flags & FRAME_BOUNDARY_START_FLAGS;
  int32_t frame_boundary_end_flags = flags & FRAME_BOUNDARY_END_FLAGS;
  int32_t frame_exclude_flags = flags & FRAME_EXCLUDE_FLAGS;

  if (frame_type_flags) {
    gen_frame_type(frame_type_flags);
  }
  if (frame_boundary_flags) {
    gen_frame_boundary(expr_list, frame_boundary_flags);
  }
  if (frame_boundary_start_flags) {
    gen_frame_boundary_start(expr_list, frame_boundary_start_flags);
  }
  if (frame_boundary_end_flags) {
    gen_frame_boundary_end(expr_list, frame_boundary_end_flags);
  }
  if (frame_exclude_flags) {
    gen_frame_exclude(frame_exclude_flags);
  }
}

static void gen_window_defn(ast_node *ast) {
  Contract(is_ast_window_defn(ast));
  EXTRACT(opt_partition_by, ast->left);
  EXTRACT_NOTNULL(window_defn_orderby, ast->right);
  EXTRACT(opt_orderby, window_defn_orderby->left);
  EXTRACT(opt_frame_spec, window_defn_orderby->right);

  // the first optional element never needs a space
  bool need_space = 0;

  gen_printf(" (");
  if (opt_partition_by) {
    Invariant(!need_space);
    gen_opt_partition_by(opt_partition_by);
    need_space = 1;
  }

  if (opt_orderby) {
    if (need_space) gen_printf(" ");
    gen_opt_orderby(opt_orderby);
    need_space = 1;
  }

  if (opt_frame_spec) {
    if (need_space) gen_printf(" ");
    gen_opt_frame_spec(opt_frame_spec);
  }
  gen_printf(")");
}

static void gen_name_or_window_defn(ast_node *ast) {
  if (is_ast_str(ast)) {
    EXTRACT_STRING(window_name, ast);
    gen_printf(" %s", window_name);
  }
  else {
    Contract(is_ast_window_defn(ast));
    gen_window_defn(ast);
  }
}

static void gen_expr_window_func_inv(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_window_func_inv(ast));
  EXTRACT_NOTNULL(call, ast->left);
  EXTRACT_ANY_NOTNULL(name_or_window_defn, ast->right);

  gen_printf("\n  ");
  gen_expr_call(call, op, pri, pri_new);
  gen_printf(" OVER");
  gen_name_or_window_defn(name_or_window_defn);
}

static void gen_expr_raise(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_raise(ast));
  EXTRACT_OPTION(flags, ast->left);
  EXTRACT_ANY(expr, ast->right);

  Contract(flags >= RAISE_IGNORE && flags <= RAISE_FAIL);

  gen_printf("RAISE(");
  switch (flags) {
    case RAISE_IGNORE: gen_printf("IGNORE"); break;
    case RAISE_ROLLBACK: gen_printf("ROLLBACK"); break;
    case RAISE_ABORT: gen_printf("ABORT"); break;
    case RAISE_FAIL: gen_printf("FAIL"); break;
  }
  if (expr) {
    gen_printf(", ");
    gen_root_expr(expr);
  }
  gen_printf(")");
}

static void gen_expr_between(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_between(ast));
  EXTRACT_NOTNULL(range, ast->right);

  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" BETWEEN ");
  gen_expr(range->left, pri_new);
  gen_printf(" AND ");
  gen_expr(range->right, pri_new + 1); // the usual rules for the right operand (see gen_binary)
  if (pri_new < pri) gen_printf(")");
}

static void gen_expr_not_between(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_not_between(ast));
  EXTRACT_NOTNULL(range, ast->right);

  if (pri_new < pri) gen_printf("(");
  gen_expr(ast->left, pri_new);
  gen_printf(" NOT BETWEEN ");
  gen_expr(range->left, pri_new);
  gen_printf(" AND ");
  gen_expr(range->right, pri_new + 1); // the usual rules for the right operand (see gen_binary)
  if (pri_new < pri) gen_printf(")");
}

static void gen_expr_between_rewrite(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_between_rewrite(ast));
  EXTRACT_NOTNULL(range, ast->right);

  // even though we did a rewrwite on the AST to make codegen easier we want to
  // echo this back the way it was originally written.  This is important to allow
  // the echoed codegen to reparse in tests -- this isn't a case of sugar, we've
  // added a codegen temporary into the AST and it really doesn't belong in the output

  if (pri_new < pri) gen_printf("(");

  gen_expr(ast->left, pri_new);
  if (is_ast_or(range->right)) {
    gen_printf(" NOT BETWEEN ");
  }
  else {
    gen_printf(" BETWEEN ");
  }
  gen_expr(range->right->left->right, pri_new);
  gen_printf(" AND ");
  gen_expr(range->right->right->right, pri_new);

  if (pri_new < pri) gen_printf(")");
}

static void gen_expr_case(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_case_expr(ast));
  EXTRACT_ANY(expr, ast->left);
  EXTRACT_NOTNULL(connector, ast->right);
  EXTRACT_NOTNULL(case_list, connector->left);
  EXTRACT_ANY(else_expr, connector->right);

  // case is like parens already, you never need more parens
  gen_printf("CASE");
  if (expr) {
    gen_printf(" ");
    // case can have expression or just when clauses
    gen_root_expr(expr);
  }
  gen_printf("\n");
  GEN_BEGIN_INDENT(case_list, 2);
  gen_case_list(case_list);
  if (else_expr) {
    gen_printf("ELSE ");
    gen_root_expr(else_expr);
    gen_printf("\n");
  }
  GEN_END_INDENT(case_list);
  gen_printf("END");
}

static void gen_expr_select(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_select_variant(ast));
  gen_printf("( ");
  gen_select_stmt(ast);
  gen_printf(" )");
}

static void gen_expr_select_if_nothing_throw(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_throw_expr(ast) || is_ast_select_if_nothing_or_null_throw_expr(ast));
  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);
  gen_printf("( ");
  gen_select_stmt(select_stmt);
  gen_printf(" %s )", op);
}

static void gen_expr_select_if_nothing(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_select_if_nothing_expr(ast) || is_ast_select_if_nothing_or_null_expr(ast));
  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);
  EXTRACT_ANY_NOTNULL(else_expr, ast->right);

  gen_printf("( ");
  gen_select_stmt(select_stmt);
  gen_printf(" %s ", op);
  gen_root_expr(else_expr);
  gen_printf(" )");
}

static void gen_expr_type_check(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_type_check_expr(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_ANY_NOTNULL(type, ast->right);

  // In SQLite context we only emit the actual expression since type checking already happened during
  // semantic analysis step. Here we're emitting the final sql statement that goes to sqlite
  if (for_sqlite()) {
    gen_expr(expr, EXPR_PRI_ROOT);
  }
  else {
    // note that this will be rewritten to nothing during semantic analysis, it only exists
    // to force an manual compile time type check (useful in macros and such)
    gen_printf("TYPE_CHECK(");
    gen_expr(expr, EXPR_PRI_ROOT);
    gen_printf(" AS ");
    gen_data_type(type);
    gen_printf(")");
  }
}

static void gen_expr_cast(ast_node *ast, CSTR op, int32_t pri, int32_t pri_new) {
  Contract(is_ast_cast_expr(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_ANY_NOTNULL(data_type, ast->right);

  if (gen_callbacks && gen_callbacks->minify_casts) {
    if (is_ast_null(expr)) {
      // when generating the actual SQL for Sqlite, we don't need to include cast expressions on NULL
      // we only need those for type checking.
      gen_printf("NULL");
      return;
    }

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)
  // with no SEM we can't do optimization, nor is there any need
#else
    if (expr->sem && ast->sem) {
      // If the expression is already of the correct type (less nullability), we don't need the cast at all.
      sem_t core_type_expr = core_type_of(expr->sem->sem_type);
      sem_t core_type_ast = core_type_of(ast->sem->sem_type);
      if (core_type_expr == core_type_ast) {
        gen_printf("(");
        gen_expr(expr, EXPR_PRI_ROOT);
        gen_printf(")");
        return;
      }
    }
#endif
  }

  gen_printf("CAST(");
  gen_expr(expr, EXPR_PRI_ROOT);
  gen_printf(" AS ");
  gen_data_type(data_type);
  gen_printf(")");
}

static void gen_expr(ast_node *ast, int32_t pri) {
  if (is_any_macro_ref(ast)) {
    gen_any_macro_ref(ast);
    return;
  }

  // These are all the expressions there are, we have to find it in this table
  // or else someone added a new expression type and it isn't supported yet.
  symtab_entry *entry = symtab_find(gen_exprs, ast->type);
  Invariant(entry);
  gen_expr_dispatch *disp = (gen_expr_dispatch*)entry->val;
  disp->func(ast, disp->str, pri, disp->pri_new);
}

cql_noexport void gen_root_expr(ast_node *ast) {
  gen_expr(ast, EXPR_PRI_ROOT);
}

static void gen_as_alias(ast_node *ast) {
  EXTRACT_NAME_AST(name_ast, ast->left);

  gen_printf(" AS ");
  gen_name(name_ast);
}

static void gen_as_alias_with_override(ast_node *ast) {
  Contract(keep_table_name_in_aliases);

  CSTR name = get_inserted_table_alias_string_override(ast);
  Invariant(name);

  gen_printf(" AS %s", name);
}

static void gen_select_expr(ast_node *ast) {
  Contract(is_ast_select_expr(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(opt_as_alias, ast->right);

  gen_root_expr(expr);

  if (opt_as_alias && is_id(opt_as_alias->left)) {
    EXTRACT_STRING(name, opt_as_alias->left);

    if (used_alias_syms && !symtab_find(used_alias_syms, name)) {
      return;
    }

    gen_as_alias(opt_as_alias);
  }
}

static void gen_col_calc(ast_node *ast) {
  Contract(is_ast_col_calc(ast));
  if (ast->left) {
    ast_node *val = ast->left;

    if (is_ast_dot(val)) {
      gen_name(val->left);
      gen_printf(".");
      gen_name(val->right);
    }
    else {
      gen_name(val);
    }

    if (ast->right) {
      gen_printf(" ");
    }
  }

  if (ast->right) {
    gen_shape_def(ast->right);
  }
}

static void gen_col_calcs(ast_node *ast) {
  Contract(is_ast_col_calcs(ast));
  ast_node *item = ast;
  while (item) {
    gen_col_calc(item->left);
    if (item->right) {
      gen_printf(", ");
    }
    item = item->right;
  }
}

static void gen_column_calculation(ast_node *ast) {
  Contract(is_ast_column_calculation(ast));
  gen_printf("@COLUMNS(");
  if (ast->right) {
    gen_printf("DISTINCT ");
  }
  gen_col_calcs(ast->left);
  gen_printf(")");
}

static void gen_select_expr_list(ast_node *ast) {
  symtab *temp = used_alias_syms;
  used_alias_syms = NULL;

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)
  // if there is no SEM then we can't do this minificiation
#else
  if (ast->sem && gen_callbacks && gen_callbacks->minify_aliases) {
    used_alias_syms = ast->sem->used_symbols;
  }
#endif
  int32_t count = 0;
  for (ast_node *item = ast; item && count < 4; item = item->right) {
     count++;
  }
  int32_t indent = count == 4 ? 4 : 0;

  if (indent) {
    gen_printf("\n");
  }

  int32_t pending_indent_saved = pending_indent;
  GEN_BEGIN_INDENT(sel_list, indent);

  if (!indent) { pending_indent = pending_indent_saved; }

  for (ast_node *item = ast; item; item = item->right) {
    ast_node *expr = item->left;

    if (is_any_macro_ref(expr)) {
      gen_any_macro_ref(expr);
    }
    else if (is_ast_star(expr)) {
      gen_printf("*");
    }
    else if (is_ast_table_star(expr)) {
      EXTRACT_NOTNULL(table_star, expr);
      gen_name(table_star->left);
      gen_printf(".*");
    }
    else if (is_ast_column_calculation(expr)) {
      gen_column_calculation(expr);
    }
    else {
      EXTRACT_NOTNULL(select_expr, expr);
      gen_select_expr(select_expr);
    }
    if (item->right) {
      if (indent) {
         gen_printf(",\n");
      }
      else {
         gen_printf(", ");
      }
    }
  }
  GEN_END_INDENT(sel_list);
  used_alias_syms = temp;
}

static void gen_table_or_subquery(ast_node *ast) {
  Contract(is_ast_table_or_subquery(ast));

  EXTRACT_ANY_NOTNULL(factor, ast->left);

  if (is_any_macro_ref(factor)) {
    gen_any_macro_ref(factor);
  }
  else if (is_ast_str(factor) || is_ast_at_id(factor)) {
    bool_t has_table_rename_callback = gen_callbacks && gen_callbacks->table_rename_callback;
    bool_t handled = false;

    if (has_table_rename_callback) {
      handled = gen_callbacks->table_rename_callback(factor, gen_callbacks->table_rename_context, gen_output);
    }

    if (!handled) {
      gen_name(factor);
    }
  }
  else if (is_ast_select_stmt(factor) || is_ast_with_select_stmt(factor)) {
    gen_printf("(");
    GEN_BEGIN_INDENT(sel, 2);
    pending_indent = 0;
    gen_select_stmt(factor);
    GEN_END_INDENT(sel);
    gen_printf(")");
  }
  else if (is_ast_shared_cte(factor)) {
    gen_printf("(");
    gen_shared_cte(factor);
    gen_printf(")");
  }
  else if (is_ast_table_function(factor)) {
    bool_t has_table_function_callback = gen_callbacks && gen_callbacks->table_function_callback;
    bool_t handled_table_function = false;
    if (has_table_function_callback) {
      handled_table_function = gen_callbacks->table_function_callback(factor, gen_callbacks->table_function_context, gen_output);
    }

    if (!handled_table_function) {
      EXTRACT_STRING(name, factor->left);
      EXTRACT(arg_list, factor->right);
      gen_printf("%s(", name);
      gen_arg_list(arg_list);
      gen_printf(")");
    }
  }
  else {
    // this is all that's left
    gen_printf("(\n");
    GEN_BEGIN_INDENT(qp, 2);
    gen_query_parts(factor);
    GEN_END_INDENT(qp);
    gen_printf(")");
  }

  EXTRACT(opt_as_alias, ast->right);
  if (opt_as_alias) {
    if (get_inserted_table_alias_string_override(opt_as_alias)) {
      gen_as_alias_with_override(opt_as_alias);
    }
    else {
      gen_as_alias(opt_as_alias);
    }
  }
}

static void gen_join_cond(ast_node *ast) {
  Contract(is_ast_join_cond(ast));
  EXTRACT_ANY_NOTNULL(cond_type, ast->left);

  if (is_ast_on(cond_type)) {
    gen_printf(" ON ");
    gen_root_expr(ast->right);
  }
  else {
    // only other ast type that is allowed
    Contract(is_ast_using(cond_type));
    gen_printf(" USING (");
    gen_name_list(ast->right);
    gen_printf(")");
  }
}

static void gen_join_target(ast_node *ast) {
  Contract(is_ast_join_target(ast));
  EXTRACT_OPTION(join_type, ast->left);

  switch (join_type) {
    case JOIN_INNER: gen_printf("\nINNER JOIN "); break;
    case JOIN_CROSS: gen_printf("\nCROSS JOIN "); break;
    case JOIN_LEFT_OUTER: gen_printf("\nLEFT OUTER JOIN "); break;
    case JOIN_RIGHT_OUTER: gen_printf("\nRIGHT OUTER JOIN "); break;
    case JOIN_LEFT: gen_printf("\nLEFT JOIN "); break;
    case JOIN_RIGHT: gen_printf("\nRIGHT JOIN "); break;
  }

  EXTRACT_NOTNULL(table_join, ast->right);
  EXTRACT_NOTNULL(table_or_subquery, table_join->left);
  gen_table_or_subquery(table_or_subquery);

  EXTRACT(join_cond, table_join->right);
  if (join_cond) {
    gen_join_cond(join_cond);
  }
}

static void gen_join_target_list(ast_node *ast) {
  Contract(is_ast_join_target_list(ast));

  for (ast_node *item = ast; item; item = item->right) {
    EXTRACT(join_target, item->left);
    gen_join_target(join_target);
  }
}

static void gen_join_clause(ast_node *ast) {
  Contract(is_ast_join_clause(ast));
  EXTRACT_NOTNULL(table_or_subquery, ast->left);
  EXTRACT_NOTNULL(join_target_list, ast->right);

  gen_table_or_subquery(table_or_subquery);
  gen_join_target_list(join_target_list);
}

static void gen_table_or_subquery_list(ast_node *ast) {
  Contract(is_ast_table_or_subquery_list(ast));

  for (ast_node *item = ast; item; item = item->right) {
    gen_table_or_subquery(item->left);
    if (item->right) {
      gen_printf(",\n");
    }
  }
}

static void gen_macro_arg_ref(ast_node *ast) {
  EXTRACT_STRING(name, ast->left);
  gen_printf("%s!", name);
}

static void gen_macro_ref(ast_node *ast) {
  EXTRACT_STRING(name, ast->left);
  gen_printf("%s!", name);
  gen_printf("(");
  if (ast->right) {
    gen_macro_args(ast->right);
  }
  gen_printf(")");
}

static void gen_any_macro_ref(ast_node *ast) {
  symtab_entry *entry = symtab_find(gen_macros, ast->type);
  Contract(entry);
  ((void (*)(ast_node*))entry->val)(ast);
}

static void gen_query_parts(ast_node *ast) {
  if (is_ast_table_or_subquery_list(ast)) {
    gen_table_or_subquery_list(ast);
  }
  else {
    Contract(is_ast_join_clause(ast)); // this is the only other choice
    gen_join_clause(ast);
  }
}

static void gen_asc_desc(ast_node *ast) {
  if (is_ast_asc(ast)) {
    gen_printf(" ASC");
    if (ast->left && is_ast_nullslast(ast->left)) {
      gen_printf(" NULLS LAST");
    }
  }
  else if (is_ast_desc(ast)) {
    gen_printf(" DESC");
    if (ast->left && is_ast_nullsfirst(ast->left)) {
      gen_printf(" NULLS FIRST");
    }
  }
  else {
    Contract(!ast);
  }
}

static void gen_groupby_list(ast_node *ast) {
  Contract(is_ast_groupby_list(ast));

  for (ast_node *item = ast; item; item = item->right) {
    Contract(is_ast_groupby_list(item));
    EXTRACT_NOTNULL(groupby_item, item->left);
    EXTRACT_ANY_NOTNULL(expr, groupby_item->left);

    gen_root_expr(expr);

    if (item->right) {
      gen_printf(", ");
    }
  }
}

static void gen_orderby_list(ast_node *ast) {
  Contract(is_ast_orderby_list(ast));

  for (ast_node *item = ast; item; item = item->right) {
    Contract(is_ast_orderby_list(item));
    EXTRACT_NOTNULL(orderby_item, item->left);
    EXTRACT_ANY_NOTNULL(expr, orderby_item->left);
    EXTRACT_ANY(opt_asc_desc, orderby_item->right);

    gen_root_expr(expr);
    gen_asc_desc(opt_asc_desc);

    if (item->right) {
      gen_printf(", ");
    }
  }
}

static void gen_opt_where(ast_node *ast) {
  Contract(is_ast_opt_where(ast));

  gen_printf("WHERE ");
  gen_root_expr(ast->left);
}

static void gen_opt_groupby(ast_node *ast) {
  Contract(is_ast_opt_groupby(ast));
  EXTRACT_NOTNULL(groupby_list, ast->left);

  gen_printf("\n  GROUP BY ");
  gen_groupby_list(groupby_list);
}

static void gen_opt_orderby(ast_node *ast) {
  Contract(is_ast_opt_orderby(ast));
  EXTRACT_NOTNULL(orderby_list, ast->left);

  gen_printf("ORDER BY ");
  gen_orderby_list(orderby_list);
}

static void gen_opt_limit(ast_node *ast) {
  Contract(is_ast_opt_limit(ast));

  gen_printf("\n  LIMIT ");
  gen_root_expr(ast->left);
}

static void gen_opt_offset(ast_node *ast) {
  Contract(is_ast_opt_offset(ast));

  gen_printf("\n  OFFSET ");
  gen_root_expr(ast->left);
}

static void gen_window_name_defn(ast_node *ast) {
  Contract(is_ast_window_name_defn(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(window_defn, ast->right);

  gen_printf("\n    %s AS", name);
  gen_window_defn(window_defn);
}

static void gen_window_name_defn_list(ast_node *ast) {
  Contract(is_ast_window_name_defn_list(ast));
  for (ast_node *item = ast; item; item = item->right) {
    EXTRACT_NOTNULL(window_name_defn, item->left);
    gen_window_name_defn(window_name_defn);
    if (item->right) {
      gen_printf(", ");
    }
  }
}

static void gen_window_clause(ast_node *ast) {
  Contract(is_ast_window_clause(ast));
  EXTRACT_NOTNULL(window_name_defn_list, ast->left);

  gen_window_name_defn_list(window_name_defn_list);
}

static void gen_opt_select_window(ast_node *ast) {
  Contract(is_ast_opt_select_window(ast));
  EXTRACT_NOTNULL(window_clause, ast->left);

  gen_printf("\n  WINDOW ");
  gen_window_clause(window_clause);
}

static void gen_select_from_etc(ast_node *ast) {
  Contract(is_ast_select_from_etc(ast));

  EXTRACT_ANY(query_parts, ast->left);
  EXTRACT_NOTNULL(select_where, ast->right);
  EXTRACT(opt_where, select_where->left);
  EXTRACT_NOTNULL(select_groupby, select_where->right);
  EXTRACT(opt_groupby, select_groupby->left);
  EXTRACT_NOTNULL(select_having, select_groupby->right);
  EXTRACT(opt_having, select_having->left);
  EXTRACT(opt_select_window, select_having->right);

  if (query_parts) {
    gen_printf("\n  FROM ");
    GEN_BEGIN_INDENT(from, 4);
      pending_indent = 0;
      gen_query_parts(query_parts);
    GEN_END_INDENT(from);
  }
  if (opt_where) {
    gen_printf("\n  ");
    gen_opt_where(opt_where);
  }
  if (opt_groupby) {
    gen_opt_groupby(opt_groupby);
  }
  if (opt_having) {
    gen_printf("\n  HAVING ");
    gen_root_expr(opt_having->left);
  }
  if (opt_select_window) {
    gen_opt_select_window(opt_select_window);
  }
}

static void gen_select_orderby(ast_node *ast) {
  Contract(is_ast_select_orderby(ast));
  EXTRACT(opt_orderby, ast->left);
  EXTRACT_NOTNULL(select_limit, ast->right);
  EXTRACT(opt_limit, select_limit->left);
  EXTRACT_NOTNULL(select_offset, select_limit->right);
  EXTRACT(opt_offset, select_offset->left);

  if (opt_orderby) {
    gen_printf("\n  ");
    gen_opt_orderby(opt_orderby);
  }
  if (opt_limit) {
    gen_opt_limit(opt_limit);
  }
  if (opt_offset) {
    gen_opt_offset(opt_offset);
  }
}

static void gen_select_expr_list_con(ast_node *ast) {
  Contract(is_ast_select_expr_list_con(ast));
  EXTRACT(select_expr_list, ast->left);
  EXTRACT(select_from_etc, ast->right);

  gen_select_expr_list(select_expr_list);
  if (select_from_etc) {
    gen_select_from_etc(select_from_etc);
  }
}

cql_noexport void init_gen_sql_callbacks(gen_sql_callbacks *cb)
{
  memset((void *)cb, 0, sizeof(*gen_callbacks));
  // with callbacks is for SQLite be default, the normal raw output
  // case is done with callbacks == NULL
  cb->mode = gen_mode_sql;
}

static void gen_select_statement_type(ast_node *ast) {
  Contract(is_ast_select_core(ast));
  EXTRACT_ANY(select_opts, ast->left);

  if (select_opts && is_ast_select_values(select_opts)) {
    gen_printf("VALUES");
  }
  else {
    gen_printf("SELECT");
    if (select_opts) {
      Contract(is_ast_select_opts(select_opts));
      gen_select_opts(select_opts);
    }
  }
}

static void gen_values(ast_node *ast) {
  Contract(is_ast_values(ast));
  bool_t many_items = ast && ast->right;
  for (ast_node *item = ast; item; item = item->right) {
    EXTRACT(insert_list, item->left);
    if (many_items) {
      gen_printf("\n  ");
    }
    else {
      gen_printf(" ");
    }
    gen_printf("(");
    if (insert_list) {
      gen_insert_list(insert_list);
    }
    gen_printf(")");
    if (item->right) {
      gen_printf(",");
    }
  }
}

cql_noexport void gen_select_core(ast_node *ast) {

  if (is_any_macro_ref(ast)) {
    gen_printf("ROWS(");
    gen_any_macro_ref(ast);
    gen_printf(")");
  }
  else {
    Contract(is_ast_select_core(ast));
    EXTRACT_ANY(select_core_left, ast->left);

    gen_select_statement_type(ast);

    if (is_ast_select_values(select_core_left)) {
      // VALUES [values]
      EXTRACT(values, ast->right);
      gen_values(values);
    }
    else {
      // SELECT [select_expr_list_con]
      // We're making sure that we're in the SELECT clause of the select stmt
      Contract(select_core_left == NULL || is_ast_select_opts(select_core_left));
      pending_indent = 1; // this gives us a single space before the select list if needed
      EXTRACT_NOTNULL(select_expr_list_con, ast->right);
      gen_select_expr_list_con(select_expr_list_con);
    }
  }
}

static void gen_select_no_with(ast_node *ast) {
  Contract(is_ast_select_stmt(ast));
  EXTRACT_NOTNULL(select_core_list, ast->left);
  EXTRACT_NOTNULL(select_orderby, ast->right);

  gen_select_core_list(select_core_list);
  gen_select_orderby(select_orderby);
}

static void gen_cte_decl(ast_node *ast)  {
  Contract(is_ast_cte_decl(ast));
  EXTRACT_ANY_NOTNULL(name_ast, ast->left);
  gen_name(name_ast);
  if (!is_ast_star(ast->right)) {
    // skip this for foo(*), the shorter syntax is just the name
    gen_printf(" (");
    gen_name_list(ast->right);
    gen_printf(")");
  }
}

static void gen_cte_binding_list(ast_node *ast) {
  Contract(is_ast_cte_binding_list(ast));

  while (ast) {
     EXTRACT_NOTNULL(cte_binding, ast->left);
     EXTRACT_STRING(actual, cte_binding->left);
     EXTRACT_STRING(formal, cte_binding->right);
     gen_printf("%s AS %s", actual, formal);

     if (ast->right) {
       gen_printf(", ");
     }
     ast = ast->right;
  }
}

static void gen_shared_cte(ast_node *ast) {
  Contract(is_ast_shared_cte(ast));
  bool_t has_cte_procs_callback = gen_callbacks && gen_callbacks->cte_proc_callback;
  bool_t handled = false;

  if (has_cte_procs_callback) {
    handled = gen_callbacks->cte_proc_callback(ast, gen_callbacks->cte_proc_context, gen_output);
  }

  if (!handled) {
    EXTRACT_NOTNULL(call_stmt, ast->left);
    EXTRACT(cte_binding_list, ast->right);
    gen_call_stmt(call_stmt);
    if (cte_binding_list) {
      gen_printf(" USING ");
      gen_cte_binding_list(cte_binding_list);
    }
  }
}

static void gen_cte_table(ast_node *ast)  {
  Contract(is_ast_cte_table(ast));
  EXTRACT(cte_decl, ast->left);
  EXTRACT_ANY_NOTNULL(cte_body, ast->right);

  bool_t suppress_decl = false;
  if (is_ast_shared_cte(cte_body) && is_ast_star(cte_decl->right)) {
    // special case for foo(*) as (call foo(...))
    // we want to emit the abbreviated form in that case

    EXTRACT_STRING(cte_name, cte_decl->left);
    EXTRACT_NOTNULL(call_stmt, cte_body->left);
    EXTRACT_STRING(call_name, call_stmt->left);

    // skip the redunant cte decl if the names are the same
    // this is much cleaner looking and avoids the "is it the same?" question
    // when reading the source
    suppress_decl = !StrCaseCmp(cte_name, call_name);
  }

  if (!suppress_decl) {
    gen_cte_decl(cte_decl);
  }

  if (is_ast_like(cte_body)) {
    gen_printf(" LIKE ");
    if (is_ast_str(cte_body->left)) {
      gen_name(cte_body->left);
    }
    else {
      gen_printf("(\n");
      GEN_BEGIN_INDENT(cte_indent, 2);
        gen_select_stmt(cte_body->left);
      GEN_END_INDENT(cte_indent);
      gen_printf("\n)");
    }
    return;
  }

  if (!suppress_decl) {
    gen_printf(" AS ");
  }

  gen_printf("(");

  if (is_ast_shared_cte(cte_body)) {
    gen_shared_cte(cte_body);
    gen_printf(")");
  }
  else {
    gen_printf("\n");
    GEN_BEGIN_INDENT(cte_indent, 2);
      // the only other alternative is the select statement form
      gen_select_stmt(cte_body);
    GEN_END_INDENT(cte_indent);
    gen_printf("\n)");
  }
}

static void gen_cte_tables(ast_node *ast, CSTR prefix) {
  bool_t first = true;

  while (ast) {
    Contract(is_ast_cte_tables(ast));
    EXTRACT_ANY_NOTNULL(cte_table, ast->left);

    bool_t handled = false;

    if (is_ast_cte_table(cte_table)) {
      Contract(is_ast_cte_table(cte_table));

      // callbacks can suppress some CTE for use in shared_fragments
      bool_t has_cte_suppress_callback = gen_callbacks && gen_callbacks->cte_suppress_callback;

      if (has_cte_suppress_callback) {
        handled = gen_callbacks->cte_suppress_callback(cte_table, gen_callbacks->cte_suppress_context, gen_output);
      }
    }

    if (!handled) {
      if (first) {
        gen_printf("%s", prefix);
        first = false;
      }
      else {
        gen_printf(",\n");
      }

      if (is_ast_cte_tables_macro_ref(cte_table)) {
        gen_any_macro_ref(cte_table);
      }
      else if (is_ast_cte_tables_macro_arg_ref(cte_table)) {
        gen_any_macro_ref(cte_table);
      }
      else {
        gen_cte_table(cte_table);
      }
    }

    ast = ast->right;
  }

  if (!first) {
    gen_printf("\n");
  }
}

static void gen_with_prefix(ast_node *ast) {
  EXTRACT(cte_tables, ast->left);
  CSTR prefix;

  // for us there is no difference between WITH and WITH RECURSIVE
  // except we have to remember which one it was so that we can
  // emit the same thing we saw.  Sqlite lets you do recursion
  // even if don't use WITH RECURSIVE
  if (is_ast_with(ast)) {
    prefix = "WITH\n";
  }
  else {
    Contract(is_ast_with_recursive(ast));
    prefix = "WITH RECURSIVE\n";
  }
  GEN_BEGIN_INDENT(cte_indent, 2);
    pending_indent -= 2;
    gen_cte_tables(cte_tables, prefix);
  GEN_END_INDENT(cte_indent);
}

static void gen_with_select_stmt(ast_node *ast) {
  Contract(is_ast_with_select_stmt(ast));
  EXTRACT_ANY_NOTNULL(with_prefix, ast->left)
  EXTRACT_ANY_NOTNULL(select_stmt, ast->right);

  gen_with_prefix(with_prefix);
  gen_select_stmt(select_stmt);
}

static void gen_select_core_list(ast_node *ast) {
  Contract(is_ast_select_core_list(ast));

  EXTRACT_ANY_NOTNULL(select_core, ast->left);

  gen_select_core(select_core);

  EXTRACT(select_core_compound, ast->right);
  if (!select_core_compound) {
    return;
  }
  EXTRACT_OPTION(compound_operator, select_core_compound->left);
  EXTRACT_NOTNULL(select_core_list, select_core_compound->right);

  gen_printf("\n%s\n", get_compound_operator_name(compound_operator));
  gen_select_core_list(select_core_list);
}


// This form is expanded late like select *
// since it only appears in shared fragments (actually only
// in conditional fragments) it will never be seen
// in the course of normal codegen, only in SQL expansion
// hence none of the code generators need to even know
// this is happening (again, just like select *).
// This approach gives us optimal sql for very little cost.
static void gen_select_nothing_stmt(ast_node *ast) {
  Contract(is_ast_select_nothing_stmt(ast));

  if (!for_sqlite() || !ast->sem || !ast->sem->sptr) {
    gen_printf("SELECT NOTHING");
    return;
  }

  // we just generate the right number of dummy columns for Sqlite
  // type doesn't matter because it's going to be "WHERE 0"

  gen_printf("SELECT ");
  sem_struct *sptr = ast->sem->sptr;
  for (uint32_t i = 0; i < sptr->count; i++) {
    if (i) {
      gen_printf(",");
    }

    if (gen_callbacks && gen_callbacks->minify_aliases) {
      gen_printf("0");
    }
    else {
      gen_printf("0 ");
      gen_sptr_name(sptr, i);
    }
  }
  gen_printf(" WHERE 0");
}

static void gen_select_stmt(ast_node *ast) {
  if (is_ast_with_select_stmt(ast)) {
    gen_with_select_stmt(ast);
  }
  else {
    Contract(is_ast_select_stmt(ast));
    gen_select_no_with(ast);
  }
}

static void gen_version_attrs(ast_node *_Nullable ast) {
  for (ast_node *attr = ast; attr; attr = attr->right) {
    if (is_ast_recreate_attr(attr)) {
      gen_recreate_attr(attr);
    }
    else if (is_ast_create_attr(attr)) {
      gen_create_attr(attr);
    }
    else {
      Contract(is_ast_delete_attr(attr)); // the only other kind
      gen_delete_attr(attr);
    }
  }
}

// If there is a handler, the handler will decide what to do.  If there is no handler
// or the handler returns false, then we honor the flag bit.  This lets you override
// the if_not_exists flag forcing it to be either ignored or enabled.  Both are potentially
// needed.  When emitting schema creation scripts for instance we always use IF NOT EXISTS
// even if the schema declaration didn't have it (which it usually doesn't).
static void gen_if_not_exists(ast_node *ast, bool_t if_not_exist) {
  bool_t if_not_exists_callback = gen_callbacks && gen_callbacks->if_not_exists_callback;
  bool_t handled = false;

  if (if_not_exists_callback) {
    handled = gen_callbacks->if_not_exists_callback(ast, gen_callbacks->if_not_exists_context, gen_output);
  }

  if (if_not_exist && !handled) {
    gen_printf("IF NOT EXISTS ");
  }
}

static void gen_eponymous(ast_node *ast, bool_t is_eponymous) {
  if (!for_sqlite() && is_eponymous) {
    gen_printf("@EPONYMOUS ");
  }
}

static void gen_create_view_stmt(ast_node *ast) {
  Contract(is_ast_create_view_stmt(ast));
  EXTRACT_OPTION(flags, ast->left);
  EXTRACT(view_and_attrs, ast->right);
  EXTRACT_NOTNULL(view_details_select, view_and_attrs->left);
  EXTRACT_NOTNULL(view_details, view_details_select->left);
  EXTRACT(name_list, view_details->right);
  EXTRACT_ANY(attrs, view_and_attrs->right);
  EXTRACT_ANY_NOTNULL(select_stmt, view_details_select->right);
  EXTRACT_NAME_AST(name_ast, view_details->left);

  bool_t if_not_exist = !!(flags & VIEW_IF_NOT_EXISTS);

  gen_printf("CREATE ");
  if (flags & VIEW_IS_TEMP) {
    gen_printf("TEMP ");
  }
  gen_printf("VIEW ");
  gen_if_not_exists(ast, if_not_exist);
  gen_name(name_ast);
  if (name_list) {
    gen_printf("(");
    gen_name_list(name_list);
    gen_printf(")");
  }
  gen_printf(" AS\n");
  GEN_BEGIN_INDENT(sel, 2);
  gen_select_stmt(select_stmt);
  gen_version_attrs(attrs);
  GEN_END_INDENT(sel);
}

static void gen_create_trigger_stmt(ast_node *ast) {
  Contract(is_ast_create_trigger_stmt(ast));

  EXTRACT_OPTION(flags, ast->left);
  EXTRACT_NOTNULL(trigger_body_vers, ast->right);
  EXTRACT_ANY(trigger_attrs, trigger_body_vers->right);
  EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
  EXTRACT_NAME_AST(trigger_name_ast, trigger_def->left);
  EXTRACT_NOTNULL(trigger_condition, trigger_def->right);
  EXTRACT_OPTION(cond_flags, trigger_condition->left);
  flags |= cond_flags;
  EXTRACT_NOTNULL(trigger_op_target, trigger_condition->right);
  EXTRACT_NOTNULL(trigger_operation, trigger_op_target->left);
  EXTRACT_OPTION(op_flags,  trigger_operation->left);
  EXTRACT(name_list, trigger_operation->right);
  flags |= op_flags;
  EXTRACT_NOTNULL(trigger_target_action, trigger_op_target->right);
  EXTRACT_NAME_AST(table_name_ast, trigger_target_action->left);
  EXTRACT_NOTNULL(trigger_action, trigger_target_action->right);
  EXTRACT_OPTION(action_flags, trigger_action->left);
  flags |= action_flags;
  EXTRACT_NOTNULL(trigger_when_stmts, trigger_action->right);
  EXTRACT_ANY(when_expr, trigger_when_stmts->left);
  EXTRACT_NOTNULL(stmt_list, trigger_when_stmts->right);

  gen_printf("CREATE ");
  if (flags & TRIGGER_IS_TEMP) {
    gen_printf("TEMP ");
  }
  gen_printf("TRIGGER ");
  gen_if_not_exists(ast, !!(flags & TRIGGER_IF_NOT_EXISTS));

  gen_name(trigger_name_ast);
  gen_printf("\n  ");

  if (flags & TRIGGER_BEFORE) {
    gen_printf("BEFORE ");
  }
  else if (flags & TRIGGER_AFTER) {
    gen_printf("AFTER ");
  }
  else if (flags & TRIGGER_INSTEAD_OF) {
    gen_printf("INSTEAD OF ");
  }

  if (flags & TRIGGER_DELETE) {
    gen_printf("DELETE ");
  }
  else if (flags & TRIGGER_INSERT) {
    gen_printf("INSERT ");
  }
  else {
    gen_printf("UPDATE ");
    if (name_list) {
      gen_printf("OF ");
      gen_name_list(name_list);
      gen_printf(" ");
    }
  }
  gen_printf("ON ");
  gen_name(table_name_ast);

  if (flags & TRIGGER_FOR_EACH_ROW) {
    gen_printf("\n  FOR EACH ROW");
  }

  if (when_expr) {
    gen_printf("\n  WHEN ");
    gen_root_expr(when_expr);
  }

  gen_printf("\nBEGIN\n");
  gen_stmt_list(stmt_list);
  gen_printf("END");
  gen_version_attrs(trigger_attrs);
}

static void gen_create_table_stmt(ast_node *ast) {
  Contract(is_ast_create_table_stmt(ast));
  EXTRACT_NOTNULL(create_table_name_flags, ast->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_ANY(table_attrs, table_flags_attrs->right);
  EXTRACT_NAME_AST(table_name_ast, create_table_name_flags->right);
  EXTRACT_NOTNULL(col_key_list, ast->right);

  bool_t temp = !!(flags & TABLE_IS_TEMP);
  bool_t if_not_exist = !!(flags & TABLE_IF_NOT_EXISTS);
  bool_t no_rowid = !!(flags & TABLE_IS_NO_ROWID);

  gen_printf("CREATE ");
  if (temp) {
    gen_printf("TEMP ");
  }

  gen_printf("TABLE ");
  gen_if_not_exists(ast, if_not_exist);

  gen_name(table_name_ast);
  gen_printf("(\n");
  gen_col_key_list(col_key_list);
  gen_printf("\n)");
  if (no_rowid) {
    gen_printf(" WITHOUT ROWID");
  }
  gen_version_attrs(table_attrs);
}

static void gen_create_virtual_table_stmt(ast_node *ast) {
  Contract(is_ast_create_virtual_table_stmt(ast));
  EXTRACT_NOTNULL(module_info, ast->left);
  EXTRACT_NOTNULL(create_table_stmt, ast->right);
  EXTRACT_NOTNULL(create_table_name_flags, create_table_stmt->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_ANY(table_attrs, table_flags_attrs->right);
  EXTRACT_STRING(name, create_table_name_flags->right);
  EXTRACT_NOTNULL(col_key_list, create_table_stmt->right);
  EXTRACT_STRING(module_name, module_info->left);
  EXTRACT_ANY(module_args, module_info->right);

  bool_t if_not_exist = !!(flags & TABLE_IF_NOT_EXISTS);
  bool_t is_eponymous = !!(flags & VTAB_IS_EPONYMOUS);

  gen_printf("CREATE VIRTUAL TABLE ");
  gen_if_not_exists(ast, if_not_exist);
  gen_eponymous(ast, is_eponymous);
  gen_printf("%s USING %s", name, module_name);

  if (!for_sqlite()) {
    if (is_ast_following(module_args)) {
      gen_printf(" (ARGUMENTS FOLLOWING) ");
    }
    else if (module_args) {
      gen_printf(" ");
      gen_misc_attr_value(module_args);
      gen_printf(" ");
    }
    else {
      gen_printf(" ");
    }

    // When emitting to SQLite we do not include the column declaration part
    // just whatever the args were because SQLite doesn't parse that part of the CQL syntax.
    // Note that CQL does not support general args because that's not parseable with this parser
    // tech but this is pretty general.  The declaration part is present here so that
    // CQL knows the type info of the net table we are creating.
    // Note also that virtual tables are always on the recreate plan, it isn't an option
    // and this will mean that you can't make a foreign key to a virtual table which is probably
    // a wise thing.

    gen_printf("AS (\n");
    gen_col_key_list(col_key_list);
    gen_printf("\n)");

    // delete attribute is the only option (recreate by default)
    if (!is_ast_recreate_attr(table_attrs)) {
      Invariant(is_ast_delete_attr(table_attrs));
      gen_delete_attr(table_attrs);
    }
  }
  else {
    if (is_ast_following(module_args)) {
      gen_printf(" (\n");
      gen_col_key_list(col_key_list);
      gen_printf(")");
    }
    else if (module_args) {
      gen_printf(" ");
      gen_misc_attr_value(module_args);
    }
  }
}

static void gen_drop_view_stmt(ast_node *ast) {
  Contract(is_ast_drop_view_stmt(ast));
  EXTRACT_ANY(if_exists, ast->left);
  EXTRACT_NAME_AST(name_ast, ast->right);

  gen_printf("DROP VIEW ");
  if (if_exists) {
    gen_printf("IF EXISTS ");
  }
  gen_name(name_ast);
}

static void gen_drop_table_stmt(ast_node *ast) {
  Contract(is_ast_drop_table_stmt(ast));
  EXTRACT_ANY(if_exists, ast->left);
  EXTRACT_NAME_AST(name_ast, ast->right);

  gen_printf("DROP TABLE ");
  if (if_exists) {
    gen_printf("IF EXISTS ");
  }
  gen_name(name_ast);
}

static void gen_drop_index_stmt(ast_node *ast) {
  Contract(is_ast_drop_index_stmt(ast));
  EXTRACT_ANY(if_exists, ast->left);
  EXTRACT_NAME_AST(name_ast, ast->right);

  gen_printf("DROP INDEX ");
  if (if_exists) {
    gen_printf("IF EXISTS ");
  }
  gen_name(name_ast);
}

static void gen_drop_trigger_stmt(ast_node *ast) {
  Contract(is_ast_drop_trigger_stmt(ast));
  EXTRACT_ANY(if_exists, ast->left);
  EXTRACT_NAME_AST(name_ast, ast->right);

  gen_printf("DROP TRIGGER ");
  if (if_exists) {
    gen_printf("IF EXISTS ");
  }
  gen_name(name_ast);
}

static void gen_alter_table_add_column_stmt(ast_node *ast) {
  Contract(is_ast_alter_table_add_column_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT(col_def, ast->right);

  gen_printf("ALTER TABLE ");
  gen_name(name_ast);
  gen_printf(" ADD COLUMN ");
  gen_col_def(col_def);
}

bool_t eval_if_stmt_callback(ast_node *ast) {
  Contract(is_ast_if_stmt(ast));

  bool_t suppress = 0;
  if (gen_callbacks && gen_callbacks->if_stmt_callback) {
    CHARBUF_OPEN(buf);
    suppress = gen_callbacks->if_stmt_callback(ast, gen_callbacks->if_stmt_context, &buf);
    gen_printf("%s", buf.ptr);
    CHARBUF_CLOSE(buf);
  }
  return suppress;
}

static void gen_cond_action(ast_node *ast) {
  Contract(is_ast_cond_action(ast));
  EXTRACT(stmt_list, ast->right);

  gen_root_expr(ast->left);
  gen_printf(" THEN\n");
  gen_stmt_list(stmt_list);
}

static void gen_elseif_list(ast_node *ast) {
  Contract(is_ast_elseif(ast));

  while (ast) {
    Contract(is_ast_elseif(ast));
    EXTRACT(cond_action, ast->left);
    gen_printf("ELSE IF ");
    gen_cond_action(cond_action);
    ast = ast->right;
  }
}

static void gen_ifxdef_stmt(ast_node *ast) {
  EXTRACT_ANY_NOTNULL(true_false, ast->left);
  EXTRACT_STRING(id, true_false->left);
  EXTRACT(pre, ast->right);
  EXTRACT_NAMED(left, stmt_list, pre->left);
  EXTRACT_NAMED(right, stmt_list, pre->right);
  gen_printf("%s\n", id);
  if (left) {
    gen_stmt_list(left);
  }
  if (right) {
    gen_printf("@ELSE\n");
    gen_stmt_list(right);
  }
  gen_printf("@ENDIF\n");
}

static void gen_ifdef_stmt(ast_node *ast) {
  gen_printf("@IFDEF ");
  gen_ifxdef_stmt(ast);
}

static void gen_ifndef_stmt(ast_node *ast) {
  gen_printf("@IFNDEF ");
  gen_ifxdef_stmt(ast);
}

static void gen_if_stmt(ast_node *ast) {
  Contract(is_ast_if_stmt(ast));
  EXTRACT_NOTNULL(cond_action, ast->left);
  EXTRACT_NOTNULL(if_alt, ast->right);
  EXTRACT(elseif, if_alt->left);
  EXTRACT_NAMED(elsenode, else, if_alt->right);

  if (eval_if_stmt_callback(ast)) {
    return;
  }

  gen_printf("IF ");
  gen_cond_action(cond_action);

  if (elseif) {
    gen_elseif_list(elseif);
  }

  if (elsenode) {
    gen_printf("ELSE\n");
    EXTRACT(stmt_list, elsenode->left);
    gen_stmt_list(stmt_list);
  }

  gen_printf("END");
}

static void gen_guard_stmt(ast_node *ast) {
  Contract(is_ast_guard_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_ANY_NOTNULL(stmt, ast->right);

  gen_printf("IF ");
  gen_expr(expr, EXPR_PRI_ROOT);
  gen_printf(" ");
  gen_one_stmt(stmt);
}

static void gen_expr_stmt(ast_node *ast) {
  Contract(is_ast_expr_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  gen_expr(expr, EXPR_PRI_ROOT);
}

static void gen_delete_stmt(ast_node *ast) {
  Contract(is_ast_delete_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT(opt_where, ast->right);

  gen_printf("DELETE FROM ");
  gen_name(name_ast);
  if (opt_where) {
    gen_printf(" WHERE ");
    gen_root_expr(opt_where->left);
  }
}

static void gen_with_delete_stmt(ast_node *ast) {
  Contract(is_ast_with_delete_stmt(ast));
  EXTRACT_ANY_NOTNULL(with_prefix, ast->left)
  EXTRACT_NOTNULL(delete_stmt, ast->right);

  gen_with_prefix(with_prefix);
  gen_delete_stmt(delete_stmt);
}

static void gen_delete_returning_stmt(ast_node *ast) {
  Contract(is_ast_delete_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(delete_stmt, ast->left);
  if (is_ast_with_delete_stmt(delete_stmt)) {
    gen_with_delete_stmt(delete_stmt);
  }
  else {
    gen_delete_stmt(delete_stmt);
  }
  gen_printf("\n  RETURNING ");
  gen_select_expr_list(ast->right);
}

static void gen_update_entry(ast_node *ast) {
  Contract(is_ast_update_entry(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->right)
  EXTRACT_NAME_AST(name_ast, ast->left);
  gen_name(name_ast);
  gen_printf(" = ");
  gen_root_expr(expr);
}

static void gen_update_list(ast_node *ast) {
  Contract(is_ast_update_list(ast));

  int32_t count = 0;
  for (ast_node *item = ast; item; item = item->right) {
    count++;
  }

  if (count <= 4) {
    gen_printf(" ");
    for (ast_node *item = ast; item; item = item->right) {
      Contract(is_ast_update_list(item));
      EXTRACT_NOTNULL(update_entry, item->left);

      gen_update_entry(update_entry);
      if (item->right) {
        gen_printf(", ");
      }
    }
  }
  else {
    GEN_BEGIN_INDENT(set_indent, 2);
    gen_printf("\n");
    for (ast_node *item = ast; item; item = item->right) {
      Contract(is_ast_update_list(item));
      EXTRACT_NOTNULL(update_entry, item->left);

      gen_update_entry(update_entry);
      if (item->right) {
        gen_printf(",\n");
      }
    }
    GEN_END_INDENT(set_indent);
  }
}

static void gen_from_shape(ast_node *ast) {
  Contract(is_ast_from_shape(ast));
  EXTRACT_STRING(shape_name, ast->right);
  EXTRACT_ANY(column_spec, ast->left);
  gen_printf("FROM %s", shape_name);
  gen_column_spec(column_spec);
}

static void gen_update_cursor_stmt(ast_node *ast) {
  Contract(is_ast_update_cursor_stmt(ast));
  EXTRACT_ANY(cursor, ast->left);
  EXTRACT_STRING(name, cursor);
  EXTRACT_ANY_NOTNULL(columns_values, ast->right);

  gen_printf("UPDATE CURSOR %s", name);

  if (is_ast_expr_names(columns_values)) {
    gen_printf(" USING ");
    gen_expr_names(columns_values);
  }
  else {
    EXTRACT_ANY(column_spec, columns_values->left);
    EXTRACT_ANY(insert_list, columns_values->right);

    gen_column_spec(column_spec);
    gen_printf(" ");
    if (is_ast_from_shape(insert_list)) {
      gen_from_shape(insert_list);
    }
    else {
      gen_printf("FROM VALUES (");
      gen_insert_list(insert_list);
      gen_printf(")");
    }
  }
}

static void gen_update_stmt(ast_node *ast) {
  Contract(is_ast_update_stmt(ast));
  EXTRACT_NOTNULL(update_set, ast->right);
  EXTRACT_ANY_NOTNULL(update_list, update_set->left);
  EXTRACT_NOTNULL(update_from, update_set->right);
  EXTRACT_NOTNULL(update_where, update_from->right);
  EXTRACT_ANY(query_parts, update_from->left);
  EXTRACT(opt_where, update_where->left);
  EXTRACT_NOTNULL(update_orderby, update_where->right);
  EXTRACT(opt_orderby, update_orderby->left);
  EXTRACT(opt_limit, update_orderby->right);

  gen_printf("UPDATE");
  if (ast->left) {
    EXTRACT_NAME_AST(name_ast, ast->left);
    gen_printf(" ");
    gen_name(name_ast);
  }
  GEN_BEGIN_INDENT(up, 2);

  gen_printf("\nSET");
  if (is_ast_columns_values(update_list)) {
    // UPDATE table_name SET ([opt_column_spec]) = ([from_shape])
    EXTRACT(column_spec, update_list->left);
    EXTRACT_ANY_NOTNULL(from_shape_or_insert_list, update_list->right);

    gen_printf(" ");
    gen_column_spec(column_spec);
    gen_printf(" = ");

    gen_printf("(");
    gen_insert_list(from_shape_or_insert_list);
    gen_printf(")");
  }
  else {
    // UPDATE table_name SET [update_list] FROM [query_parts]
    gen_update_list(update_list);
  }

  if (query_parts) {
    gen_printf("\nFROM ");
    gen_query_parts(query_parts);
  }
  if (opt_where) {
    gen_printf("\n");
    gen_opt_where(opt_where);
  }
  if (opt_orderby) {
    gen_printf("\n");
    gen_opt_orderby(opt_orderby);
  }
  if (opt_limit) {
    gen_opt_limit(opt_limit);
  }
  GEN_END_INDENT(up);
}

static void gen_with_update_stmt(ast_node *ast) {
  Contract(is_ast_with_update_stmt(ast));
  EXTRACT_ANY_NOTNULL(with_prefix, ast->left)
  EXTRACT_NOTNULL(update_stmt, ast->right);

  gen_with_prefix(with_prefix);
  gen_update_stmt(update_stmt);
}

static void gen_update_returning_stmt(ast_node *ast) {
  Contract(is_ast_update_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(update_stmt, ast->left);
  if (is_ast_with_update_stmt(update_stmt)) {
    gen_with_update_stmt(update_stmt);
  }
  else {
    gen_update_stmt(update_stmt);
  }
  gen_printf("\n  RETURNING ");
  gen_select_expr_list(ast->right);
}

static void gen_insert_list(ast_node *_Nullable ast) {
  Contract(!ast || is_ast_insert_list(ast));

  while (ast) {
    Contract(is_ast_insert_list(ast));

    if (is_ast_from_shape(ast->left)) {
      gen_shape_arg(ast->left);
    }
    else {
      gen_root_expr(ast->left);
    }

    if (ast->right) {
      gen_printf(", ");
    }
    ast = ast->right;
  }
}

cql_noexport void gen_insert_type(ast_node *ast) {
  if (is_ast_insert_or_ignore(ast)) {
    gen_printf("INSERT OR IGNORE");
  }
  else if (is_ast_insert_or_replace(ast)) {
    gen_printf("INSERT OR REPLACE");
  }
  else if (is_ast_insert_replace(ast)) {
    gen_printf("REPLACE");
  }
  else if (is_ast_insert_or_abort(ast)) {
    gen_printf("INSERT OR ABORT");
  }
  else if (is_ast_insert_or_fail(ast)) {
    gen_printf("INSERT OR FAIL");
  }
  else if (is_ast_insert_or_rollback(ast)) {
     gen_printf("INSERT OR ROLLBACK");
  }
  else {
    Contract(is_ast_insert_normal(ast));
    gen_printf("INSERT");
  }
}

static void gen_insert_dummy_spec(ast_node *ast) {
  Contract(is_ast_insert_dummy_spec(ast) || is_ast_seed_stub(ast));
  EXTRACT_ANY_NOTNULL(seed_expr, ast->left);
  EXTRACT_OPTION(flags, ast->right);

  if (suppress_attributes()) {
    return;
  }

  gen_printf(" @DUMMY_SEED(");
  gen_root_expr(seed_expr);
  gen_printf(")");

  if (flags & INSERT_DUMMY_DEFAULTS) {
    gen_printf(" @DUMMY_DEFAULTS");
  }

  if (flags & INSERT_DUMMY_NULLABLES) {
    gen_printf(" @DUMMY_NULLABLES");
  }
}

static void gen_shape_def_base(ast_node *ast) {
  Contract(is_ast_like(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY(from_args, ast->right);

  gen_printf("LIKE ");
  gen_name(name_ast);
  if (from_args) {
    gen_printf(" ARGUMENTS");
  }
}

static void gen_shape_expr(ast_node *ast) {
  Contract(is_ast_shape_expr(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);

  if (!ast->right) {
    gen_printf("-");
  }
  gen_name(name_ast);
}

static void gen_shape_exprs(ast_node *ast) {
 Contract(is_ast_shape_exprs(ast));

  while (ast) {
    Contract(is_ast_shape_exprs(ast));
    gen_shape_expr(ast->left);
    if (ast->right) {
      gen_printf(", ");
    }
    ast = ast->right;
  }
}

static void gen_shape_def(ast_node *ast) {
  Contract(is_ast_shape_def(ast));
  EXTRACT_NOTNULL(like, ast->left);
  gen_shape_def_base(like);

  if (ast->right) {
    gen_printf("(");
    gen_shape_exprs(ast->right);
    gen_printf(")");
  }
}

static void gen_column_spec(ast_node *ast) {
  // allow null column_spec here so we don't have to test it everywhere
  if (ast) {
    gen_printf("(");
    if (is_ast_shape_def(ast->left)) {
      gen_shape_def(ast->left);
    }
    else {
      EXTRACT(name_list, ast->left);
      if (name_list) {
        gen_name_list(name_list);
      }
    }
    gen_printf(")");
  }
}

static void gen_insert_stmt(ast_node *ast) {
  Contract(is_ast_insert_stmt(ast));
  EXTRACT_ANY_NOTNULL(insert_type, ast->left);
  EXTRACT_NOTNULL(name_columns_values, ast->right);
  EXTRACT_NAME_AST(name_ast, name_columns_values->left);
  EXTRACT_ANY_NOTNULL(columns_values, name_columns_values->right);
  EXTRACT_ANY(insert_dummy_spec, insert_type->left);

  gen_insert_type(insert_type);
  gen_printf(" INTO ");
  gen_name(name_ast);

  if (is_ast_expr_names(columns_values)) {
    gen_printf(" USING ");
    gen_expr_names(columns_values);
  }
  else if (is_select_variant(columns_values)) {
    gen_printf(" USING ");
    gen_select_stmt(columns_values);
  }
  else if (is_ast_columns_values(columns_values)) {
    EXTRACT(column_spec, columns_values->left);
    EXTRACT_ANY(insert_list, columns_values->right);
    gen_column_spec(column_spec);

    if (is_select_variant(insert_list)) {
      gen_printf("\n");
      GEN_BEGIN_INDENT(sel, 2);
        gen_select_stmt(insert_list);
      GEN_END_INDENT(sel);
    }
    else if (is_ast_from_shape(insert_list)) {
      gen_printf(" ");
      gen_from_shape(insert_list);
    }
    else {
      gen_printf(" VALUES (");
      gen_insert_list(insert_list);
      gen_printf(")");
    }

    if (insert_dummy_spec) {
      gen_insert_dummy_spec(insert_dummy_spec);
    }
  }
  else {
    // INSERT [conflict resolution] INTO name DEFAULT VALUES
    Contract(is_ast_default_columns_values(columns_values));
    gen_printf(" DEFAULT VALUES");
  }
}

static void gen_with_insert_stmt(ast_node *ast) {
  Contract(is_ast_with_insert_stmt(ast));
  EXTRACT_ANY_NOTNULL(with_prefix, ast->left)
  EXTRACT_NOTNULL(insert_stmt, ast->right);

  gen_with_prefix(with_prefix);
  gen_insert_stmt(insert_stmt);
}

static void gen_insert_returning_stmt(ast_node *ast) {
  Contract(is_ast_insert_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(insert_stmt, ast->left);
  if (is_ast_with_insert_stmt(insert_stmt)) {
    gen_with_insert_stmt(insert_stmt);
  }
  else {
    gen_insert_stmt(insert_stmt);
  }
  gen_printf("\n  RETURNING ");
  gen_select_expr_list(ast->right);
}

static void gen_expr_names(ast_node *ast) {
  Contract(is_ast_expr_names(ast));

  for (ast_node *list = ast; list; list = list->right) {
    EXTRACT(expr_name, list->left);
    EXTRACT_ANY(expr, expr_name->left);
    EXTRACT_NOTNULL(opt_as_alias, expr_name->right);

    gen_expr(expr, EXPR_PRI_ROOT);
    gen_as_alias(opt_as_alias);

    if (list->right) {
      gen_printf(", ");
    }
  }
}

static void gen_fetch_values_stmt(ast_node *ast) {
  Contract(is_ast_fetch_values_stmt(ast));

  EXTRACT(insert_dummy_spec, ast->left);
  EXTRACT_NOTNULL(name_columns_values, ast->right);
  EXTRACT_STRING(name, name_columns_values->left);
  EXTRACT_ANY_NOTNULL(columns_values, name_columns_values->right);

  gen_printf("FETCH %s", name);

  if (is_ast_expr_names(columns_values)) {
    gen_printf(" USING ");
    gen_expr_names(columns_values);
  }
  else {
    EXTRACT(column_spec, columns_values->left);
    gen_column_spec(column_spec);
    gen_printf(" ");

    if (is_ast_from_shape(columns_values->right)) {
      gen_from_shape(columns_values->right);
    }
    else {
      EXTRACT(insert_list, columns_values->right);
      gen_printf("FROM VALUES (");
      gen_insert_list(insert_list);
      gen_printf(")");
    }
  }

  if (insert_dummy_spec) {
    gen_insert_dummy_spec(insert_dummy_spec);
  }
}

static void gen_assign(ast_node *ast) {
  Contract(is_ast_assign(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  gen_printf("SET ");
  gen_name(name_ast);
  gen_printf(" := ");
  gen_root_expr(expr);
}

static void gen_let_stmt(ast_node *ast) {
  Contract(is_ast_let_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  gen_printf("LET ");
  gen_name(name_ast);
  gen_printf(" := ");
  gen_root_expr(expr);
}

static void gen_const_stmt(ast_node *ast) {
  Contract(is_ast_const_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  gen_printf("CONST ");
  gen_name(name_ast);
  gen_printf(" := ");
  gen_root_expr(expr);
}

static void gen_opt_inout(ast_node *ast) {
  if (is_ast_in(ast)) {
    gen_printf("IN ");
  }
  else if (is_ast_out(ast)) {
    gen_printf("OUT ");
  }
  else if (is_ast_inout(ast)) {
    gen_printf("INOUT ");
  }
  else {
    Contract(!ast);
  }
}

static void gen_normal_param(ast_node *ast) {
  Contract(is_ast_param(ast));
  EXTRACT_ANY(opt_inout, ast->left);
  EXTRACT_NOTNULL(param_detail, ast->right);
  EXTRACT_NAME_AST(name_ast, param_detail->left);
  EXTRACT_ANY_NOTNULL(data_type, param_detail->right);

  gen_opt_inout(opt_inout);
  gen_name(name_ast);
  gen_printf(" ");
  gen_data_type(data_type);
}

static void gen_like_param(ast_node *ast) {
  Contract(is_ast_param(ast));
  EXTRACT_NOTNULL(param_detail, ast->right);
  EXTRACT_NOTNULL(shape_def, param_detail->right);

  if (param_detail->left) {
    EXTRACT_STRING(name, param_detail->left);
    gen_printf("%s ", name);
  }

  gen_shape_def(shape_def);
}

cql_noexport void gen_param(ast_node *ast) {
  Contract(is_ast_param(ast));

  EXTRACT_NOTNULL(param_detail, ast->right);
  if (is_ast_shape_def(param_detail->right)) {
    gen_like_param(ast);
  }
  else {
    gen_normal_param(ast);
  }
}

cql_noexport void gen_params(ast_node *ast) {
  Contract(is_ast_params(ast));

  for (ast_node *cur = ast; cur; cur = cur->right) {
    Contract(is_ast_params(cur));
    EXTRACT_NOTNULL(param, cur->left);

    gen_param(param);

    if (cur->right) {
      gen_printf(", ");
    }
  }
}

static void gen_create_proc_stmt(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);

  gen_printf("PROC ");
  gen_name(name_ast);
  gen_printf(" (");
  if (params) {
    gen_params(params);
  }
  gen_printf(")\nBEGIN\n");
  gen_stmt_list(stmt_list);
  gen_printf("END");
}

static void gen_declare_proc_from_create_proc(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast));
  Contract(!for_sqlite());
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);

  gen_printf("DECLARE PROC %s (", name);
  if (params) {
    gen_params(params);
  }
  gen_printf(")");

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)
  // if no SEM then we can't do the full declaration, do the best we can with just AST
#else
  if (ast->sem) {
    if (has_out_stmt_result(ast)) {
      gen_printf(" OUT");
    }

    if (has_out_union_stmt_result(ast)) {
      gen_printf(" OUT UNION");
    }

    if (is_struct(ast->sem->sem_type)) {
      sem_struct *sptr = ast->sem->sptr;

      gen_printf(" (");
      for (uint32_t i = 0; i < sptr->count; i++) {
        gen_sptr_name(sptr, i);
        gen_printf(" ");

        sem_t sem_type = sptr->semtypes[i];
        gen_printf("%s", coretype_string(sem_type));

        CSTR kind = sptr->kinds[i];
        if (kind) {
          gen_type_kind(kind);
        }

        if (is_not_nullable(sem_type)) {
          gen_not_null();
        }

        if (sensitive_flag(sem_type)) {
          gen_printf(" @SENSITIVE");
        }

        if (i + 1 < sptr->count) {
          gen_printf(", ");
        }
      }
      gen_printf(")");

      if ((has_out_stmt_result(ast) || has_out_union_stmt_result(ast)) && is_dml_proc(ast->sem->sem_type)) {
        // out [union] can be DML or not, so we have to specify
        gen_printf(" USING TRANSACTION");
      }
    }
    else if (is_dml_proc(ast->sem->sem_type)) {
      gen_printf(" USING TRANSACTION");
    }
  }
#endif
}

// the current primary output buffer for the closure of declares
static charbuf *closure_output;

// The declares we have already emitted, if NULL we are emitting
// everything every time -- useful for --test output but otherwise
// just redundant at best.  Note cycles are not possible.
// even with no checking because declares form a partial order.
static symtab *closure_emitted;

static bool_t gen_found_set_kind(ast_node *ast, void *context, charbuf *buffer) {
  EXTRACT_STRING(name, ast);
  ast_node *proc = NULL;

  CHARBUF_OPEN(proc_name);
    for (int32_t i = 0; name[i] && name[i] != ' '; i++) {
      bputc(&proc_name, name[i]);
    }
    proc = find_proc(proc_name.ptr);
  CHARBUF_CLOSE(proc_name);

  if (proc) {
    // get canonical name
    EXTRACT_STRING(pname, get_proc_name(proc));

    // we interrupt the current decl to emit a decl for this new name
    if (!closure_emitted || symtab_add(closure_emitted, pname, NULL)) {
      CHARBUF_OPEN(current);
      charbuf *gen_output_saved = gen_output;

      gen_output = &current;
      gen_declare_proc_from_create_or_decl(proc);

      gen_output = closure_output;
      gen_printf("%s;\n", current.ptr);

      gen_output = gen_output_saved;
      CHARBUF_CLOSE(current);
    }
  }

  return false;
}

cql_noexport void gen_declare_proc_closure(ast_node *ast, symtab *emitted) {
  gen_sql_callbacks callbacks = {
     .set_kind_callback = gen_found_set_kind,
     .set_kind_context = emitted
  };
  gen_callbacks = &callbacks;

  EXTRACT_STRING(name, ast->left);
  if (emitted) {
    // if specified then we use this to track what we have already emitted
    symtab_add(emitted, name, NULL);
  }

  closure_output = gen_output;
  closure_emitted = emitted;

  CHARBUF_OPEN(current);
    gen_output = &current;
    gen_declare_proc_from_create_proc(ast);

    gen_output = closure_output;
    gen_printf("%s;\n", current.ptr);
  CHARBUF_CLOSE(current);

  // Make sure we're clean on exit -- mainly so that ASAN leak detection
  // doesn't think there are roots when we are actually done with the
  // stuff.  We want to see the leaks if there are any.
  gen_callbacks = NULL;
  closure_output = NULL;
  closure_emitted = NULL;
}

static void gen_typed_name(ast_node *ast) {
  EXTRACT(typed_name, ast);
  EXTRACT_ANY(name, typed_name->left);
  EXTRACT_ANY_NOTNULL(type, typed_name->right);

  if (name) {
    gen_name(name);
    gen_printf(" ");
  }

  if (is_ast_shape_def(type)) {
    gen_shape_def(type);
  }
  else {
    gen_data_type(type);
  }
}

void gen_typed_names(ast_node *ast) {
  Contract(is_ast_typed_names(ast));

  for (ast_node *item = ast; item; item = item->right) {
    Contract(is_ast_typed_names(item));
    gen_typed_name(item->left);

    if (item->right) {
      gen_printf(", ");
    }
  }
}

static void gen_declare_proc_no_check_stmt(ast_node *ast) {
  Contract(is_ast_declare_proc_no_check_stmt(ast));
  EXTRACT_ANY_NOTNULL(proc_name, ast->left);
  EXTRACT_STRING(name, proc_name);
  gen_printf("DECLARE PROC %s NO CHECK", name);
}

cql_noexport void gen_declare_interface_stmt(ast_node *ast) {
  Contract(is_ast_declare_interface_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT_NOTNULL(typed_names, proc_params_stmts->right);

  gen_printf("DECLARE INTERFACE %s", name);

  gen_printf(" (");
  gen_typed_names(typed_names);
  gen_printf(")");
}

static void gen_declare_proc_stmt(ast_node *ast) {
  Contract(is_ast_declare_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_name_type, ast->left);
  EXTRACT_STRING(name, proc_name_type->left);
  EXTRACT_OPTION(type, proc_name_type->right);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(typed_names, proc_params_stmts->right);

  gen_printf("DECLARE PROC %s (", name);
  if (params) {
    gen_params(params);
  }
  gen_printf(")");

  if (type & PROC_FLAG_USES_OUT) {
    gen_printf(" OUT");
  }

  if (type & PROC_FLAG_USES_OUT_UNION) {
    gen_printf(" OUT UNION");
  }

  if (typed_names) {
    Contract(type & PROC_FLAG_STRUCT_TYPE);
    gen_printf(" (");
    gen_typed_names(typed_names);
    gen_printf(")");
  }

  // we don't emit USING TRANSACTION unless it's needed

  // if it doesnt use DML it's not needed
  if (!(type & PROC_FLAG_USES_DML)) {
    return;
  }

  // out can be either, so emit it if needed
  if (type & (PROC_FLAG_USES_OUT | PROC_FLAG_USES_OUT_UNION)) {
    gen_printf(" USING TRANSACTION");
    return;
  }

  // if the proc returns a struct not via out then it uses SELECT and so it's implictly DML
  if (type & PROC_FLAG_STRUCT_TYPE) {
    return;
  }

  // it's not an OUT and it doesn't have a result but it does use DML
  // the only flag combo left is a basic dml proc.
  Contract(type == PROC_FLAG_USES_DML);
  gen_printf(" USING TRANSACTION");
}

cql_noexport void gen_declare_proc_from_create_or_decl(ast_node *ast) {
  Contract(is_ast_create_proc_stmt(ast) || is_ast_declare_proc_stmt(ast));
  if (is_ast_create_proc_stmt(ast)) {
    gen_declare_proc_from_create_proc(ast);
  }
  else {
    gen_declare_proc_stmt(ast);
  }
}

static void gen_declare_select_func_stmt(ast_node *ast) {
  Contract(is_ast_declare_select_func_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT(params, func_params_return->left);
  EXTRACT_ANY_NOTNULL(ret_data_type, func_params_return->right);

  gen_printf("DECLARE SELECT FUNC %s (", name);
  if (params) {
    gen_params(params);
  }
  gen_printf(") ");

  if (is_ast_typed_names(ret_data_type)) {
    // table valued function
    gen_printf("(");
    gen_typed_names(ret_data_type);
    gen_printf(")");
  }
  else {
    // standard function
    gen_data_type(ret_data_type);
  }
}

static void gen_declare_select_func_no_check_stmt(ast_node *ast) {
  Contract(is_ast_declare_select_func_no_check_stmt(ast));
  EXTRACT_STRING(name, ast-> left);
  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT_ANY_NOTNULL(ret_data_type, func_params_return->right);

  gen_printf("DECLARE SELECT FUNC %s NO CHECK ", name);

  if (is_ast_typed_names(ret_data_type)) {
    // table valued function
    gen_printf("(");
    gen_typed_names(ret_data_type);
    gen_printf(")");
  }
  else {
    // standard function
    gen_data_type(ret_data_type);
  }
}

static void gen_declare_func_stmt(ast_node *ast) {
  Contract(is_ast_declare_func_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT(params, func_params_return->left);
  EXTRACT_ANY_NOTNULL(ret_data_type, func_params_return->right);

  gen_printf("DECLARE FUNC %s (", name);
  if (params) {
    gen_params(params);
  }
  gen_printf(") ");

  gen_data_type(ret_data_type);
}

static void gen_declare_func_no_check_stmt(ast_node *ast) {
  Contract(is_ast_declare_func_no_check_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT_ANY_NOTNULL(ret_data_type, func_params_return->right);

  gen_printf("DECLARE FUNC %s NO CHECK ", name);

  gen_data_type(ret_data_type);
}

static void gen_declare_vars_type(ast_node *ast) {
  Contract(is_ast_declare_vars_type(ast));
  EXTRACT_NOTNULL(name_list, ast->left);
  EXTRACT_ANY_NOTNULL(data_type, ast->right);

  gen_printf("DECLARE ");
  gen_name_list(name_list);
  gen_printf(" ");
  gen_data_type(data_type);
}

static void gen_declare_cursor(ast_node *ast) {
  Contract(is_ast_declare_cursor(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(source, ast->right);

  gen_printf("CURSOR ");
  gen_name(name_ast);
  gen_printf(" FOR");

  // we have to handle an insert/delete statement in the AST here which might not be a row source
  // we detect that later in semantic analysis, it's wrong but so are many other things
  // in the ast at this point, we still echo them... We could fix this in the grammar but then
  // (a) the grammar gets more complex for no good reason and (b) the error message isn't as good.
  if (is_row_source(source) ||
      is_ast_call_stmt(source) ||
      is_insert_stmt(source) ||
      is_update_stmt(source) ||
      is_upsert_stmt(source) ||
      is_delete_stmt(source)) {
    // The two statement cases are unified
    gen_printf("\n");
    GEN_BEGIN_INDENT(cursor, 2);
      gen_one_stmt(source);
    GEN_END_INDENT(cursor);
  }
  else {
    gen_printf(" ");
    gen_root_expr(source);
  }
}

static void gen_declare_cursor_like_name(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_name(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(shape_def, ast->right);

  gen_printf("CURSOR ");
  gen_name(name_ast);
  gen_printf(" ");
  gen_shape_def(shape_def);
}

static void gen_declare_cursor_like_select(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_select(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(stmt, ast->right);

  gen_printf("CURSOR ");
  gen_name(name_ast);
  gen_printf(" LIKE ");
  gen_one_stmt(stmt);
}

static void gen_declare_cursor_like_typed_names(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_typed_names(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(typed_names, ast->right);

  gen_printf("CURSOR ");
  gen_name(name_ast);
  gen_printf(" LIKE (");
  gen_typed_names(typed_names);
  gen_printf(")");
}

static void gen_declare_named_type(ast_node *ast) {
  Contract(is_ast_declare_named_type(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(data_type, ast->right);

  gen_printf("TYPE ");
  gen_name(name_ast);
  gen_printf(" ");
  gen_data_type(data_type);
}

static void gen_declare_value_cursor(ast_node *ast) {
  Contract(is_ast_declare_value_cursor(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(stmt, ast->right);

  gen_printf("CURSOR ");
  gen_name(name_ast);
  gen_printf(" FETCH FROM ");
  gen_one_stmt(stmt);
}

static void gen_declare_enum_stmt(ast_node *ast) {
  Contract(is_ast_declare_enum_stmt(ast));
  EXTRACT_NOTNULL(typed_name, ast->left);
  EXTRACT_NOTNULL(enum_values, ast->right);
  gen_printf("DECLARE ENUM ");
  gen_typed_name(typed_name);
  gen_printf(" (");

  while (enum_values) {
     EXTRACT_NOTNULL(enum_value, enum_values->left);
     EXTRACT_STRING(enum_name, enum_value->left);
     EXTRACT_ANY(expr, enum_value->right);

     gen_printf("\n  %s", enum_name);
     if (expr) {
       gen_printf(" = ");
       gen_root_expr(expr);
     }

     if (enum_values->right) {
       gen_printf(",");
     }

     enum_values = enum_values->right;
  }
  gen_printf("\n)");
}

static void gen_declare_group_stmt(ast_node *ast) {
  Contract(is_ast_declare_group_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(stmt_list, ast->right);
  gen_printf("DECLARE GROUP %s\nBEGIN\n", name);

  while (stmt_list) {
     EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);
     gen_printf("  ");
     gen_one_stmt(stmt);
     gen_printf(";\n");
     stmt_list = stmt_list->right;
  }
  gen_printf("END");
}

static void gen_declare_const_stmt(ast_node *ast) {
  Contract(is_ast_declare_const_stmt(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(const_values, ast->right);
  gen_printf("DECLARE CONST GROUP %s (", name);

  while (const_values) {
     EXTRACT_NOTNULL(const_value, const_values->left);
     EXTRACT_STRING(const_name, const_value->left);
     EXTRACT_ANY(expr, const_value->right);

     gen_printf("\n  %s", const_name);
     if (expr) {
       gen_printf(" = ");
       gen_root_expr(expr);
     }

     if (const_values->right) {
       gen_printf(",");
     }

     const_values = const_values->right;
  }
  gen_printf("\n)");
}

static void gen_set_from_cursor(ast_node *ast) {
  Contract(is_ast_set_from_cursor(ast));
  EXTRACT_NAME_AST(var_name_ast, ast->left);
  EXTRACT_NAME_AST(cursor_name_ast, ast->right);

  gen_printf("SET ");
  gen_name(var_name_ast);
  gen_printf(" FROM CURSOR ");
  gen_name(cursor_name_ast);
}

static void gen_fetch_stmt(ast_node *ast) {
  Contract(is_ast_fetch_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT(name_list, ast->right);

  gen_printf("FETCH ");
  gen_name(name_ast);
  if (name_list) {
    gen_printf(" INTO ");
    gen_name_list(name_list);
  }
}

static void gen_switch_cases(ast_node *ast) {
  Contract(is_ast_switch_case(ast));

  while (ast) {
     EXTRACT_NOTNULL(connector, ast->left);
     if (connector->left) {
        EXTRACT_NOTNULL(expr_list, connector->left);
        EXTRACT(stmt_list, connector->right);

        gen_printf("  WHEN ");
        gen_expr_list(expr_list);
        if (stmt_list) {
            gen_printf(" THEN\n");
            GEN_BEGIN_INDENT(statement, 2);
              gen_stmt_list(stmt_list);
            GEN_END_INDENT(statement);
        }
        else {
          gen_printf(" THEN NOTHING\n");
        }
     }
     else {
        EXTRACT_NOTNULL(stmt_list, connector->right);

        gen_printf("  ELSE\n");
        GEN_BEGIN_INDENT(statement, 2);
          gen_stmt_list(stmt_list);
        GEN_END_INDENT(statement);
     }
     ast = ast->right;
  }
  gen_printf("END");
}

static void gen_switch_stmt(ast_node *ast) {
  Contract(is_ast_switch_stmt(ast));
  EXTRACT_OPTION(all_values, ast->left);
  EXTRACT_NOTNULL(switch_body, ast->right);
  EXTRACT_ANY_NOTNULL(expr, switch_body->left);
  EXTRACT_NOTNULL(switch_case, switch_body->right);

  // SWITCH [expr] [switch_body] END
  // SWITCH [expr] ALL VALUES [switch_body] END

  gen_printf("SWITCH ");
  gen_root_expr(expr);

  if (all_values) {
    gen_printf(" ALL VALUES");
  }
  gen_printf("\n");

  gen_switch_cases(switch_case);
}

static void gen_for_stmt(ast_node *ast) {
  Contract(is_ast_for_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(for_info, ast->right);

  // FOR [expr] ; stmt_list; BEGIN [stmt_list] END

  gen_printf("FOR ");
  gen_root_expr(expr);
  gen_printf("; ");
  gen_stmt_list_flat(for_info->left);

  gen_printf("\nBEGIN\n");
  gen_stmt_list(for_info->right);
  gen_printf("END");
}

static void gen_while_stmt(ast_node *ast) {
  Contract(is_ast_while_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(stmt_list, ast->right);

  // WHILE [expr] BEGIN [stmt_list] END

  gen_printf("WHILE ");
  gen_root_expr(expr);

  gen_printf("\nBEGIN\n");
  gen_stmt_list(stmt_list);
  gen_printf("END");
}

static void gen_loop_stmt(ast_node *ast) {
  Contract(is_ast_loop_stmt(ast));
  EXTRACT_NOTNULL(fetch_stmt, ast->left);
  EXTRACT(stmt_list, ast->right);

  // LOOP [fetch_stmt] BEGIN [stmt_list] END

  gen_printf("LOOP ");
  gen_fetch_stmt(fetch_stmt);
  gen_printf("\nBEGIN\n");
  gen_stmt_list(stmt_list);
  gen_printf("END");
}

static void gen_call_stmt(ast_node *ast) {
  Contract(is_ast_call_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT(arg_list, ast->right);

  gen_printf("CALL ");
  gen_name(name_ast);
  gen_printf("(");
  if (arg_list) {
    gen_arg_list(arg_list);
  }

  gen_printf(")");
}

static void gen_declare_out_call_stmt(ast_node *ast) {
  EXTRACT_NOTNULL(call_stmt, ast->left);
  gen_printf("DECLARE OUT ");
  gen_call_stmt(call_stmt);
}

static void gen_fetch_call_stmt(ast_node *ast) {
  Contract(is_ast_fetch_call_stmt(ast));
  Contract(is_ast_call_stmt(ast->right));
  EXTRACT_STRING(cursor_name, ast->left);
  EXTRACT_NOTNULL(call_stmt, ast->right);

  gen_printf("FETCH %s FROM ", cursor_name);
  gen_call_stmt(call_stmt);
}

static void gen_continue_stmt(ast_node *ast) {
  Contract(is_ast_continue_stmt(ast));

  gen_printf("CONTINUE");
}

static void gen_leave_stmt(ast_node *ast) {
  Contract(is_ast_leave_stmt(ast));

  gen_printf("LEAVE");
}

static void gen_return_stmt(ast_node *ast) {
  Contract(is_ast_return_stmt(ast));

  gen_printf("RETURN");
}

static void gen_rollback_return_stmt(ast_node *ast) {
  Contract(is_ast_rollback_return_stmt(ast));

  gen_printf("ROLLBACK RETURN");
}

static void gen_commit_return_stmt(ast_node *ast) {
  Contract(is_ast_commit_return_stmt(ast));

  gen_printf("COMMIT RETURN");
}

static void gen_proc_savepoint_stmt(ast_node *ast) {
  Contract(is_ast_proc_savepoint_stmt(ast));
  EXTRACT(stmt_list, ast->left);

  gen_printf("PROC SAVEPOINT");
  gen_printf("\nBEGIN\n");
  gen_stmt_list(stmt_list);
  gen_printf("END");
}

static void gen_throw_stmt(ast_node *ast) {
  Contract(is_ast_throw_stmt(ast));

  gen_printf("THROW");
}

static void gen_begin_trans_stmt(ast_node *ast) {
  Contract(is_ast_begin_trans_stmt(ast));
  EXTRACT_OPTION(mode, ast->left);

  gen_printf("BEGIN");

  if (mode == TRANS_IMMEDIATE) {
    gen_printf(" IMMEDIATE");
  }
  else if (mode == TRANS_EXCLUSIVE) {
    gen_printf(" EXCLUSIVE");
  }
  else {
    // this is the default, and only remaining case, no additional output needed
    Contract(mode == TRANS_DEFERRED);
  }
}

static void gen_commit_trans_stmt(ast_node *ast) {
  Contract(is_ast_commit_trans_stmt(ast));

  gen_printf("COMMIT");
}

static void gen_rollback_trans_stmt(ast_node *ast) {
  Contract(is_ast_rollback_trans_stmt(ast));

  gen_printf("ROLLBACK");

  if (ast->left) {
    EXTRACT_STRING(name, ast->left);
    gen_printf(" TO %s", name);
  }
}

static void gen_savepoint_stmt(ast_node *ast) {
  Contract(is_ast_savepoint_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  gen_printf("SAVEPOINT %s", name);
}

static void gen_release_savepoint_stmt(ast_node *ast) {
  Contract(is_ast_release_savepoint_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  gen_printf("RELEASE %s", name);
}

static void gen_trycatch_stmt(ast_node *ast) {
  Contract(is_ast_trycatch_stmt(ast));
  EXTRACT_NAMED(try_list, stmt_list, ast->left);
  EXTRACT_NAMED(catch_list, stmt_list, ast->right);

  gen_printf("TRY\n");
  gen_stmt_list(try_list);
  gen_printf("CATCH\n");
  gen_stmt_list(catch_list);
  gen_printf("END");
}

static void gen_close_stmt(ast_node *ast) {
  Contract(is_ast_close_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  gen_printf("CLOSE %s", name);
}

static void gen_op_stmt(ast_node *ast) {
  Contract(is_ast_op_stmt(ast));
  EXTRACT_ANY_NOTNULL(data_type, ast->left);
  EXTRACT_ANY_NOTNULL(v1, ast->right);
  EXTRACT_ANY_NOTNULL(v2, v1->right);

  gen_printf("@OP ");
  gen_data_type(data_type);
  gen_printf(" : ");
  gen_name(v1->left);
  gen_printf(" ");
  gen_name(v2->left);
  gen_printf(" AS ");
  gen_name(v2->right);
}

static void gen_out_stmt(ast_node *ast) {
  Contract(is_ast_out_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  gen_printf("OUT %s", name);
}

static void gen_out_union_stmt(ast_node *ast) {
  Contract(is_ast_out_union_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  gen_printf("OUT UNION %s", name);
}

static void gen_child_results(ast_node *ast) {
  Contract(is_ast_child_results(ast));

  ast_node *item = ast;
  while (item) {
    Contract(is_ast_child_results(item));

    EXTRACT_NOTNULL(child_result, item->left);
    EXTRACT_NOTNULL(call_stmt, child_result->left);
    EXTRACT_NOTNULL(named_result, child_result->right);

    EXTRACT_NOTNULL(name_list, named_result->right);
    CSTR child_column_name = NULL;
    if (named_result->left) {
      EXTRACT_STRING(name, named_result->left);
      child_column_name = name;
    }

    gen_printf("\n  ");
    gen_call_stmt(call_stmt);
    gen_printf(" USING (");
    gen_name_list(name_list);
    gen_printf(")");

    if (child_column_name) {
      gen_printf(" AS %s", child_column_name);
    }

    if (item->right) {
      gen_printf(" AND");
    }

    item = item->right;
  }
}

static void gen_out_union_parent_child_stmt(ast_node *ast) {
  Contract(is_ast_out_union_parent_child_stmt(ast));
  EXTRACT_NOTNULL(call_stmt, ast->left);
  EXTRACT_NOTNULL(child_results, ast->right);

  gen_printf("OUT UNION ");
  gen_call_stmt(call_stmt);
  gen_printf(" JOIN ");
  gen_child_results(child_results);
}

static void gen_echo_stmt(ast_node *ast) {
  Contract(is_ast_echo_stmt(ast));
  EXTRACT_STRING(rt_name, ast->left);

  gen_printf("@ECHO %s, ", rt_name);
  gen_root_expr(ast->right);  // emit the quoted literal
}

static void gen_schema_upgrade_script_stmt(ast_node *ast) {
  Contract(is_ast_schema_upgrade_script_stmt(ast));

  gen_printf("@SCHEMA_UPGRADE_SCRIPT");
}

static void gen_schema_upgrade_version_stmt(ast_node *ast) {
  Contract(is_ast_schema_upgrade_version_stmt(ast));
  EXTRACT_OPTION(vers, ast->left);

  gen_printf("@SCHEMA_UPGRADE_VERSION (%d)", vers);
}

static void gen_previous_schema_stmt(ast_node *ast) {
  Contract(is_ast_previous_schema_stmt(ast));

  gen_printf("@PREVIOUS_SCHEMA");
}

static void gen_enforcement_options(ast_node *ast) {
  EXTRACT_OPTION(option, ast);

  switch (option) {
    case ENFORCE_CAST:
      gen_printf("CAST");
      break;

    case ENFORCE_STRICT_JOIN:
      gen_printf("JOIN");
      break;

    case ENFORCE_FK_ON_UPDATE:
      gen_printf("FOREIGN KEY ON UPDATE");
      break;

    case ENFORCE_UPSERT_STMT:
      gen_printf("UPSERT STATEMENT");
      break;

    case ENFORCE_WINDOW_FUNC:
      gen_printf("WINDOW FUNCTION");
      break;

    case ENFORCE_WITHOUT_ROWID:
      gen_printf("WITHOUT ROWID");
      break;

    case ENFORCE_TRANSACTION:
      gen_printf("TRANSACTION");
      break;

    case ENFORCE_SELECT_IF_NOTHING:
      gen_printf("SELECT IF NOTHING");
      break;

    case ENFORCE_INSERT_SELECT:
      gen_printf("INSERT SELECT");
      break;

    case ENFORCE_TABLE_FUNCTION:
      gen_printf("TABLE FUNCTION");
      break;

    case ENFORCE_IS_TRUE:
      gen_printf("IS TRUE");
      break;

    case ENFORCE_SIGN_FUNCTION:
      gen_printf("SIGN FUNCTION");
      break;

    case ENFORCE_CURSOR_HAS_ROW:
      gen_printf("CURSOR HAS ROW");
      break;

    case ENFORCE_UPDATE_FROM:
      gen_printf("UPDATE FROM");
      break;

    case ENFORCE_AND_OR_NOT_NULL_CHECK:
      gen_printf("AND OR NOT NULL CHECK");
      break;

    default:
      // this is all that's left
      Contract(option == ENFORCE_FK_ON_DELETE);
      gen_printf("FOREIGN KEY ON DELETE");
      break;
  }
}

static void gen_enforce_strict_stmt(ast_node *ast) {
  Contract(is_ast_enforce_strict_stmt(ast));
  gen_printf("@ENFORCE_STRICT ");
  gen_enforcement_options(ast->left);
}

static void gen_enforce_normal_stmt(ast_node *ast) {
  Contract(is_ast_enforce_normal_stmt(ast));
  gen_printf("@ENFORCE_NORMAL ");
  gen_enforcement_options(ast->left);
}

static void gen_enforce_reset_stmt(ast_node *ast) {
  Contract(is_ast_enforce_reset_stmt(ast));
  gen_printf("@ENFORCE_RESET");
}

static void gen_enforce_push_stmt(ast_node *ast) {
  Contract(is_ast_enforce_push_stmt(ast));
  gen_printf("@ENFORCE_PUSH");
}

static void gen_enforce_pop_stmt(ast_node *ast) {
  Contract(is_ast_enforce_pop_stmt(ast));
  gen_printf("@ENFORCE_POP");
}

static void gen_region_spec(ast_node *ast) {
  Contract(is_ast_region_spec(ast));
  EXTRACT_OPTION(type, ast->right);
  bool_t is_private = (type == PRIVATE_REGION);

  gen_name(ast->left);
  if (is_private) {
    gen_printf(" PRIVATE");
  }
}

static void gen_region_list(ast_node *ast) {
  Contract(is_ast_region_list(ast));
  while (ast) {
    gen_region_spec(ast->left);
    if (ast->right) {
      gen_printf(", ");
    }
    ast = ast->right;
  }
}

static void gen_declare_deployable_region_stmt(ast_node *ast) {
  Contract(is_ast_declare_deployable_region_stmt(ast));
  gen_printf("@DECLARE_DEPLOYABLE_REGION ");
  gen_name(ast->left);
  if (ast->right) {
    gen_printf(" USING ");
    gen_region_list(ast->right);
  }
}

static void gen_declare_schema_region_stmt(ast_node *ast) {
  Contract(is_ast_declare_schema_region_stmt(ast));
  gen_printf("@DECLARE_SCHEMA_REGION ");
  gen_name(ast->left);
  if (ast->right) {
    gen_printf(" USING ");
    gen_region_list(ast->right);
  }
}

static void gen_begin_schema_region_stmt(ast_node *ast) {
  Contract(is_ast_begin_schema_region_stmt(ast));
  gen_printf("@BEGIN_SCHEMA_REGION ");
  gen_name(ast->left);
}

static void gen_end_schema_region_stmt(ast_node *ast) {
  Contract(is_ast_end_schema_region_stmt(ast));
  gen_printf("@END_SCHEMA_REGION");
}

static void gen_schema_unsub_stmt(ast_node *ast) {
  Contract(is_ast_schema_unsub_stmt(ast));
  EXTRACT_NOTNULL(version_annotation, ast->left);
  EXTRACT_NAME_AST(name_ast, version_annotation->right);

  gen_printf("@UNSUB(");
  gen_name(name_ast);
  gen_printf(")");
}

static void gen_schema_ad_hoc_migration_stmt(ast_node *ast) {
  Contract(is_ast_schema_ad_hoc_migration_stmt(ast));
  EXTRACT_ANY_NOTNULL(l, ast->left);
  EXTRACT_ANY(r, ast->right);

  // two arg version is a recreate upgrade instruction
  if (r) {
    EXTRACT_STRING(group, l);
    EXTRACT_STRING(proc, r);
    gen_printf("@SCHEMA_AD_HOC_MIGRATION FOR @RECREATE(");
    gen_printf("%s, %s)", group, proc);
  }
  else {
    gen_printf("@SCHEMA_AD_HOC_MIGRATION(");
    gen_version_and_proc(l);
    gen_printf(")");
  }
}

static void gen_emit_group_stmt(ast_node *ast) {
  Contract(is_ast_emit_group_stmt(ast));
  EXTRACT(name_list, ast->left);

  gen_printf("@EMIT_GROUP");
  if (name_list) {
    gen_printf(" ");
    gen_name_list(name_list);
  }
}


static void gen_emit_enums_stmt(ast_node *ast) {
  Contract(is_ast_emit_enums_stmt(ast));
  EXTRACT(name_list, ast->left);

  gen_printf("@EMIT_ENUMS");
  if (name_list) {
    gen_printf(" ");
    gen_name_list(name_list);
  }
}

static void gen_emit_constants_stmt(ast_node *ast) {
  Contract(is_ast_emit_constants_stmt(ast));
  EXTRACT_NOTNULL(name_list, ast->left);

  gen_printf("@EMIT_CONSTANTS ");
  gen_name_list(name_list);
}

static void gen_conflict_target(ast_node *ast) {
  Contract(is_ast_conflict_target(ast));
  EXTRACT(indexed_columns, ast->left);
  EXTRACT(opt_where, ast->right);

  gen_printf("\nON CONFLICT");
  if (indexed_columns) {
    gen_printf(" (");
    gen_indexed_columns(indexed_columns);
    gen_printf(")");
  }
  if (opt_where) {
    gen_printf("\n");
    gen_opt_where(opt_where);
    gen_printf(" ");
  }
}

static void gen_upsert_update(ast_node *ast) {
  Contract(is_ast_upsert_update(ast));
  EXTRACT_NOTNULL(conflict_target, ast->left);
  EXTRACT(update_stmt, ast->right);

  gen_conflict_target(conflict_target);
  gen_printf("\nDO ");
  if (update_stmt) {
    gen_update_stmt(update_stmt);
  }
  else {
    gen_printf("NOTHING");
  }
}

static void gen_upsert_stmt(ast_node *ast) {
  Contract(is_ast_upsert_stmt(ast));

  EXTRACT_NOTNULL(insert_stmt, ast->left);
  EXTRACT_NOTNULL(upsert_update, ast->right);

  gen_insert_stmt(insert_stmt);
  gen_upsert_update(upsert_update);
}

static void gen_with_upsert_stmt(ast_node *ast) {
  Contract(is_ast_with_upsert_stmt(ast));
  EXTRACT_ANY_NOTNULL(with_prefix, ast->left)
  EXTRACT_NOTNULL(upsert_stmt, ast->right);

  gen_with_prefix(with_prefix);
  gen_upsert_stmt(upsert_stmt);
}

static void gen_upsert_returning_stmt(ast_node *ast) {
  Contract(is_ast_upsert_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(upsert_stmt, ast->left);
  if (is_ast_with_upsert_stmt(upsert_stmt)) {
    gen_with_upsert_stmt(upsert_stmt);
  }
  else {
    gen_upsert_stmt(upsert_stmt);
  }
  gen_printf("\n  RETURNING ");
  gen_select_expr_list(ast->right);
}


static void gen_keep_table_name_in_aliases_stmt(ast_node *ast) {
  Contract(is_ast_keep_table_name_in_aliases_stmt(ast));
  gen_printf("@KEEP_TABLE_NAME_IN_ALIASES");
}

static void gen_explain_stmt(ast_node *ast) {
  Contract(is_ast_explain_stmt(ast));
  EXTRACT_OPTION(query_plan, ast->left);
  EXTRACT_ANY_NOTNULL(stmt_target, ast->right);

  gen_printf("EXPLAIN");
  if (query_plan == EXPLAIN_QUERY_PLAN) {
    gen_printf(" QUERY PLAN");
  }
  gen_printf("\n");
  gen_one_stmt(stmt_target);
}

static void gen_macro_formal(ast_node *macro_formal) {
  Contract(is_ast_macro_formal(macro_formal));
  EXTRACT_STRING(l, macro_formal->left);
  EXTRACT_STRING(r, macro_formal->right);
  gen_printf("%s! %s", l, r);
}

static void gen_macro_formals(ast_node *macro_formals) {
  for ( ; macro_formals; macro_formals = macro_formals->right) {
     Contract(is_ast_macro_formals(macro_formals));
     gen_macro_formal(macro_formals->left);
     if (macro_formals->right) {
       gen_printf(", ");
     }
  }
}

static void gen_expr_macro_def(ast_node *ast) {
  Contract(is_ast_expr_macro_def(ast));
  EXTRACT_NOTNULL(macro_name_formals, ast->left);
  EXTRACT_ANY_NOTNULL(body, ast->right);
  EXTRACT_STRING(name, macro_name_formals->left);

  gen_printf("@MACRO(EXPR) %s!(", name);
  gen_macro_formals(macro_name_formals->right);
  gen_printf(")\nBEGIN\n");
  GEN_BEGIN_INDENT(body_indent, 2);
    gen_root_expr(body);
  GEN_END_INDENT(body_indent);
  gen_printf("\nEND");
}

static void gen_stmt_list_macro_def(ast_node *ast) {
  Contract(is_ast_stmt_list_macro_def(ast));
  EXTRACT_NOTNULL(macro_name_formals, ast->left);
  EXTRACT_ANY_NOTNULL(body, ast->right);
  EXTRACT_STRING(name, macro_name_formals->left);

  gen_printf("@MACRO(STMT_LIST) %s!(", name);
  gen_macro_formals(macro_name_formals->right);
  gen_printf(")\nBEGIN\n");
  gen_stmt_list(body);
  gen_printf("END");
}

static void gen_select_core_macro_def(ast_node *ast) {
  Contract(is_ast_select_core_macro_def(ast));
  EXTRACT_NOTNULL(macro_name_formals, ast->left);
  EXTRACT_ANY_NOTNULL(body, ast->right);
  EXTRACT_STRING(name, macro_name_formals->left);

  gen_printf("@MACRO(SELECT_CORE) %s!(", name);
  gen_macro_formals(macro_name_formals->right);
  gen_printf(")\nBEGIN\n");
  GEN_BEGIN_INDENT(body_indent, 2);
    gen_select_core_list(body);
  GEN_END_INDENT(body_indent);
  gen_printf("\nEND");
}

static void gen_select_expr_macro_def(ast_node *ast) {
  Contract(is_ast_select_expr_macro_def(ast));
  EXTRACT_NOTNULL(macro_name_formals, ast->left);
  EXTRACT_ANY_NOTNULL(body, ast->right);
  EXTRACT_STRING(name, macro_name_formals->left);

  gen_printf("@MACRO(SELECT_EXPR) %s!(", name);
  gen_macro_formals(macro_name_formals->right);
  gen_printf(")\nBEGIN\n");
  GEN_BEGIN_INDENT(body_indent, 2);
    gen_select_expr_list(body);
  GEN_END_INDENT(body_indent);
  gen_printf("\nEND");
}

static void gen_query_parts_macro_def(ast_node *ast) {
  Contract(is_ast_query_parts_macro_def(ast));
  EXTRACT_NOTNULL(macro_name_formals, ast->left);
  EXTRACT_ANY_NOTNULL(body, ast->right);
  EXTRACT_STRING(name, macro_name_formals->left);

  gen_printf("@MACRO(QUERY_PARTS) %s!(", name);
  gen_macro_formals(macro_name_formals->right);
  gen_printf(")\nBEGIN\n");
  GEN_BEGIN_INDENT(body_indent, 2);
    gen_query_parts(body);
  GEN_END_INDENT(body_indent);
  gen_printf("\nEND");
}

static void gen_cte_tables_macro_def(ast_node *ast) {
  Contract(is_ast_cte_tables_macro_def(ast));
  EXTRACT_NOTNULL(macro_name_formals, ast->left);
  EXTRACT_ANY_NOTNULL(body, ast->right);
  EXTRACT_STRING(name, macro_name_formals->left);

  gen_printf("@MACRO(CTE_TABLES) %s!(", name);
  gen_macro_formals(macro_name_formals->right);
  gen_printf(")\nBEGIN\n");
  GEN_BEGIN_INDENT(body_indent, 2);
    gen_cte_tables(body, "");
  GEN_END_INDENT(body_indent);
  gen_printf("END");
}

cql_data_defn( int32_t gen_stmt_level );

static void gen_stmt_list_flat(ast_node *root) {
  Contract(is_ast_stmt_list(root));

  for (ast_node *semi = root; semi; semi = semi->right) {
    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, semi);

    if (misc_attrs) {
      gen_misc_attrs(misc_attrs);
    }

    gen_one_stmt(stmt);

    bool_t prep = is_ast_ifdef_stmt(stmt) || is_ast_ifndef_stmt(stmt);

    if (!prep) {
      gen_printf(";");
    }

    if (semi->right) {
       gen_printf(" ");
    }
  }
}

static void gen_stmt_list(ast_node *root) {
  if (!root) {
    return;
  }

  gen_stmt_level++;

  int32_t indent_level = (gen_stmt_level > 1) ? 2 : 0;

  GEN_BEGIN_INDENT(statement, indent_level);

  bool first_stmt = true;

  for (ast_node *semi = root; semi; semi = semi->right) {
    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, semi);
    if (misc_attrs) {
      // do not echo declarations that came from the builtin stream
      if (exists_attribute_str(misc_attrs, "builtin")) {
        continue;
      }
    }

    if (gen_stmt_level == 1 && !first_stmt) {
      gen_printf("\n");
    }

    first_stmt = false;

    if (misc_attrs) {
      gen_misc_attrs(misc_attrs);
    }
    gen_one_stmt(stmt);

    bool_t prep = is_ast_ifdef_stmt(stmt) || is_ast_ifndef_stmt(stmt);

    if (!prep) {
      gen_printf(";");
    }

    if (gen_stmt_level != 0 || semi->right != NULL) {
       gen_printf("\n");
    }
  }

  GEN_END_INDENT(statement);
  gen_stmt_level--;
}

cql_noexport void gen_one_stmt(ast_node *stmt)  {
  if (is_any_macro_ref(stmt)) {
    gen_any_macro_ref(stmt);
    return;
  }

  symtab_entry *entry = symtab_find(gen_stmts, stmt->type);

  // These are all the statements there are, we have to find it in this table
  // or else someone added a new statement and it isn't supported yet.
  Invariant(entry);
  ((void (*)(ast_node*))entry->val)(stmt);
}

cql_noexport void gen_one_stmt_and_misc_attrs(ast_node *stmt)  {
  EXTRACT_MISC_ATTRS(stmt, misc_attrs);
  if (misc_attrs) {
    gen_misc_attrs(misc_attrs);
  }
  gen_one_stmt(stmt);
}

// so the name doesn't otherwise conflict in the amalgam
#undef output

#undef STMT_INIT
#define STMT_INIT(x) symtab_add(gen_stmts, k_ast_ ## x, (void *)gen_ ## x)

#undef EXPR_INIT
#define EXPR_INIT(x, func, str, pri_new) \
  static gen_expr_dispatch expr_disp_ ## x = { func, str, pri_new }; \
  symtab_add(gen_exprs, k_ast_ ## x, (void *)&expr_disp_ ## x);

#undef MACRO_INIT
#define MACRO_INIT(x) \
  symtab_add(gen_macros, k_ast_ ## x ## _macro_ref, (void *)gen_macro_ref); \
  symtab_add(gen_macros, k_ast_ ## x ## _macro_arg_ref, (void *)gen_macro_arg_ref); \

cql_noexport void gen_init() {
  gen_stmts = symtab_new();
  gen_exprs = symtab_new();
  gen_macros = symtab_new();

  MACRO_INIT(expr);
  MACRO_INIT(stmt_list);
  MACRO_INIT(query_parts);
  MACRO_INIT(cte_tables);
  MACRO_INIT(select_core);
  MACRO_INIT(select_expr);
  MACRO_INIT(unknown);

  STMT_INIT(alter_table_add_column_stmt);
  STMT_INIT(assign);
  STMT_INIT(begin_schema_region_stmt);
  STMT_INIT(begin_trans_stmt);
  STMT_INIT(call_stmt);
  STMT_INIT(close_stmt);
  STMT_INIT(commit_return_stmt);
  STMT_INIT(commit_trans_stmt);
  STMT_INIT(conflict_target);
  STMT_INIT(const_stmt);
  STMT_INIT(continue_stmt);
  STMT_INIT(create_index_stmt);
  STMT_INIT(create_proc_stmt);
  STMT_INIT(create_table_stmt);
  STMT_INIT(create_trigger_stmt);
  STMT_INIT(create_view_stmt);
  STMT_INIT(create_virtual_table_stmt);
  STMT_INIT(cte_tables_macro_def);
  STMT_INIT(declare_const_stmt);
  STMT_INIT(declare_cursor);
  STMT_INIT(declare_cursor_like_name);
  STMT_INIT(declare_cursor_like_select);
  STMT_INIT(declare_cursor_like_typed_names);
  STMT_INIT(declare_deployable_region_stmt);
  STMT_INIT(declare_enum_stmt);
  STMT_INIT(declare_func_no_check_stmt);
  STMT_INIT(declare_func_stmt);
  STMT_INIT(declare_group_stmt);
  STMT_INIT(declare_interface_stmt);
  STMT_INIT(declare_named_type);
  STMT_INIT(declare_out_call_stmt);
  STMT_INIT(declare_proc_no_check_stmt);
  STMT_INIT(declare_proc_stmt);
  STMT_INIT(declare_schema_region_stmt);
  STMT_INIT(declare_select_func_no_check_stmt);
  STMT_INIT(declare_select_func_stmt);
  STMT_INIT(declare_value_cursor);
  STMT_INIT(declare_vars_type);
  STMT_INIT(delete_returning_stmt);
  STMT_INIT(delete_stmt);
  STMT_INIT(drop_index_stmt);
  STMT_INIT(drop_table_stmt);
  STMT_INIT(drop_trigger_stmt);
  STMT_INIT(drop_view_stmt);
  STMT_INIT(echo_stmt);
  STMT_INIT(emit_constants_stmt);
  STMT_INIT(emit_enums_stmt);
  STMT_INIT(emit_group_stmt);
  STMT_INIT(end_schema_region_stmt);
  STMT_INIT(enforce_normal_stmt);
  STMT_INIT(enforce_pop_stmt);
  STMT_INIT(enforce_push_stmt);
  STMT_INIT(enforce_reset_stmt);
  STMT_INIT(enforce_strict_stmt);
  STMT_INIT(explain_stmt);
  STMT_INIT(expr_stmt);
  STMT_INIT(fetch_call_stmt);
  STMT_INIT(fetch_stmt);
  STMT_INIT(fetch_values_stmt);
  STMT_INIT(for_stmt);
  STMT_INIT(guard_stmt);
  STMT_INIT(if_stmt);
  STMT_INIT(ifdef_stmt);
  STMT_INIT(ifndef_stmt);
  STMT_INIT(insert_stmt);
  STMT_INIT(insert_returning_stmt);
  STMT_INIT(leave_stmt);
  STMT_INIT(let_stmt);
  STMT_INIT(loop_stmt);
  STMT_INIT(stmt_list_macro_def);
  STMT_INIT(expr_macro_def);
  STMT_INIT(op_stmt);
  STMT_INIT(out_stmt);
  STMT_INIT(out_union_parent_child_stmt);
  STMT_INIT(out_union_stmt);
  STMT_INIT(previous_schema_stmt);
  STMT_INIT(proc_savepoint_stmt);
  STMT_INIT(query_parts_macro_def);
  STMT_INIT(release_savepoint_stmt);
  STMT_INIT(return_stmt);
  STMT_INIT(rollback_return_stmt);
  STMT_INIT(rollback_trans_stmt);
  STMT_INIT(savepoint_stmt);
  STMT_INIT(schema_ad_hoc_migration_stmt);
  STMT_INIT(schema_unsub_stmt);
  STMT_INIT(schema_upgrade_script_stmt);
  STMT_INIT(schema_upgrade_version_stmt);
  STMT_INIT(select_core_macro_def);
  STMT_INIT(select_expr_macro_def);
  STMT_INIT(select_nothing_stmt);
  STMT_INIT(select_stmt);
  STMT_INIT(set_from_cursor);
  STMT_INIT(switch_stmt);
  STMT_INIT(throw_stmt);
  STMT_INIT(trycatch_stmt);
  STMT_INIT(update_cursor_stmt);
  STMT_INIT(update_returning_stmt);
  STMT_INIT(update_stmt);
  STMT_INIT(upsert_returning_stmt);
  STMT_INIT(upsert_stmt);
  STMT_INIT(upsert_update);
  STMT_INIT(while_stmt);
  STMT_INIT(with_delete_stmt);
  STMT_INIT(with_insert_stmt);
  STMT_INIT(with_select_stmt);
  STMT_INIT(with_update_stmt);
  STMT_INIT(with_upsert_stmt);

  STMT_INIT(keep_table_name_in_aliases_stmt);

  EXPR_INIT(table_star, gen_expr_table_star, "T.*", EXPR_PRI_ROOT);
  EXPR_INIT(at_id, gen_expr_at_id, "@ID", EXPR_PRI_ROOT);
  EXPR_INIT(star, gen_expr_star, "*", EXPR_PRI_ROOT);
  EXPR_INIT(num, gen_expr_num, "NUM", EXPR_PRI_ROOT);
  EXPR_INIT(str, gen_expr_str, "STR", EXPR_PRI_ROOT);
  EXPR_INIT(blob, gen_expr_blob, "BLB", EXPR_PRI_ROOT);
  EXPR_INIT(null, gen_expr_null, "NULL", EXPR_PRI_ROOT);
  EXPR_INIT(dot, gen_expr_dot, ".", EXPR_PRI_REVERSE_APPLY);
  EXPR_INIT(macro_text, gen_expr_macro_text, "!", EXPR_PRI_ROOT);
  EXPR_INIT(const, gen_expr_const, "CONST", EXPR_PRI_ROOT);
  EXPR_INIT(bin_and, gen_binary, "&", EXPR_PRI_BINARY);
  EXPR_INIT(bin_or, gen_binary, "|", EXPR_PRI_BINARY);
  EXPR_INIT(lshift, gen_binary, "<<", EXPR_PRI_BINARY);
  EXPR_INIT(rshift, gen_binary, ">>", EXPR_PRI_BINARY);
  EXPR_INIT(mul, gen_binary, "*", EXPR_PRI_MUL);
  EXPR_INIT(div, gen_binary, "/", EXPR_PRI_MUL);
  EXPR_INIT(mod, gen_binary, "%", EXPR_PRI_MUL);
  EXPR_INIT(add, gen_binary, "+", EXPR_PRI_ADD);
  EXPR_INIT(sub, gen_binary, "-", EXPR_PRI_ADD);
  EXPR_INIT(not, gen_unary, "NOT ", EXPR_PRI_NOT);
  EXPR_INIT(tilde, gen_unary, "~", EXPR_PRI_TILDE);
  EXPR_INIT(collate, gen_binary, "COLLATE", EXPR_PRI_COLLATE);
  EXPR_INIT(uminus, gen_uminus, "-", EXPR_PRI_TILDE);
  EXPR_INIT(eq, gen_binary, "=", EXPR_PRI_EQUALITY);
  EXPR_INIT(lt, gen_binary, "<", EXPR_PRI_INEQUALITY);
  EXPR_INIT(gt, gen_binary, ">", EXPR_PRI_INEQUALITY);
  EXPR_INIT(ne, gen_binary, "<>", EXPR_PRI_INEQUALITY);
  EXPR_INIT(ge, gen_binary, ">=", EXPR_PRI_INEQUALITY);
  EXPR_INIT(le, gen_binary, "<=", EXPR_PRI_INEQUALITY);
  EXPR_INIT(expr_assign, gen_binary, ":=", EXPR_PRI_ASSIGN);
  EXPR_INIT(add_eq, gen_binary, "+=", EXPR_PRI_ASSIGN);
  EXPR_INIT(sub_eq, gen_binary, "-=", EXPR_PRI_ASSIGN);
  EXPR_INIT(mul_eq, gen_binary, "*=", EXPR_PRI_ASSIGN);
  EXPR_INIT(div_eq, gen_binary, "/=", EXPR_PRI_ASSIGN);
  EXPR_INIT(mod_eq, gen_binary, "%=", EXPR_PRI_ASSIGN);
  EXPR_INIT(or_eq, gen_binary, "|=", EXPR_PRI_ASSIGN);
  EXPR_INIT(and_eq, gen_binary, "&=", EXPR_PRI_ASSIGN);
  EXPR_INIT(rs_eq, gen_binary, ">>=", EXPR_PRI_ASSIGN);
  EXPR_INIT(ls_eq, gen_binary, "<<=", EXPR_PRI_ASSIGN);
  EXPR_INIT(array, gen_array, "[]", EXPR_PRI_REVERSE_APPLY);
  EXPR_INIT(call, gen_expr_call, "CALL", EXPR_PRI_ROOT);
  EXPR_INIT(window_func_inv, gen_expr_window_func_inv, "WINDOW-FUNC-INV", EXPR_PRI_ROOT);
  EXPR_INIT(raise, gen_expr_raise, "RAISE", EXPR_PRI_ROOT);
  EXPR_INIT(between, gen_expr_between, "BETWEEN", EXPR_PRI_BETWEEN);
  EXPR_INIT(not_between, gen_expr_not_between, "NOT BETWEEN", EXPR_PRI_BETWEEN);
  EXPR_INIT(and, gen_binary, "AND", EXPR_PRI_AND);
  EXPR_INIT(between_rewrite, gen_expr_between_rewrite, "BETWEEN", EXPR_PRI_BETWEEN);
  EXPR_INIT(or, gen_binary, "OR", EXPR_PRI_OR);
  EXPR_INIT(select_stmt, gen_expr_select, "SELECT", EXPR_PRI_ROOT);
  EXPR_INIT(select_if_nothing_throw_expr, gen_expr_select_if_nothing_throw, "IF NOTHING THEN THROW", EXPR_PRI_ROOT);
  EXPR_INIT(select_if_nothing_expr, gen_expr_select_if_nothing, "IF NOTHING THEN", EXPR_PRI_ROOT);
  EXPR_INIT(select_if_nothing_or_null_expr, gen_expr_select_if_nothing, "IF NOTHING OR NULL THEN", EXPR_PRI_ROOT);
  EXPR_INIT(select_if_nothing_or_null_throw_expr, gen_expr_select_if_nothing_throw, "IF NOTHING OR NULL THEN THROW", EXPR_PRI_ROOT);
  EXPR_INIT(with_select_stmt, gen_expr_select, "WITH...SELECT", EXPR_PRI_ROOT);
  EXPR_INIT(is, gen_binary, "IS", EXPR_PRI_EQUALITY);
  EXPR_INIT(is_not, gen_binary, "IS NOT", EXPR_PRI_EQUALITY);
  EXPR_INIT(is_true, gen_postfix, "IS TRUE", EXPR_PRI_EQUALITY);
  EXPR_INIT(is_false, gen_postfix, "IS FALSE", EXPR_PRI_EQUALITY);
  EXPR_INIT(is_not_true, gen_postfix, "IS NOT TRUE", EXPR_PRI_EQUALITY);
  EXPR_INIT(is_not_false, gen_postfix, "IS NOT FALSE", EXPR_PRI_EQUALITY);
  EXPR_INIT(like, gen_binary, "LIKE", EXPR_PRI_EQUALITY);
  EXPR_INIT(not_like, gen_binary, "NOT LIKE", EXPR_PRI_EQUALITY);
  EXPR_INIT(match, gen_binary, "MATCH", EXPR_PRI_EQUALITY);
  EXPR_INIT(not_match, gen_binary, "NOT MATCH", EXPR_PRI_EQUALITY);
  EXPR_INIT(regexp, gen_binary, "REGEXP", EXPR_PRI_EQUALITY);
  EXPR_INIT(not_regexp, gen_binary, "NOT REGEXP", EXPR_PRI_EQUALITY);
  EXPR_INIT(glob, gen_binary, "GLOB", EXPR_PRI_EQUALITY);
  EXPR_INIT(not_glob, gen_binary, "NOT GLOB", EXPR_PRI_EQUALITY);
  EXPR_INIT(in_pred, gen_expr_in_pred, "IN", EXPR_PRI_EQUALITY);
  EXPR_INIT(not_in, gen_expr_not_in, "NOT IN", EXPR_PRI_EQUALITY);
  EXPR_INIT(case_expr, gen_expr_case, "CASE", EXPR_PRI_ROOT);
  EXPR_INIT(exists_expr, gen_expr_exists, "EXISTS", EXPR_PRI_ROOT);
  EXPR_INIT(cast_expr, gen_expr_cast, "CAST", EXPR_PRI_ROOT);
  EXPR_INIT(type_check_expr, gen_expr_type_check, "TYPE_CHECK", EXPR_PRI_ROOT);
  EXPR_INIT(concat, gen_concat, "||", EXPR_PRI_CONCAT);
  EXPR_INIT(jex1, gen_jex1, "->", EXPR_PRI_CONCAT);
  EXPR_INIT(jex2, gen_jex2, "->>", EXPR_PRI_CONCAT);
  EXPR_INIT(reverse_apply, gen_binary_no_spaces, ":", EXPR_PRI_REVERSE_APPLY);
  EXPR_INIT(reverse_apply_poly_args, gen_binary_no_spaces, ":", EXPR_PRI_REVERSE_APPLY);
}

cql_export void gen_cleanup() {
  SYMTAB_CLEANUP(gen_stmts);
  SYMTAB_CLEANUP(gen_exprs);
  SYMTAB_CLEANUP(gen_macros);
  gen_output = NULL;
  gen_callbacks = NULL;
  used_alias_syms = NULL;
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// super simple linked list handlers


cql_noexport void add_item_to_list(list_item **head, struct ast_node *ast) {
  list_item *item = _ast_pool_new(list_item);
  item->next = *head;
  item->ast = ast;
  *head = item;
}

cql_noexport void reverse_list(list_item **head) {
  list_item *cur = *head;
  list_item *prev = NULL;
  list_item *next = NULL;

  while (cur) {
      next = cur->next;
      cur->next = prev;
      prev = cur;
      cur = next;
  }
  *head = prev;
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


#define MAX(a,b) ((a >b ) ? a : b)

// This is the stupidest pool allocator ever, it's only useful for cases where everything lives
// until the end.  Currently it's used to hold ast nodes and duplicated strings.  It may hold
// more.  The old CQL strategy was to just let exit clean up everything since we were only
// an executable and we can't free the tree until we're exiting anyway.  However there is some
// desire to use CQL in library form now which means it has to be able to do a compile and
// then end up clean.  To help with this we make these ultra-dumb pools that simply keep
// the allocated items together.  This means that we don't have to do zillions of seperate free
// calls when we're exiting.  It also helps with locality and fragmentation in the client.
// It's dumb as rocks.


// Make a pool node, set it's size to MINIBLOCK
cql_noexport void minipool_open(minipool **pool) {
  *pool = _new(minipool);
  (*pool)->bytes = malloc(MINIBLOCK);
  (*pool)->current = (*pool)->bytes;
  (*pool)->available = MINIBLOCK;
  (*pool)->next = NULL;
}

// Give back all the memory in the pool and nil out the pool pointer
// To accomplish this all we need to to is walk the chain of blocks
// freeing the bytes from each block as well as the minipool object.
cql_noexport void minipool_close(minipool **head) {
  minipool *pool = *head;
  while (pool) {
    minipool *next = pool->next;
    free(pool->bytes);
    free(pool);
    pool = next;
  }
  *head = NULL;
}

// Get needed memory; if the memory is not available then
// we allocate a new block and thread it into the list.  Note
// that this is different than the other CQL helper bytebuf.
// This allocation never moves bytes or copies bytes.  Once
// you get memory it is valid until you close the buffer.
// Bytebuf cannot hold pointers because the structure moves when it
// grows and it is one continuous allocation so it's only for byte streams.
// Minipool doesn't move objects around so pointers remain valid.
cql_noexport void *minipool_alloc(minipool *pool, uint32_t needed) {
  void *result;

  // for alignment, all allocs will be on a 8 byte boundary
  needed += 7;
  needed &= u32_not(7);

  if (needed > pool->available) {
    // Make a copy of the most recent head node and link to it
    // we have to do this because the head of the pool never
    // changes once it's created.  Note that none of the byte
    // buffers are copied, only the minipool struct.  Once
    // we've copied it, we re-initialize the minipool to a size
    // that is at least big enough for the next allocation.
    minipool *old = malloc(sizeof(minipool));
    *old = *pool;
    uint32_t blocksize = MAX(needed, MINIBLOCK);
    pool->bytes = malloc(blocksize);
    pool->current = pool->bytes;
    pool->available = blocksize;
    pool->next = old;
  }

  // For sure safe to get the memory now, so get it.Ï€
  result = pool->current;
  pool->current += needed;
  pool->available -= needed;
  return result;
}

static lazy_free *_Nullable lazy_frees;

cql_noexport void add_lazy_free(lazy_free *p) {
  p->next = lazy_frees;
  lazy_frees = p;
}

cql_noexport void run_lazy_frees() {
  lazy_free *head = lazy_frees;
  while (head) {
    lazy_free *next = head->next;
    head->teardown(head->context);
    free(head);
    head = next;
  }
  lazy_frees = NULL;
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// stubs to avoid link errors (none needed)

#else


// Declares the single-character C string `name` given a character `c`.
#define CSTR_OF_CHAR(name, c) \
  char name[2] = {0}; \
  name[0] = c;

// There are seven options flags that can be associated with a substitution in a
// SQLite format string.
typedef enum {
  PRINTF_FLAGS_NONE  = 0,
  PRINTF_FLAGS_MINUS = 1 << 0,
  PRINTF_FLAGS_PLUS  = 1 << 1,
  PRINTF_FLAGS_SPACE = 1 << 2,
  PRINTF_FLAGS_ZERO  = 1 << 3,
  PRINTF_FLAGS_HASH  = 1 << 4,
  PRINTF_FLAGS_COMMA = 1 << 5,
  PRINTF_FLAGS_BANG  = 1 << 6,
} printf_flags;

// Parsing a format string involves the use of a state machine with the
// following states. The name of each state indicates what we're looking for
// next, e.g., the start of a substitution, a percent sign following the start
// ('%%'), a flag, a width specification, et cetera.
typedef enum {
  PRINTF_STATE_START,
  PRINTF_STATE_PERCENT,
  PRINTF_STATE_FLAG,
  PRINTF_STATE_WIDTH,
  PRINTF_STATE_WIDTH_NUMERIC,
  PRINTF_STATE_DOT,
  PRINTF_STATE_PRECISION,
  PRINTF_STATE_LENGTH_LONG,
  PRINTF_STATE_LENGTH_LONG_LONG,
  PRINTF_STATE_TYPE,
} printf_state;

// A width in SQLite can be either numeric or '*'. In the latter case, two
// arguments are required for the substition, the first of which will be the
// width.
typedef enum {
  PRINTF_WIDTH_NONE,
  PRINTF_WIDTH_NUMERIC,
  PRINTF_WIDTH_STAR,
} printf_width;

// A length specifier can be absent (indicating the default, 32-bit length), 'l'
// (which does nothing in SQLite and therefore also indicates 32 bits), or 'll'
// (indicating 64 bits).
typedef enum {
  PRINTF_LENGTH_DEFAULT,
  PRINTF_LENGTH_LONG,
  PRINTF_LENGTH_LONG_LONG,
} printf_length;

struct printf_iterator {
  // The AST to use for error reporting. This should be the string literal
  // `ast_node` itself so that problems with the format string are reported with
  // the correct location.
  ast_node *ast;
  // The flags associated with the current substitution.
  printf_flags flags;
  // A pointer into the null-terminated format string that is being parsed. This
  // string must NOT simply be the string extracted from the `ast_node`, but
  // rather a decoded version without the leading and trailing quotes.
  CSTR format_string;
  // The length associated with the current substitution.
  printf_length length;
  // The core type associated with the type specifier of the current
  // substitution (e.g., `SEM_TYPE_INTEGER`), `SEM_TYPE_PENDING` if we're
  // currently in the middle of parsing a substitution, `SEM_TYPE_OK` if we've
  // finished parsing the format string successfully, or `SEM_TYPE_ERROR` if we
  // encountered an error. In the lattermost two cases, the iterator is finished
  // and `printf_iterator_next` must not be called again.
  sem_t sem_type;
  // The current state of parsing for the current substitution.
  printf_state state;
  // The width associated with the current substitution.
  printf_width width;
};

// We need to provide `sizeof_printf_iterator` because `printf_iterator` is
// abstract in the header.
size_t sizeof_printf_iterator = sizeof(printf_iterator);

// Initializes a `printf_iterator`.
cql_noexport void printf_iterator_init(printf_iterator *iterator, ast_node *format_strlit, CSTR format_string) {
  Contract(!format_strlit || is_strlit(format_strlit));

  iterator->ast = format_strlit;
  iterator->flags = PRINTF_FLAGS_NONE;
  iterator->format_string = format_string;
  iterator->length = PRINTF_LENGTH_DEFAULT;
  iterator->sem_type = SEM_TYPE_PENDING;
  iterator->state = PRINTF_STATE_START;
  iterator->width = PRINTF_WIDTH_NONE;
}

// Given a character, returns the associated flag (or `PRINTF_FLAGS_NONE` if the
// character does not correspond to a flag).
static printf_flags printf_flag_of_char(char c) {
  switch (c) {
    case '-':
      return PRINTF_FLAGS_MINUS;
    case '+':
      return PRINTF_FLAGS_PLUS;
    case ' ':
      return PRINTF_FLAGS_SPACE;
    case '0':
      return PRINTF_FLAGS_ZERO;
    case '#':
      return PRINTF_FLAGS_HASH;
    case ',':
      return PRINTF_FLAGS_COMMA;
    case '!':
      return PRINTF_FLAGS_BANG;
    default:
      return PRINTF_FLAGS_NONE;
  }
}

// Indicates an error in the format string and sets `SEM_TYPE_ERROR`.
static void printf_iterator_error(printf_iterator *iterator, CSTR msg, CSTR subject) {
  if (iterator->ast) {
    report_error(iterator->ast, msg, subject);
    record_error(iterator->ast);
  }
  iterator->sem_type = SEM_TYPE_ERROR;
}

// Returns `true` if the character corresponds to one of the seven possible
// flags, else `false`.
static bool_t printf_is_flag_char(char c) {
  return printf_flag_of_char(c) != PRINTF_FLAGS_NONE;
}

// Records that a character corresponding to one of the seven possible flags is
// associated with the current substituion. This must not be called with a
// character that does not correspond to a flag. Sets `SEM_TYPE_ERROR` if the
// flag character is a duplicate or if there is an invalid combination of flags.
static void printf_iterator_add_flag_char(printf_iterator *iterator, char c) {
  Contract(iterator);
  Contract(iterator->sem_type == SEM_TYPE_PENDING);
  Contract(iterator->state == PRINTF_STATE_FLAG);

  printf_flags flag = printf_flag_of_char(c);
  Invariant(flag != PRINTF_FLAGS_NONE);

  if (iterator->flags & flag) {
    CSTR_OF_CHAR(flag_string, c);
    printf_iterator_error(iterator, "CQL0411: duplicate flag in substitution", flag_string);
    return;
  }

  printf_flags plus_or_space = PRINTF_FLAGS_PLUS | PRINTF_FLAGS_SPACE;
  if ((iterator->flags & plus_or_space) && (flag & plus_or_space)) {
    // We already had a plus or space, and we just got a plus or space, and we
    // know the one we just got is not a duplicate of what we already had
    // because we just checked, so now we have both.
    printf_iterator_error(iterator, "CQL0412: cannot combine '+' flag with space flag", NULL);
    return;
  }

  iterator->flags |= flag;
}

// Records the width specifier for the current substition. Sets `SEM_TYPE_ERROR`
// if the substitution has no width but one is required for a previously
// recorded flag to make sense.
static void printf_set_width(printf_iterator *iterator, printf_width width) {
  Contract(iterator);
  Contract(iterator->sem_type == SEM_TYPE_PENDING);
  Contract(iterator->state == PRINTF_STATE_WIDTH);
  Contract(iterator->width == PRINTF_WIDTH_NONE);

  switch (width) {
    case PRINTF_WIDTH_NONE:
      if ((iterator->flags & (PRINTF_FLAGS_MINUS | PRINTF_FLAGS_ZERO))) {
        CSTR flag_string = (iterator->flags & PRINTF_FLAGS_MINUS) ? "-" : "0";
        printf_iterator_error(iterator, "CQL0413: width required when using flag in substitution", flag_string);
        return;
      }
      break;
    case PRINTF_WIDTH_NUMERIC:
      break;
    case PRINTF_WIDTH_STAR:
      break;
  }

  iterator->width = width;
}

// Sets the length specifier for the current substitution. Sets `SEM_TYPE_ERROR`
// if the specifier is `PRINTF_STATE_LENGTH_LONG` (as 'l' serves no purpose in
// SQLite) or if a length specifier has been combined with a flag that doesn't
// make sense with a length specifier.
static void printf_set_length(printf_iterator *iterator, printf_length length) {
  Contract(iterator);
  Contract(iterator->sem_type == SEM_TYPE_PENDING);
  Contract(iterator->state == PRINTF_STATE_LENGTH_LONG || iterator->state == PRINTF_STATE_LENGTH_LONG_LONG);

  switch (length) {
    case PRINTF_LENGTH_DEFAULT:
      break;
    case PRINTF_LENGTH_LONG:
      printf_iterator_error(iterator, "CQL0414: 'l' length specifier has no effect; consider 'll' instead", NULL);
      return;
    case PRINTF_LENGTH_LONG_LONG:
      if ((iterator->flags & PRINTF_FLAGS_BANG)) {
        printf_iterator_error(iterator, "CQL0415: length specifier cannot be combined with '!' flag", NULL);
        return;
      }
      break;
  }

  iterator->length = length;
}

// Sets the type specifier associated with the character provided for the
// current substitution. Sets `SEM_TYPE_ERROR` if the type specifier is not
// compatible with the previously recorded flags or length specifier, or if the
// type specifier is not allowed in CQL, or if the character provided does not
// correspond to any type specifier.
static void printf_iterator_set_type_char(printf_iterator *iterator, char c) {
  Contract(iterator);
  Contract(iterator->sem_type == SEM_TYPE_PENDING);
  Contract(iterator->state == PRINTF_STATE_TYPE);

  CSTR_OF_CHAR(type_string, c);

  // '-' works with all possible type specifications.
  printf_flags valid_flags = PRINTF_FLAGS_MINUS;
  bool_t allows_length_specifier;

  switch (c) {
    case 'd': case 'i': {
      allows_length_specifier = true;
      valid_flags |= PRINTF_FLAGS_PLUS;
      valid_flags |= PRINTF_FLAGS_SPACE;
      valid_flags |= PRINTF_FLAGS_ZERO;
      valid_flags |= PRINTF_FLAGS_COMMA;
      if (iterator->length == PRINTF_LENGTH_LONG_LONG) {
        iterator->sem_type = SEM_TYPE_LONG_INTEGER;
      }
      else {
        iterator->sem_type = SEM_TYPE_INTEGER;
      }
      break;
    }
    case 'u':
      allows_length_specifier = true;
      valid_flags |= PRINTF_FLAGS_ZERO;
      if (iterator->length == PRINTF_LENGTH_LONG_LONG) {
        iterator->sem_type = SEM_TYPE_LONG_INTEGER;
      }
      else {
        iterator->sem_type = SEM_TYPE_INTEGER;
      }
      break;
    case 'f': case 'e': case 'E': case 'g': case 'G':
      allows_length_specifier = false;
      valid_flags |= PRINTF_FLAGS_ZERO;
      valid_flags |= PRINTF_FLAGS_BANG;
      valid_flags |= PRINTF_FLAGS_HASH;
      iterator->sem_type = SEM_TYPE_REAL;
      break;
    case 'x': case 'X': case 'o':
      allows_length_specifier = true;
      valid_flags |= PRINTF_FLAGS_ZERO;
      valid_flags |= PRINTF_FLAGS_HASH;
      if (iterator->length == PRINTF_LENGTH_LONG_LONG) {
        iterator->sem_type = SEM_TYPE_LONG_INTEGER;
      }
      else {
        iterator->sem_type = SEM_TYPE_INTEGER;
      }
      break;
    case 's':
      allows_length_specifier = false;
      valid_flags |= PRINTF_FLAGS_BANG;
      iterator->sem_type = SEM_TYPE_TEXT;
      break;
    case 'c': case 'z': case 'p': case 'n': case 'q': case 'Q': case 'w': {
      // NOTE: 'c' could be supported with codegen changes. It is presently
      // disallowed because it requires a TEXT argument when used in an SQL
      // context, yet it requires an integer argument when used via
      // `sqlite3_mprintf`. The code generator currently cannot handle the
      // latter case correctly.
      printf_iterator_error(iterator, "CQL0416: type specifier not allowed in CQL", type_string);
      return;
    }
    default:
      printf_iterator_error(iterator, "CQL0417: unrecognized type specifier", type_string);
      return;
  }

  if ((iterator->flags | valid_flags) != valid_flags) {
    printf_iterator_error(iterator, "CQL0418: type specifier combined with inappropriate flags", type_string);
    return;
  }

  if (iterator->length != PRINTF_LENGTH_DEFAULT && !allows_length_specifier) {
    printf_iterator_error(iterator, "CQL0419: type specifier cannot be combined with length specifier", type_string);
    return;
  }
}

// Resets the iterator after successfully parsing one substitution to prepare
// for the next call to `printf_iterator_next`. This must not be called if in
// the middle of a substitution with a '*' width specifier;
// `printf_iterator_suspend_for_star` should be used instead.
static void printf_iterator_reset(printf_iterator *iterator) {
  Contract(iterator);
  Contract(iterator->state == PRINTF_STATE_TYPE);
  Contract(iterator->sem_type != SEM_TYPE_ERROR);
  Contract(iterator->sem_type != SEM_TYPE_OK);
  Contract(iterator->sem_type != SEM_TYPE_PENDING);

  iterator->flags = PRINTF_FLAGS_NONE;
  iterator->format_string++;
  iterator->length = PRINTF_LENGTH_DEFAULT;
  iterator->sem_type = SEM_TYPE_PENDING;
  iterator->state = PRINTF_STATE_START;
  iterator->width = PRINTF_WIDTH_NONE;
}

// Prepares the iterator for the next call to `printf_iterator_next` after
// encountering a '*' width specifier.
static void printf_iterator_suspend_for_star(printf_iterator *iterator) {
  Contract(iterator);
  Contract(iterator->state == PRINTF_STATE_WIDTH);
  Contract(iterator->width == PRINTF_WIDTH_NONE);
  Contract(*iterator->format_string == '*');

  // The '*' width requires two arguments for the substitution instead of one,
  // the first of which will be the width. For example, the following two uses
  // of printf are equivalent:
  //
  //   printf("%10d\n", 42);
  //   printf("%*d\n, 10, 42);
  //
  // It therefore follows that we need to return the fact that we need an
  // integer, and then be ready to resume parsing the rest of the current
  // substitution later.
  printf_set_width(iterator, PRINTF_WIDTH_STAR);
  // Setting the width to `PRINTF_WIDTH_STAR` cannot fail.
  Invariant(iterator->sem_type != SEM_TYPE_ERROR);
  // We'll resume looking for a dot after the star.
  iterator->state = PRINTF_STATE_DOT;
  // Consume the '*' character.
  iterator->format_string++;
}

// Returns the type of the next substitution, else `SEM_TYPE_OK` if no
// substitutions remain or `SEM_TYPE_ERROR` in the case of an error.
cql_noexport sem_t printf_iterator_next(printf_iterator *iterator) {
  Contract(iterator);
  Contract(iterator->sem_type == SEM_TYPE_PENDING);
  // We should either be at the start of a substituion or resuming a
  // substitution with a '*' width specifier.
  Contract(iterator->state == PRINTF_STATE_START || iterator->width == PRINTF_WIDTH_STAR);

  for (;;) {
    // If we encountered an error or hit the end of the string, stop.
    if (iterator->sem_type != SEM_TYPE_PENDING) {
      return iterator->sem_type;
    }

    // Read the current character in the format string.
    char c = *iterator->format_string;

    // Check if we're at the end of the string. If so, stop.
    if (c == '\0') {
      if (iterator->state == PRINTF_STATE_START) {
        // We hit the end while not within a substitution, so we're simply done.
        iterator->sem_type = SEM_TYPE_OK;
      }
      else {
        // We hit the end in the middle of a substitution, so the substitution
        // is incomplete and the format string is invalid.
        printf_iterator_error(iterator, "CQL0420: incomplete substitution in format string", NULL);
      }
      return iterator->sem_type;
    }

    // Here, we dispatch appropriately based on the current state. If the
    // current character should be consumed, we `break` to jump out of the
    // switch and advance the string to the next character at the end of the for
    // loop. If we want to go onto another step without consuming the current
    // character, we `continue` instead to jump back to the top of the for loop
    // without advancing the string.
    switch (iterator->state) {
      case PRINTF_STATE_START:
        if (c == '%') {
          iterator->state = PRINTF_STATE_PERCENT;
        }
        break;
      case PRINTF_STATE_PERCENT:
        if (c == '%') {
          iterator->state = PRINTF_STATE_START;
          break;
        }
        iterator->state = PRINTF_STATE_FLAG;
        continue;
      case PRINTF_STATE_FLAG:
        if (printf_is_flag_char(c)) {
          printf_iterator_add_flag_char(iterator, c);
          break;
        }
        iterator->state = PRINTF_STATE_WIDTH;
        continue;
      case PRINTF_STATE_WIDTH:
        if (c >= '0' && c <= '9') {
          printf_set_width(iterator, PRINTF_WIDTH_NUMERIC);
          iterator->state = PRINTF_STATE_WIDTH_NUMERIC;
          break;
        }
        if (c == '*') {
          // Return the fact that we need an integer and prepare to resume
          // parsing the rest of the substitution later.
          printf_iterator_suspend_for_star(iterator);
          return SEM_TYPE_INTEGER;
        }
        printf_set_width(iterator, PRINTF_WIDTH_NONE);
        iterator->state = PRINTF_STATE_DOT;
        continue;
      case PRINTF_STATE_WIDTH_NUMERIC:
        if (c >= '0' && c <= '9') {
          break;
        }
        iterator->state = PRINTF_STATE_DOT;
        continue;
      case PRINTF_STATE_DOT:
        if (c == '.') {
          iterator->state = PRINTF_STATE_PRECISION;
          break;
        }
        iterator->state = PRINTF_STATE_LENGTH_LONG;
        continue;
      case PRINTF_STATE_PRECISION:
        if (c >= '0' && c <= '9') {
          break;
        }
        iterator->state = PRINTF_STATE_LENGTH_LONG;
        continue;
      case PRINTF_STATE_LENGTH_LONG:
        if (c == 'l') {
          iterator->state = PRINTF_STATE_LENGTH_LONG_LONG;
          break;
        }
        printf_set_length(iterator, PRINTF_LENGTH_DEFAULT);
        iterator->state = PRINTF_STATE_TYPE;
        continue;
      case PRINTF_STATE_LENGTH_LONG_LONG:
        if (c == 'l') {
          printf_set_length(iterator, PRINTF_LENGTH_LONG_LONG);
          iterator->state = PRINTF_STATE_TYPE;
          break;
        }
        printf_set_length(iterator, PRINTF_LENGTH_LONG);
        iterator->state = PRINTF_STATE_TYPE;
        continue;
      case PRINTF_STATE_TYPE:
        printf_iterator_set_type_char(iterator, c);
        sem_t sem_type = iterator->sem_type;
        if (sem_type != SEM_TYPE_ERROR) {
          printf_iterator_reset(iterator);
        }
        return sem_type;
    }

    // Consume the current character and continue.
    iterator->format_string++;
  }
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


// note the @ is split from the generated so that tools don't think this is a generated file
#define RT_AUTOGEN(x) x " @" "generated S" "ignedSource<<deadbeef8badf00ddefec8edfacefeed>>\n"

// These are the various result types we can produce
// they include useful string fragments for the code generator

static rtdata rt_c = {
  .name = "c",
  .code_generator = &cg_c_main,
  .required_file_names_count = -1,
  .header_prefix =
    RT_AUTOGEN("//")
    "#pragma once\n\n",
  .cqlrt_template = "#include \"%s\"\n\n",
  .cqlrt = "cqlrt.h",
  .header_wrapper_begin = "",
  .header_wrapper_end = "",
  .source_prefix =
    RT_AUTOGEN("//") "\n",
  .source_wrapper_begin = "",
  .source_wrapper_end = "",
  .exports_prefix =
    RT_AUTOGEN("--") "\n",
  .symbol_case = cg_symbol_case_snake,
  .generate_equality_macros = 1,
  .symbol_prefix = "",
  .symbol_visibility = "extern ",
};

static rtdata rt_lua = {
  .name = "lua",
  .code_generator = &cg_lua_main,
  .required_file_names_count = 1,
  .header_prefix = "",
  .cqlrt_template = "require(\"%s\")\n\n",
  .cqlrt = "cqlrt",
  .header_wrapper_begin = "",
  .header_wrapper_end = "",
  .source_prefix =
    RT_AUTOGEN("--") "\n",
  .source_wrapper_begin = "",
  .source_wrapper_end = "",
  .exports_prefix = "",
  .symbol_case = cg_symbol_case_snake,
  .generate_equality_macros = 1,
  .symbol_prefix = ""
};

static rtdata rt_schema_upgrade = {
  .name = "schema_upgrade",
  .code_generator = &cg_schema_upgrade_main,
  .required_file_names_count = 1,
  .source_prefix =
    RT_AUTOGEN("--") "\n",
  .symbol_case = cg_symbol_case_camel,
};

static rtdata rt_schema_sqlite = {
  .name = "schema_sqlite",
  .code_generator = &cg_schema_sqlite_main,
  .required_file_names_count = 1,
  .source_prefix =
    RT_AUTOGEN("--") "\n",
  .symbol_case = cg_symbol_case_camel,
};

static rtdata rt_schema = {
  .name = "schema",
  .code_generator = &cg_schema_main,
  .required_file_names_count = 1,
  .source_prefix =
    RT_AUTOGEN("--") "\n",
  .symbol_case = cg_symbol_case_camel,
};

static rtdata rt_json_schema = {
  .name = "json_schema",
  .code_generator = &cg_json_schema_main,
  .required_file_names_count = 1,
  .source_prefix = "",
  .symbol_case = cg_symbol_case_camel,
};

static rtdata rt_test_helpers = {
  .name = "test_helpers",
  .code_generator = &cg_test_helpers_main,
  .required_file_names_count = 1,
  .source_prefix =
    RT_AUTOGEN("--") "\n",
};

static rtdata rt_query_plan = {
  .name = "query_plan",
  .code_generator = &cg_query_plan_main,
  .required_file_names_count = 1,
  .source_prefix =
    RT_AUTOGEN("--") "\n",
};

static rtdata rt_stats = {
  .name = "stats",
  .code_generator = &cg_stats_main,
  .required_file_names_count = 1,
};

static rtdata *(rt_all[]) = {
  &rt_c,
  &rt_lua,
  &rt_schema_upgrade,
  &rt_schema_sqlite,
  &rt_schema,
  &rt_json_schema,
  &rt_test_helpers,
  &rt_query_plan,
  &rt_stats,
  NULL,
};

cql_noexport rtdata *find_rtdata(CSTR name) {
  rt_cleanup();

  int32_t i = 0;
  rtdata *rt_ = NULL;
  while ((rt_ = rt_all[i])) {
    if (!strcmp(rt_->name, name)) {
       break;
    }
    i++;
  }

  return rt_;
}

cql_noexport void rt_cleanup() {
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// stubs to avoid link errors (none needed)

#else

// Most of the functions that rewrite the AST have been hoisted out of sem.c and are here
// Rewrites always happen during semantic analysis so this is really part of that phase.


static ast_node *rewrite_gen_iif_case_expr(ast_node *expr, ast_node *val1, ast_node *val2);
static bool_t rewrite_one_def(ast_node *head);
static void rewrite_one_typed_name(ast_node *typed_name, symtab *used_names);
static void rewrite_from_shape_args(ast_node *head);

// To do this rewrite we only need to check a few things:
//  * is the given name really a shape
//  * does the shape have storage (i.e. SEM_TYPE_HAS_SHAPE_STORAGE is set)
//  * were enough fields specified?
//  * were any fields requested?  [e.g. FETCH C() FROM CURSOR is meaningless]
//
// If the above conditions are met then we're basically good to go. For each column specified
// e.g. FETCH C(a,b) has two; we will take the next shape columns and add it an automatically
// created values list.  At the end the AST will be transformed into
//   FETCH C(a,b, etc.) FROM VALUES(D.col1, D.col2, etc.)
// and it can then be type checked as usual.
//
cql_noexport void rewrite_insert_list_from_shape(ast_node *ast, ast_node *from_shape, uint32_t count) {
  Contract(is_ast_columns_values(ast));
  Contract(is_ast_from_shape(from_shape));
  Contract(count > 0);
  EXTRACT_ANY_NOTNULL(shape, from_shape->right);

  // from_shape must have the columns
  if (!(shape->sem->sem_type & SEM_TYPE_HAS_SHAPE_STORAGE)) {
    report_error(shape, "CQL0298: cannot read from a cursor without fields", shape->sem->name);
    record_error(shape);
    record_error(ast);
    return;
  }

  EXTRACT_ANY_NOTNULL(column_spec, from_shape->left);
  EXTRACT_ANY(name_list, column_spec->left);

  uint32_t provided_count = 0;
  for (ast_node *item = name_list; item; item = item->right) {
    provided_count++;
  }

  if (provided_count < count) {
    report_error(ast, "CQL0299: [shape] has too few fields", shape->sem->name);
    record_error(ast);
    return;
  }

  AST_REWRITE_INFO_SET(shape->lineno, shape->filename);

  ast_node *insert_list = NULL;
  ast_node *insert_list_tail = NULL;

  ast_node *item = name_list;

  for (uint32_t i = 0; i < count; i++, item = item->right) {
    EXTRACT_STRING(item_name, item->left);
    ast_node *cname = new_maybe_qstr(shape->sem->name);
    ast_node *col = new_maybe_qstr(item_name);
    ast_node *dot = new_ast_dot(cname, col);

    // add name to the name list
    ast_node *new_tail = new_ast_insert_list(dot, NULL);

    if (insert_list) {
      ast_set_right(insert_list_tail, new_tail);
    }
    else {
      insert_list = new_tail;
    }

    insert_list_tail = new_tail;
  }

  AST_REWRITE_INFO_RESET();

  // the tree is rewritten, semantic analysis can proceed
  ast_set_right(ast, insert_list);

  // temporarily mark the ast ok, there is more checking to do
  record_ok(ast);
}

// The form "LIKE x" can appear in most name lists instead of a list of names
// the idea here is that if you want to use the columns of a shape
// for the data you don't want to specify the columns manually, you'd like
// to get them from the type information.  So for instance:
// INSERT INTO T(like C) values(C.x, C.y) is better than
// INSERT INTO T(x,y) values(C.x, C.y), but better still
// INSERT INTO T(like C) from C;
//
// This is sugar, so the code gen system never sees the like form.
// The rewrite is semantically checked as usual so you get normal errors
// if the column types are not compatible.
//
// There are good helpers for creating the name list and for finding
// the likeable object.  So we just use those for all the heavy lifting.
cql_noexport void rewrite_like_column_spec_if_needed(ast_node *columns_values) {
  Contract(is_ast_columns_values(columns_values) || is_ast_from_shape(columns_values));
  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT_ANY(shape_def, column_spec->left);

  if (is_ast_shape_def(shape_def)) {
     ast_node *found_shape = sem_find_shape_def(shape_def, LIKEABLE_FOR_VALUES);
     if (!found_shape) {
       record_error(columns_values);
       return;
     }

     AST_REWRITE_INFO_SET(shape_def->lineno, shape_def->filename);

     sem_struct *sptr = found_shape->sem->sptr;
     ast_node *name_list = rewrite_gen_full_column_list(sptr);
     ast_set_left(column_spec, name_list);

     AST_REWRITE_INFO_RESET();
  }

  record_ok(columns_values);
}

// FROM [shape] is a sugar feature, this is the place where we trigger rewriting of the AST
// to replace FROM [shape] with normal values from the shape
//  * Note: By this point column_spec has already  been rewritten so that it is for sure not
//    null if it was absent.  It will be an empty name list.
// All we're doing here is setting up the call to the worker using the appropriate AST args
cql_noexport void rewrite_from_shape_if_needed(ast_node *ast_stmt, ast_node *columns_values)
{
  Contract(ast_stmt); // we can record the error on any statement
  Contract(is_ast_columns_values(columns_values));
  EXTRACT_NOTNULL(column_spec, columns_values->left);

  if (!is_ast_from_shape(columns_values->right)) {
    record_ok(ast_stmt);
    return;
  }

  uint32_t count = 0;
  for (ast_node *item = column_spec->left; item; item = item->right) {
    count++;
  }

  if (count == 0) {
    report_error(columns_values->right, "CQL0297: FROM [shape] is redundant if column list is empty", NULL);
    record_error(ast_stmt);
    return;
  }

  EXTRACT_NOTNULL(from_shape, columns_values->right);
  EXTRACT_ANY_NOTNULL(shape, from_shape->right);

  sem_any_shape(shape);
  if (is_error(shape)) {
    record_error(ast_stmt);
    return;
  }

  // Now we're going to go a bit meta, the from [shape] clause itself has a column
  // list we might need to rewrite THAT column list before we can proceed.
  // The from [shape] column list could be empty
  sem_struct *sptr = shape->sem->sptr;
  rewrite_empty_column_list(from_shape, sptr);

  rewrite_like_column_spec_if_needed(from_shape);
  if (is_error(from_shape)) {
    record_error(ast_stmt);
    return;
  }

  rewrite_insert_list_from_shape(columns_values, from_shape, count);
  if (is_error(columns_values)) {
    record_error(ast_stmt);
    return;
  }

  // temporarily mark the ast ok, there is more checking to do
  // record_ok(ast_stmt);
  record_ok(ast_stmt);
}

// Here we will rewrite the arguments in a call statement expanding any
// FROM [shape] [LIKE type ] entries we encounter.  We don't validate
// the types here.  That happens after expansion.  It's possible that the
// types don't match at all, but we don't care yet.
static void rewrite_from_shape_args(ast_node *head) {
  Contract(is_ast_expr_list(head) || is_ast_arg_list(head) || is_ast_insert_list(head));

  // We might need to make arg_list nodes, insert_list nodes, or expr_list nodes, they are the
  // same really so we'll change the node type to what we need.  We just stash what
  // the first item was and make any that we create the same as this one.
  CSTR node_type = head->type;

  for (ast_node *item = head ; item ; item = item->right) {
    EXTRACT_ANY_NOTNULL(arg, item->left);
    if (is_ast_from_shape(arg)) {
      EXTRACT_ANY_NOTNULL(shape, arg->left);

      // Note if this shape has no storage (e.g. non automatic cursor) then we will fail later
      // when we try to resolve the '.' expression.  That error message tells the story well enough
      // so we don't need an extra check here.
      sem_any_shape(shape);
      if (is_error(shape)) {
        record_error(head);
        return;
      }

      ast_node *shape_def = arg->right;
      ast_node *likeable_shape = NULL;

      if (shape_def) {
          likeable_shape = sem_find_shape_def(shape_def, LIKEABLE_FOR_VALUES);
          if (!likeable_shape) {
            record_error(head);
            return;
          }
      }

      AST_REWRITE_INFO_SET(shape->lineno, shape->filename);

      // use the names from the LIKE clause if there is one, otherwise use
      // all the names in the shape.
      sem_struct *sptr = likeable_shape ? likeable_shape->sem->sptr : shape->sem->sptr;
      uint32_t count = sptr->count;

      for (uint32_t i = 0; i < count; i++) {
        ast_node *cname = new_maybe_qstr(shape->sem->name);
        ast_node *col = new_str_or_qstr(sptr->names[i], sptr->semtypes[i]);
        ast_node *dot = new_ast_dot(cname, col);

        if (i == 0) {
          // the first item just replaces the FROM cursor node
          ast_set_left(item, dot);
        }
        else {
          // subsequent items are threaded after our current position
          // we leave arg_list pointed to the end of what we inserted
          ast_node *right = item->right;
          ast_node *new_item = new_ast_expr_list(dot, right);
          new_item->type = node_type;
          ast_set_right(item, new_item);
          item = new_item;
        }
      }

      AST_REWRITE_INFO_RESET();
    }
  }

  // at least provisionally ok
  record_ok(head);
}

// Walk the list of column definitions looking for any of the
// "LIKE table/proc/view". If any are found, replace that parameter with
// the table/prov/view columns
cql_noexport bool_t rewrite_col_key_list(ast_node *head) {
  for (ast_node *ast = head; ast; ast = ast->right) {
    Contract(is_ast_col_key_list(ast));

    if (is_ast_shape_def(ast->left)) {
      bool_t success = rewrite_one_def(ast);
      if (!success) {
        return false;
      }
    }
  }

  return true;
}

// There is a LIKE [table/view/proc] used to create a table so we
// - Look up the parameters to the table/view/proc
// - Create a col_def node for each field of the table/view/proc
// - Reconstruct the ast
cql_noexport bool_t rewrite_one_def(ast_node *head) {
  Contract(is_ast_col_key_list(head));
  EXTRACT_NOTNULL(shape_def, head->left);

  // it's ok to use the LIKE construct on old tables
  ast_node *likeable_shape = sem_find_shape_def(shape_def, LIKEABLE_FOR_VALUES);
  if (!likeable_shape) {
    record_error(head);
    return false;
  }

  AST_REWRITE_INFO_SET(shape_def->lineno, shape_def->filename);

  // Store the remaining nodes while we reconstruct the AST
  EXTRACT_ANY(right_ast, head->right);

  sem_struct *sptr = likeable_shape->sem->sptr;
  uint32_t count = sptr->count;

  for (uint32_t i = 0; i < count; i++) {
    sem_t sem_type = sptr->semtypes[i];
    CSTR col_name = sptr->names[i];

    // Construct a col_def using name and core semantic type
    ast_node *data_type = rewrite_gen_data_type(core_type_of(sem_type), NULL);
    ast_node *name_ast = new_str_or_qstr(col_name, sem_type);
    ast_node *name_type = new_ast_col_def_name_type(name_ast, data_type);

    // In the case of columns the ast has col attributes to represent
    // not null and sensitive so we add those after we've already
    // added the basic data type above
    ast_node *attrs = NULL;
    if (is_not_nullable(sem_type)) {
      attrs = new_ast_col_attrs_not_null(NULL, NULL);
    }

    if (sensitive_flag(sem_type)) {
      // link it in, in case not null was also in play
      attrs = new_ast_sensitive_attr(NULL, attrs);
    }

    ast_node *col_def_type_attrs = new_ast_col_def_type_attrs(name_type, attrs);
    ast_node *col_def = new_ast_col_def(col_def_type_attrs, NULL);

    if (i) {
      ast_node *new_head = new_ast_col_key_list(col_def, NULL);
      ast_set_right(head, new_head);
      head = new_head;
    }
    else {
      Invariant(is_ast_col_key_list(head));
      Invariant(is_ast_shape_def(head->left));

      // replace the shape def entry with a col_def
      // on the next iteration, we will insert to the right of ast
      ast_set_right(head, NULL);
      ast_set_left(head, col_def);
    }
  }

  AST_REWRITE_INFO_RESET();

  // Put the stored columns at the 'tail' of the linked list
  ast_set_right(head, right_ast);
  return true;
}

// Give the best name for the shape type given then AST
// there are many casese, the best data is on the struct type unless
// it's anonymous, in which case the item name is the best choice.
CSTR static best_shape_type_name(ast_node *shape) {
  Contract(shape->sem);
  Contract(shape->sem->sptr);

  CSTR struct_name = shape->sem->sptr->struct_name;
  CSTR obj_name = shape->sem->name;

  // "_select_" is the generic name used for structs that are otherwise unnamed.
  // e.g.  "declare C cursor like select 1 x, 2 y"
  if (struct_name && strcmp("_select_", struct_name)) {
    return struct_name;
  }
  else {
    // use "_select_" only as a last recourse, it means some anonymous shape
    return obj_name ? obj_name : "_select_";
  }
}

// Here we have found a "like T" name that needs to be rewritten with
// the various columns of T.  We do this by:
// * looking up "T" (this is the only thing that can go wrong)
// * replace the "like T" slug with a param node for the first column of T
// * for each additional column create a param node and link it in.
// * emit any given name only once, (so you can do like T1, like T1 even if both have the same pk)
// * arg names get a _ suffix so they don't conflict with column names
static ast_node *rewrite_one_param(ast_node *param, symtab *param_names, bytebuf *args_info) {
  Contract(is_ast_param(param));
  EXTRACT_NOTNULL(param_detail, param->right);
  EXTRACT_ANY(shape_name_ast, param_detail->left);
  EXTRACT_NOTNULL(shape_def, param_detail->right);

  ast_node *likeable_shape = sem_find_shape_def(shape_def, LIKEABLE_FOR_ARGS);
  if (!likeable_shape) {
    record_error(param);
    return param;
  }

  AST_REWRITE_INFO_SET(shape_def->lineno, shape_def->filename);

  // Nothing can go wrong from here on
  record_ok(param);

  sem_struct *sptr = likeable_shape->sem->sptr;
  uint32_t count = sptr->count;
  bool_t first_rewrite = true;
  CSTR shape_name = "";
  CSTR shape_type = best_shape_type_name(likeable_shape);

  if (shape_name_ast) {
    EXTRACT_STRING(sname, shape_name_ast);
    shape_name = sname;
    ast_node *shape_ast = new_maybe_qstr(shape_name);
    shape_ast->sem = likeable_shape->sem;
    sem_add_flags(shape_ast, SEM_TYPE_HAS_SHAPE_STORAGE); // the arg bundle has storage!
    shape_ast->sem->name = shape_name;
    add_arg_bundle(shape_ast, shape_name);
  }

  for (uint32_t i = 0; i < count; i++) {
    sem_t param_type = sptr->semtypes[i];
    CSTR param_name = sptr->names[i];
    CSTR param_kind = sptr->kinds[i];
    CSTR original_name = param_name;

    if (shape_name[0]) {
      // the orignal name in this form has to be compound to disambiguate
      if ((param_type & SEM_TYPE_QID) && param_name[0] == 'X' && param_name[1] == '_') {
        // if we had a QID then we need to move the X_ to the front
        param_name = dup_printf("X_%s_%s", shape_name, param_name + 2);
      }
      else {
        // otherwise normal concat
        param_name = dup_printf("%s_%s", shape_name, param_name);
      }

      // note we skip none of these, if the names conflict that is an error:
      // e.g. if you make an arg like x_y and you then have a shape named x
      //      with a field y you'll get an error
      symtab_add(param_names, param_name, NULL);
    }
    else {
      // If the shape came from a procedure we keep the args unchanged
      // If the shape came from a data type or cursor then we add _
      // The idea here is that if it came from a procedure we want to keep the same signature
      // exactly and if any _ needed to be added to avoid conflict with a column name then it already was.

      if (!(param_type & (SEM_TYPE_IN_PARAMETER | SEM_TYPE_OUT_PARAMETER))) {
        param_name = dup_printf("%s_", param_name);
      }

      // skip any that we have already added or that are manually present
      if (!symtab_add(param_names, param_name, NULL)) {
        continue;
      }
    }

    if (args_info) {
      // args info uses the cleanest version of the name, no trailing _
      bytebuf_append_var(args_info, original_name);
      bytebuf_append_var(args_info, shape_name);
      bytebuf_append_var(args_info, shape_type);
    }

    ast_node *type = rewrite_gen_data_type(param_type, param_kind);
    ast_node *name_ast = new_str_or_qstr(param_name, param_type);
    ast_node *param_detail_new = new_ast_param_detail(name_ast, type);

    ast_node *inout = NULL; // IN by default
    if (param_type & SEM_TYPE_OUT_PARAMETER) {
      if (param_type & SEM_TYPE_IN_PARAMETER) {
        inout = new_ast_inout();
      }
      else {
        inout = new_ast_out();
      }
    }

    if (!first_rewrite) {
      // for the 2nd and subsequent args make a new node
      ast_node *params = param->parent;
      ast_node *new_param = new_ast_param(inout, param_detail_new);
      ast_set_right(params, new_ast_params(new_param, params->right));
      param = new_param;
    }
    else {
      // for the first arg, just replace the param details
      // recall that we are on a param node and it is the like entry
      Invariant(is_ast_param(param));

      // replace the like entry with a real param detail
      // on the next iteration, we will insert to the right of ast
      ast_set_right(param, param_detail_new);
      ast_set_left(param, inout);
      first_rewrite = false;
    }
    record_ok(param);
  }

  // There's a chance we did nothing.  If that happens we still have to remove the like node.
  // If we did anything the like node is already gone.
  if (first_rewrite) {
    // since this can only happen if there is 100% duplication, that means there is always a previous parameter
    // if this were the first node we would have expanded ... something
    EXTRACT_NOTNULL(params, param->parent);
    EXTRACT_NAMED_NOTNULL(tail, params, params->parent);
    ast_set_right(tail, params->right);
  }

  AST_REWRITE_INFO_RESET();

  // this is the last param that we modified
  return param;
}

// generates an AST node for a data_type_any based on the semantic type
// we need this any time we need to make a tree for a semantic type out
// of thin air.
cql_noexport ast_node *rewrite_gen_data_type(sem_t sem_type, CSTR kind) {
  ast_node *ast = NULL;
  ast_node *kind_ast = kind ? new_ast_str(kind) : NULL;

  switch (core_type_of(sem_type)) {
    case SEM_TYPE_INTEGER:      ast = new_ast_type_int(kind_ast); break;
    case SEM_TYPE_TEXT:         ast = new_ast_type_text(kind_ast); break;
    case SEM_TYPE_LONG_INTEGER: ast = new_ast_type_long(kind_ast); break;
    case SEM_TYPE_REAL:         ast = new_ast_type_real(kind_ast); break;
    case SEM_TYPE_BOOL:         ast = new_ast_type_bool(kind_ast); break;
    case SEM_TYPE_BLOB:         ast = new_ast_type_blob(kind_ast); break;
    case SEM_TYPE_OBJECT:       ast = new_ast_type_object(kind_ast); break;
  }

  Invariant(ast);

  if (is_not_nullable(sem_type)) {
    ast = new_ast_notnull(ast);
  }

  if (sensitive_flag(sem_type)) {
    ast = new_ast_sensitive_attr(ast, NULL);
  }

  return ast;
}

// If no name list then fake a name list so that both paths are the same
// no name list is the same as all the names
cql_noexport ast_node *rewrite_gen_full_column_list(sem_struct *sptr) {
  Contract(sptr);
  ast_node *name_list = NULL;
  ast_node *name_list_tail = NULL;

  for (uint32_t i = 0; i < sptr->count; i++) {
    if (sptr->semtypes[i] & SEM_TYPE_HIDDEN_COL) {
      continue;
    }

    ast_node *ast_col = new_str_or_qstr(sptr->names[i], sptr->semtypes[i]);

    // add name to the name list
    ast_node *new_tail = new_ast_name_list(ast_col, NULL);
    if (name_list) {
      ast_set_right(name_list_tail, new_tail);
    }
    else {
      name_list = new_tail;
    }

    name_list_tail = new_tail;
  }

  return  name_list;
}

// This helper function rewrites the expr_names ast to the columns_values ast.
// e.g: fetch C using 1 a, 2 b, 3 c; ==> fetch C (a,b,c) values (1, 2, 3);
cql_noexport void rewrite_expr_names_to_columns_values(ast_node *columns_values) {
  Contract(is_ast_expr_names(columns_values));

  AST_REWRITE_INFO_SET(columns_values->lineno, columns_values->filename);

  EXTRACT(expr_names, columns_values);
  ast_node *name_list = NULL;
  ast_node *insert_list = NULL;

  for ( ; expr_names->right ; expr_names = expr_names->right) ;

  do {
    EXTRACT(expr_name, expr_names->left);
    EXTRACT_ANY(expr, expr_name->left);
    EXTRACT_ANY(as_alias, expr_name->right);
    EXTRACT_ANY_NOTNULL(name, as_alias->left);

    name_list = new_ast_name_list(name, name_list);
    insert_list = new_ast_insert_list(expr, insert_list);

    expr_names = expr_names->parent;
  } while (is_ast_expr_names(expr_names));

  ast_node *opt_column_spec = new_ast_column_spec(name_list);
  ast_node *new_columns_values = new_ast_columns_values(opt_column_spec, insert_list);

  columns_values->type = new_columns_values->type;
  ast_set_left(columns_values, new_columns_values->left);
  ast_set_right(columns_values, new_columns_values->right);

  AST_REWRITE_INFO_RESET();
}

// This helper function rewrites the select statement ast to the columns_values ast.
// e.g: insert into X using select 1 a, 2 b, 3 c; ==> insert into X (a,b,c) values (1, 2, 3);
cql_noexport void rewrite_select_stmt_to_columns_values(ast_node *columns_values) {
  EXTRACT_ANY_NOTNULL(select_stmt, columns_values);
  Contract(is_select_variant(select_stmt));

  AST_REWRITE_INFO_SET(columns_values->lineno, columns_values->filename);

  ast_node *name_list = NULL;

  Invariant(select_stmt->sem);
  Invariant(select_stmt->sem->sptr);

  sem_struct *sptr = select_stmt->sem->sptr;

  // doing the names in reverse order is easier to build up the list
  int32_t i = (int32_t)sptr->count;

  while (--i >= 0) {
    CSTR name = sptr->names[i];
    ast_node *name_ast = new_str_or_qstr(name, sptr->semtypes[i]);

    name_list = new_ast_name_list(name_ast, name_list);
  }

  // we need a new select statement to push down the tree because we're mutating the current one
  ast_node *new_select_stmt = new_ast_select_stmt(select_stmt->left, select_stmt->right);
  new_select_stmt->type = select_stmt->type;

  // now make the columns values we need that holds the names we computed plus the new select node
  ast_node *opt_column_spec = new_ast_column_spec(name_list);
  ast_node *new_columns_values = new_ast_columns_values(opt_column_spec, new_select_stmt);

  // The current columns_values becomes a true columns values node taking over the content
  // of the fresh one we just made.  This used to be the select node, hence we copied it.
  columns_values->type = new_columns_values->type;
  ast_set_left(columns_values, new_columns_values->left);
  ast_set_right(columns_values, new_columns_values->right);

  AST_REWRITE_INFO_RESET();
}

// There are two reasons the columns might be missing. A form like this:
//    INSERT C FROM VALUES(...);
// or
//    INSERT C() FROM VALUES() @dummy_seed(...)
//
// The first form is shorthand for specifying that all of the columns are present.
// It will be expanded into something like FETCH C(x,y,z) FROM VALUES(....)
//
// The second form indicates that there are NO values specified at all.  This might
// be ok if all the columns have some default value.  Or if dummy data is used.
// When dummy data is present, any necessary but missing columns are provided
// using the seed variable.  The same rules apply to the FETCH statement.
//
// So these kinds of cases:
//   FETCH C FROM VALUES(...)  // all values are specified
//   FETCH C() FROM VALUES() @dummy_seed(...) -- NO values are specified, all dummy
//
// If you add FROM ARGUMENTS to this situation, the arguments take the place of the
// values. Each specified column will cause an argument to be used as a value, in
// the declared order.  The usual type checking will be done.
//
// So we have these kinds of cases:
//  FETCH C FROM ARGUMENTS  -- args are covering everything (dummy data not applicable as usual)
//  FETCH C() FROM ARGUMENTS @dummy_seed(...)  -- error, args can't possibly be used, no columns specified
//  FETCH C() FROM VALUES() @dummy_seed(...)  -- all values are dummy
//  FETCH C(x,y) FROM VALUES(1,2) @dummy_seed(...)  -- x, y from values, the rest are dummy
//  FETCH C(x,y) FROM ARGUMENTS @dummy_seed(...) -- x,y from args, the rest are dummy
//
// This is harder to explain than it is to code.
cql_noexport void rewrite_empty_column_list(ast_node *columns_values, sem_struct *sptr)
{
  Invariant(is_ast_columns_values(columns_values) || is_ast_from_shape(columns_values));
  EXTRACT(column_spec, columns_values->left);

  AST_REWRITE_INFO_SET(columns_values->lineno, columns_values->filename);

  if (!column_spec) {
    // no list was specified, always make the full list
    ast_node *name_list = rewrite_gen_full_column_list(sptr);
    column_spec = new_ast_column_spec(name_list);
    ast_set_left(columns_values, column_spec);
  }

  AST_REWRITE_INFO_RESET();
}

// We can't just return the error in the tree like we usually do because
// arg_list might be null and we're trying to do all the helper logic here.
cql_noexport bool_t rewrite_shape_forms_in_list_if_needed(ast_node *arg_list) {
  if (arg_list) {
    // if there are any cursor forms in the arg list that need to be expanded, do that here.
    rewrite_from_shape_args(arg_list);
    if (is_error(arg_list)) {
      return false;
    }
  }
  return true;
}

// This helper function rewrites an iif ast to a case_expr ast, e.g.:
//
//   iif(X, Y, Z) => CASE WHEN X THEN Y ELSE Z END;
//
// The caller is responsible for validating that we have the three arguments
// required. In fact, we don't do any form of semantic analysis here at all:
// Unlike in other rewrite functions that call `sem_expr` to validate the
// rewrite, it's very much the case that the rewritten expression may not be
// semantically valid due to an error in the input program, so we simply let the
// caller deal with it.
cql_noexport void rewrite_iif(ast_node *ast) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  ast_node *arg1 = first_arg(arg_list);
  ast_node *arg2 = second_arg(arg_list);
  ast_node *arg3 = third_arg(arg_list);

  AST_REWRITE_INFO_SET(name_ast->lineno, name_ast->filename);

  ast_node *case_expr = rewrite_gen_iif_case_expr(arg1, arg2, arg3);

  AST_REWRITE_INFO_RESET();

  // Reset the call node to a case_expr node.
  ast->type = case_expr->type;
  ast_set_left(ast, case_expr->left);
  ast_set_right(ast, case_expr->right);
}

// The form we're trying to rewrite here is
// with cte(*) as (select 1 a, 2 b) select * from cte;
// The idea is that if you named all the columns in the projection of the select
// in this case "a, b" you don't want to rename all again in the cte definiton.
// That is with cte(a,b) as (select 1 a, 2 b) is redundant.
// There are many cases with dozens of names and it becomes a real problem to make sure
// the names all match and are in the right order.  This avoids all that.  Even if you
// select the columns you need in the wrong order it won't matter because you get them
// by name from the CTE anyway.  If you're using a union, the additional enforcement
// that the names match on each branch locks you in to correct columns.
// All we have to do is:
//   * make sure all the columns have a name and a reasonable type
//   * make a name list for the column names
//   * swap it in
cql_noexport void rewrite_cte_name_list_from_columns(ast_node *ast, ast_node *select_core) {
  Contract(is_ast_cte_decl(ast));
  EXTRACT_NOTNULL(star, ast->right)

  sem_verify_no_anon_no_null_columns(select_core);
  if (is_error(select_core)) {
    record_error(ast);
    return;
  }

  AST_REWRITE_INFO_SET(star->lineno, star->filename);

  sem_struct *sptr = select_core->sem->sptr;
  ast_node *name_list = rewrite_gen_full_column_list(sptr);
  ast_set_right(ast, name_list);

  AST_REWRITE_INFO_RESET();

  record_ok(ast);
}

// Here we have found a "like T" name that needs to be rewritten with
// the various columns of T.  We do this by:
// * looking up "T" (this is the only thing that can go wrong)
// * replace the "like T" slug with the first column of T
// * for each additional column create a typed name node and link it in.
// * emit any given name only once, (so you can do like T1, like T1 even if both have the same pk)
static void rewrite_one_typed_name(ast_node *typed_name, symtab *used_names) {
  Contract(is_ast_typed_name(typed_name));
  EXTRACT_ANY(shape_name_ast, typed_name->left);
  EXTRACT_NOTNULL(shape_def, typed_name->right);

  ast_node *found_shape = sem_find_shape_def(shape_def, LIKEABLE_FOR_VALUES);
  if (!found_shape) {
    record_error(typed_name);
    return;
  }

  AST_REWRITE_INFO_SET(shape_def->lineno, shape_def->filename);

  // Nothing can go wrong from here on
  record_ok(typed_name);

  sem_struct *sptr = found_shape->sem->sptr;
  uint32_t count = sptr->count;
  bool_t first_rewrite = true;
  CSTR shape_name = "";

  ast_node *insertion = typed_name;

  if (shape_name_ast) {
    EXTRACT_STRING(sname, shape_name_ast);
    shape_name = sname;

    // note that typed names are part of a procedure return type in a declaration
    // they don't create a proc or a proc body and so we don't add to arg_bundles,
    // indeed arg_bundles is null at this point
  }

  for (uint32_t i = 0; i < count; i++) {
    sem_t sem_type = sptr->semtypes[i];
    CSTR name = sptr->names[i];
    CSTR kind = sptr->kinds[i];
    CSTR combined_name = name;

    if (shape_name[0]) {
      combined_name = dup_printf("%s_%s", shape_name, name);
    }

    // skip any that we have already added or that are manually present
    if (!symtab_add(used_names, combined_name, NULL)) {
      continue;
    }

    ast_node *name_ast = new_ast_str(combined_name);
    ast_node *type = rewrite_gen_data_type(sem_type, kind);
    ast_node *new_typed_name = new_ast_typed_name(name_ast, type);
    ast_node *typed_names = insertion->parent;

    if (!first_rewrite) {
      ast_set_right(typed_names, new_ast_typed_names(new_typed_name, typed_names->right));
    }
    else {
      ast_set_left(typed_names, new_typed_name);
      first_rewrite = false;
    }

    insertion = new_typed_name;
  }

  // There's a chance we did nothing.  If that happens we still have to remove the like node.
  // If we did anything the like node is already gone.
  if (first_rewrite) {
    // since this can only happen if there is 100% duplication, that means there is always a previous typed name
    // if this were the first node we would have expanded ... something
    EXTRACT_NOTNULL(typed_names, typed_name->parent);
    EXTRACT_NAMED_NOTNULL(tail, typed_names, typed_names->parent);
    ast_set_right(tail, typed_names->right);
  }

  AST_REWRITE_INFO_RESET();
}

// Walk the typed name list looking for any of the "like T" forms
// if any is found, replace that entry  with the table/shape columns
cql_noexport void rewrite_typed_names(ast_node *head) {
  symtab *used_names = symtab_new();

  for (ast_node *ast = head; ast; ast = ast->right) {
    Contract(is_ast_typed_names(ast));
    EXTRACT_NOTNULL(typed_name, ast->left);

    if (is_ast_shape_def(typed_name->right)) {
      rewrite_one_typed_name(typed_name, used_names);
      if (is_error(typed_name)) {
        record_error(head);
        goto cleanup;
      }
    }
    else {
      // Just extract the name and record that we used it -- no rewrite needed.
      EXTRACT_STRING(name, typed_name->left);
      symtab_add(used_names, name, NULL);
    }
  }
  record_ok(head);

cleanup:
  symtab_delete(used_names);
}

// These are the canonical short names for types.  They are used in the @op
// directive and in  places where a type name becomes part of a function name.
cql_noexport CSTR _Nonnull rewrite_type_suffix(sem_t sem_type) {
   CSTR result = "";
    switch (core_type_of(sem_type)) {
     case SEM_TYPE_NULL: result = "null"; break;
     case SEM_TYPE_BOOL: result = "bool"; break;
     case SEM_TYPE_INTEGER:  result = "int"; break;
     case SEM_TYPE_LONG_INTEGER: result = "long"; break;
     case SEM_TYPE_REAL:  result = "real"; break;
     case SEM_TYPE_TEXT:  result = "text"; break;
     case SEM_TYPE_BLOB:  result = "blob"; break;
     case SEM_TYPE_OBJECT: result = "object"; break;
     case SEM_TYPE_STRUCT: result = "cursor"; break;
  };
  // Only the above are possible
  Contract(result[0]);
  return result;
}

// Walk through the ast and grab the arg list as well as the function name.
// Create a new call node using these two and the argument passed in
// prior to the ':' symbol.
cql_noexport void rewrite_reverse_apply(ast_node *_Nonnull head) {
  Contract(is_ast_reverse_apply(head));
  EXTRACT_ANY_NOTNULL(argument, head->left);
  EXTRACT_NOTNULL(call, head->right);
  EXTRACT_ANY_NOTNULL(function_name, call->left);
  EXTRACT_NOTNULL(call_arg_list, call->right);
  // This may be NULL if the function only has one argument
  EXTRACT(arg_list, call_arg_list->right);

  AST_REWRITE_INFO_SET(head->lineno, head->filename);

  EXTRACT_STRING(func, function_name);

  sem_t sem_type = argument->sem->sem_type;
  CSTR kind = argument->sem->kind;
  CSTR new_name = NULL;

  CHARBUF_OPEN(key);

  if (kind) {
    bprintf(&key, "%s<%s>:call:%s", rewrite_type_suffix(sem_type), kind, func);
    new_name = find_op(key.ptr);
  }

  if (!new_name) {
    bclear(&key);
    bprintf(&key, "%s:call:%s", rewrite_type_suffix(sem_type), func);
    new_name = find_op(key.ptr);
  }

  if (!new_name) {
    new_name = func;
  }

  CHARBUF_CLOSE(key);

  // new name is durable for the ast node -- in all cases either already in a symbol
  // table or it's an AST string.
  function_name = new_maybe_qstr(new_name);

  ast_node *new_arg_list =
    new_ast_call_arg_list(
      new_ast_call_filter_clause(NULL, NULL),
      new_ast_arg_list(argument, arg_list)
    );
  ast_node *new_call = new_ast_call(function_name, new_arg_list);

  AST_REWRITE_INFO_RESET();

  ast_set_right(head, new_call->right);
  ast_set_left(head, new_call->left);
  head->type = new_call->type;
}

// Walk through the ast and grab the arg list as well as the function name.
// Create a new call node using these two and the argument passed in
// prior to the ':' symbol.  This is the "overloaded" version of the function
// where the target name is appended with the types of the arguments.  So
// for instance if the function name is "foo" and the arguments are "int, text"
// the new name will be "foo_int_text".
cql_noexport void rewrite_reverse_apply_polymorphic(ast_node *_Nonnull head) {
  Contract(is_ast_reverse_apply_poly_args(head));
  EXTRACT_ANY_NOTNULL(argument, head->left);
  EXTRACT(arg_list, head->right);
  Contract(argument->sem);

  sem_t sem_type = argument->sem->sem_type;
  CSTR kind = argument->sem->kind;

  CHARBUF_OPEN(new_name);
  CHARBUF_OPEN(key);

  if (!kind) {
    bprintf(&key, "%s:functor:all", rewrite_type_suffix(sem_type));
  }
  else {
    bprintf(&key, "%s<%s>:functor:all", rewrite_type_suffix(sem_type), kind);
  }

  CSTR base_name = find_op(key.ptr);

  if (!base_name) {
    // This has no hope of working.... the key name makes for a good error message
    // so that's what we use.  This isn't even a valid identifier.
    bprintf(&new_name, "%s", key.ptr);
  }
  else {
    bprintf(&new_name, "%s", base_name);
  }

  CHARBUF_CLOSE(key);

  AST_REWRITE_INFO_SET(head->lineno, head->filename);

  ast_node *item = arg_list;
  while (item) {
    EXTRACT_ANY_NOTNULL(arg, item->left);

    bprintf(&new_name, "_%s", rewrite_type_suffix(arg->sem->sem_type));
    item = item->right;
  }

  // we're set to go, we just need a durable string for the ast node
  ast_node *function_name = new_maybe_qstr(Strdup(new_name.ptr));

  CHARBUF_CLOSE(new_name);

  // set up the function call AST
  ast_node *new_arg_list =
    new_ast_call_arg_list(
      new_ast_call_filter_clause(NULL, NULL),
      new_ast_arg_list(argument, arg_list)
    );
  ast_node *new_call = new_ast_call(function_name, new_arg_list);

  AST_REWRITE_INFO_RESET();

  ast_set_right(head, new_call->right);
  ast_set_left(head, new_call->left);
  head->type = new_call->type;
}

// Walk the param list looking for any of the "like T" forms
// if any is found, replace that parameter with the table/shape columns
cql_noexport void rewrite_params(ast_node *head, bytebuf *args_info) {
  symtab *param_names = symtab_new();

  for (ast_node *ast = head; ast; ast = ast->right) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left)
    EXTRACT_NOTNULL(param_detail, param->right)

    if (is_ast_shape_def(param_detail->right)) {
      param = rewrite_one_param(param, param_names, args_info);
      if (is_error(param)) {
        record_error(head);
        goto cleanup;
      }
      ast = param->parent;
      Invariant(is_ast_params(ast));
    }
    else {
      // Just extract the name and record that we used it -- no rewrite needed.
      EXTRACT_STRING(param_name, param_detail->left);
      CSTR shape_type = "";
      CSTR shape_name = "";
      if (args_info) {
        bytebuf_append_var(args_info, param_name);
        bytebuf_append_var(args_info, shape_name);
        bytebuf_append_var(args_info, shape_type);
      }

      symtab_add(param_names, param_name, NULL);
    }
  }

  record_ok(head);

cleanup:
  symtab_delete(param_names);
}

// This helper generates a case_expr node that check if an expression to return value or
// otherwise another value
// e.g: (expr, val1, val2) => CASE WHEN expr THEN val2 ELSE val1;
static ast_node *rewrite_gen_iif_case_expr(ast_node *expr, ast_node *val1, ast_node *val2) {
  // left case_list node
  ast_node *when = new_ast_when(expr, val1);
  // left connector node
  ast_node *case_list = new_ast_case_list(when, NULL);
  // case list with no ELSE (we get ELSE NULL by default)
  ast_node *connector = new_ast_connector(case_list, val2);
  // CASE WHEN expr THEN result form; not CASE expr WHEN val THEN result
  ast_node *case_expr = new_ast_case_expr(NULL, connector);
  return case_expr;
}

// This helper rewrites col_def_type_attrs->right nodes to include notnull and sensitive
// flag from the data type of a column in create table statement. This is only applicable
// if column data type of the column is the name of an emum type or a declared named type.
cql_noexport void rewrite_right_col_def_type_attrs_if_needed(ast_node *ast) {
  Contract(is_ast_col_def_type_attrs(ast));
  EXTRACT_NOTNULL(col_def_name_type, ast->left);
  EXTRACT_ANY_NOTNULL(data_type, col_def_name_type->right);
  EXTRACT_ANY(col_attrs, ast->right);

  if (is_ast_str(data_type)) {
    EXTRACT_STRING(name, data_type);
    ast_node *named_type = find_named_type(name);
    if (!named_type) {
      report_error(ast, "CQL0360: unknown type", name);
      record_error(ast);
      return;
    }

    AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

    sem_t found_sem_type = named_type->sem->sem_type;
    if (!is_nullable(found_sem_type)) {
      col_attrs = new_ast_col_attrs_not_null(NULL, col_attrs);
    }
    if (sensitive_flag(found_sem_type)) {
      col_attrs = new_ast_sensitive_attr(NULL, col_attrs);
    }

    ast_set_right(ast, col_attrs);

    AST_REWRITE_INFO_RESET();
  }

  record_ok(ast);
}

// Rewrite a data type represented as a string node to the
// actual type if the string name is a declared type.
cql_noexport void rewrite_data_type_if_needed(ast_node *ast) {
  ast_node *data_type = NULL;
  if (is_ast_create_data_type(ast)) {
    data_type = ast->left;
  }
  else {
    data_type = ast;
  }

  if (is_ast_str(data_type)) {
    EXTRACT_STRING(name, data_type);
    ast_node *named_type = find_named_type(name);
    if (!named_type) {
      report_error(ast, "CQL0360: unknown type", name);
      record_error(ast);
      return;
    }

    sem_t sem_type = named_type->sem->sem_type;

    // * The cast_expr node doesn't need attributes, it only casts to the
    //   target type.  When casting, both nullability and sensitivity are
    //   preserved. So in that case we remove the extra attributes.  They
    //   are not expected/required in the rewrite.
    //
    // * Columns are a little different; nullability and sensitivity are
    //   encoded differently in columns than in variables.
    //   So in that case we again only produce the base type here.
    //   The caller will do the rest. This work is done in
    //   rewrite_right_col_def_type_attrs_if_needed(ast_node
    bool_t only_core_type = ast->parent &&
        (is_ast_col_def_name_type(ast->parent) || is_ast_cast_expr(ast->parent));

    if (only_core_type) {
      sem_type = core_type_of(sem_type);
    }

    AST_REWRITE_INFO_SET(data_type->lineno, data_type->filename);
    ast_node *node = rewrite_gen_data_type(sem_type, named_type->sem->kind);
    AST_REWRITE_INFO_RESET();

    ast_set_left(data_type, node->left);
    ast_set_right(data_type, node->right);
    data_type->sem = node->sem;
    data_type->type = node->type;  // note this is ast type, not semantic type
  }

  record_ok(ast);
}

// Wraps an id or dot in a call to cql_inferred_notnull.
cql_noexport void rewrite_nullable_to_notnull(ast_node *_Nonnull ast) {
  Contract(is_id_or_dot(ast));

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  ast_node *id_or_dot;
  if (is_id(ast)) {
    EXTRACT_STRING(name, ast);
    id_or_dot = new_maybe_qstr(name);
  }
  else {
    Invariant(is_ast_dot(ast));
    EXTRACT_NAME_AND_SCOPE(ast);
    id_or_dot = new_ast_dot(new_maybe_qstr(scope), new_maybe_qstr(name));
  }
  ast_node *cql_inferred_notnull = new_ast_str("cql_inferred_notnull");
  ast_node *call_arg_list =
    new_ast_call_arg_list(
      new_ast_call_filter_clause(NULL, NULL),
      new_ast_arg_list(id_or_dot, NULL));
  ast->type = k_ast_call;
  ast_set_left(ast, cql_inferred_notnull);
  ast_set_right(ast, call_arg_list);

  AST_REWRITE_INFO_RESET();

  // Analyze the AST to validate the rewrite.
  sem_expr(ast);

  // The rewrite is not expected to have any semantic error.
  Invariant(!is_error(ast));
}

// Rewrites a guard statement of the form `IF expr stmt` to a regular if
// statement of the form `IF expr THEN stmt END IF`.
cql_noexport void rewrite_guard_stmt_to_if_stmt(ast_node *_Nonnull ast) {
  Contract(is_ast_guard_stmt(ast));

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_ANY_NOTNULL(stmt, ast->right);

  ast->type = k_ast_if_stmt;
  ast_set_left(ast, new_ast_cond_action(expr, new_ast_stmt_list(stmt, NULL)));
  ast_set_right(ast, new_ast_if_alt(NULL, NULL));

  AST_REWRITE_INFO_RESET();

  sem_one_stmt(ast);
}

// Rewrites an already analyzed printf call such that all arguments whose core
// types do not match the format string exactly have casts inserted to make them
// do so. This allows programmers to enjoy the usual subtyping semantics of
// `sem_verify_assignment` while making sure that all types match up exactly for
// calls to `sqlite3_mprintf` in the C output.
cql_noexport void rewrite_printf_inserting_casts_as_needed(ast_node *ast, CSTR format_string) {
  Contract(is_ast_call(ast));
  Contract(!is_error(ast));
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT_NOTNULL(arg_list, call_arg_list->right);

  printf_iterator *iterator = minipool_alloc(ast_pool, (uint32_t)sizeof_printf_iterator);
  printf_iterator_init(iterator, NULL, format_string);

  ast_node *args_for_format = arg_list->right;
  for (ast_node *arg_item = args_for_format; arg_item; arg_item = arg_item->right) {
    sem_t sem_type = printf_iterator_next(iterator);
    // We know the format string cannot have an error.
    Contract(sem_type != SEM_TYPE_ERROR);
    // We know that we do not have too many arguments.
    Contract(sem_type != SEM_TYPE_OK);
    ast_node *arg = arg_item->left;
    AST_REWRITE_INFO_SET(arg->lineno, arg->filename);
    if (core_type_of(arg->sem->sem_type) == SEM_TYPE_NULL) {
      // We cannot cast NULL outside of an SQL context, so we just insert the
      // correct zero-valued literal instead, if needed.
      switch (sem_type) {
        case SEM_TYPE_INTEGER:
          ast_set_left(arg_item, new_ast_num(NUM_INT, "0"));
          break;
        case SEM_TYPE_LONG_INTEGER:
          ast_set_left(arg_item, new_ast_num(NUM_LONG, "0"));
          break;
        case SEM_TYPE_REAL:
          ast_set_left(arg_item, new_ast_num(NUM_REAL, "0.0"));
          break;
        default:
          // Reference types do not need to be casted.
          break;
      }
    }
    else if (core_type_of(arg->sem->sem_type) != sem_type) {
      Invariant(is_numeric(sem_type));
      // The format string specifies a larger type than what was provided, so
      // we must insert a cast to make the types match exactly.
      ast_node *type_ast;
      switch (sem_type) {
        case SEM_TYPE_INTEGER:
          type_ast = new_ast_type_int(NULL);
          break;
        case SEM_TYPE_LONG_INTEGER:
          type_ast = new_ast_type_long(NULL);
          break;
        default:
          Invariant(sem_type == SEM_TYPE_REAL);
          type_ast = new_ast_type_real(NULL);
          break;
      }
      ast_set_left(arg_item, new_ast_cast_expr(arg, type_ast));
    }
    AST_REWRITE_INFO_RESET();
  }

  // We know that we do not have too few arguments.
  Contract(printf_iterator_next(iterator) == SEM_TYPE_OK);

  // Validate the rewrite.
  sem_expr(ast);
}

// Just maintain head and tail whilst adding a node at the tail.
// This uses the usual convention that ->right is the "next" pointer.
static void add_tail(ast_node **head, ast_node **tail, ast_node *node) {
  if (*head) {
    ast_set_right(*tail, node);
  }
  else {
    *head = node;
  }
  *tail = node;
}

static void append_scoped_name(
  ast_node **head,
  ast_node **tail,
  CSTR scope,
  CSTR name)
{
  ast_node *expr = NULL;
  if (scope) {
    expr = new_ast_dot(new_maybe_qstr(scope), new_maybe_qstr(name));
  }
  else {
    expr = new_maybe_qstr(name);
  }
  ast_node *select_expr = new_ast_select_expr(expr, NULL);
  ast_node *select_expr_list = new_ast_select_expr_list(select_expr, NULL);
  add_tail(head, tail, select_expr_list);
}

// This is our helper struct with the computed symbol tables for disambiguation
// we flow this around when we need to do the searches.
typedef struct jfind_t {
  sem_join *jptr;
  symtab *location;
  symtab *dups;
  symtab *tables;
} jfind_t;

// This just gives us easy access to the sem_struct or NULL
static sem_struct *jfind_table(jfind_t *jfind, CSTR name) {
  symtab_entry *entry = symtab_find(jfind->tables, name);
  return entry ? (sem_struct *)(entry->val) : NULL;
}

// If we need them we make these fast disambiguation tables so that
// we don't have to do a cubic algorithm re-searching every column we need
// These will tell us the disambiguated location of any given column name
// and its duplicate status as well fast access to the sem_struct for
// any scope within the jptr -- this will be the jptr of a FROM clause.
static void jfind_init(jfind_t *jfind, sem_join *jptr) {
  jfind->jptr = jptr;

  // this will map from column name to the first table that has that column
  jfind->location = symtab_new();

  // this will tell us if any given column requires disambiguation
  jfind->dups = symtab_new();

  // this will tell us the sptr index for a particular table name
  jfind->tables = symtab_new();

  // here we make the lookup maps by walking the jptr for the from clause
  // this will save us a lot of searching later...
  for (uint32_t i = 0; i < jptr->count; i++) {
    CSTR name = jptr->names[i];
    sem_struct *sptr = jptr->tables[i];
    symtab_add(jfind->tables, name, (void *)sptr);

    for (uint32_t j = 0; j < sptr->count; j++) {
      CSTR col = sptr->names[j];

      if (!symtab_add(jfind->location, col, (void*)name)) {
        symtab_add(jfind->dups, col, NULL);
      }
    }
  }
}

// cleanup the helper tables so we don't leak in the amalgam
static void jfind_cleanup(jfind_t *jfind) {
  if (jfind->location) {
    symtab_delete(jfind->location);
  }
  if (jfind->dups) {
    symtab_delete(jfind->dups);
  }
  if (jfind->tables) {
    symtab_delete(jfind->tables);
  }
}

// This will check if the indicated column of the required sptr is a type match
// for the same column name (maybe different index) in the actual column.  We
// have to do this because we want to make sure that when you say @COLUMNS(X like foo)
// that the foo columns of X are the same type as those in foo.
static bool_t verify_matched_column(
  ast_node *ast,
  sem_struct *sptr_reqd,
  uint32_t i_reqd,
  sem_struct *sptr_actual,
  CSTR scope)
{
  CHARBUF_OPEN(err);
  bool_t ok = false;
  CSTR col = sptr_reqd->names[i_reqd];

  // if we're emitting from the same structure there's nothing to check
  // this is not the LIKE case
  if (sptr_reqd == sptr_actual) {
    ok = true;
    goto cleanup;
  }

  // for better diagnostics, we can give the scoped name
  bprintf(&err, "%s.%s", scope, col);

  int32_t i_actual = find_col_in_sptr(sptr_actual, col);
  if (i_actual < 0) {
    report_error(ast, "CQL0069: name not found", err.ptr);
    goto cleanup;
  }

  // here the ast is only where we charge the error, but as it happens that will be the node we just added
  // which by an amazing coincidence has exactly the right file/line number for the columns node
  if (!sem_verify_assignment(ast, sptr_reqd->semtypes[i_reqd], sptr_actual->semtypes[i_actual], err.ptr)) {
    goto cleanup;
  }

  ok = true;

cleanup:
  CHARBUF_CLOSE(err);
  return ok;
}

// Here we've found one column_calculation node, this corresponds to a single
// instance of @COLUMNS(...) in the select list.  When we process this, we
// will replace it with its expansion.  Note that each one is independent
// so often you really only need one (distinct is less powerful if you have two or more).
static void rewrite_column_calculation(ast_node *column_calculation, jfind_t *jfind) {
  Contract(is_ast_column_calculation(column_calculation));

  bool_t distinct = !!column_calculation->right;

  symtab *used_names = distinct ? symtab_new() : NULL;

  ast_node *tail = NULL;
  ast_node *head = NULL;

  for (ast_node *item = column_calculation->left; item; item = item->right) {
    Contract(is_ast_col_calcs(item));
    EXTRACT(col_calc, item->left);

    if (is_ast_dot(col_calc->left)) {
      // If a column is explicitly mentioned, we simply emit it
      // we won't duplicate the column later but neither will we
      // filter it out if distinct is mentioned, this is to prevent
      // bogus manual columns from staying in select lists.  If it's
      // not distinct, either hoist it to the front or else remove it.

      EXTRACT_NOTNULL(dot, col_calc->left);
      EXTRACT_STRING(left, dot->left);
      EXTRACT_STRING(right, dot->right);

      // no type check is needed here, we just emit the name whatever it is
      append_scoped_name(&head, &tail, left, right);
      if (used_names) {
        symtab_add(used_names, right, NULL);
      }
    }
    else if (col_calc->left) {
      EXTRACT_STRING(scope, col_calc->left);

      sem_struct *sptr_table = jfind_table(jfind, scope);

      if (!sptr_table) {
        report_error(col_calc->left, "CQL0054: table not found", scope);
        record_error(column_calculation);
        goto cleanup;
      }

      EXTRACT(shape_def, col_calc->right);

      sem_struct *sptr;

      if (shape_def) {
        ast_node *found_shape = sem_find_shape_def(shape_def, LIKEABLE_FOR_VALUES);
        if (!found_shape) {
          record_error(column_calculation);
          goto cleanup;
        }
        // get just the shape columns (or try anyway)
        sptr = found_shape->sem->sptr;
      }
      else {
        // get all the columns from this table
        sptr = sptr_table;
      }

      for (uint32_t j = 0; j < sptr->count; j++) {
        CSTR col = sptr->names[j];

        if (!strcmp(col, "rowid") || (sptr->semtypes[j] & SEM_TYPE_HIDDEN_COL)) {
          // `rowid` is a special case, it's not a real column it's a virtual
          // column from the base table. we don't want to emit it in the select
          // list unless it is explictly mentioned

          // This business is much more important that it might look. When
          // considering backed table the backed table does not mention rowid
          // but it is known to be there.  The CTE for the backed table include
          // rowid from the underlying table, it's important for doing say
          // delete and stuff like that.  However we do not want rowid to appear
          // in results unless it is explicitly mentioned. The way we do that is
          // to make * not include rowid.  This is exactly what SQLite itself
          // does.  Rowid is "there" but it doesn't count.
          //
          // we might want to alias the rowid column in backed tables to make
          // this less likely to conflict with a user named table... but that's
          // a different issue. As it is, you'll get an error if you name a
          // backed column rowid and that's fine I guess.  It seems like a
          // terrible terrible idea to name your own column rowid.
          continue;
        }

        if (used_names && !symtab_add(used_names, col, NULL)) {
          continue;
        }

        append_scoped_name(&head, &tail, scope, col);

        if (!verify_matched_column(tail, sptr, j, sptr_table, scope)) {
          record_error(column_calculation);
          goto cleanup;
        }
      }
    }
    else {
      // the other case has just a like expression
      EXTRACT_NOTNULL(shape_def, col_calc->right);

      ast_node *found_shape = sem_find_shape_def(shape_def, LIKEABLE_FOR_VALUES);
      if (!found_shape) {
        record_error(column_calculation);
        goto cleanup;
      }

      // get just the shape columns (or try anyway)
      sem_struct *sptr = found_shape->sem->sptr;

      // now we can use our found structure from the like
      // we will find the table that has the given column
      // we generate a disambiguation scope if it is needed
      for (uint32_t i = 0; i < sptr->count; i++) {
        CSTR col = sptr->names[i];

        if (!used_names || symtab_add(used_names, col, NULL)) {
          // if the name has duplicates then qualify it

          symtab_entry *entry = symtab_find(jfind->location, col);

          if (!entry) {
            report_error(shape_def, "CQL0069: name not found", col);
            record_error(column_calculation);
            goto cleanup;
          }

          CSTR scope = (CSTR)entry->val;

          sem_struct *sptr_table = jfind_table(jfind, scope);
          Invariant(sptr_table); // this is our lookup of a scope that is known, it cant fail

          // We only use the scope in the output if it's needed and if distinct was specified
          // if distinct wasn't specified then ambiguity is an error and it will be.  The later
          // stages will check for an unambiguous name.
          CSTR used_scope = (used_names && symtab_find(jfind->dups, col)) ? scope : NULL;

          append_scoped_name(&head, &tail, used_scope, col);

          // We check the type of the first match of the name, this is the only column that
          // can match legally.  If there are other columns ambiguity errors will be emitted.
          if (!verify_matched_column(tail, sptr, i, sptr_table, scope)) {
            record_error(column_calculation);
            goto cleanup;
          }
        }
      }
    }
  }

  // replace the calc node with the head payload
  ast_node *splice = column_calculation->parent;

  ast_set_left(splice, head->left);
  ast_set_right(tail, splice->right); // this could be mutating the head
  ast_set_right(splice, head->right); // works even if head is an alias for tail

  record_ok(column_calculation);

cleanup:
  if (used_names) {
    symtab_delete(used_names);
  }
}

// At this point we're going to walk the select expression list looking for
// the construct @COLUMNS(...) with its various forms.  This is a generalization
// of the T.* syntax that allows you to pull slices of the tables and to
// get distinct columns where there are duplicates due to joins.  Ultimately
// this is just sugar but the point is that there could be dozens of such columns
// and if you have to type it all yourself it is very easy to get it wrong. So
// here we're going to expand out the @COLUMNS(...) operator into the actual
// tables/columns you requested.  SQLite, has no support for this sort of thing
// so it, and indeed the rest of the compilation chain, will just see the result
// of the expansion.
cql_noexport void rewrite_select_expr_list(ast_node *select_expr_list, sem_join *jptr_from) {

  // change * and T.* to @COLUMNS(T) or @COLUMNS(A, B, C) as appropriate
  rewrite_star_and_table_star_as_columns_calc(select_expr_list, jptr_from);

  jfind_t jfind = {0};

  for (ast_node *item = select_expr_list; item; item = item->right) {
    Contract(is_ast_select_expr_list(item));

    // all star and table star will be rewritten to @columns(...) by now so any left will indicate
    // jptr_from is null like a select with no from clause.
    if (is_ast_column_calculation(item->left) || is_ast_star(item->left) || is_ast_table_star(item->left)) {
      if (!jptr_from) {
        report_error(select_expr_list, "CQL0052: select *, T.*, or @columns(...) cannot be used with no FROM clause", NULL);
        record_error(item->left);
        record_error(select_expr_list);
        return;
      }
    }

    if (is_ast_column_calculation(item->left)) {
      EXTRACT_NOTNULL(column_calculation, item->left);
      Invariant(jptr_from);

      if (!jfind.jptr) {
        jfind_init(&jfind, jptr_from);
      }

      AST_REWRITE_INFO_SET(column_calculation->lineno, column_calculation->filename);

      rewrite_column_calculation(column_calculation, &jfind);

      AST_REWRITE_INFO_RESET();

      if (is_error(column_calculation)) {
        record_error(select_expr_list);
        goto cleanup;
      }
    }
  }
  record_ok(select_expr_list);

cleanup:
  jfind_cleanup(&jfind);
}

static int32_t cursor_base;

static ast_node *shape_exprs_from_name_list(ast_node *ast) {
  if (!ast) {
    return NULL;
  }

  Contract(is_ast_name_list(ast));

  // the additive form of shape expression
  ast_node *shape_expr = new_ast_shape_expr(ast->left, ast->left);

  return new_ast_shape_exprs(shape_expr, shape_exprs_from_name_list(ast->right));
}

// This creates the statements for each child partition creation
static ast_node *rewrite_child_partition_creation(
  ast_node *child_results,
  int32_t cursor_num,
  ast_node *tail)
{
  if (!child_results) {
    return tail;
  }

  // note that I have not included the numbers that get appended to the names
  //
  // let __partition__ := cql_partition_create();
  // declare __child_cursor__ cursor for call child_proc();  -- args as needed
  // loop fetch __child_cursor__
  // begin
  //   fetch __key__ from __child_cursor__(like __key__);
  //   set result_ := cql_partition_cursor(__partition__, __key__, __child_cursor__));
  // end;
  //

  EXTRACT_NOTNULL(child_result, child_results->left);
  EXTRACT_NOTNULL(call_stmt, child_result->left);
  EXTRACT_NOTNULL(named_result, child_result->right);
  EXTRACT_NOTNULL(name_list, named_result->right);
  EXTRACT_STRING(proc_name, call_stmt->left);

  CSTR key_name = dup_printf("__key__%d", cursor_num);
  CSTR cursor_name = dup_printf("__child_cursor__%d", cursor_num);
  CSTR partition_name = dup_printf("__partition__%d", cursor_num);
  CSTR result_name = dup_printf("__result__%d", cursor_base);

  return new_ast_stmt_list(
      new_ast_declare_cursor_like_name(
        new_maybe_qstr(key_name),
        new_ast_shape_def(
          new_ast_like(
            new_ast_str(proc_name),
            NULL
          ),
          shape_exprs_from_name_list(name_list)
        )
      ),
    new_ast_stmt_list(
      new_ast_let_stmt(
        new_maybe_qstr(partition_name),
        new_ast_call(
          new_ast_str("cql_partition_create"),
          new_ast_call_arg_list(
            new_ast_call_filter_clause(NULL, NULL),
            NULL
          )
        )
      ),
    new_ast_stmt_list(
      new_ast_declare_cursor(
        new_ast_str(cursor_name),
        call_stmt
      ),
    // loop fetch __child_cursor__
    new_ast_stmt_list(
      new_ast_loop_stmt(
        new_ast_fetch_stmt(
          new_maybe_qstr(cursor_name),
          NULL
        ),
        // FETCH __key_cursor FROM _child_cursor_(LIKE __key_cursor_);
        new_ast_stmt_list(
          new_ast_fetch_values_stmt(
            NULL,  // no dummy values
            new_ast_name_columns_values(
              new_maybe_qstr(key_name),
              new_ast_columns_values(
                NULL,
                new_ast_from_shape(
                  new_ast_column_spec(
                    new_ast_shape_def(
                      new_ast_like(
                        new_maybe_qstr(key_name),
                        NULL
                      ),
                      NULL
                    )
                  ),
                  new_ast_str(cursor_name)
                )
              )
            )
          ),
          //  SET _add_result_ := cql_partition_cursor(__partition___, __key_cursor_, __child_cursor__);
          new_ast_stmt_list(
            new_ast_assign(
              new_maybe_qstr(result_name),
              new_ast_call(
                new_ast_str("cql_partition_cursor"),
                new_ast_call_arg_list(
                  new_ast_call_filter_clause(NULL, NULL),
                  new_ast_arg_list(
                    new_maybe_qstr(partition_name),
                    new_ast_arg_list(
                      new_maybe_qstr(key_name),
                      new_ast_arg_list(
                        new_ast_str(cursor_name),
                        NULL
                      )
                    )
                  )
                )
              )
            ),
            NULL
          )
        )
      ),
      rewrite_child_partition_creation(child_results->right, cursor_num + 1, tail)
  ))));
}

static ast_node *build_child_typed_names(ast_node *child_results, int32_t child_index) {
  if (!child_results) {
    return NULL;
  }

  // named_type  child[n] object<child_proc set>, ...

  Contract(is_ast_child_results(child_results));
  EXTRACT_NOTNULL(child_result, child_results->left);
  EXTRACT_NOTNULL(call_stmt, child_result->left);
  EXTRACT_NOTNULL(named_result, child_result->right);
  EXTRACT_NOTNULL(name_list, named_result->right);
  EXTRACT_STRING(proc_name, call_stmt->left);

  // optional child result name
  CSTR child_column_name = NULL;
  if (named_result->left) {
    EXTRACT_STRING(name, named_result->left);
    child_column_name = name;
  }

  if (!child_column_name) {
    child_column_name = dup_printf("child%d", child_index);
  }

  return new_ast_typed_names(
    new_ast_typed_name(
      new_maybe_qstr(child_column_name),
      new_ast_notnull(
        new_ast_type_object(
          new_ast_str(dup_printf("%s SET", proc_name))
        )
      )
    ),
    build_child_typed_names(child_results->right, child_index + 1)
  );
}

static ast_node *rewrite_out_cursor_declare(
  CSTR parent_proc_name,
  CSTR out_cursor_name,
  ast_node *child_results,
  ast_node *tail)
{
  // DECLARE __out_cursor__ CURSOR LIKE (LIKE __parent__,  .. child .. list)
  return new_ast_stmt_list(
    new_ast_declare_cursor_like_typed_names(
      new_ast_str(out_cursor_name),
      new_ast_typed_names(
        new_ast_typed_name(
          NULL,
          new_ast_shape_def(
            new_ast_like(
              new_ast_str(parent_proc_name),
              NULL
            ),
            NULL
          )
        ),
        build_child_typed_names(child_results, 1)
      )
    ),
    tail
  );
}

ast_node *rewrite_load_child_keys_from_parent(
  ast_node *child_results,
  CSTR parent_cursor_name,
  int32_t cursor_num,
  ast_node *tail)
{
  if (!child_results) {
    return tail;
  }

  // generates this pattern for each child
  // fetch __key__ from __parent__0(like __key__);

  CSTR key_name = dup_printf("__key__%d", cursor_num);

  return new_ast_stmt_list(
    new_ast_fetch_values_stmt(
      NULL,  // no dummy values
      new_ast_name_columns_values(
        new_maybe_qstr(key_name),
        new_ast_columns_values(
          NULL,
          new_ast_from_shape(
            new_ast_column_spec(
              new_ast_shape_def(
                new_ast_like(
                  new_maybe_qstr(key_name),
                  NULL
                ),
                NULL
              )
            ),
            new_ast_str(parent_cursor_name)
          )
        )
      )
    ),
    rewrite_load_child_keys_from_parent(child_results->right, parent_cursor_name, cursor_num + 1, tail)
  );
}

static ast_node *rewrite_insert_children_partitions(
  ast_node *child_results,
  int32_t cursor_num)
{
  if (!child_results) {
    return NULL;
  }

  //  cql_partition_extract(__partition__, __key__)
  CSTR partition_name = dup_printf("__partition__%d", cursor_num);
  CSTR key_name = dup_printf("__key__%d", cursor_num);

  return new_ast_insert_list(
    new_ast_call(
      new_ast_str("cql_extract_partition"),
      new_ast_call_arg_list(
        new_ast_call_filter_clause(NULL, NULL),
        new_ast_arg_list(
          new_maybe_qstr(partition_name),
          new_ast_arg_list(
            new_maybe_qstr(key_name),
            NULL
          )
        )
      )
    ),
    rewrite_insert_children_partitions(child_results->right, cursor_num + 1)
  );
}

static ast_node *rewrite_declare_parent_cursor(
  CSTR parent_cursor_name,
  ast_node *parent_call_stmt,
  ast_node *tail)
{
  Contract(is_ast_call_stmt(parent_call_stmt));

  // DECLARE CP CURSOR FOR CALL parent();

  return new_ast_stmt_list(
    new_ast_declare_cursor(
      new_ast_str(parent_cursor_name),
      parent_call_stmt
    ),
    tail
  );
}

static ast_node *rewrite_fetch_results(
  CSTR out_cursor_name,
  CSTR parent_cursor_name,
  ast_node *child_results)
{
  Contract(is_ast_child_results(child_results));

  //   -- load up the wider cursor
  //   fetch __out_cursor__ from values(
  //     from __parent__,
  //     cql_partition_extract(__partition__1, __key__1),
  //     cql_partition_extract(__partition__2, __key__2)
  //   );

  return new_ast_stmt_list(
    new_ast_fetch_values_stmt(
      NULL,  // no dummy values
      new_ast_name_columns_values(
        new_ast_str(out_cursor_name),
        new_ast_columns_values(
          NULL,
          new_ast_insert_list(
            new_ast_from_shape(
              new_ast_str(parent_cursor_name),
              NULL
            ),
            rewrite_insert_children_partitions(child_results, cursor_base)
          )
        )
      )
    ),
    new_ast_stmt_list(
      new_ast_out_union_stmt(
        new_ast_str(out_cursor_name)
      ),
      NULL
    )
  );
}

static ast_node *rewrite_loop_fetch_parent_cursor(
  CSTR parent_cursor_name,
  CSTR out_cursor_name,
  ast_node *child_results)
{
  // generate code to read rows from parent and attach the matching rows from each partition above via hash lookup
  //
  // declare __parent__ cursor for call parent();  -- args as needed
  // loop fetch __parent__
  // begin
  //   -- look up key columns using the matching column names
  //   fetch __key__1 from __parent__(like __key__1);
  //   fetch __key__2 from __parent__(like __key__2);
  //
  //   -- load up the wider cursor
  //   fetch __out_cursor__ from values(
  //     from __parent__,
  //     cql_partition_extract(__partition__1, __key__1),
  //     cql_partition_extract(__partition__2, __key__2)
  //   );
  //   out union __out_cursor__;
  // end;

  return new_ast_stmt_list(
    new_ast_loop_stmt(
      new_ast_fetch_stmt(
        new_ast_str(parent_cursor_name),
        NULL
      ),
      rewrite_load_child_keys_from_parent(child_results, parent_cursor_name, cursor_base,
        rewrite_fetch_results(out_cursor_name, parent_cursor_name, child_results)
      )
    ),
    NULL
  );
}

// The general rewrite looks like this:
//
// create proc test_parent_child()
// begin
//   out union call parent(2) join call child(1) using (x);
// end;
//
// becomes:
//
// CREATE PROC test_parent_child ()
// BEGIN
//   DECLARE __result__0 BOOL NOT NULL;
//   DECLARE __key__0 CURSOR LIKE test_child(x);
//   LET __partition__0 := cql_partition_create();
//   DECLARE __child_cursor__0 CURSOR FOR CALL test_child(1);
//   LOOP FETCH __child_cursor__0
//   BEGIN
//     FETCH __key__0(x) FROM VALUES(__child_cursor__0.x);
//     SET __result__0 := cql_partition_cursor(__partition__0, __key__0, __child_cursor__0);
//   END;
//
//   The above repeats once for each child result set
//
//   DECLARE __out_cursor__0 CURSOR LIKE (x INTEGER, child1 OBJECT<test_child SET> NOT NULL);
//   DECLARE __parent__0 CURSOR FOR CALL test_parent(2);
//   LOOP FETCH __parent__0
//   BEGIN
//     FETCH __key__0(x) FROM VALUES(__parent__0.x);
//     FETCH __out_cursor__0(x, child1) FROM VALUES(__parent__0.x, cql_extract_partition(__partition__0, __key__0));
//     OUT UNION __out_cursor__0;
//   END;
// END;
//
cql_noexport void rewrite_out_union_parent_child_stmt(ast_node *ast) {
  Contract(is_ast_out_union_parent_child_stmt(ast));

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  CSTR result_name = dup_printf("__result__%d", cursor_base);
  CSTR out_cursor_name = dup_printf("__out_cursor__%d", cursor_base);
  CSTR parent_cursor_name = dup_printf("__parent__%d", cursor_base);

  // DECLARE __result_ BOOL NOT NULL;
  ast_node *result_var =
    new_ast_declare_vars_type(
      new_ast_name_list(
        new_maybe_qstr(result_name), NULL),
      new_ast_notnull(new_ast_type_bool(NULL))
    );

  EXTRACT_NOTNULL(child_results, ast->right);
  EXTRACT_NOTNULL(call_stmt, ast->left);
  EXTRACT_STRING(parent_proc_name, call_stmt->left);

  // we have to go up the ast to find the statement list, we need to insert ourselves here.
  ast_node *stmt_tail = ast;
  while (!is_ast_stmt_list(stmt_tail)) {
    stmt_tail = stmt_tail->parent;
  }

  ast_node *result = rewrite_child_partition_creation(child_results, cursor_base,
    rewrite_out_cursor_declare(parent_proc_name, out_cursor_name, child_results,
      rewrite_declare_parent_cursor(parent_cursor_name, call_stmt,
        rewrite_loop_fetch_parent_cursor(parent_cursor_name, out_cursor_name, child_results)
      )
    )
  );

  // now we find the last statement in the chain of statements we just generated
  ast_node *end = result;
  Invariant(is_ast_stmt_list(end));

  while (end->right) {
    end = end->right;
    Invariant(is_ast_stmt_list(end));
  }

  Invariant(is_ast_stmt_list(end));

  // we link our new stuff in and we're good to go
  ast_set_right(end, stmt_tail->right);
  ast_set_right(stmt_tail, result);

  AST_REWRITE_INFO_RESET();

  // the last thing we do is clobber the original statement node with the result variable assignment
  // leaving no trace of the original ast
  ast_set_left(ast, result_var->left);
  ast_set_right(ast, result_var->right);
  ast->type = result_var->type;

  int32_t child_count = 0;
  while (child_results) {
    child_count++;
    child_results = child_results->right;
  }
  cursor_base += child_count;
}

typedef struct {
  ast_node *backed_table;
  CSTR key;
  sem_t sem_type_key;
  CSTR val;
  sem_t sem_type_val;
} backed_expr_list_info;

// Each column in the backed table needs an entry in the select list for the generated
// create proc.  It will fetch from either the key blob or the value blob.  This can be
// generalized in the future but for now we support only the "two blob" backing store
// shape.  We peel off the first item and then recurse to add the nested item.  Not
// especially economical but fine for any normal sized table.  This can be made non-recursive
// if it ever matters.
static ast_node *rewrite_backed_expr_list(backed_expr_list_info *info, uint32_t index) {
  sem_struct *sptr = info->backed_table->sem->sptr;
  if (index >= sptr->count) {
    return NULL;
  }

  sem_t sem_type = sptr->semtypes[index];
  bool_t is_key_column = is_primary_key(sem_type) || is_partial_pk(sem_type);

  ast_node *col_name_ast;
  if (is_key_column) {
     col_name_ast = new_str_or_qstr(info->key, info->sem_type_key);
  }
  else {
     col_name_ast = new_str_or_qstr(info->val, info->sem_type_val);
  }

  ast_node *result = new_ast_select_expr_list(
    new_ast_select_expr(
      new_ast_call(
        new_ast_str("cql_blob_get"),
        new_ast_call_arg_list(
          new_ast_call_filter_clause(NULL, NULL),
          new_ast_arg_list(
            new_ast_dot(
              new_maybe_qstr("T"),
              col_name_ast
            ),
            new_ast_arg_list(
              new_ast_dot(
                new_maybe_qstr(sptr->struct_name),
                new_str_or_qstr(sptr->names[index], sem_type)
              ),
              NULL
            )
          )
        )
      ),
      new_ast_opt_as_alias(
        new_str_or_qstr(sptr->names[index], sem_type)
      )
    ),
    rewrite_backed_expr_list(info, index + 1)
  );

  return result;
}

// Once we have a valid backed table we need to create a shared fragment that access it
// so that we can use it when rewriting select statements.  To do this we make the create
// proc statement out of thin air and then parse it, adding it to the set of shared fragments.
// The generated procedure looks like this:
//
// [[shared_fragment]]
// CREATE PROC _backed ()
// BEGIN
//   SELECT
//     cql_blob_get(T.k, backed.id) AS id,
//     cql_blob_get(T.v, backed.t) AS t,
//     cql_blob_get(T.v, backed.v) AS v
//   FROM backing AS T;
// END;
//
// This is a fixed shape with just names plugged in except for the expression list
// which is generated by a helper above.
// Here the table "backing" has two blob columns "k" and "v" for the key and value storage.
cql_noexport void rewrite_shared_fragment_from_backed_table(ast_node *_Nonnull backed_table) {
  EXTRACT_MISC_ATTRS(backed_table, misc_attrs);

  AST_REWRITE_INFO_SET(backed_table->lineno, backed_table->filename);

  Contract(is_ast_create_table_stmt(backed_table));
  EXTRACT_NOTNULL(create_table_name_flags, backed_table->left);
  EXTRACT_STRING(backed_table_name, create_table_name_flags->right);
  CSTR proc_name = dup_printf("_%s", backed_table_name);

  CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
  Invariant(backing_table_name);  // already validated
  ast_node *backing_table = find_table_or_view_even_deleted(backing_table_name);
  Invariant(backing_table);  // already validated
  sem_struct *sptr_backing = backing_table->sem->sptr;
  Invariant(sptr_backing);  // table must have a sem_struct

  // figure out the column order of the key and value columns in the backing store
  // the options are "key, value" or "value, key"
  sem_t sem_type = sptr_backing->semtypes[0];
  bool_t is_key_first = is_primary_key(sem_type) || is_partial_pk(sem_type);

  backed_expr_list_info info = {
    .backed_table = backed_table,
    .key = sptr_backing->names[!is_key_first], // if the order is kv then the key is column 0, else 1
    .sem_type_key = sptr_backing->semtypes[!is_key_first],
    .val = sptr_backing->names[is_key_first], // if the order is kv then the key is column 0, else 1
    .sem_type_val = sptr_backing->semtypes[is_key_first],  // if the order is kv then the value is colume 1, else 0
  };

  ast_node *select_expr_list = rewrite_backed_expr_list(&info, 0);

  ast_node *select_stmt =
    new_ast_select_stmt(
      new_ast_select_core_list(
        new_ast_select_core(
          NULL,
          new_ast_select_expr_list_con(
            // computed select list (see above)
            new_ast_select_expr_list(
              new_ast_select_expr(
                new_ast_str("rowid"),
                NULL
              ),
              select_expr_list
            ),
            // from backing store, with short alias "T"
            new_ast_select_from_etc(
              new_ast_table_or_subquery_list(
                new_ast_table_or_subquery(
                  new_maybe_qstr(backing_table_name),
                  new_ast_opt_as_alias(new_ast_str("T"))
                ),
                NULL
              ),
              // use where to constraint the row type
              new_ast_select_where(
                new_ast_opt_where(
                  new_ast_eq(
                    new_ast_call(
                      new_ast_str("cql_blob_get_type"),
                      new_ast_call_arg_list(
                        new_ast_call_filter_clause(NULL, NULL),
                        new_ast_arg_list(
                          new_maybe_qstr(backed_table_name),
                          new_ast_arg_list(
                            new_ast_dot(
                              new_ast_str("T"),
                              new_str_or_qstr(info.key, info.sem_type_key)
                            ),
                            NULL
                          )
                        )
                      )
                    ),
                    new_ast_num(NUM_LONG, gen_type_hash(backed_table))
                  )
                ),
                new_ast_select_groupby(
                  NULL,
                  new_ast_select_having(
                    NULL,
                    NULL
                  )
                )
              )
            )
          )
        ),
        NULL
      ),
      // empty orderby, limit, offset
      new_ast_select_orderby(
        NULL,
        new_ast_select_limit(
          NULL,
          new_ast_select_offset(
            NULL,
            NULL
          )
        )
      )
    );

  // create the proc wrapper and add [[shared_fragment]]
  ast_node *stmt_and_attr =
    new_ast_stmt_and_attr(
      new_ast_misc_attrs(
        new_ast_misc_attr(
          new_ast_dot(
            new_ast_str("cql"),
            new_ast_str("shared_fragment")
          ),
          NULL
        ),
        NULL
      ),
      new_ast_create_proc_stmt(
        new_ast_str(proc_name), // certainly not a qname, it has a leading _
        new_ast_proc_params_stmts(
          NULL,
          new_ast_stmt_list(
            select_stmt,
            NULL
          )
        )
      )
    );

  // stdout the rewrite for debugging if needed
  // gen_stmt_list_to_stdout(new_ast_stmt_list(stmt_and_attr, NULL));

  AST_REWRITE_INFO_RESET();

  // analysis can't fail, there's nothing to go wrong, all names already checked
  // note that semantic analysis expects to start at the statement not the attributes
  // so we skip into the statement.
  sem_one_stmt(stmt_and_attr->right);
  Invariant(!is_error(stmt_and_attr->right));
}

// Here we find all of the backed tables that have been mentioned in this statement
// from the backed tables list and produce a chain of CTEs that define them.  This
// can then be linked into some other statement (see below)
//
// Note that walking the list in this way effectively reverses the order the items
// will appear in the  CTE list.
//
// If you're thinking, just a hold it, what if there's a reference to the base
// table for say an insert statement or something, won't the CTE we add for
// that table be hiding the table we are trying to insert into?  But no, for
// the main table if it is backed is necessarily renamed to be the backing table
// so by the time SQLite sees it there will be possibly many CTEs for backed
// tables that were mentioned, including the main table, but the main table
// is gone, replaced by the backing table. This leaves the main table name
// free to be used in the statement by a CTE like usual.
static void rewrite_backed_table_ctes(
  list_item *backed_tables_list,
  ast_node **pcte_tables,
  ast_node **pcte_tail)
{
  symtab *backed = symtab_new();

  ast_node *backed_cte_tables = NULL;
  ast_node *cte_tail = NULL;

  for (list_item *item = backed_tables_list; item; item = item->next) {
    // already formed table on the list to add
    bool_t added = false;

    if (is_ast_cte_table(item->ast)) {
      backed_cte_tables = new_ast_cte_tables(item->ast, backed_cte_tables);
      added = true;
    }
    else {
      EXTRACT_NOTNULL(table_or_subquery, item->ast);
      EXTRACT_NAME_AST(backed_table_name_ast, table_or_subquery->left);
      EXTRACT_STRING(backed_table_name, backed_table_name_ast);
      CSTR backed_proc_name = dup_printf("_%s", backed_table_name);

      if (symtab_add(backed, backed_table_name, NULL)) {
        added = true;
        // need a new backed table CTE for this one
        backed_cte_tables = new_ast_cte_tables(
          new_ast_cte_table(
            new_ast_cte_decl(
              new_maybe_qstr(backed_table_name), // the table name could be a qname
              new_ast_star()
            ),
            new_ast_shared_cte(
              new_ast_call_stmt(
                new_ast_str(backed_proc_name),  // with the leading _ this is not a qname for sure
                NULL
              ),
              NULL
            )
          ),
          backed_cte_tables
        );
      }
    }

    if (added && cte_tail == NULL) {
      cte_tail = backed_cte_tables;
    }
  }

  *pcte_tail = cte_tail;
  *pcte_tables = backed_cte_tables;

  symtab_delete(backed);
}

// This is the magic, we have tracked the backed tables so now we can insert calls to
// the generated shared fragments (see above) for each such table.  Once we've done that,
// the select will "just work." because the backed table has been aliased by a correct CTE.
cql_noexport void rewrite_statement_backed_table_ctes(
  ast_node *_Nonnull stmt,
  list_item *_Nonnull backed_tables_list)
{
  Contract(stmt);
  Contract(backed_tables_list);

  ast_node *backed_cte_tables = NULL;
  ast_node *cte_tail = NULL;

  rewrite_backed_table_ctes(backed_tables_list, &backed_cte_tables, &cte_tail);

  Invariant(cte_tail);
  Invariant(backed_cte_tables);

  if (is_ast_with(stmt->left)) {
    // add the backed table CTEs to the front of the list
    EXTRACT(with, stmt->left);
    EXTRACT(cte_tables, with->left);
    ast_set_right(cte_tail, cte_tables);
    ast_set_left(with, backed_cte_tables);
  }
  else {
    // preserve the old (left, right) in a nested node and swap in the "with" node
    ast_set_right(stmt, new_ast(stmt->type, stmt->left, stmt->right));
    ast_set_left(stmt, new_ast_with(backed_cte_tables));

    // map the node type to the with form
    if (stmt->type == k_ast_select_stmt) {
      stmt->type = k_ast_with_select_stmt;
    }
    else if (stmt->type == k_ast_upsert_stmt) {
      stmt->type = k_ast_with_upsert_stmt;
    }
    else if (stmt->type == k_ast_update_stmt) {
      stmt->type = k_ast_with_update_stmt;
    }
    else if (stmt->type == k_ast_delete_stmt) {
      stmt->type = k_ast_with_delete_stmt;
    }
    else {
      // this is all that's left
      Invariant(stmt->type == k_ast_insert_stmt);
      stmt->type = k_ast_with_insert_stmt;
    }
  }

  // stdout the rewrite for debugging if needed
  // printf("------------\n");
  // gen_stmt_list_to_stdout(new_ast_stmt_list(stmt, NULL));
  // printf("------------\n\n\n\n");
}

// Select is the simplest case, all we have to do is add the references
// to the backed tables to the select statement converting it into
// a with select in the process rewrite_statement_backed_table_ctes
// does exactly this job.  All the statement types use that helper
// to get the CTE structure correct.
cql_noexport void rewrite_select_for_backed_tables(
  ast_node *_Nonnull stmt,
  list_item *_Nonnull backed_tables_list)
{
  Contract(is_ast_select_stmt(stmt) || is_ast_with_select_stmt(stmt));
  Contract(backed_tables_list);

  AST_REWRITE_INFO_SET(stmt->lineno, stmt->filename);

  rewrite_statement_backed_table_ctes(stmt, backed_tables_list);

  AST_REWRITE_INFO_RESET();

  sem_any_row_source(stmt);
}

// As we do our recursion creating the fields for blob creation we flow this state
typedef struct create_blob_args_info {
  // inputs to recursion (same at every level)
  ast_node *backed_table;
  bool_t for_key;
  ast_node *name_list;

} create_blob_args_info;


// This walks the name list and generates either the args for the key or the args for the value
// both are just going to be V.col_name from the _vals alias and the backed table.column.
// The info we need to flows in the info variable.
static ast_node *rewrite_create_blob_args(create_blob_args_info *info) {
  Invariant(info->backed_table->sem);
  Invariant(info->backed_table->sem->table_info);
  Invariant(info->backed_table->sem->sptr);

  ast_node *name_list = info->name_list;
  table_node *table_info = info->backed_table->sem->table_info;
  sem_struct *sptr = info->backed_table->sem->sptr;
  CSTR backed_table_name = sptr->struct_name;
  symtab *seen_names = symtab_new();
  sem_t backed_table_sem_type = info->backed_table->sem->sem_type;

  symtab *def_values = find_default_values(sptr->struct_name);
  Invariant(def_values);  // table name known to be good

  int16_t col_count;
  int16_t *cols;

  // We have the column indexes we need in the order we need them
  // get the correct count and indices.
  if (info->for_key) {
    col_count = table_info->key_count;
    cols = table_info->key_cols;
  }
  else {
    col_count = table_info->value_count;
    cols = table_info->value_cols;
  }

  // We need to know which names were manually specified, we do
  // this so that we can use either the specified value or the
  // default value if one was not specified and is available.
  for (ast_node *item = name_list; item ; item = item->right) {
    EXTRACT_STRING(name, item->left);
    symtab_add(seen_names, name, NULL);
  }

  ast_node *root = new_ast_arg_list(NULL, NULL);
  ast_node *tail = root;

  // We always emit the args for blob create in the order the cols array indicates.
  // That is either value order or key order.  The key case is especially
  // important since ordinals are implicit in the key create blob helper.
  for (int16_t i = 0; i < col_count; i++) {
    // we're looking for the columns in the order we need them now
    int16_t icol = cols[i];
    Invariant(icol >= 0);
    Invariant((uint32_t)icol < sptr->count);
    CSTR name = sptr->names[icol];
    sem_t sem_type = sptr->semtypes[icol];
    ast_node *name_ast = new_str_or_qstr(name, sem_type);

    ast_node *new_item = NULL;
    symtab_entry *entry = NULL;

    // the manually specified columns
    if (symtab_find(seen_names, name)) {
      // these are named columns present in _vals so use V.name
      new_item =
        new_ast_arg_list(
          new_ast_dot(new_ast_str("V"), ast_clone_tree(name_ast)),
          new_ast_arg_list(
            new_ast_dot(new_str_or_qstr(backed_table_name, backed_table_sem_type), name_ast),
            NULL
          )
        );
    }
    else if ((entry = symtab_find(def_values, name))) {
      // there is a default value, copy it!
      // when we copy the tree we will use the file and line numbers from the original
      // so we temporarily discard whatever file and line number we are using right now

      // this can happen inside of other rewrites so we nest it
      AST_REWRITE_INFO_SAVE();
        ast_node *_Nonnull node = entry->val;
        ast_node *def_value;

        Contract(is_ast_num(node) || is_ast_str(node));

        AST_REWRITE_INFO_SET(node->lineno, node->filename);
        if (is_ast_num(node)) {
          EXTRACT_NUM_TYPE(num_type, node);
          EXTRACT_NUM_VALUE(val, node);
          def_value = new_ast_num(num_type, val);
        }
        else {
          EXTRACT_STRING(value, node);
          def_value = new_maybe_qstr(value);
        }
        AST_REWRITE_INFO_RESET();

        Invariant(def_value);

      AST_REWRITE_INFO_RESTORE();

      // new args for a default arg
      new_item = new_ast_arg_list(
        def_value,
        new_ast_arg_list(
          new_ast_dot(new_maybe_qstr(backed_table_name), name_ast),
          NULL
        )
      );
    }

    // if this column is present (in the values case some can be missing) then
    // add it to the end of the existing list.  Note we made a fake node at the
    // head so we never have to deal with tail is null.

    if (new_item) {
      ast_set_right(tail, new_item);
      // find the new tail
      while (tail->right) {
        tail = tail->right;
      }
    }
  }

  symtab_delete(seen_names);

  // skip the stub node we created to make tail handling uniform
  return root->right;
}

// This walks the name list and generates either the key create call or the
// value create call. This is the fixed part of the call.
static ast_node *rewrite_blob_create(
  bool_t for_key,
  ast_node *backed_table,
  ast_node *name_list)
{
  // set up state for the recursion, (note it will clean the symbol table)
  create_blob_args_info info = {
    .for_key = for_key,
    .backed_table = backed_table,
    .name_list = name_list
  };

  ast_node *table_name_ast = ast_clone_tree(sem_get_name_ast(backed_table));

  return new_ast_call(
    new_ast_str("cql_blob_create"),
    new_ast_call_arg_list(
      new_ast_call_filter_clause(NULL, NULL),
      new_ast_arg_list(
        table_name_ast,
        rewrite_create_blob_args(&info)
      )
    )
  );
}

// create the wrapper for a cql_blob_get call for the given blob, backed table
// name and column name
static ast_node *cql_blob_get_call (
  CSTR blob_field,
  sem_t sem_type_blob,
  CSTR backed_table,
  CSTR col,
  sem_t sem_type_col)
{
  // this is just cql_blob_get(blob_field, backed_table.col)
  return new_ast_call(
    new_ast_str("cql_blob_get"),
    new_ast_call_arg_list(
      new_ast_call_filter_clause(NULL, NULL),
      new_ast_arg_list(
        new_str_or_qstr(blob_field, sem_type_blob),
        new_ast_arg_list(
          new_ast_dot(
            new_maybe_qstr(backed_table),
            new_str_or_qstr(col, sem_type_col)
          ),
          NULL
        )
      )
    )
  );
}


// create the wrapper for a cql_blob_get call for the given blob, backed table
// name and column name, this is almost the same as the above but we use
// the excluded name prefix to get the key or value field.  So it looks like
// cql_blob_get(excluded.key, backed_table.col)
static ast_node *cql_blob_get_call_with_excluded (
  CSTR blob_field,
  sem_t sem_type_blob,
  CSTR backed_table,
  CSTR col,
  sem_t sem_type_col)
{
  // this is just cql_blob_get(excluded.blob_field, backed_table.col)
  return new_ast_call(
    new_ast_str("cql_blob_get"),
    new_ast_call_arg_list(
      new_ast_call_filter_clause(NULL, NULL),
      new_ast_arg_list(
        new_ast_dot(
          new_ast_str("excluded"),
          new_str_or_qstr(blob_field, sem_type_blob)
        ),
        new_ast_arg_list(
          new_ast_dot(
            new_maybe_qstr(backed_table),
            new_str_or_qstr(col, sem_type_col)
          ),
          NULL
        )
      )
    )
  );
}


// Several args need to flow during the recursion so we bundle them into a struct
// so that we can flow the pointer instead of all these arguments
typedef struct update_rewrite_info {
  CSTR backing_key;
  sem_t sem_type_key;
  CSTR backing_val;
  sem_t sem_type_val;
  bool_t for_key;
  ast_node *backed_table;
} update_rewrite_info;

// if we found any references to backed columns extract from the blob
static void rewrite_blob_column_references(
  update_rewrite_info *info,
  ast_node *ast)
{
  // the name nodes have all we need in the semantic payload
  if (is_ast_str(ast) || is_ast_dot(ast)) {
    if (ast->sem && ast->sem->backed_table) {
      // we know the name but to get the PK info we need to get to the semantic
      // type of the column pk info doesn't flow through the normal exression
      // tree. No problem, we'll just look up the name in the backed table and
      // get the type from there.

      sem_struct *sptr_backed = info->backed_table->sem->sptr;
      Invariant(ast->sem);
      Invariant(ast->sem->name);

      bool excluded = false;

      if (is_ast_dot(ast) && is_ast_str(ast->left)) {
        // if the left side is excluded then we need to use the excluded.(k/v) blob
        // instead of the k/v. This is a special case for upserts.  Note that
        // "excluded" in this context is an alias for the set of columns being inserted
        // and it will map back to the sptr with the backed table name in its sptr
        // just like any other alias.  We set up the excluded join this way on
        // purpose so that we would have the "real" name handy.
        EXTRACT_STRING(sc, ast->left);
        if (!strcmp(sc, "excluded")) {
          excluded = true;
        }
      }

      // these could be a subset of the columns in the backed table name if
      // it's an insert and only some columns are in scope.
      int32_t i = find_col_in_sptr(sptr_backed, ast->sem->name);
      Invariant(i >= 0);  // the column for sure exists, it's already been checked
      sem_t sem_type = sptr_backed->semtypes[i];

      // now we can easily decide which backing column to use
      bool_t is_key_column = is_primary_key(sem_type) || is_partial_pk(sem_type);
      CSTR blob_field = is_key_column ? info->backing_key : info->backing_val;
      sem_t blob_type = is_key_column ? info->sem_type_key : info->sem_type_val;

      ast_node *new = !excluded ?
        cql_blob_get_call(
          blob_field,
          blob_type,
          ast->sem->backed_table, // this is a direct reference to the backed table
          ast->sem->name,
          ast->sem->sem_type) :
        cql_blob_get_call_with_excluded( // use excluded.(k/v) for the blob
          blob_field,
          blob_type,
          sptr_backed->struct_name, // get the backed table directly from struct name
          ast->sem->name,
          ast->sem->sem_type);

      ast->type = new->type;
      ast_set_left(ast, new->left);
      ast_set_right(ast, new->right);
    }
    return;
  }

  if (ast_has_left(ast)) {
    rewrite_blob_column_references(info, ast->left);
  }
  if (ast_has_right(ast)) {
    rewrite_blob_column_references(info, ast->right);
  }
}

// given just the backed table and the root of the ast to patch (like a select list)
// we path any names needing to be converted to the backing table.
cql_noexport void rewrite_backed_column_references_in_ast(
  ast_node *_Nonnull root,
  ast_node *_Nonnull backed_table)
{
  EXTRACT_MISC_ATTRS(backed_table, misc_attrs);

  CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
  Invariant(backing_table_name);  // already validated
  ast_node *backing_table = find_table_or_view_even_deleted(backing_table_name);
  Invariant(backing_table);  // already validated
  sem_struct *sptr_backing = backing_table->sem->sptr;
  Invariant(sptr_backing);  // table must have a sem_struct

  sem_t sem_type = sptr_backing->semtypes[0];
  bool_t is_key_first = is_primary_key(sem_type) || is_partial_pk(sem_type);

  update_rewrite_info info = {
   .backing_key = sptr_backing->names[!is_key_first], // if the order is kv then the key is column 0, else 1
   .sem_type_key = sptr_backing->semtypes[!is_key_first],
   .backing_val = sptr_backing->names[is_key_first],
   .sem_type_val = sptr_backing->semtypes[is_key_first],
   .backed_table = backed_table,
   .for_key = false,  // this is ignored anyway
  };

  // this can be called from an existing rewrite in the upsert case, handle both cases
  AST_REWRITE_INFO_SAVE();
  AST_REWRITE_INFO_SET(root->lineno, root->filename);
    rewrite_blob_column_references(&info, root);
  AST_REWRITE_INFO_RESET();
  AST_REWRITE_INFO_RESTORE();
}

// This walks the update list and generates either the args for the key or the
// args for the value the values come from the assignment in the update entry list
static ast_node *rewrite_update_blob_args(
  update_rewrite_info *info,
  ast_node *update_list)
{
  if (!update_list) {
    return NULL;
  }

  Contract(is_ast_update_list(update_list));

  EXTRACT_NOTNULL(update_entry, update_list->left);
  EXTRACT_STRING(name, update_entry->left);
  EXTRACT_ANY_NOTNULL(expr, update_entry->right);

  sem_struct *sptr = info->backed_table->sem->sptr;
  int32_t icol = sem_column_index(sptr, name);
  Invariant(icol >= 0);  // must be valid name, already checked!
  sem_t sem_type = sptr->semtypes[icol];
  bool_t is_key = is_primary_key(sem_type) || is_partial_pk(sem_type);
  CSTR backed_table_name = sptr->struct_name;

  if (is_key == info->for_key) {
    rewrite_blob_column_references(info, expr);
    return new_ast_arg_list(
      expr,
      new_ast_arg_list(
        new_ast_dot(new_maybe_qstr(backed_table_name), new_str_or_qstr(name, sem_type)),
        rewrite_update_blob_args(info, update_list->right)
      )
    );
  }
  else {
    return rewrite_update_blob_args(info, update_list->right);
  }
}

// This walks the name list and generates either the key update call or the value update call
// This is the fixed part of the call.
static ast_node *rewrite_blob_update(
  bool_t for_key,
  sem_struct *sptr_backing,
  ast_node *backed_table,
  ast_node *update_list)
{
  sem_t sem_type = sptr_backing->semtypes[0];
  bool_t is_key_first = is_primary_key(sem_type) || is_partial_pk(sem_type);

  update_rewrite_info info = {
   .backing_key = sptr_backing->names[!is_key_first], // if the order is kv then the key is column 0, else 1
   .sem_type_key = sptr_backing->semtypes[!is_key_first],
   .backing_val = sptr_backing->names[is_key_first],
   .sem_type_val = sptr_backing->semtypes[is_key_first],
   .for_key = for_key,
   .backed_table = backed_table,
  };

  // if there are no args for this blob type then do not make the blob update
  // call at all.
  ast_node *arg_list = rewrite_update_blob_args(&info, update_list);
  if (!arg_list) {
    return NULL;
  }

  CSTR blob_name = for_key ? info.backing_key : info.backing_val;
  sem_t blob_type = for_key ? info.sem_type_key : info.sem_type_val;
  ast_node *blob_val = new_str_or_qstr(blob_name, blob_type);

  Contract(is_ast_update_list(update_list));

  return new_ast_call(
    new_ast_str("cql_blob_update"),
    new_ast_call_arg_list(
      new_ast_call_filter_clause(NULL, NULL),
      new_ast_arg_list(
        blob_val,
        arg_list
      )
    )
  );
}

// This helper creates the select list we will need to get the values out from
// the statement that was the insert list (it could be values or a select
// statement)
static ast_node *rewrite_insert_list_as_select_values(
  ast_node *insert_list)
{
  return new_ast_select_stmt(
    new_ast_select_core_list(
      new_ast_select_core(
        new_ast_select_values(),
        new_ast_values(
            insert_list,
            NULL
        )
      ),
      NULL
    ),
    new_ast_select_orderby(
      NULL,
      new_ast_select_limit(
        NULL,
        new_ast_select_offset(
          NULL,
          NULL
        )
      )
    )
  );
}

// The general insert pattern converts something like this:
//
// insert into backed values(1,2,3), (4,5,6), (7,8,9);
//
// into:
//
// WITH
// _vals (pk, x, y) AS (VALUES(1, "2", 3.14), (4, "5", 6), (7, "8", 9.7))
// INSERT INTO backing(k, v)
//   SELECT bcreatekey(9032558069325805135L, V.pk, 1),
//          bcreateval(9032558069325805135L, V.x, 7953209610392031882L, 4, V.y, 4501343740738089802L, 3)
//   FROM _vals V;
//
// To do this we need to:
//  * make the _vals CTE out of the values clause
//  * add a select clause that maps the values
//
// This code uses cql_blob_create(...) to which ultimately expands into whatever the blob create
// functions will be when sql code gen happens.
//
// cql_blob_create calls look like
//
// cql_blob_create(backed_type, val1, backed_type.col1, val2, backed_type.col2, ...)
//
// Those calls expand to include the hash codes if needed and field types.
//
cql_noexport void rewrite_insert_statement_for_backed_table(
  ast_node *ast,
  list_item *backed_tables_list)
{
  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  // skip the outer WITH if there is one
  ast_node *stmt = sem_skip_with(ast);
  Invariant(is_ast_insert_stmt(stmt));
  EXTRACT_NOTNULL(name_columns_values, stmt->right);
  EXTRACT_STRING(backed_table_name, name_columns_values->left);
  EXTRACT_ANY_NOTNULL(columns_values, name_columns_values->right);

  // table has already been checked, it exists, it's legal
  // but it might not be backed, in which case we have less work to do
  ast_node *backed_table = find_table_or_view_even_deleted(backed_table_name);
  Contract(is_ast_create_table_stmt(backed_table));
  if (!is_backed(backed_table->sem->sem_type)) {
    goto replace_backed_tables_only;
  }

  EXTRACT_MISC_ATTRS(backed_table, misc_attrs);

  CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
  Invariant(backing_table_name);  // already validated
  ast_node *backing_table = find_table_or_view_even_deleted(backing_table_name);
  Invariant(backing_table);  // already validated
  sem_struct *sptr_backing = backing_table->sem->sptr;
  Invariant(sptr_backing);  // table must have a sem_struct

  // Some explicit contract to clarify which error you have made...

  // the INSERT... USING form must already be resolved by the time we get here
  Contract(!is_ast_expr_names(columns_values));

  // DEFAULT VALUES is not allowed for backed tables, this should have already errored out
  Contract(!is_ast_default_columns_values(columns_values));

  // Standard columns_values node is the only option
  Contract(is_ast_columns_values(columns_values));

  EXTRACT(column_spec, columns_values->left);
  EXTRACT_ANY(insert_list, columns_values->right);

  // Most insert types are rewritten into select form including the standard
  // values clause but the insert forms that came from a cursor, args, or some
  // other shape are still written using an insert list, these are just vanilla
  // values.  Dummy default and all that sort of business likewise applies to
  // simple insert lists and all of that processing is done. If we find an
  // insert list form the first step is to normalize the insert list into a
  // select...values. We do this so thatwe have just one rewrite path after this
  // point, and because it's stupid simple

  if (is_ast_insert_list(insert_list)) {
    ast_node *select_stmt = rewrite_insert_list_as_select_values(insert_list);
    // debug output if needed
    // gen_stmt_list_to_stdout(new_ast_stmt_list(select_stmt, NULL));
    insert_list = select_stmt;
  }

  // Now either the incoming list came in before it was transformed, in which
  // case contract is broken, or we fixed the one legal case above.  We have an
  // select statement or a broken caller.
  Contract(is_select_variant(insert_list));

  EXTRACT_NOTNULL(name_list, column_spec->left);

  // make a CTE table _vals that will hold the selected data using the
  // user-provided name list
  ast_node *cte_table_vals = new_ast_cte_table(
    new_ast_cte_decl(
      new_ast_str("_vals"),
      name_list
    ),
    insert_list // this could be values or a select statement and it's where caluse if it has one
  );

  ast_node *key_expr = rewrite_blob_create(true, backed_table, name_list);
  ast_node *val_expr = rewrite_blob_create(false, backed_table, name_list);

  // now we need expressions for the key and value
  ast_node *select_expr_list = new_ast_select_expr_list(
    new_ast_select_expr(key_expr, NULL),
    new_ast_select_expr_list(
      new_ast_select_expr(val_expr, NULL),
      NULL
    )
  );

  ast_node *select_stmt =
    new_ast_select_stmt(
      new_ast_select_core_list(
        new_ast_select_core(
          NULL,
          new_ast_select_expr_list_con(
            // computed select list (see above)
            select_expr_list,
            // from insert values, with short alias "V"
            new_ast_select_from_etc(
              new_ast_table_or_subquery_list(
                new_ast_table_or_subquery(
                  new_ast_str("_vals"),
                  new_ast_opt_as_alias(new_ast_str("V"))
                ),
                NULL
              ),
              // we only need this where 1 business to avoid ambiguity
              // in the conflict clause of an upsert, it's the documented "use a where" business
              // we actually check for this in user generated code but there are no laws for us
              // Note that if there was an existing where clause associated with say a select that
              // contributed to the values, it would be hoisted into the _vals CTE and would be
              // part of the where clause of that select statement.  Which means for sure
              // there is no user-created where clause left here for us to handle.
              new_ast_select_where(
                  in_upsert ? new_ast_opt_where( new_ast_num(NUM_INT, "1")) : NULL,
                new_ast_select_groupby(
                  NULL,
                  new_ast_select_having(
                    NULL,
                    NULL
                  )
                )
              )
            )
          )
        ),
        NULL
      ),
      // empty orderby, limit, offset
      new_ast_select_orderby(
        NULL,
        new_ast_select_limit(
          NULL,
          new_ast_select_offset(
            NULL,
            NULL
          )
        )
      )
    );

  // for debugging dump the generated select statement
  // gen_stmt_list_to_stdout(new_ast_stmt_list(select_stmt, NULL));

  // figure out the column order of the key and value columns in the backing store
  // the options are "key, value" or "value, key"
  sem_t sem_type = sptr_backing->semtypes[0];
  bool_t is_key_first = is_primary_key(sem_type) || is_partial_pk(sem_type);

  CSTR backing_key = sptr_backing->names[!is_key_first]; // if the order is kv then the key is column 0, else 1
  CSTR backing_val = sptr_backing->names[is_key_first];  // if the order is kv then the value is colume 1, else 0
  sem_t sem_type_key = sptr_backing->semtypes[!is_key_first];
  sem_t sem_type_val = sptr_backing->semtypes[is_key_first];

  ast_node *new_name_columns_values = new_ast_name_columns_values(
    new_maybe_qstr(backing_table_name),
    new_ast_columns_values(
      new_ast_column_spec(
        new_ast_name_list(
          new_str_or_qstr(backing_key, sem_type_key),
          new_ast_name_list(
            new_str_or_qstr(backing_val, sem_type_val),
            NULL
          )
        )
      ),
      select_stmt
    )
  );

  ast_set_right(stmt, new_name_columns_values);
  // for debugging dump the generated insert statement
  // gen_stmt_list_to_stdout(new_ast_stmt_list(ast, NULL));

  ast_node *with_node = NULL;
  ast_node *main_node = NULL;

  // recover the main statement, we need to add our CTE there
  if (in_upsert) {
    main_node = sem_recover_with_stmt(ast->parent);
    Invariant(is_ast_upsert_stmt(main_node) || is_ast_with_upsert_stmt(main_node));
  }
  else {
    main_node = ast;
    Invariant(is_ast_insert_stmt(main_node) || is_ast_with_insert_stmt(main_node));
  }

  if (is_ast_with(main_node->left)) {
    with_node = main_node->left;
  }

  // the _vals node has to go after everything else
  if (with_node) {
    EXTRACT_NOTNULL(cte_tables, with_node->left);

    // find the end and append
    while (cte_tables->right) {
      Contract(is_ast_cte_tables(cte_tables));
      cte_tables = cte_tables->right;
    }

    Contract(is_ast_cte_tables(cte_tables));
    ast_set_right(cte_tables, new_ast_cte_tables(cte_table_vals, NULL));
  }
  else {
    // there is nothing else, so we can go first, leverage our other converter
    list_item *vals_cte_list = NULL;
    add_item_to_list(&vals_cte_list, cte_table_vals);
    rewrite_statement_backed_table_ctes(main_node, vals_cte_list);
  }

replace_backed_tables_only:

  if (backed_tables_list) {
    if (!in_upsert) {
      rewrite_statement_backed_table_ctes(ast, backed_tables_list);
    }
  }

  // for debugging, dump the generated ast without trying to validate it at all
  // print_root_ast(ast);
  //
  // for debugging dump the generated insert statement
  // gen_stmt_list_to_stdout(new_ast_stmt_list(ast, NULL));

  AST_REWRITE_INFO_RESET();

  // if in upsert the overall statement will be analyzed, don't do it yet
  if (!in_upsert) {
    // the insert statement is top level, when it re-enters it expects the cte state to be nil
    cte_state *saved = cte_cur;
    cte_cur = NULL;
      sem_one_stmt(ast);
    cte_cur = saved;
  }
}

static ast_node *rewrite_select_rowid(
  CSTR backed_table_name,
  ast_node *opt_where,
  ast_node *opt_orderby,
  ast_node *opt_limit)
{
  return
    new_ast_select_stmt(
      new_ast_select_core_list(
        new_ast_select_core(
          NULL,
          new_ast_select_expr_list_con(
            // select list is just "rowid"
            new_ast_select_expr_list(
              new_ast_select_expr(
                new_ast_str("rowid"),
                NULL
              ),
              NULL
            ),
            // from clause is just the backed table which will will alias a CTE as usual
            new_ast_select_from_etc(
              new_ast_table_or_subquery_list(
                new_ast_table_or_subquery(
                  new_maybe_qstr(backed_table_name),
                  NULL
                ),
                NULL
              ),
              // use where to hold the previous where clause if any
              new_ast_select_where(
                opt_where,
                new_ast_select_groupby(
                  NULL,
                  new_ast_select_having(
                    NULL,
                    NULL
                  )
                )
              )
            )
          )
        ),
        NULL
      ),
      // empty orderby, limit, offset
      new_ast_select_orderby(
        opt_orderby,
        new_ast_select_limit(
          opt_limit,
          new_ast_select_offset(
            NULL,
            NULL
          )
        )
      )
    );
}

cql_noexport void rewrite_delete_statement_for_backed_table(
  ast_node *ast,
  list_item *backed_tables_list)
{
  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  // get the inner delete, skipping the "with" part for now
  ast_node *stmt = sem_skip_with(ast);
  Invariant(is_ast_delete_stmt(stmt));

  EXTRACT_STRING(backed_table_name, stmt->left);
  EXTRACT(opt_where, stmt->right);

  // table has already been checked, it exists, it's legal
  // but it might not be backed, in which case we have less work to do
  ast_node *backed_table = find_table_or_view_even_deleted(backed_table_name);
  Contract(is_ast_create_table_stmt(backed_table));
  if (!is_backed(backed_table->sem->sem_type)) {
    goto replace_backed_tables_only;
  }

  // the deleted table needs to be added to the referenced backed tables
  add_item_to_list(
    &backed_tables_list,
    new_ast_table_or_subquery(new_maybe_qstr(backed_table_name), NULL)
  );

  // we are going to need the name of the backing table

  EXTRACT_MISC_ATTRS(backed_table, misc_attrs);

  CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
  Invariant(backing_table_name);  // already validated

  // the new where clause has at its core a select statement that generates the
  // rowids of the rows to be deleted.  This is using the existing where clause
  // against a from clause that is just the backed table.

  ast_node *select_stmt = rewrite_select_rowid(backed_table_name, opt_where, NULL, NULL);

  // for debugging print just the select statement
  // gen_stmt_list_to_stdout(new_ast_stmt_list(select_stmt, NULL));

  // the new where clause for the delete statement is going to be something like
  // rowid IN (select rowid from selected rows)

  ast_node *new_opt_where =
    new_ast_opt_where(
     new_ast_in_pred(
       new_ast_str("rowid"),
       select_stmt
     )
  );

  // replace the target table and where clause of the backed table
  // with the backing table and adjusted where clause

  ast_set_left(stmt, new_maybe_qstr(backing_table_name));
  ast_set_right(stmt, new_opt_where);

replace_backed_tables_only:

  // now add the backed tables and convert the node to a with delete if necessary
  rewrite_statement_backed_table_ctes(ast, backed_tables_list);

  AST_REWRITE_INFO_RESET();

  // the delete statement is top level, when it re-enters it expects the cte state to be nil
  cte_state *saved = cte_cur;
  cte_cur = NULL;
    sem_one_stmt(ast);
  cte_cur = saved;
}

cql_noexport void rewrite_update_statement_for_backed_table(
  ast_node *ast,
  list_item *backed_tables_list)
{
  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  // skip the outer WITH on the update statement if there is one
  ast_node *stmt = sem_skip_with(ast);

  Invariant(is_ast_update_stmt(stmt));
  EXTRACT_NOTNULL(update_set, stmt->right);
  EXTRACT_NOTNULL(update_list, update_set->left);
  EXTRACT_NOTNULL(update_from, update_set->right);
  EXTRACT_NOTNULL(update_where, update_from->right);
  EXTRACT(opt_where, update_where->left);
  EXTRACT_NOTNULL(update_orderby, update_where->right);
  EXTRACT(opt_orderby, update_orderby->left);
  EXTRACT(opt_limit, update_orderby->right);

  CSTR backed_table_name = NULL;

  if (stmt->left) {
    EXTRACT_STRING(t_name, stmt->left);
    backed_table_name = t_name;
  }
  else {
    // upsert case, get name from context
    Contract(is_ast_create_table_stmt(current_upsert_table_ast));
    EXTRACT_NOTNULL(create_table_name_flags, current_upsert_table_ast->left);
    EXTRACT_STRING(t_name, create_table_name_flags->right);
    backed_table_name = t_name;
  }


  // table has already been checked, it exists, it's legal
  // but it might not be backed, in which case we have less work to do
  ast_node *backed_table = find_table_or_view_even_deleted(backed_table_name);
  Contract(is_ast_create_table_stmt(backed_table));
  if (!is_backed(backed_table->sem->sem_type)) {
    goto replace_backed_tables_only;
  }

  // the updated table needs to be added to the referenced backed tables
  add_item_to_list(
    &backed_tables_list,
    new_ast_table_or_subquery(new_maybe_qstr(backed_table_name), NULL)
  );

  // we are going to need the name of the backing table

  EXTRACT_MISC_ATTRS(backed_table, misc_attrs);

  CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
  Invariant(backing_table_name);  // already validated
  ast_node *backing_table = find_table_or_view_even_deleted(backing_table_name);
  Invariant(backing_table);  // already validated
  sem_struct *sptr_backing = backing_table->sem->sptr;
  Invariant(sptr_backing);  // table must have a sem_struct

  // figure out the column order of the key and value columns in the backing store
  // the options are "key, value" or "value, key"
  sem_t sem_type = sptr_backing->semtypes[0];
  bool_t is_key_first = is_primary_key(sem_type) || is_partial_pk(sem_type);

  CSTR backing_key = sptr_backing->names[!is_key_first]; // if the order is kv then the key is column 0, else 1
  sem_t sem_type_key = sptr_backing->semtypes[!is_key_first];
  CSTR backing_val = sptr_backing->names[is_key_first];
  sem_t sem_type_val = sptr_backing->semtypes[is_key_first];

  // the new where clause has at its core a select statement that generates the
  // rowids of the rows to be updated.  This is using the existing where clause
  // against a from clause that is just the backed table.

  ast_node *select_stmt;

  if (!in_upsert) {

    // this generates the normal where clause for the update statement WHERE
    // rowid in (SELECT rowid FROM backed) which is what you want for the update
    // case

    select_stmt = rewrite_select_rowid(
      backed_table_name,
      opt_where,
      opt_orderby,
      opt_limit);

    // for debugging print just the select statement
    // gen_stmt_list_to_stdout(new_ast_stmt_list(select_stmt, NULL));

    // the new where clause for the update statement is going to be something like
    // rowid IN (select rowid from selected rows)
  }
  else {
    // in the upsert case, the rows in question are already selected by SQLite
    // itself. We don't need to do the rowid selection, we just need to rewrite
    // the update list to use the backing table columns directly and we'll
    // select the rowid out of excluded.rowid
    select_stmt = NULL;
  }

  ast_node *key_expr = rewrite_blob_update(true, sptr_backing, backed_table, update_list);
  ast_node *val_expr = rewrite_blob_update(false, sptr_backing, backed_table, update_list);

  ast_node *new_update_list = new_ast_update_list(NULL, NULL);  // fake list head
  ast_node *up_tail = new_update_list;
  if (key_expr) {
    ast_node *new = new_ast_update_list(
      new_ast_update_entry(new_str_or_qstr(backing_key, sem_type_key), key_expr),
      NULL
    );
    ast_set_right(up_tail, new);
    up_tail =  new;
  }

  if (val_expr) {
    ast_node *new = new_ast_update_list(
      new_ast_update_entry(new_str_or_qstr(backing_val, sem_type_val), val_expr),
      NULL
    );
    ast_set_right(up_tail, new);
  }

  ast_node *new_opt_where = NULL;

  if (!in_upsert) {
    new_opt_where = new_ast_opt_where(
     new_ast_in_pred(
       new_ast_str("rowid"),
       select_stmt
     )
    );
  }
  else {
    // the upsert case can have a WHERE clause of its own, it stays as is
    new_opt_where = opt_where;

    if (opt_where) {
      AST_REWRITE_INFO_SAVE();
      AST_REWRITE_INFO_SET(opt_where->lineno, opt_where->filename);
      rewrite_backed_column_references_in_ast(opt_where, backed_table);
      AST_REWRITE_INFO_RESET();
      AST_REWRITE_INFO_RESTORE();
    }
  }

  // replace the target table and where clause of the backed table
  // with the backing table and adjusted where clause

  ast_set_left(stmt, in_upsert ? NULL : new_maybe_qstr(backing_table_name));
  ast_set_left(update_set, new_update_list->right);
  ast_set_left(update_where, new_opt_where);
  ast_set_left(update_orderby, NULL); // opt orderby handled in the select
  ast_set_right(update_orderby, NULL); // opt limit handled in the select

replace_backed_tables_only:

  if (!in_upsert) {
    // now add the backed tables and convert the node to a with update if necessary
    rewrite_statement_backed_table_ctes(ast, backed_tables_list);
  }

  AST_REWRITE_INFO_RESET();

  // if in upsert the overall statement will be analyzed
  if (!in_upsert) {
    // the update statement is top level, when it re-enters it expects the cte state to be nil
    cte_state *saved = cte_cur;
    cte_cur = NULL;
      sem_one_stmt(ast);
    cte_cur = saved;
  }
}

cql_noexport void rewrite_upsert_statement_for_backed_table(
  ast_node *ast,
  list_item *backed_tables_list)
{
  Contract(is_ast_upsert_stmt(ast) || is_ast_with_upsert_stmt(ast));

  ast_node *stmt = sem_skip_with(ast);

  Invariant(is_ast_upsert_stmt(stmt));
  EXTRACT_NOTNULL(insert_stmt, stmt->left);
  EXTRACT_NOTNULL(upsert_update, stmt->right);
  EXTRACT(conflict_target, upsert_update->left);
  EXTRACT(update_stmt, upsert_update->right);
  EXTRACT(indexed_columns, conflict_target->left);

  Invariant(current_upsert_table_ast);
  ast_node *table_ast = current_upsert_table_ast;
  bool_t backed = is_backed(table_ast->sem->sem_type);

  rewrite_insert_statement_for_backed_table(insert_stmt, backed_tables_list);

  if (update_stmt) {
    rewrite_update_statement_for_backed_table(update_stmt, backed_tables_list);
  }

  // we need to change any references to the tables to be the blob extractions
  // from the key and value blobs
  if (backed) {
    rewrite_backed_column_references_in_ast(conflict_target, table_ast);
  }

  AST_REWRITE_INFO_SET(stmt->lineno, stmt->filename);

  if (backed_tables_list) {
    rewrite_statement_backed_table_ctes(ast, backed_tables_list);
  }

  if (backed) {
    EXTRACT_NOTNULL(create_table_name_flags, table_ast->left);
    EXTRACT_STRING(backed_table_name, create_table_name_flags->right);
    EXTRACT_MISC_ATTRS(table_ast, misc_attrs);
    CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
    Invariant(backing_table_name);  // already validated
    ast_node *backing_table = find_table_or_view_even_deleted(backing_table_name);
    Invariant(backing_table);  // already validated
    sem_struct *sptr_backing = backing_table->sem->sptr;
    Invariant(sptr_backing);  // table must have a sem_struct

    // figure out the column order of the key and value columns in the backing store
    // the options are "key, value" or "value, key"
    sem_t sem_type = sptr_backing->semtypes[0];
    bool_t is_key_first = is_primary_key(sem_type) || is_partial_pk(sem_type);

    CSTR backing_key = sptr_backing->names[!is_key_first]; // if the order is kv then the key is column 0, else 1

    ast_node *new_indexed_columns =
      new_ast_indexed_columns(
        new_ast_indexed_column(new_maybe_qstr(backing_key), NULL),
        NULL
      );

    ast_set_left(conflict_target, new_indexed_columns);
  }

  AST_REWRITE_INFO_RESET();

  // the insert statement is top level, when it re-enters it expects the cte state to be nil
  cte_state *saved = cte_cur;
  cte_cur = NULL;
  in_upsert = false;
  in_upsert_rewrite = true;
  current_upsert_table_ast = NULL;
    sem_one_stmt(ast);
  in_upsert_rewrite = false;
  cte_cur = saved;
}

// The expression node has been identified to be a procedure call
// Rewrite it as a call operation
cql_noexport void rewrite_func_call_as_proc_call(ast_node *_Nonnull ast) {
  Contract(is_ast_expr_stmt(ast));
  EXTRACT_NOTNULL(call, ast->left);
  EXTRACT_NAME_AST(name_ast, call->left);

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  EXTRACT_NOTNULL(call_arg_list, call->right);
  EXTRACT_ANY(arg_list, call_arg_list->right);

  // arg_list might be null if no args, that's ok.
  ast_node *new = new_ast_call_stmt(name_ast, arg_list);

  AST_REWRITE_INFO_RESET();

  ast->type = new->type;
  ast_set_left(ast, new->left);
  ast_set_right(ast, new->right);
}

cql_noexport bool_t rewrite_ast_star_if_needed(
  ast_node *_Nullable arg_list,
  ast_node *_Nonnull proc_name_ast)
{
  if (!arg_list) {
    return true;
  }

  // verify ast_star is a leaf, it mixes with nothing
  // then replace it with "FROM LOCALS LIKE proc_name"
  if (is_ast_star(arg_list->left)) {
    // the * operator is a singleton
    Contract(is_ast_arg_list(arg_list));
    if (arg_list->right) {
      report_error(arg_list, "CQL0474: when '*' appears in an expression list there can be nothing else in the list", NULL);
      record_error(arg_list);
      return false;
    }

    AST_REWRITE_INFO_SET(arg_list->lineno, arg_list->filename);
    ast_node *like = new_ast_like(proc_name_ast, proc_name_ast);
    ast_node *shape_def = new_ast_shape_def(like, NULL);
    ast_node *call_expr = new_ast_from_shape(new_maybe_qstr("LOCALS"), shape_def);
    ast_set_left(arg_list, call_expr);
    AST_REWRITE_INFO_RESET();
  }

  return true;
}

cql_noexport void rewrite_op_equals_assignment_if_needed(
  ast_node *_Nonnull expr,
  CSTR _Nonnull op)
{
  Contract(expr);
  Contract(op);

  size_t len = strlen(op);
  Contract(len);
  if (op[len-1] != '=') {
    return;
  }

  CSTR node_type = NULL;

  if (len == 2) {
    switch (op[0]) {
      case '+':  node_type = k_ast_add; break;  // +=
      case '-':  node_type = k_ast_sub; break;  // -=
      case '*':  node_type = k_ast_mul; break;  // *=
      case '/':  node_type = k_ast_div; break;  // /=
      case '%':  node_type = k_ast_mod; break;  // %=
      case '&':  node_type = k_ast_bin_and; break;  // &=
      case '|':  node_type = k_ast_bin_or; break;   // |=
    }
  }
  else if (len == 3) {
    // this is <<= and >>=
    if (op[0] == op[1]) {
      switch (op[0]) {
        case '<':  node_type = k_ast_lshift; break;
        case '>':  node_type = k_ast_rshift; break;
      }
    }
  }

  // nothing to do
  if (!node_type) {
     return;
  }

  EXTRACT_ANY_NOTNULL(lval, expr->left);

  AST_REWRITE_INFO_SET(expr->lineno, expr->filename);

  // make a copy of the left side to use on the right
  ast_node *rval = ast_clone_tree(lval);

  // convert whatever it was we had into normal assignment
  expr->type = k_ast_expr_assign;

  // create the tree in += form
  ast_node *oper = new_ast_add(rval, expr->right);

  // change it to the correct operator (provided)
  oper->type = node_type;

  // and load it up on the right side of the expression
  // we now have an assignment expression which will be
  // rewritten again into a SET
  ast_set_right(expr, oper);

  AST_REWRITE_INFO_RESET();
}

// Array access foo[a,b] can turn into a getter or a setter
// This helper does the job of rewriting the array into a function call.,
// In the set case a second rewrite moves the assigned value into the end of
// the arg list.
cql_noexport void rewrite_array_as_call(
  ast_node *_Nonnull expr,
  CSTR _Nonnull op)
{
  Contract(is_ast_array(expr));
  EXTRACT_ANY_NOTNULL(array, expr->left);
  EXTRACT_NOTNULL(arg_list, expr->right);
  sem_t sem_type = array->sem->sem_type;
  CSTR kind = array->sem->kind;

  CHARBUF_OPEN(tmp);
  bprintf(&tmp, "%s<%s>:array:%s", rewrite_type_suffix(sem_type), kind, op);
  CSTR new_name = find_op(tmp.ptr);

  if (!new_name) {
    new_name = Strdup(tmp.ptr); // this is for sure going to be an error
  }

  CHARBUF_CLOSE(tmp);

  AST_REWRITE_INFO_SET(expr->lineno, expr->filename);

  ast_node *new_arg_list = new_ast_arg_list(array, arg_list);
  ast_node *name_ast = new_maybe_qstr(new_name);
  ast_node *call_arg_list = new_ast_call_arg_list(new_ast_call_filter_clause(NULL, NULL), new_arg_list);
  ast_node *new_call = new_ast_call(name_ast, call_arg_list);

  expr->type = new_call->type;
  ast_set_left(expr, new_call->left);
  ast_set_right(expr, new_call->right);

  AST_REWRITE_INFO_RESET();
}

// Appends the given argument to the end of an existing (not empty)
// call argument list
cql_noexport void rewrite_append_arg(
  ast_node *_Nonnull call,
  ast_node *_Nonnull arg)
{
  Contract(is_ast_call(call));
  EXTRACT_NOTNULL(call_arg_list, call->right);
  EXTRACT_NOTNULL(arg_list, call_arg_list->right);

  while (arg_list->right) {
    arg_list = arg_list->right;
  }

  // we're now at the end
  AST_REWRITE_INFO_SET(arg->lineno, arg->filename);
  ast_node *new_arg_list = new_ast_arg_list(arg, NULL);
  ast_set_right(arg_list, new_arg_list);
  AST_REWRITE_INFO_RESET();
}

// rewrites the indicated binary operator as a function call if a mapping exists
// op can be "arrow", "lshift", "rshift", "concat" at this point.  More are
// likely to be added.
cql_noexport bool_t try_rewrite_op_as_call(ast_node *_Nonnull ast, CSTR op) {
  EXTRACT_ANY_NOTNULL(left, ast->left);
  EXTRACT_ANY_NOTNULL(right, ast->right);

  sem_t sem_type_left = left->sem->sem_type;
  CSTR kind_left = left->sem->kind;
  sem_t sem_type_right = right->sem->sem_type;

  if (!kind_left) {
    return false;
  }

  CHARBUF_OPEN(key);

  bprintf(&key, "%s<%s>:%s:", rewrite_type_suffix(sem_type_left), kind_left, op);
  uint32_t used = key.used;  // so we can truncate back to here later

  CSTR new_name = NULL;

  CSTR kind_right = right->sem->kind;
  if (kind_right) {
     bprintf(&key, "%s<%s>", rewrite_type_suffix(sem_type_right), kind_right);
     new_name = find_op(key.ptr);
  }

  if (!new_name) {
     key.used = used;
     key.ptr[used] = 0;
     bprintf(&key, "%s", rewrite_type_suffix(sem_type_right));
     new_name = find_op(key.ptr);
  }

  if (!new_name) {
     key.used = used;
     key.ptr[used] = 0;
     bprintf(&key, "all");
     new_name = find_op(key.ptr);
  }

  CHARBUF_CLOSE(key);

  if (!new_name) {
    return false;
  }

  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  ast_node *new_arg_list = new_ast_arg_list(left, new_ast_arg_list(right, NULL));
  ast_node *function_name = new_maybe_qstr(new_name);
  ast_node *call_arg_list = new_ast_call_arg_list(new_ast_call_filter_clause(NULL, NULL), new_arg_list);
  ast_node *new_call = new_ast_call(function_name, call_arg_list);

  ast->type = new_call->type;
  ast_set_left(ast, new_call->left);
  ast_set_right(ast, new_call->right);

  AST_REWRITE_INFO_RESET();

  return true;
}

// rewrites the dot operator foo.bar as a function, the operation is either get or set
cql_noexport void rewrite_dot_as_call(
  ast_node *_Nonnull dot,
  CSTR _Nonnull op)
{
  Contract(is_ast_dot(dot));
  EXTRACT_ANY_NOTNULL(expr, dot->left);
  EXTRACT_STRING(func, dot->right);

  CHARBUF_OPEN(k1);
  CHARBUF_OPEN(k2);

  sem_t sem_type = expr->sem->sem_type;
  CSTR kind = expr->sem->kind;

  bprintf(&k1, "%s<%s>:%s:%s", rewrite_type_suffix(sem_type), kind, op, func);
  CSTR new_name = find_op(k1.ptr);
  bool_t add_arg = false;

  if (!new_name) {
    bprintf(&k2, "%s<%s>:%s:all", rewrite_type_suffix(sem_type), kind, op);
    new_name = find_op(k2.ptr);
    add_arg = !!new_name;
  }

  if (!new_name) {
    new_name = Strdup(k1.ptr); // this is for sure going to be an error
  }

  CHARBUF_CLOSE(k2);
  CHARBUF_CLOSE(k1);

  AST_REWRITE_INFO_SET(dot->lineno, dot->filename);

  ast_node *base_list = NULL;
  if (add_arg) {
    EXTRACT_STRING(name, dot->right);
    ast_node *new_str = new_ast_str(dup_printf("'%s'", name));
    base_list = new_ast_arg_list(new_str, NULL);
  }

  ast_node *new_arg_list = new_ast_arg_list(expr, base_list);
  ast_node *function_name = new_maybe_qstr(new_name);
  ast_node *call_arg_list = new_ast_call_arg_list(new_ast_call_filter_clause(NULL, NULL), new_arg_list);
  ast_node *new_call = new_ast_call(function_name, call_arg_list);

  dot->type = new_call->type;
  ast_set_left(dot, new_call->left);
  ast_set_right(dot, new_call->right);

  AST_REWRITE_INFO_RESET();
}

cql_noexport ast_node *_Nonnull rewrite_column_values_as_update_list(
  ast_node *_Nonnull columns_values)
{
  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT_ANY_NOTNULL(name_list, column_spec->left);
  EXTRACT_ANY_NOTNULL(insert_list, columns_values->right);

  AST_REWRITE_INFO_SET(columns_values->lineno, columns_values->filename);

  ast_node *new_update_list_head = new_ast_update_list(NULL, NULL); // fake list head
  ast_node *curr_update_list = new_update_list_head;
  ast_node *name_item = NULL;
  ast_node *insert_item = NULL;
  for (
    name_item = name_list, insert_item = insert_list;
    name_item && insert_item;
    name_item = name_item->right, insert_item = insert_item->right
  ) {
    EXTRACT_STRING(name, name_item->left);
    EXTRACT_ANY_NOTNULL(expr, insert_item->left);
    ast_node *new_update_list = new_ast_update_list(
      new_ast_update_entry(new_maybe_qstr(name), expr),
      NULL
    );
    ast_set_right(curr_update_list, new_update_list);
    curr_update_list = curr_update_list->right;
  }

  AST_REWRITE_INFO_RESET();

  return new_update_list_head->right;
}

// This helper helps us with functions that are only allowed to be
// called in a SQL context.  It rewrites the function call into
// a select statement that returns the result of the function call.
// We use (select ... if nothing throw);
void rewrite_as_select_expr(ast_node *ast) {
  AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

  Contract(is_ast_call(ast));

  // mutate the root
  ast->type = k_ast_select_if_nothing_throw_expr;

  ast_node *new_call = new_ast_call(ast->left, ast->right);

  ast_set_left(
    ast,
    new_ast_select_stmt(
      new_ast_select_core_list(
        new_ast_select_core(
          NULL,
          new_ast_select_expr_list_con(
            new_ast_select_expr_list(
              new_ast_select_expr(new_call, NULL),
              NULL
            ),
            new_ast_select_from_etc(
              NULL,
              new_ast_select_where(
                NULL,
                new_ast_select_groupby(
                  NULL,
                  new_ast_select_having(NULL, NULL)
                )
              )
            )
          )
        ),
        NULL
      ),
      new_ast_select_orderby(
        NULL,
        new_ast_select_limit(
          NULL,
          new_ast_select_offset(NULL, NULL)
        )
      )
    )
  );
  ast_set_right(ast, NULL);

  // for debugging, dump the generated ast without trying to validate it at all
  // print_root_ast(ast->parent);
  // for debugging dump the tree
  // gen_stmt_list_to_stdout(new_ast_stmt_list(ast, NULL));

  AST_REWRITE_INFO_RESET();
}

cql_noexport void rewrite_star_and_table_star_as_columns_calc(
  ast_node *select_expr_list,
  sem_join *jptr)
{
  // no expansion is possible, errors will be emitted later
  if (!jptr) {
    return;
  }

  // if we are in a select statement that is part of an exists expression
  // we don't to expand the *, or T.*, the columns don't matter
  if (is_ast_select_expr_list_con(select_expr_list->parent)) {
    EXTRACT(select_expr_list_con, select_expr_list->parent);
    EXTRACT(select_core, select_expr_list_con->parent);
    EXTRACT_ANY(any_select_core, select_core->parent);

    while (!is_ast_select_stmt(any_select_core)) {
      any_select_core = any_select_core->parent;
    }
    EXTRACT_ANY_NOTNULL(select_context, any_select_core->parent);

    if (is_ast_exists_expr(select_context)) {
      select_expr_list->right = NULL;
      AST_REWRITE_INFO_SET(select_expr_list->lineno, select_expr_list->filename);
      ast_set_left(select_expr_list, new_ast_select_expr(new_ast_num(NUM_INT, "1"), NULL));
      AST_REWRITE_INFO_RESET();

      return;
    }
  }

  for (ast_node *item = select_expr_list; item; item = item->right) {
    EXTRACT_ANY_NOTNULL(select_expr, item->left);

    if (is_ast_star(select_expr)) {
      // if we have * then we need to expand it to the full list of columns
      // we need to do this first because it could include backed columns
      // the usual business of delaying this until codegen time doesn't work
      // fortunately we have a rewrite ready for this case, @COLUMNS(T)
      // so we'll swap that in for the * right here before we go any further.
      // As it is there is an invariant that * never applies to backed tables
      // because in the select form the backed table is instantly replaced with
      // a CTE so the * refers to that CTE.

      AST_REWRITE_INFO_SET(select_expr->lineno, select_expr->filename);

      ast_node *prev = NULL;
      ast_node *first = NULL;

      for (int i = 0; i < jptr->count; i++) {
        CSTR tname = jptr->names[i];

        ast_node *calcs = new_ast_col_calcs(
          new_ast_col_calc(new_maybe_qstr(tname), NULL),
          NULL
        );

        if (i == 0) {
          first = calcs;
        }
        else {
          ast_set_right(prev, calcs);
        }

        prev = calcs;
      }

      select_expr->type = k_ast_column_calculation;
      ast_set_left(select_expr, first);
      AST_REWRITE_INFO_RESET();
    }
    else if (is_ast_table_star(select_expr)) {
      AST_REWRITE_INFO_SET(select_expr->lineno, select_expr->filename);

      // the table name might be an error, no problem, it will be flagged shortly
      // the only name that actually works is the one in the joinscope
      EXTRACT_STRING(tname, select_expr->left);

      select_expr->type = k_ast_column_calculation;
      ast_set_left(select_expr,
        new_ast_col_calcs(
          new_ast_col_calc(
            new_maybe_qstr(tname),
            NULL
          ),
          NULL
        )
      );
      AST_REWRITE_INFO_RESET();
    }
  }
}

#endif
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_SEM)

// stubs to avoid link errors,

cql_noexport void sem_main(ast_node *head) {}
cql_noexport void sem_cleanup() {}
cql_noexport void print_sem_type(struct sem_node *sem) {}

#else

// Perform semantic analysis of the various nodes and validate type correctness
// the semantic nodes contain enough information that code can be generated
// include, importantly, data about the shape of any given select statement
// and the type of any expression.


#define NORMAL_CALL  0  // a normal procedure or function call
#define PROC_AS_FUNC 1  // treating a proc like a function with the out-arg trick

#define IS_NOT_COUNT 0  // analyzing the arguments of a normal function
#define IS_COUNT     1  // analyzing the arguments of the count function

#define IS_CASE 0  // analyzing the arguments of a case expression
#define IS_IIF  1  // analyzing the arguments of an iif expression

#define CQL_FROM_RECREATE "cql:from_recreate"
#define CQL_MODULE_WARN "cql:module_must_not_be_deleted_see_docs_for_CQL0392"

#define SEM_EXPR_CONTEXT_NONE           0x0001
#define SEM_EXPR_CONTEXT_SELECT_LIST    0x0002
#define SEM_EXPR_CONTEXT_WHERE          0x0004
#define SEM_EXPR_CONTEXT_ON             0x0008
#define SEM_EXPR_CONTEXT_HAVING         0x0010
#define SEM_EXPR_CONTEXT_ORDER_BY       0x0020
#define SEM_EXPR_CONTEXT_GROUP_BY       0x0040
#define SEM_EXPR_CONTEXT_LIMIT          0x0080
#define SEM_EXPR_CONTEXT_OFFSET         0x0100
#define SEM_EXPR_CONTEXT_UDF            0x0200
#define SEM_EXPR_CONTEXT_WINDOW         0x0400
#define SEM_EXPR_CONTEXT_WINDOW_FILTER  0x0800
#define SEM_EXPR_CONTEXT_CONSTRAINT     0x1000
#define SEM_EXPR_CONTEXT_FLAGS          0x1FFF // all the flag bits

#define CURRENT_EXPR_CONTEXT_IS(x)  (!!(current_expr_context & (x)))
#define CURRENT_EXPR_CONTEXT_IS_NOT(x)  (!(current_expr_context & (x)))

// These let us form bit masks of acceptable types
#define SEM_TYPE_MASK_NULL (1 << SEM_TYPE_NULL)          // code n
#define SEM_TYPE_MASK_BOOL (1 << SEM_TYPE_BOOL)          // code f (flag)
#define SEM_TYPE_MASK_INT  (1 << SEM_TYPE_INTEGER)       // code i
#define SEM_TYPE_MASK_LONG (1 << SEM_TYPE_LONG_INTEGER)  // code l
#define SEM_TYPE_MASK_REAL (1 << SEM_TYPE_REAL)          // code r
#define SEM_TYPE_MASK_TEXT (1 << SEM_TYPE_TEXT)          // code t
#define SEM_TYPE_MASK_BLOB (1 << SEM_TYPE_BLOB)          // code b
#define SEM_TYPE_MASK_OBJ  (1 << SEM_TYPE_OBJECT)        // code o
#define SEM_TYPE_MASK_OPT  (SEM_TYPE_MASK_OBJ << 1)      // []
#define SEM_TYPE_MASK_REP  (SEM_TYPE_MASK_OBJ << 2)      // code *

// As we walk sql expressions we note the ast nodes that hold table names that
// are backed tables so that we can swap them out later
static list_item *backed_tables_list;
static bool_t in_backing_rewrite;

// This will create the chain of backed tables that we need to rewrite.
// The point of this is to only initialize the list once and then just add
// to it as we go.  These may nest so began_backing_rewrite is used to indicate
// the scope that was outermost.
#define BEGIN_BACKING_REWRITE() \
  bool_t began_backing_rewrite = false; \
  if (!in_backing_rewrite) { \
    backed_tables_list = NULL; \
    in_backing_rewrite = true; \
    began_backing_rewrite = true; \
  }

// This resets the list of tables we need to rewrite. Again we'll do this only once.
// The END_BACKING_REWRITE macro may nest.  Only the outermost scope does anything.
#define END_BACKING_REWRITE() \
  if (began_backing_rewrite) { \
    backed_tables_list = NULL; \
    in_backing_rewrite = false; \
  }

// This is going to tell us if we have to do a backing rewrite.  We have to do a
// backing rewrite if:
//  * we're not in an error state
//  * we've started the backing rewrite
//  * we have a list of backed tables, or
//  * the table we're processing is backed
//
// We'll have a backed table list if there were internal tables in the statement
// that were backed. The backed table list only requires us use the CTE rewrite
// for the tables referred to in the list. If the table we're processing is
// backed then we have to do the full rewrite for that operation type.
#define BACKING_REWRITE_NEEDED(ast, table_ast) \
  (!is_error(ast) && began_backing_rewrite && \
   (backed_tables_list || (table_ast != NULL && is_backed(table_ast->sem->sem_type))))

// These are the symbol tables with the ast dispatch when we get to an ast node
// we look it up here and call the appropriate function whose name matches the ast
// node type.

static symtab *non_sql_stmts;
static symtab *sql_stmts;

// Note: initialized statics are moot because in amalgam mode the code
// will not be reloaded... you have to re-initialize all statics in the cleanup function

// We have to do extra checks against tables that transitioned from the @recreate plan
// to the strongly managed plan
static list_item *all_prev_recreate_tables;

// When validating against the previous schema all newly @create columns must
// have a schema version >= the max in the previous schema.
static list_item *created_columns;
static int32_t max_previous_schema_version;

// Some facts to keep in mind when thinking about pending region validations:
// * when doing previous schema validation the previous schema come after
//   @previous_schema; this means it comes after the main schema so even though
//   it's "previous" it comes second in the file this can be confusing.
//   Previous here always means the item in the previous schema which is the
//   second item of that name found.
// * when the item is encountered it's possible that it is in a region but that
//   region has not yet been used in a deployable region. In order to be sure
//   that deployable regions don't change we have to wait until we've seen all
//   the regions to decide which entities are in which deployable regions.
// * The canonical form of the previous schema has the region declarations first
//   but we can't assume we're getting these in the canonical order. So we have
//   to enqueue.
// * The ast nodes here are durable as always as is the name which comes from
//   the symbol table or the ast node both of which are durable
// * The current region (current_region) won't be set when we come back to this
//   later to validate so we have to store that too.  Confusingly current_region
//   is the current region we are processing and so when this is enqueued it
//   will be the current region of an item in the previous schema.  So it's the
//   current previous region...  We don't want to count on the semantic node of
//   the previous schema item because it might have errors for other reasons and
//   they are lightly processed so we harvest everything we need for later
//   checking.
typedef struct deployable_validation {
  ast_node *prev;       // the node in the previous schema
  ast_node *cur;        // and in the "current" schema (which came before)
  CSTR prev_region;     // the logical region of the previous schema item
  CSTR cur_region;      // and the logical region of the current schema
  CSTR name;            // the name of the entity (whatever type it may be)
} deployable_validation;

// Define the signature of the callback registered in MISC_ATTRS_INT(...) to
// validate attributes on any statement.
typedef void (*sem_misc_attribute_callback)(
    CSTR misc_attr_prefix,
    CSTR misc_attr_name,
    ast_node *ast_misc_attr_values,
    ast_node *misc_attrs,
    ast_node *any_stmt);

static bytebuf *deployable_validations;

static bytebuf *unitary_locals;

// A list node holding the `sem_t *` for a nullability improvement of a global
// variable. These are used for un-setting all improvements of globals at every
// procedure call.
typedef struct global_notnull_improvement_item {
  sem_t *type;
  struct global_notnull_improvement_item *next;
} global_notnull_improvement_item;

// The analysis of loops like LOOP and WHILE is done in two passes. First, we
// analyze the loop to conservatively figure out every improvement that the loop
// could possibly unset. After that, then we reanalyze it with said improvements
// unset to ensure that everything is safe. See `sem_stmt_list_within_loop` for
// more information on why this is necessary.
typedef enum {
  LOOP_ANALYSIS_STATE_NONE,
  LOOP_ANALYSIS_STATE_ANALYZE,
  LOOP_ANALYSIS_STATE_REANALYZE
} loop_analysis_state;

// If a function has been registered via `FUNC_INIT`, its associated analysis
// function must conform to the type `sem_func`. When called, its argument list
// will have already been analyzed and verified to be free of errors.
typedef void sem_func(ast_node *ast, uint32_t arg_count);

// If a function has been registered via `SPECIAL_FUNC_INIT`, its associated
// analysis function must conform to the type `sem_special_func`. When called,
// it must do analysis of its own arguments as appropriate. It must also set
// `*is_aggregate` to true if it should be treated as an aggregate function by
// `sem_expr_call`; it will not be considered an aggregate function otherwise.
typedef void sem_special_func(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate);

// forward references for mutual recursion cases
static void sem_expr_invalid_op(ast_node *ast, CSTR op);
static void sem_stmt_list(ast_node *ast);
static void sem_stmt_list_in_current_flow_context(ast_node *ast);
static void sem_stmt_list_within_loop(ast_node *stmt_list, ast_node *true_expr);
static void sem_select_rewrite_backing(ast_node *node);
static void sem_select_core_list(ast_node *ast);
static void sem_query_parts(ast_node *node);
static void sem_table_function(ast_node *node);
static void sem_as_alias(ast_node *node, CSTR *alias_target, ast_node *ast_target);
static void sem_fetch_stmt(ast_node *ast);
static void sem_fetch_values_stmt(ast_node *ast);
static void sem_call_stmt_opt_cursor(ast_node *ast, CSTR cursor_name);
static void sem_resolve_cursor_field(ast_node *expr, ast_node *cursor, CSTR field, sem_t **type_ptr);
static bool_t sem_try_as_cursor(ast_node *ast, bool_t *hard_fail);
static bool_t sem_validate_context(ast_node *ast, CSTR name, uint32_t valid_contexts);
static void sem_validate_dot_transform(ast_node *ast, CSTR op);
static void sem_expr_select(ast_node *ast, CSTR cstr);
static void sem_with_select_stmt(ast_node *ast);
static void sem_upsert_stmt(ast_node *ast);
static void sem_with_upsert_stmt(ast_node *ast);
static void sem_with_select(ast_node *ast);
static void sem_explain(ast_node *ast);
static void sem_validate_args(ast_node *ast, ast_node *arg_list);
static void sem_validate_args_vs_formals(ast_node *ast, CSTR name, ast_node *arg_list, ast_node *params, bool_t proc_as_func);
static void sem_validate_old_object_or_marked_create(ast_node *root, ast_node *ast, CSTR err_msg, CSTR name);
static void sem_validate_marked_create_or_delete(ast_node *root, ast_node *ast, CSTR err_msg, CSTR name);
static bool_t sem_validate_compatible_table_cols_vals(ast_node *table_ast, ast_node *name_list, ast_node *insert_list);
static bool_t sem_validate_compatible_table_cols_select(ast_node *table_ast, ast_node *name_list, ast_node *select_stmt);
static bool_t sem_validate_compatible_cols_vals(ast_node *name_list, ast_node *values);
static void enqueue_pending_region_validation(ast_node *prev, ast_node *cur, CSTR name);
static void sem_validate_previous_deployable_region(ast_node *root, deployable_validation *v);
static void sem_opt_where(ast_node *ast);
static void sem_opt_orderby(ast_node *ast);
static void sem_opt_filter_clause(ast_node *ast);
static bool_t sem_validate_identical_text(ast_node *prev_def, ast_node *def, gen_func fn, gen_sql_callbacks *callbacks);
static bool_t sem_validate_identical_ddl(ast_node *cur, ast_node *prev);
static void sem_setup_region_filters(void);
static void sem_inside_create_proc_stmt(ast_node *ast);
static void sem_declare_cursor_for_expr(ast_node *ast);
static sem_join * new_sem_join(uint32_t count);
static void sem_validate_check_expr_for_table(ast_node *table, ast_node *expr, CSTR context);
static void sem_validate_index_expr_for_jptr(sem_join *jptr, ast_node *expr);
static void sem_numeric_expr(ast_node *expr, ast_node *context, CSTR subject, uint32_t expr_context);
static void sem_misc_attrs_basic(ast_node *ast);
static void sem_data_type_var(ast_node *ast);
static CSTR sem_combine_kinds_general(ast_node *ast, CSTR kind_left, CSTR kind_right);
static CSTR sem_combine_kinds(ast_node *ast, CSTR current_kind);
static bool_t sem_select_stmt_is_mixed_results(ast_node *ast);
static bool_t sem_verify_legal_variable_name(ast_node *variable, CSTR name);
static void sem_verify_no_anon_columns(ast_node *ast);
static void sem_verify_no_null_columns(ast_node *ast);
static bool_t sem_verify_no_duplicate_names(ast_node *name_list);
static bool_t sem_verify_no_duplicate_shape_exprs(ast_node *shape_exprs);
static sem_t *find_mutable_type(CSTR name, CSTR scope);
static void sem_set_notnull_improved(CSTR name, CSTR scope);
static void sem_unset_notnull_improved(CSTR name, CSTR scope);
static void sem_unset_global_notnull_improvements();
static void sem_set_has_row_improved(CSTR cursor_name);
static void sem_unset_has_row_improved(CSTR cursor_name);
static void sem_set_improvements_for_true_condition(ast_node *ast);
static void sem_set_improvements_for_false_condition(ast_node *ast);
static bool_t variable_should_require_initialization(sem_t sem_type);
static void reset_enforcements(void);
static uint32_t sem_with_depth(void);
static ast_node *sem_find_table(CSTR name, ast_node *ast_error);
static void sem_shared_cte(ast_node *cte_body);
static void sem_declare_proc_stmt(ast_node *ast);
static bool sem_create_migration_proc_prototype(ast_node *origin, CSTR name);
static bool_t sem_has_extra_clauses(ast_node *select_from_etc, ast_node *select_orderby);
static void sem_non_blob_storage_table(ast_node *ast_error, ast_node *ast_table);
static void sem_non_backed_table(ast_node *ast_error, ast_node *ast_table);
static ast_node *sem_synthesize_current_locals();
static CSTR find_column_kind(CSTR table_name, CSTR column_name);
static void sem_assign(ast_node *ast);
static void insert_table_alias_string_overide(ast_node *_Nonnull ast, CSTR _Nonnull table_name);
static bool_t sem_binary_prep_helper(ast_node *ast, ast_node *left, ast_node *right, sem_t *core_type_left, sem_t *core_type_right, sem_t *combined_flags);
static void rewrite_column_values_for_update_stmts(ast_node *_Nonnull ast, ast_node *_Nonnull columns_values, sem_struct *sptr);
static bool_t sem_validate_arg_pattern(CSTR _Nonnull type_string, ast_node *_Nonnull ast_call, uint32_t arg_count);
static sem_node *_Nonnull new_sem_std(sem_t sem_type, ast_node *_Nonnull ast_call);
static void sem_infer_result_blob_type(ast_node *ast, ast_node *arg_list);
static void sem_proc_call_post_check(CSTR name, ast_node *ast, ast_node *arg_list);
static void sem_any_select(ast_node *ast);
static void sem_insert_returning(ast_node *ast);
static void sem_delete_returning(ast_node *ast);
static void sem_update_returning(ast_node *ast);
static void sem_upsert_returning(ast_node *ast);

// create a new id node either qid or normal based on the bool
cql_noexport ast_node *new_str_or_qstr(CSTR name, sem_t sem_type) {
  if (sem_type & SEM_TYPE_QID) {
    return new_ast_qstr_escaped(name);
  }
  else {
    return new_ast_str(name);
  }
}

cql_noexport ast_node *new_maybe_qstr(CSTR name) {
  if (is_qname(name)) {
    return new_ast_qstr_escaped(name);
  }
  else {
    return new_ast_str(name);
  }
}

static void copy_nullability(ast_node *ast, sem_t nullable) {
  ast->sem->sem_type &= sem_not(SEM_TYPE_NOTNULL);
  ast->sem->sem_type |= (nullable & SEM_TYPE_NOTNULL);
}

static void copy_sensitivity(ast_node *ast, sem_t sensitive) {
  ast->sem->sem_type &= sem_not(SEM_TYPE_SENSITIVE);
  ast->sem->sem_type |= (sensitive & SEM_TYPE_SENSITIVE);
}

#define SEM_REVERSE_APPLY_ANALYZE_CALL 1
#define SEM_REVERSE_APPLY_REWRITE_ONLY 0
static bool_t sem_reverse_apply_if_needed(ast_node *ast, bool_t analyze);

static void lazy_free_symtab(void *syms) {
  symtab_delete(syms);
}

static void add_pending_symtab_free(symtab *syms) {
  lazy_free *p = _new(lazy_free);
  p->context = syms;
  p->teardown = lazy_free_symtab;
  add_lazy_free(p);
}

struct enforcement_options {
  bool_t strict_fk_update;            // indicates there must be some "ON UPDATE" action in every FK
  bool_t strict_fk_delete;            // indicates there must be some "ON DELETE" action in every FK
  bool_t strict_join;                 // only ANSI style joins may be used, "from A,B" is rejected
  bool_t strict_upsert_stmt;          // no upsert statement may be used
  bool_t strict_window_func;          // no window functions may be used
  bool_t strict_without_rowid;        // no WITHOUT ROWID may be used.
  bool_t strict_transaction;          // no transactions may be started, commited, aborted etc.
  bool_t strict_if_nothing;           // (select ..) expressions must include the if nothing form
  bool_t strict_insert_select;        // insert with select may not include joins
  bool_t strict_table_function;       // table valued functions cannot be used on left/right joins (avoiding SQLite bug)
  bool_t strict_is_true;              // IS TRUE, IS FALSE, etc. may not be used because of downlevel issues
  bool_t strict_cast;                 // NO-OP casts result in errors
  bool_t strict_sign_function;        // the SQLite sign function may not be used (as it is absent in <3.35.0)
  bool_t strict_cursor_has_row;       // auto cursors require a has-row check before certain fields are accessed
  bool_t strict_update_from;          // the UPDATE statement may not include a FROM clause (absent in <3.33.0)
  bool_t strict_and_or_not_null_check; // nullability analysis on AND/OR logical expressions
};

static struct enforcement_options enforcement;

typedef struct enforcement_stack_record {
  struct enforcement_stack_record *next;
  struct enforcement_options options;
} enforcement_stack_record;

static struct enforcement_stack_record *enforcement_stack;

typedef struct dummy_info {
  CSTR name;                    // the column name
  sem_t sem_type_col;           // its type
  ast_node *name_list_head;     // name list head and tail
  ast_node *name_list_tail;
  ast_node *insert_list_head;   // insert list head and tail
  ast_node *insert_list_tail;
  sem_join *jptr;               // the scope of the name
  bool_t use_null;              // use null for the dummy value rather than the seed
  bool_t sql_context;           // true if the dummy value is evaluated by SQLite (e.g. an insert value)
} dummy_info;

static void sem_synthesize_dummy_value(dummy_info *info);

// When processing version attributes there's a lot going on and loose arguments are insane.  So hence this struct.
typedef struct version_attrs_info {
  // inputs
  CSTR name;                          // the name of the thing we're studying (for errors)
  ast_node *target_ast;               // the thing whose version attributes are being studied
  ast_node *attrs_ast;                // the start of the version attributes on the thing

  // result
  int32_t create_version;             // the create version or -1
  ast_node *create_version_ast;       // the @create version ast
  CSTR create_proc;                   // the create migration proc if any
  int32_t delete_version;             // the delete version or -1
  ast_node *delete_version_ast;       // the @delete version ast
  CSTR delete_proc;                   // the delete migration proc if any
  sem_t flags;                        // SEM_FLAGS_DELETED or  0
  uint32_t create_code;               // @create annotation code (computed from ast type)
  uint32_t delete_code;               // @delete annotation code (computed from ast type)
  bool_t recreate;                    // true if table is on the @recreate plan
  ast_node *recreate_version_ast;     // the @recreate node
  CSTR recreate_group_name;           // the @recreate group name if there is one
  bool_t is_virtual_table;            // versioning rules for virtual tables apply
  bool_t is_temp;                     // versioning rules for temp objects apply
} version_attrs_info;

// extracts the useful information out of @create and @delete versions
static bool_t sem_validate_version_attrs(version_attrs_info *vers_info);

// validates previous and current attributes for valid progression
static bool_t sem_validate_attrs_prev_cur(version_attrs_info *prev, version_attrs_info *cur, ast_node *name_ast);

// ensures DDL inside of a proc has no attributes
static bool_t sem_validate_vers_ok_in_context(version_attrs_info *vers);

// records an annotation from the version info
static void sem_record_annotation_from_vers_info(version_attrs_info *vers_info);

// Validate whether or not an object is usable with a schema region. The object
// can only be a table, view, trigger or index.
static bool_t sem_validate_object_ast_in_current_region(
    CSTR name,
    ast_node *table_ast,
    ast_node *err_target,
    CSTR msg);

// The current join can have a parent if it is a nested select so we have to capture a stack
// of joins as the current joinscope.

typedef struct sem_joinscope {
  sem_join *jptr;
  struct sem_joinscope *parent;
} sem_joinscope;

// This defines the join scope that will be searched when resolving names
static sem_joinscope *current_joinscope;

// we're watching any symbols that come from this scope
static sem_join *monitor_jptr;

// if we see a symbol in the monitored scope, put it in this table.
static symtab *monitor_symtab;

// nested select level
static int32_t select_level;

// nested statement level
static int32_t sem_stmt_level;

// for making unique names of between temporaries
static int32_t between_count;

// If we are nested in a loop/while.
static int32_t loop_depth;

// If the current proc has used DML/DDL.
static bool_t has_dml;

// If the current proc is a shared fragment
static bool_t in_shared_fragment;

// If we are current processing the use of a shared fragment
static bool_t in_shared_fragment_call;

// If the current context is a trigger statement list
static bool_t in_trigger;

// If the current context is a trigger statement when clause
static bool_t in_trigger_when_expr;

// If the current context is inside of a switch statement
static bool_t in_switch;

// If we are within a proc savepoint block, then true
static bool_t in_proc_savepoint;

// The schema version can be overridden to look at previous versions for upgrade scripts
// -1 indicates that the lastest schema should be used
static int32_t schema_upgrade_version;

// In a schema upgrade script we don't hide tables and we don't use create statements
// in procs as declarations.
static bool_t schema_upgrade_script;

// The current schema region if any, these do not nest
static CSTR current_region;

// These are all the names of all the antecedents of the current region (transitively)
static symtab *current_region_image;

// The current explain statement being process
static ast_node *current_explain_stmt;

// The current expression context (i.e. what part of the statement are we parsing).
static uint32_t current_expr_context;

// If we have started validating previous schema this will be true
static bool_t validating_previous_schema;

// The current annonation target in create proc statement
static CSTR annotation_target;

// When we're doing previous schema validation we will march through the unsub
// directives in order, this tells us the next one to consider.
static list_item *next_subscription;

// Once we've found an error during previous subscription validation, we don't
// report any more to avoid crazy spam. This is the mercy flag.
static bool_t found_subscription_error;

// True if we are analyzing a call to `cql_inferred_notnull`. This can happen
// for three reasons:
//
// * We just did a rewrite that produced a `cql_inferred_notnull` call and now
//   we're computing its type.
// * We're analyzing an expression that was already analyzed (e.g., in a CTE).
// * We're analyzing the output of a previous CQL run within which calls to
//   `cql_inferred_notnull` may occur.
//
// Regardless of the cause, if `is_analyzing_notnull_rewrite` is true, we do not
// want to rewrite again.
static bool_t is_analyzing_notnull_rewrite;

// Keeps track of all global variables that may currently be improved to be NOT
// NULL. We need this because we must un-improve all such variables after every
// procedure call (because we don't do inter-procedural analysis and cannot know
// which globals may have been set to NULL).
static global_notnull_improvement_item *global_notnull_improvements;

// Keeps tracks of the current loop analysis state. If this is equal to
// `LOOP_ANALYSIS_STATE_ANALYZE`, we are analyzing with a non-final set of
// improvements. This is useful for two reasons:
//
// 1. Procedures that perform rewrites based on improvements (e.g.,
//    `sem_resolve_id_expr`) can use this to verify whether a rewrite is safe to
//    perform (`LOOP_ANALYSIS_STATE_NONE` or `LOOP_ANALYSIS_STATE_REANALYZE`) or
//    whether they should wait because they do not yet have definitive
//    information (`LOOP_ANALYSIS_STATE_ANALYZE`).
//
// 2. Analyses that would otherwise fail if called during reanalysis (e.g.,
//    `sem_verify_legal_variable_name`) can use this to check whether the
//    current state is `LOOP_ANALYSIS_STATE_REANALYZE` and adjust their
//    behaviors accordingly.
static loop_analysis_state current_loop_analysis_state = LOOP_ANALYSIS_STATE_NONE;

// True if the procedure currently being analyzed contains a TRY block that has
// been annotated with [[try_is_proc_body]]. Such an annotation
// implies that, conceptually, the main logic of the procedure exists entirely
// within the TRY block; any surrounding code typically exists only for the
// purpose of atypical error reporting or logging.
//
// See `sem_find_ast_misc_attr_trycatch_is_proc_body_callback` for context.
static bool_t current_proc_contains_try_is_proc_body;

// sentinel for blocking the join chain
static sem_join join_block;

// Push a context that stops us from searching further up.
#define PUSH_JOIN_BLOCK() \
  sem_joinscope blocker;\
  blocker.parent = current_joinscope; \
  blocker.jptr = &join_block; \
  current_joinscope = &blocker;

// Push the current join onto the joinscope, this is for nested selects for instance.
#define PUSH_JOIN(name, x)  \
  sem_joinscope name;  \
  name.parent = current_joinscope; \
  name.jptr = x; \
  current_joinscope = &name;

#define POP_JOIN() \
  current_joinscope = current_joinscope->parent;

// Save the current expression context and create a new one, needed for instance
// if there is a nested select expression.  The context must have EXACTLY one
// bit set (enforced by contract below)
#define PUSH_EXPR_CONTEXT(x) \
  uint32_t saved_expr_context = current_expr_context; \
  current_expr_context = (x); \
  Contract(0 == (current_expr_context & (current_expr_context - 1)))

#define POP_EXPR_CONTEXT() \
  current_expr_context = saved_expr_context

// We push a new monitor but only if there isn't already one present; the signal
// is that the symtab is not null if there is one present if there is one
// present, we just disable it by setting the jptr to null we only do the
// monitoring and therefore alias minification on the top level select
// statements;  internal names can be used all over for nested nested selects
// and correlated sub-queries.  That's not where the space savings is anyway.
#define PUSH_MONITOR_SYMTAB() \
  symtab *monitor_symbtab_saved = monitor_symtab; \
  sem_join *monitor_jptr_saved = monitor_jptr; \
  if (select_level != 1) { \
    monitor_jptr = NULL; \
    used_symbols = NULL; \
    monitor_symtab = NULL; \
  } \
  else { \
    monitor_jptr = current_joinscope->jptr; \
    used_symbols = monitor_symtab = symtab_new(); \
    add_pending_symtab_free(used_symbols); \
  }

// put it all back unconditionally.
#define POP_MONITOR_SYMTAB() \
  monitor_jptr = monitor_jptr_saved; \
  monitor_symtab = monitor_symbtab_saved;

// These are the various symbol tables we need, they are stored super dumbly.
static symtab *interfaces;
static symtab *procs;
static symtab *unchecked_procs;
static symtab *proc_arg_info;
static symtab *triggers;
static symtab *upgrade_procs;
static symtab *ad_hoc_migrates;
static symtab *builtin_funcs;
static symtab *builtin_special_funcs;
static symtab *builtin_sql_rewrites;
static symtab *funcs;
static symtab *unchecked_funcs;
static symtab *exprs;
static symtab *tables;
static symtab *table_default_values;
static symtab *backing_info;
static symtab *ops;
static symtab *indices;
static symtab *globals;
static symtab *locals;
static symtab *enums;
static symtab *constant_groups;
static symtab *variable_groups;
static symtab *constants;
static symtab *current_variables;
static symtab *savepoints;
static symtab *table_items;  // assorted things that go into a table
static symtab *builtin_aggregated_funcs;
static symtab *arg_bundles;
static symtab *global_types;
static symtab *local_types;
static symtab *misc_attributes;

static ast_node *current_table_ast;
static CSTR current_table_name;

// during previous schema validations when we hit the previous section we have
// to save these, they the new schema for later comparison
static symtab *new_regions;
static symtab *new_enums;

// for dispatching expression types
typedef struct sem_expr_dispatch {
  void (*func)(ast_node *ast, CSTR str);
  CSTR str;
} sem_expr_dispatch;

// If we encounter an FK that refers to the table it is in then we have to defer
// processing of that FK until the table's columns and types are all known.
// This just gives us an easy way to hold the data we need to validate until
// later.
typedef struct pending_table_validation {
  struct pending_table_validation *next;
  ast_node *ref_table_ast;
  ast_node *table_ast;
  ast_node *def;
  ast_node *fk;  // for fk attributes
  ast_node *check; // for check expressions
} pending_table_validation;

// The list of pending FK validations
static pending_table_validation *pending_table_validations_head;

static void sem_validate_fk_attr(pending_table_validation *pending);

// for verifying that a particular shared fragment call does not cause name
// conflicts inside the fragment
typedef struct binding_info {
  CSTR actual;
  CSTR formal;
  CSTR proc;
  CSTR proc_calling;
  charbuf *err;
} binding_info;

// This helper method checks the given name against the current context
static bool_t sem_validate_context(ast_node *ast, CSTR name, uint32_t valid_contexts) {
  if (CURRENT_EXPR_CONTEXT_IS(valid_contexts)) {
    return true;
  }

  report_error(ast, "CQL0080: function may not appear in this context", name);
  record_error(ast);
  return false;
}

// This helper method checks the function against the mask of its valid contexts.
static bool_t sem_validate_function_context(ast_node *ast, uint32_t valid_contexts) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);

  return sem_validate_context(ast, name, valid_contexts);
}

// validate the node appear inside SQL statement
static bool_t sem_validate_appear_inside_sql_stmt(ast_node *ast) {
  return sem_validate_function_context(ast, u32_not(SEM_EXPR_CONTEXT_NONE));
}

// validate the node appear inside SQL statement
static bool_t sem_validate_sql_not_constraint(ast_node *ast) {
  return sem_validate_function_context(
    ast,
    u32_not(SEM_EXPR_CONTEXT_NONE | SEM_EXPR_CONTEXT_CONSTRAINT));
}


// If a foreign key in a table is self-referencing (i.e. T references T)
// then we have to defer the validation until we're done with the table and
// have compute all the types of all the columns.  So store the data so we can
// run it later
static void enqueue_pending_table_validation(pending_table_validation *pending) {
  pending_table_validation *v = _ast_pool_new(pending_table_validation);
  *v = *pending;
  v->next = pending_table_validations_head;
  pending_table_validations_head = v;
}

// Once we're done with the table, if any validations are pending we can dispatch them
// There are two types:  the attribute type e.g. "ref_id references T(id)" and
// the check expression type e.g. check(length(name) <32).  Both cases can be
// resolved after the table is fully processed because at that point we know all
// the column names in the table.  FK references seem like they could be
// resolved immediately until you consider that a table may FK to its own
// columns so we have to know all the names to be sure to give correct errors in
// that case, too.
static void run_pending_table_validations() {
  pending_table_validation *v = pending_table_validations_head;

  for (; v; v = v->next) {
    if (v->fk) {
      sem_validate_fk_attr(v);
      if (is_error(v->fk)) {
        goto error;
      }
    }
    else {
      Invariant(v->check);
      sem_validate_check_expr_for_table(v->table_ast, v->check, "CHECK");
      if (is_error(v->check)) {
        goto error;
      }
    }
  }

  pending_table_validations_head = NULL;  // the minipool will free these
  return;

error:
  record_error(v->table_ast);
  record_error(v->def);
  pending_table_validations_head = NULL;  // the minipool will free these
}

// This is validation for a check expression: deferred The tables columns are
// now known that there is a computed sptr for the tables type. We can put all
// it's columns into scope by creating a pending join expression the one struct
// in it. There is nothing else in scope here.  Note variables are allowed, but
// weird. You can in principle bind variables in place of constants in DDL but
// this is basically never done. Still, for symmetry we allow this (not new here
// but expressions are few in DDL)
//   * create a join context with a table that is impossible to name
//   * expressions like T.id are always invalid hence we use $$ for the name
//     because that can match no syntactically correct "T".
//   * do semantic analysis as usual on the expression, any numeric is ok for a
//     bool
static void sem_validate_check_expr_for_table(
  ast_node *table,
  ast_node *expr,
  CSTR context)
{
  Contract(is_ast_create_table_stmt(table));
  Contract(expr);

  if (!is_error(table)) {
    sem_join *jptr;
    sem_struct *sptr = table->sem->sptr;

    // there is no scope name for this, use an invalid identifier
    jptr = new_sem_join(1);
    jptr->names[0] = "$$";
    jptr->tables[0] = sptr;

    // jptr is freed by the mini allocator later

    // save current symbol tables
    symtab *saved_locals = locals;
    symtab *saved_globals = globals;

    // hide variables for this expression
    locals = globals = NULL;

    PUSH_JOIN(expr_scope, jptr);
    sem_numeric_expr(expr, NULL, context, SEM_EXPR_CONTEXT_CONSTRAINT);
    POP_JOIN();

    locals = saved_locals;
    globals = saved_globals;

    // expr is already marked with an error by the above, no further
    // record_error needed
  }
}

static void sem_validate_index_expr_for_jptr(sem_join *jptr, ast_node *expr) {
  Contract(jptr);
  Contract(expr);

  // save current symbol tables
  symtab *saved_locals = locals;
  symtab *saved_globals = globals;

  // hide variables for this expression
  locals = globals = NULL;

  PUSH_JOIN(expr_scope, jptr);
  sem_root_expr(expr, SEM_EXPR_CONTEXT_CONSTRAINT);
  POP_JOIN();

  locals = saved_locals;
  globals = saved_globals;

  // expr is already marked with an error by the above, no further record_error
  // needed
}

// data needed for processing a column definition
typedef struct col_def_info {
  version_attrs_info *table_info;    // the various table version info items from the containing table
  sem_t col_sem_type;                // the semantic type of the created_columns
  CSTR col_name;                     // the column we are currently processing
  int32_t autoinc_columns;           // total number of autoinc columns in this table (at most 1)
  int32_t primary_keys;              // total number of primary key columns in this table (at most 1)
  int32_t previous_create_version;   // version number of the previous column (ordinal n-1)
  int32_t create_version;            // create version of this column or -1
  int32_t delete_version;            // delete version of this column or -1
  int32_t column_ordinal;            // column ordinal number (0 based, for this table)
  CSTR create_proc;                  // the name of the create migration proc if any
  CSTR delete_proc;                  // the name of the delete migration proc if any
  ast_node *default_value;           // the default value expression if there is one
} col_def_info;

// We collect these as we process the column definitions. tracking this
// information helps us to report on duplicates (e.g., you can't specify primary
// key two times) and otherwise get the results on a silver platter when
// processing is done. This also gives us access to the pending table info which
// can be used for validation and error messages.
static void init_col_def_info(col_def_info *info, version_attrs_info *table_info) {
  info->table_info = table_info;
  info->col_sem_type = SEM_TYPE_PENDING;
  info->col_name = NULL;
  info->autoinc_columns = 0;
  info->primary_keys = 0;
  info->create_version = -1;
  info->delete_version = -1;
  info->previous_create_version = -1;
  info->column_ordinal = -1;
  info->create_proc = NULL;
  info->delete_proc = NULL;
  info->default_value = NULL;
}

typedef struct name_check {
  // inputs
  ast_node *name_list;       // the name list
  sem_join *jptr;            // the scope in which to look for these names

  symtab *names;             // the names we found (no duplicates)
  ast_node *name_list_tail;  // the tail of the name list
  uint32_t count;            // the count of names
} name_check;

static bool_t sem_name_check(name_check *check);

// This is the setup for looking for a list of names in a particular join scope.
// This is useful for making sure names are from (e.g.) the names in the select
// list, or the names of the columns of a table (one sptr in the jptr will do
// that job) or other such contexts.
static void init_name_check(
  name_check *check,
  ast_node *name_list,
  sem_join *jptr)
{
  check->names = symtab_new();
  check->name_list_tail = NULL;
  check->count = 0;
  check->jptr = jptr;
  check->name_list = name_list;
}

// Releases the temp info.
static void destroy_name_check(name_check *check) {
  symtab_delete(check->names);
  check->name_list_tail = NULL;
  check->count = 0;
}

// create a durable copy of the text of a simple expression
static CSTR dup_expr_text_buffer(charbuf *tmp, ast_node *expr) {
  CSTR result = NULL;

  // we want all the text, unexpanded, so NOT for Sqlite output (this is raw echo)
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_echo;

  gen_set_output_buffer(tmp);
  if (is_ast_param(expr)) {
    gen_with_callbacks(expr, gen_param, &callbacks);
  }
  else {
    gen_with_callbacks(expr, gen_root_expr, &callbacks);
  }
  result = Strdup(tmp->ptr);

  return result;
}

// create a durable copy of the text of a simple expression
CSTR dup_expr_text(ast_node *expr) {
  CHARBUF_OPEN(tmp);
  CSTR result = dup_expr_text_buffer(&tmp, expr);
  CHARBUF_CLOSE(tmp);
  return result;
}

// get the text for the expression, avoid the memory alloc for the easy case
static CSTR expr_as_text(ast_node *expr) {
  if (is_ast_str(expr)) {
   // easy case, super common, we have the name handy
   EXTRACT_STRING(name, expr);
   return name;
  }

  // it's an expression so we have to compute the text
  return dup_expr_text(expr);
}

// The name list item could be either indexed columns or a vanilla name list
// indexed columns have extra shape and might hold an expression. If an
// expression then we need to use the text of the expression as the value.
CSTR string_from_name_list_item(ast_node *node) {
  Contract(is_ast_indexed_columns(node) || is_ast_name_list(node));

  if (is_ast_indexed_columns(node)) {
    EXTRACT_NOTNULL(indexed_column, node->left);
    EXTRACT_ANY_NOTNULL(expr, indexed_column->left);

    return expr_as_text(expr);
  }

  EXTRACT_STRING(name, node->left);
  return name;
}

// Check if two name list nodes have the same members (in any order)
static bool_t is_name_list_equal(ast_node *name_list1, ast_node *name_list2) {
  symtab *cache = symtab_new();

  uint32_t count1 = 0;

  for (ast_node *name_list = name_list1; name_list; name_list = name_list->right) {
    CSTR name = string_from_name_list_item(name_list);
    symtab_add(cache, name, NULL);
    count1++;
  }

  uint32_t count2 = 0;

  for (ast_node *name_list = name_list2; name_list; name_list = name_list->right) {
    CSTR name = string_from_name_list_item(name_list);
    if (!symtab_find(cache, name)) {
      symtab_delete(cache);
      return false;
    }
    count2++;
  }

  symtab_delete(cache);
  return count1 == count2;
}

// Check if one of the indexed_columns is a subset of the other
// e.g: if indexed_columns2 is (a, b) then
//
// indexed_columns1 = (a, b, c) returns true
// indexed_columns1 = (b, a) returns true
// indexed_columns1 = (c, d, b, a) returns true
// indexed_columns1 = (a) returns true
//
// AND
//
// indexed_columns1 = (a, c) return false
// indexed_columns1 = (d) return false
// indexed_columns1 = (b, d) return false
static bool_t is_either_list_a_subset(ast_node *indexed_columns1, ast_node *indexed_columns2) {
  ast_node *a1 = indexed_columns1;
  ast_node *a2 = indexed_columns2;
  while (a1 && a2) {
    a1 = a1->right;
    a2 = a2->right;
  }

  // First make sure the small list is indexed_columns1 and bigger list is
  // indexed_columns2 so we can just check if small list is in bigger list.
  if (!a2 && a1) {
    // exchange if is a2 is smaller
    ast_node *temp = indexed_columns1;
    indexed_columns1 = indexed_columns2;
    indexed_columns2 = temp;
  }

  bool_t included = true;
  symtab *cache = symtab_new();
  for (ast_node *names = indexed_columns2; names; names = names->right) {
    EXTRACT(indexed_column, names->left);
    EXTRACT_ANY_NOTNULL(expr, indexed_column->left);
    symtab_add(cache, expr_as_text(expr), NULL);
  }

  for (ast_node *names = indexed_columns1; names; names = names->right) {
    EXTRACT(indexed_column, names->left);
    EXTRACT_ANY_NOTNULL(expr, indexed_column->left);
    if (!symtab_find(cache, expr_as_text(expr))) {
      included = false;
      break;
    }
  }

  symtab_delete(cache);
  return included;
}

// Find the first unique key node in table_ast
static ast_node *find_first_unique_key(ast_node *table_ast) {
  Contract(is_ast_create_table_stmt(table_ast) &&
           is_ast_col_key_list(table_ast->right));
  ast_node *result = NULL;
  for (ast_node *col_key_list = table_ast->right; col_key_list; col_key_list = col_key_list->right) {
    ast_node *col_def = col_key_list->left;
    if (is_ast_unq_def(col_def)) {
      result = col_def;
      break;
    }
  }
  return result;
}

// Find the next unique key node to uk node in table_ast
static ast_node *find_next_unique_key(ast_node *unq_def) {
  Contract(is_ast_unq_def(unq_def));
  EXTRACT_NOTNULL(col_key_list, unq_def->parent);
  ast_node *result = NULL;
  while ((col_key_list = col_key_list->right)) {
    ast_node *col_def = col_key_list->left;
    if (is_ast_unq_def(col_def)) {
      result = col_def;
      break;
    }
  }
  return result;
}

// Check if a unique key ('uk') is valid. We only look at at all the unique keys
// preceding 'uk' because they have passed all validation already. e.g.,
//
//   create table simple_ak_table_4 (
//     a integer not null,
//     b text,
//     c real,
//     d long int
//   );
//
// case 1:
//  * uk a,b  OK so far!
//  * uk a,b,c  INVALID:  (a,b) already unique
//  * uk b,a  INVALID: same as (a,b)
//  * uk c, d, b, a  INVALID: contains (a,b) which is already unique
//  * uk a  INVALID: because then (b,a) would be bogus because it contains (a)
//
// case 2:
//  * uk a, b  OK!
//  * uk a, c  OK! Because it has c, not found in (a, b)
//  * uk d  OK! Because d not in any of the above
//  * uk b, d  INVALID: because d already unique by itself above
//  * uk b, c  OK! because no one key already has (b, c) in it
//
// As you can see from the examples the general rule here is that if the columns
// of the new key are a superset of any previous key then it's kind of a goofy
// unique key because something smaller is already unique.  And likewise if this
// key is completely contained in any previous key then that previous key is
// goofy because this smaller key is already unique.
static bool_t is_unique_key_valid(ast_node *table_ast, ast_node *uk) {
  Contract(is_ast_create_table_stmt(table_ast) && is_ast_unq_def(uk));
  EXTRACT_NOTNULL(indexed_columns_conflict_clause, uk->right);
  EXTRACT_NAMED_NOTNULL(indexed_columns1, indexed_columns, indexed_columns_conflict_clause->left);
  for (ast_node *unq_def = find_first_unique_key(table_ast); unq_def; unq_def = find_next_unique_key(unq_def)) {
    if (uk == unq_def) {
      break;
    }

    EXTRACT_NAMED_NOTNULL(indexed_columns_conflict_clause2, indexed_columns_conflict_clause, unq_def->right);
    EXTRACT_NAMED_NOTNULL(indexed_columns2, indexed_columns, indexed_columns_conflict_clause2->left);
    if (is_either_list_a_subset(indexed_columns1, indexed_columns2)) {
      return false;
    }
  }
  return true;
}

// Make sure the given number is an integer, and is in range. We can only check
// the range if the integer evaluates to a constant which is common enough that
// we try to do this here. If it's a not something we recognize is a constant
// then all bets are off.
static bool_t is_num_int_in_range(
  ast_node *ast,
  int64_t lower,
  int64_t upper)
{
  // any non-integer type is out;  can't be "real" or "null" in particular which
  // are usually considered numeric compat but not here.  This is an index.
  if (!is_any_int(ast->sem->sem_type)) {
    return false;
  }

  eval_node result = EVAL_NIL;
  eval(ast, &result);

  if (result.sem_type == SEM_TYPE_ERROR) {
    // not a constant, can't verify it now, this will have to be a run time
    // error
    return true;
  }

  // put the result in the int64 fields
  eval_cast_to(&result, SEM_TYPE_LONG_INTEGER);

  return result.int64_value >= lower && result.int64_value <= upper;
}

// Wrappers for the func table.
static bool_t add_func(ast_node *ast, CSTR name) {
  return symtab_add(funcs, name, ast);
}

ast_node *find_func(CSTR name) {
  symtab_entry *entry = symtab_find(funcs, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// wrappers for unchecked functions
static bool_t add_unchecked_func(ast_node *ast, CSTR name) {
  return symtab_add(unchecked_funcs, name, ast);
}

cql_noexport ast_node *find_unchecked_func(CSTR name) {
  symtab_entry *entry = symtab_find(unchecked_funcs, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// wrapper for the op table (for @op)
CSTR find_op(CSTR op_key) {
  symtab_entry *entry = symtab_find(ops, op_key);
  CSTR result = NULL;
  if (entry && entry->val && ((CSTR)entry->val)[0]) {
    result = (CSTR)entry->val;
  }
  return result;
}

// wrapper for @recreate migration procs, these turn out to be a bad idea but we
// are stuck supporting this now.
ast_node *find_recreate_migrator(CSTR name) {
  symtab_entry *entry = symtab_find(ad_hoc_recreate_actions, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrappers for the index tables (note we only use these for validation).
static void add_index(ast_node *ast, CSTR name) {
  symtab_add(indices, name, ast);
}

static ast_node *find_index(CSTR name) {
  symtab_entry *entry = symtab_find(indices, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// returns the node only if it exists and is not restricted by the schema region.
static ast_node *find_usable_index(CSTR name, ast_node *err_target, CSTR msg) {
  ast_node *index_ast = find_index(name);
  if (!index_ast) {
    report_error(err_target, msg, name);
    return NULL;
  }

  if (!sem_validate_object_ast_in_current_region(name, index_ast, err_target, msg)) {
    return NULL;
  }

  return index_ast;
}

// Standard helpers for checking for a semantic error in the AST.
cql_noexport bool_t is_sem_error(sem_node *sem) {
  return !sem || core_type_of(sem->sem_type) == SEM_TYPE_ERROR;
}

cql_noexport bool_t is_error(ast_node *ast) {
  return !ast || is_sem_error(ast->sem);
}

// These tables do not get deployed, they are logical constructs only
cql_noexport bool_t is_table_not_physical(ast_node *table_ast) {
  return is_table_blob_storage(table_ast) || is_table_backed(table_ast);
}

// we're looking for an an inline (inline in the SQL) function call to a shared
// fragment.  These will have been previously marked with SEM_TYPE_INLINE_CALL
// in sem_validate_expression_fragment.
cql_noexport bool_t is_inline_func_call(ast_node *call_ast) {
  Contract(is_ast_call(call_ast));
  return call_ast->left &&
    call_ast->left->sem &&
    (call_ast->left->sem->sem_type & SEM_TYPE_INLINE_CALL);
}

// Note: this returns the flag not a bool.
static sem_t not_nullable_flag(sem_t sem_type) {
  return sem_type & SEM_TYPE_NOTNULL;
}

cql_noexport bool_t is_not_nullable(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_NOTNULL);
}

static bool_t has_default(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_HAS_DEFAULT);
}

static bool_t has_autoincrement(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_AUTOINCREMENT);
}

// Note this returns the flag not a bool.
static sem_t both_notnull_flag(sem_t sem_type_1, sem_t sem_type_2) {
  return sem_type_1 & sem_type_2 & SEM_TYPE_NOTNULL;
}

// Note this returns the flag not a bool.
cql_noexport sem_t sensitive_flag(sem_t sem_type) {
  return sem_type & SEM_TYPE_SENSITIVE;
}

// If any of the fields of the struct type are SENSITIVE then the result is SENSITIVE
// We need this to handle EXISTS(select * from ...)
static sem_t any_sensitive(sem_struct *sptr) {
  sem_t sem_sensitive = 0;
  for (uint32_t i = 0; sem_sensitive == 0 && i < sptr->count; i++) {
    sem_sensitive |= sensitive_flag(sptr->semtypes[i]);
  }
  return sem_sensitive;
}

// The normal combination for semantic flags, just the flags:
// * if either is nullable the result is nullable
// * if either is sensitive the result is sensitive nullable is weird because
//   the flag is "NOTNULL" so everything is inverted
static sem_t combine_flags(sem_t sem_type_1, sem_t sem_type_2) {
  return both_notnull_flag(sem_type_1, sem_type_2) |
         sensitive_flag(sem_type_1) |
         sensitive_flag(sem_type_2);
}

// This is needed as often as the other case.
cql_noexport bool_t is_nullable(sem_t sem_type) {
  return !(sem_type & SEM_TYPE_NOTNULL);
}

cql_noexport bool_t is_inferred_notnull(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_INFERRED_NOTNULL);
}

cql_noexport bool_t is_sensitive(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_SENSITIVE);
}

static bool_t is_unique_key(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_UK);
}

cql_noexport bool_t is_virtual_ast(ast_node *ast) {
  return ast->sem && (ast->sem->sem_type & SEM_TYPE_VIRTUAL);
}

cql_noexport bool_t is_primary_key(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_PK);
}

cql_noexport bool_t is_partial_pk(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_PARTIAL_PK);
}

cql_noexport bool_t is_foreign_key(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_FK);
}

// Returns true if exactly one flag bit is set, else false.
cql_noexport bool_t is_single_flag(sem_t sem_type) {
  return sem_type & SEM_TYPE_FLAGS && !(sem_type & (sem_type - 1));
}

// Strips out all the flag bits and gives you the base/core type.
cql_noexport sem_t core_type_of(sem_t sem_type) {
  return sem_type & SEM_TYPE_CORE;
}

// Several helpers for identifying various node types.
cql_noexport bool_t is_bool(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_BOOL;
}

cql_noexport bool_t is_real(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_REAL;
}

cql_noexport bool_t is_variable(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_VARIABLE);
}

cql_noexport bool_t is_in_parameter(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_IN_PARAMETER);
}

cql_noexport bool_t is_out_parameter(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_OUT_PARAMETER);
}

cql_noexport bool_t is_cursor_formal(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_CURSOR_FORMAL;
}

cql_noexport bool_t was_set_variable(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_WAS_SET);
}

cql_noexport bool_t is_backing(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_BACKING);
}

cql_noexport bool_t is_backed(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_BACKED);
}

cql_noexport bool_t is_inout_parameter(sem_t sem_type) {
  return is_in_parameter(sem_type) && is_out_parameter(sem_type);
}

cql_noexport bool_t is_constant(sem_t sem_type) {
 return !!(sem_type & SEM_TYPE_CONSTANT);
}

cql_noexport bool_t has_out_stmt_result(ast_node *ast) {
  sem_t sem_type = ast->sem->sem_type;
  return !!(sem_type & SEM_TYPE_USES_OUT);
}

cql_noexport bool_t has_out_union_stmt_result(ast_node *ast) {
  sem_t sem_type = ast->sem->sem_type;
  return !!(sem_type & SEM_TYPE_USES_OUT_UNION);
}

cql_noexport bool_t has_out_union_call(ast_node *ast) {
  sem_t sem_type = ast->sem->sem_type;
  return !!(sem_type & SEM_TYPE_CALLS_OUT_UNION);
}

// The proc has a normal result set if it has a struct type and it isn't using either out or out union
cql_noexport bool_t has_result_set(ast_node *ast) {
  sem_t sem_type = ast->sem->sem_type;
  sem_t any_out = sem_type & (SEM_TYPE_USES_OUT | SEM_TYPE_USES_OUT_UNION); // non-zero if either
  return !any_out && is_struct(ast->sem->sem_type);
}

cql_noexport bool_t is_create_func(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_CREATE_FUNC);
}

cql_noexport bool_t is_deleted(ast_node *ast) {
  Contract(ast->sem);
  sem_node *sem = ast->sem;

  // if unsubscribed it's logically deleted
  if (sem->unsubscribed) {
    // note only tables ever set this so we just don't go here at all for columns
    return true;
  }

  sem_t sem_type = sem->sem_type;
  return !!(sem_type & SEM_TYPE_DELETED);
}

static bool_t is_validated(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_VALIDATED);
}

cql_noexport bool_t is_dml_proc(sem_t sem_type) {
  return !!(sem_type & SEM_TYPE_DML_PROC);
}

cql_noexport bool_t is_text(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_TEXT;
}

cql_noexport bool_t is_long(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_LONG_INTEGER;
}

cql_noexport bool_t is_any_int(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_INTEGER || core_type_of(sem_type) == SEM_TYPE_LONG_INTEGER;
}

cql_noexport bool_t is_object(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_OBJECT;
}

cql_noexport bool_t is_blob(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_BLOB;
}

cql_noexport bool_t is_ref_type(sem_t sem_type) {
  return is_text(sem_type) || is_object(sem_type) || is_blob(sem_type);
}

cql_noexport bool_t is_null_type(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_NULL;
}

cql_noexport bool_t is_string_compat(sem_t sem_type) {
  return is_text(sem_type) || is_null_type(sem_type);
}

cql_noexport bool_t is_object_compat(sem_t sem_type) {
  return is_object(sem_type) || is_null_type(sem_type);
}

cql_noexport bool_t is_blob_compat(sem_t sem_type) {
  return is_blob(sem_type) || is_null_type(sem_type);
}

cql_noexport bool_t is_numeric(sem_t sem_type) {
  sem_type = core_type_of(sem_type);
  return sem_type >= SEM_TYPE_BOOL && sem_type <= SEM_TYPE_REAL;
}

cql_noexport bool_t is_numeric_compat(sem_t sem_type) {
  sem_type = core_type_of(sem_type);
  return sem_type >= SEM_TYPE_NULL && sem_type <= SEM_TYPE_REAL;
}

// The non-compound types (i.e. not struct or join)
cql_noexport bool_t is_unitary(sem_t sem_type) {
  return core_type_of(sem_type) < SEM_TYPE_MAX_UNITARY;
}

cql_noexport bool_t is_cursor(sem_t sem_type) {
  return is_struct(sem_type) && is_variable(sem_type);
}

cql_noexport bool_t is_auto_cursor(sem_t sem_type) {
  return is_cursor(sem_type) && (sem_type & SEM_TYPE_HAS_SHAPE_STORAGE);
}

cql_noexport bool_t is_struct(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_STRUCT;
}

static bool_t is_join(sem_t sem_type) {
  return core_type_of(sem_type) == SEM_TYPE_JOIN;
}

cql_noexport bool_t is_numeric_expr(ast_node *expr) {
  return is_numeric_compat(expr->sem->sem_type);
}

cql_noexport bool_t is_autotest_dummy_table(CSTR name) {
  return !StrCaseCmp(name, "dummy_table");
}

cql_noexport bool_t is_autotest_dummy_insert(CSTR name) {
  return !StrCaseCmp(name, "dummy_insert");
}

cql_noexport bool_t is_autotest_dummy_select(CSTR name) {
  return !StrCaseCmp(name, "dummy_select");
}

cql_noexport bool_t is_autotest_dummy_result_set(CSTR name) {
  return !StrCaseCmp(name, "dummy_result_set");
}

cql_noexport bool_t is_autotest_dummy_test(CSTR name) {
  return !StrCaseCmp(name, "dummy_test");
}

// helper to search for the indicated misc attribute on a procedure
cql_noexport bool_t is_proc_private(ast_node *_Nonnull proc_stmt) {
  Contract(is_ast_create_proc_stmt(proc_stmt) || is_ast_declare_proc_stmt(proc_stmt));
  EXTRACT_MISC_ATTRS(proc_stmt, misc_attrs);

  return misc_attrs && exists_attribute_str(misc_attrs, "private");
}

// helper to search for the indicated misc attribute on a procedure
cql_noexport bool_t is_proc_suppress_result_set(ast_node *_Nonnull proc_stmt) {
  Contract(is_ast_create_proc_stmt(proc_stmt) || is_ast_declare_proc_stmt(proc_stmt));
  EXTRACT_MISC_ATTRS(proc_stmt, misc_attrs);

  return misc_attrs && exists_attribute_str(misc_attrs, "suppress_result_set");
}

// helper to search for the indicated misc attribute on a procedure
cql_noexport bool_t is_proc_suppress_getters(ast_node *_Nonnull proc_stmt) {
  Contract(is_ast_create_proc_stmt(proc_stmt) || is_ast_declare_proc_stmt(proc_stmt));
  EXTRACT_MISC_ATTRS(proc_stmt, misc_attrs);

  return misc_attrs && exists_attribute_str(misc_attrs, "suppress_getters");
}

// helper to search for the indicated misc attribute on a procedure
cql_noexport bool_t is_proc_emit_setters(ast_node *_Nonnull proc_stmt) {
  Contract(is_ast_create_proc_stmt(proc_stmt) || is_ast_declare_proc_stmt(proc_stmt));
  EXTRACT_MISC_ATTRS(proc_stmt, misc_attrs);

  return misc_attrs && exists_attribute_str(misc_attrs, "emit_setters");
}

// helper to search for the indicated misc attribute on a procedure
cql_noexport bool_t is_proc_shared_fragment(ast_node *_Nonnull proc_stmt) {
  Contract(is_ast_create_proc_stmt(proc_stmt) || is_ast_declare_proc_stmt(proc_stmt));
  EXTRACT_MISC_ATTRS(proc_stmt, misc_attrs);

  return misc_attrs && exists_attribute_str(misc_attrs, "shared_fragment");
}

// This is used to ensure column name (param 'name') is part of the proc return
// struct
static void sem_column_name_exist_in_result_set(
  CSTR name,
  ast_node *misc_attr_value,
  void *context)
{
  EXTRACT_NOTNULL(misc_attrs, (ast_node *)context);
  Contract(current_proc);
  sem_struct *sptr = current_proc->sem->sptr;

  // if there is no return struct that's a different error
  if (sptr) {
    int32_t icol = sem_column_index(sptr, name);
    if (icol < 0) {
      CHARBUF_OPEN(msg);
      bprintf(&msg, "CQL0239: %s column does not exist in result set", annotation_target);
      report_error(misc_attrs, msg.ptr, name);
      record_error(misc_attrs);
      CHARBUF_CLOSE(msg);
      return;
    }
  }

  record_ok(misc_attr_value);
}

// subscription directives have the same kind of payload and need the same basic info
typedef struct subs_info {
  ast_node *target_ast;
  CSTR name;
  int32_t vers;
} subs_info;

// This tells us if we're actually going to try to add the entity we are working on
// to our tables and so forth.  The idea here is that a view/table/whatever might
// not "count" in terms of checking for uniqueness and adding to the all_whatevers
// tables if we are processing in certain contexts.  Specifically if we are
// validating previous schema then the previous version "doesn't count" and
// if we are doing a schema upgrade then any DDL we find also doesn't count because
// those versions might be different than the "final" version after all the upgrades
// are applied.  So, for instance, checking that they are the same as the declared
// version would be counter-productive.
static bool_t will_add_current_entity() {
  return !(validating_previous_schema) && !(schema_upgrade_script && current_proc);
}

CSTR coretype_string(sem_t sem_type) {
  CSTR result = NULL;
  switch (core_type_of(sem_type)) {
    case SEM_TYPE_INTEGER: result = "INT"; break;
    case SEM_TYPE_TEXT: result = "TEXT"; break;
    case SEM_TYPE_LONG_INTEGER: result = "LONG"; break;
    case SEM_TYPE_REAL: result = "REAL"; break;
    case SEM_TYPE_BOOL: result = "BOOL"; break;
    case SEM_TYPE_BLOB: result = "BLOB"; break;
    case SEM_TYPE_OBJECT: result = "OBJECT"; break;
  }
  Invariant(result);
  return result;
}

// Construct the version_attrs_info struct.
static void init_version_attrs_info(
  version_attrs_info *vers_info,
  CSTR name, ast_node *ast,
  ast_node *attrs)
{
  version_attrs_info v = {
    .name = name,
    .target_ast = ast,
    .attrs_ast = attrs,
    .create_version = -1,
    .delete_version = -1,
    // all others 0, NULL, false, etc.
  };
  *vers_info = v;

  if (is_ast_create_table_stmt(ast)) {
    vers_info->create_code = SCHEMA_ANNOTATION_CREATE_TABLE;
    vers_info->delete_code = SCHEMA_ANNOTATION_DELETE_TABLE;
    vers_info->is_virtual_table =  ast->parent && is_ast_create_virtual_table_stmt(ast->parent);
    EXTRACT_NOTNULL(create_table_name_flags, ast->left);
    EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
    EXTRACT_OPTION(flags, table_flags_attrs->left);
    vers_info->is_temp = !!(flags & TABLE_IS_TEMP);
  }
  else if (is_ast_create_index_stmt(ast)) {
    vers_info->create_code = SCHEMA_ANNOTATION_INVALID;
    vers_info->delete_code = SCHEMA_ANNOTATION_DELETE_INDEX;
  }
  else if (is_ast_create_trigger_stmt(ast)) {
    vers_info->create_code = SCHEMA_ANNOTATION_INVALID;
    vers_info->delete_code = SCHEMA_ANNOTATION_DELETE_TRIGGER;
    EXTRACT_OPTION(flags, ast->left);
    vers_info->is_temp = !! (flags & TRIGGER_IS_TEMP);
  }
  else {
    // this is all that's left
    Contract(is_ast_create_view_stmt(ast));
    vers_info->create_code = SCHEMA_ANNOTATION_INVALID;
    vers_info->delete_code = SCHEMA_ANNOTATION_DELETE_VIEW;

    EXTRACT_OPTION(flags, ast->left);
    vers_info->is_temp = !! (flags & VIEW_IS_TEMP);
  }
}

// Simple wrappers for the tables list.
static void add_table_or_view(ast_node *ast) {
  symtab_add(tables, ast->sem->sptr->struct_name, ast);
}

// Validates whether or not an object is usable within the current schema
// region. The object can only be a table, view, trigger or index. If not valid,
// reports an error using `err_target` and `msg`, if present.
static bool_t sem_validate_object_ast_in_current_region(
  CSTR name,
  ast_node *table_ast,
  ast_node *err_target,
  CSTR msg)
{
  Contract(name);
  Contract(table_ast);
  Contract((err_target && msg) || (!err_target && !msg));

  // We're in a non-region therefore no validation needed because non-region stmt
  // can reference schema in any region.
  if (!current_region) {
    return true;
  }

  if (table_ast->sem && table_ast->sem->region) {
    // if we have a current region then the image is always computed!
    Invariant(current_region_image);
    if (!symtab_find(current_region_image, table_ast->sem->region)) {
      // The target region is not accessible from this region
      if (err_target) {
        CHARBUF_OPEN(err_msg);
        bprintf(&err_msg, "%s (object is in schema region '%s' not accessible from region '%s')",
          msg,
          table_ast->sem->region,
          current_region);
        report_error(err_target, err_msg.ptr, name);
        CHARBUF_CLOSE(err_msg);
      }
      return false;
    }
  }
  else if (err_target) {
    CHARBUF_OPEN(err_msg);
    bprintf(&err_msg, "%s (while in schema region '%s', accessing an object that isn't in a region is invalid)",
      msg,
      current_region);
    report_error(err_target, err_msg.ptr, name);
    CHARBUF_CLOSE(err_msg);
    return false;
  }

  return true;
}

// Only callers that want to ensure no conflict of names (whether deleted or not)
// use this version. Deleted names are not good for anything but de-duping against.
ast_node *find_table_or_view_even_deleted(CSTR name) {
  Contract(name);
  symtab_entry *entry = symtab_find(tables, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Returns the node only if it exists and is not restricted by the schema
// region. If not found, reports an error using `err_target` and `msg`, if
// present.
static ast_node *find_usable_table_or_view_even_deleted(
  CSTR name,
  ast_node *err_target,
  CSTR msg)
{
  Contract(name);
  Contract((err_target && msg) || (!err_target && !msg));

  ast_node *table_ast = find_table_or_view_even_deleted(name);
  if (!table_ast) {
    if (err_target) {
      report_error(err_target, msg, name);
    }
    return NULL;
  }

  if (!sem_validate_object_ast_in_current_region(name, table_ast, err_target, msg)) {
    return NULL;
  }

  return table_ast;
}

// Returns the node only if the table is not deleted; most clients use this. If
// not found, reports an error using `err_target` and `msg`, if present.
cql_noexport ast_node *find_usable_and_not_deleted_table_or_view(
  CSTR name,
  ast_node *err_target,
  CSTR msg)
{
  Contract(name);
  Contract((err_target && msg) || (!err_target && !msg));

  ast_node *table_ast = find_usable_table_or_view_even_deleted(name, err_target, msg);
  if (!table_ast) {
    return NULL;
  }

  // Check for views first. If this is a migration script, the view will be a
  // stub so we don't want to look at it it too deeply: It's just there so we
  // can produce this error.
  if (schema_upgrade_version > 0 && !is_ast_create_table_stmt(table_ast)) {
    // Views may not be accessed in a migration script, because during migration
    // they have been deleted and will come back after.  FWIW migration scripts
    // turned out to be a terrible idea and using them at all is not
    // recommended.
    Invariant(is_ast_create_view_stmt(table_ast));
    if (err_target) {
      CHARBUF_OPEN(err_msg);
      bprintf(&err_msg, "%s (view hidden in migration script)", msg);
      report_error(err_target, err_msg.ptr, name);
      CHARBUF_CLOSE(err_msg);
    }
    return NULL;
  }

  if (is_deleted(table_ast)) {
    if (err_target) {
      CHARBUF_OPEN(err_msg);
      if (schema_upgrade_version > 0) {
        bprintf(&err_msg, "%s (not visible in schema version %d)", msg, schema_upgrade_version);
      }
      else {
        if (table_ast->sem->delete_version > table_ast->sem->unsubscribed)  {
          bprintf(&err_msg, "%s (hidden by @delete)", msg);
        }
        else {
          bprintf(&err_msg, "%s (hidden by @unsub)", msg);
        }
      }
      report_error(err_target, err_msg.ptr, name);
      CHARBUF_CLOSE(err_msg);
    }
    return NULL;
  }

  return table_ast;
}

// The idea here is that CTE names should not be allowed to hide real table
// names because this pattern really confuses people.  So we look to see if a
// usable table exists with the given name in the given scope and give an error.
// The exception here is that it's normal to hide the definition of a backed
// table because it isn't real.  But otherwise if the name already exists an
// error is coming.
static bool_t name_hides_root_table(CSTR name) {
  Contract(name);

  ast_node *table_ast = find_usable_and_not_deleted_table_or_view(name, NULL, NULL);

  // it's ok to hide a backed table with a CTE, that's the point
  return table_ast && !is_backed(table_ast->sem->sem_type);
}

static void add_cte(ast_node *ast) {
  Contract(cte_cur);
  Contract(cte_cur->ctes);
  symtab_add(cte_cur->ctes, ast->sem->sptr->struct_name, ast);
}

static ast_node *find_cte(CSTR name) {
  cte_state *state = cte_cur;
  while (state) {
    symtab_entry *entry = symtab_find(state->ctes, name);
    if (entry) {
        return (ast_node*)entry->val;
    }
    state = state->prev;
  }

  return NULL;
}

// Wrappers for the default values table
cql_noexport symtab *find_default_values(CSTR name) {
  symtab_entry *entry = symtab_find(table_default_values, name);
  return entry ? (symtab*)(entry->val) : NULL;
}

// When processing the schema, record default values for each table
// so that we can find them quickly.  This is a symbol table of symbol tables.
// We store them here rather than on the sem_node because they are sparse
cql_noexport bool_t add_default_values(symtab *def_values, CSTR name) {
  return symtab_add_symtab(table_default_values, name, def_values);
}

// Wrappers for the trigger table.
static bool_t add_trigger(ast_node *ast, CSTR name) {
  return symtab_add(triggers, name, ast);
}

// Wrapper for triggers.
static ast_node *find_trigger(CSTR name) {
  symtab_entry *entry = symtab_find(triggers, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrappers for the backing_info table.
static bool_t add_backing_info(struct cg_blob_mappings_struct *data, CSTR name) {
  return symtab_add(backing_info, name, data);
}

// Wrapper for backing info
cql_noexport struct cg_blob_mappings_struct *find_backing_info(CSTR name) {
  symtab_entry *entry = symtab_find(backing_info, name);
  return entry ? (struct cg_blob_mappings_struct *)(entry->val) : NULL;
}

// Wrapper for variable groups.
cql_noexport ast_node *find_variable_group(CSTR name) {
  symtab_entry *entry = symtab_find(variable_groups, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrapper for constant groups.
cql_noexport ast_node *find_constant_group(CSTR name) {
  symtab_entry *entry = symtab_find(constant_groups, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrapper for constants.
cql_noexport ast_node *find_constant(CSTR name) {
  symtab_entry *entry = symtab_find(constants, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Returns the node only if it exists and is not restricted by the schema region.
static ast_node *find_usable_trigger(CSTR name, ast_node *err_target, CSTR msg) {
  ast_node *trigger_ast = find_trigger(name);

  if (!trigger_ast) {
    report_error(err_target, msg, name);
    return NULL;
  }

  if (!sem_validate_object_ast_in_current_region(name, trigger_ast, err_target, msg)) {
    return NULL;
  }

  return trigger_ast;
}

// Wrappers for the enum table.
static bool_t add_enum(ast_node *ast, CSTR name) {
  return symtab_add(enums, name, ast);
}

ast_node *find_enum(CSTR name) {
  symtab_entry *entry = symtab_find(enums, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrappers for the arg bundles table.
cql_noexport bool_t add_arg_bundle(ast_node *ast, CSTR name) {
  return symtab_add(arg_bundles, name, ast);
}

cql_noexport ast_node *find_arg_bundle(CSTR name) {
  if (!StrCaseCmp(name,  "LOCALS")) {
    return sem_synthesize_current_locals();
  }
  symtab_entry *entry = symtab_find(arg_bundles, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrappers for the proc table.
static bool_t add_proc(ast_node *ast, CSTR name) {
  return symtab_add(procs, name, ast);
}

cql_noexport ast_node *find_proc(CSTR name) {
  symtab_entry *entry = symtab_find(procs, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrappers for the unchecked proc table.
static bool_t add_unchecked_proc(ast_node *ast, CSTR name) {
  return symtab_add(unchecked_procs, name, ast);
}

cql_noexport ast_node *find_unchecked_proc(CSTR name) {
  symtab_entry *entry = symtab_find(unchecked_procs, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

cql_noexport bytebuf *find_proc_arg_info(CSTR name) {
  symtab_entry *entry = symtab_find(proc_arg_info, name);
  return entry ? (bytebuf *)(entry->val) : NULL;
}

// Wrapper for upgrade procedures (e.g. in an @create directive)
static ast_node *find_upgrade_proc(CSTR name) {
  symtab_entry *entry = symtab_find(upgrade_procs, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrapper for ad hoc migration procs (from @SCHEMA_AD_HOC_MIGRATION)
static ast_node *find_ad_hoc_migrate(CSTR name) {
  symtab_entry *entry = symtab_find(ad_hoc_migrates, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrappers for interfaces table (user defined shapes)
static bool_t add_interface_type(ast_node *ast, CSTR name) {
  return symtab_add(interfaces, name, ast);
}

ast_node *find_interface_type(CSTR name) {
  symtab_entry *entry = symtab_find(interfaces, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Wrappers for the region table.
cql_noexport ast_node *find_region(CSTR name) {
  symtab_entry *entry = symtab_find(schema_regions, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

// Helper to store the named type in a symbol table. As with local variables,
// types declared in a procedure are local to that procedure and stored in their
// own symbol table. The local symbol table is always searched first to find
// named type otherwise the global storage is used.
static bool_t add_named_type(CSTR name, ast_node *ast) {

  // the target symbol table, local or global
  symtab *tab = current_proc ? local_types : global_types;

  // look for the type only in the scope it is going into.
  symtab_entry *entry = symtab_find(tab, name);
  ast_node *existing_type = entry ? (ast_node*)(entry->val) : NULL;

  if (existing_type) {
    bool_t matching = sem_validate_identical_text(existing_type, ast, gen_one_stmt, NULL);

    if (!matching) {
      report_error(ast, "CQL0359: conflicting type declaration", name);
      record_error(ast);
      return false;
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      sem_add_flags(ast, SEM_TYPE_ALIAS);
    }
  }
  else {
    bool_t added = symtab_add(tab, name, ast);
    Invariant(added);
  }

  return true;
}

// Look up the named type node from the relevant symbol tables. Recall that
// local named types are in their own table.
cql_noexport ast_node *find_named_type(CSTR name) {
  symtab_entry *entry = NULL;
  // We first try to find it in local storage because it has higher priority
  // otherwise we look into the global storage
  if (local_types) {
    entry = symtab_find(local_types, name);
  }
  if (!entry) {
    entry = symtab_find(global_types, name);
  }

  return entry ? (ast_node*)(entry->val) : NULL;
}

static ast_node *find_cur_region(CSTR name) {
  // During previous schema validation the current region is the previous ones.
  symtab_entry *entry = symtab_find(new_regions, name);
  return entry ? (ast_node*)(entry->val) : NULL;
}

static bool_t add_region(ast_node *ast, CSTR name) {
  return symtab_add(schema_regions, name, ast);
}

// Helper function to create unique ID to store recreate group dependencies in
// symbol table
CSTR create_group_id(CSTR group_name, CSTR table_name) {
  // These names are used as keys in symbol tables and were selected to match
  // the facet names
   Contract(table_name);
   if (group_name && group_name[0]) {
     return dup_printf("%s_group", group_name);
   }
   else {
     return dup_printf("%s_table", table_name);
   }
}

// Helper function to walk the graph stored in recreate_group_deps from a
// starting group name to an ending group name. We perform a simple depth first
// search.
static bool_t walk_recreate_group_deps (CSTR start, CSTR end) {
  if (!StrCaseCmp(start, end)) {
    return true;
  }
  bytebuf *buf = symtab_ensure_bytebuf(recreate_group_deps, start);
  size_t count = buf->used / sizeof(CSTR);
  CSTR *neighbors = (CSTR *) (buf->ptr);

  for (size_t i = 0; i < count; i++) {
    if (walk_recreate_group_deps(neighbors[i], end)) {
      return true;
    }
  }
  return false;
}

static bool_t add_group_dependency_to_recreate_group(CSTR group_name, CSTR new_dependent_group_name) {
  // We don't want to create self-cycles in our symbol table
  if (!StrCaseCmp(group_name, new_dependent_group_name)) return true;

  // We want to make sure adding a new dependency does not introduce a cycle in
  // recreate_group_deps. We know that recreate_group_deps before this function
  // is a DAG without a cycle, so we just need to check whether add a new edge
  // (u,v) introduces a cycle. We can do this by checking whether there is a
  // path from v to u using a DFS.
  if (walk_recreate_group_deps(new_dependent_group_name, group_name)) {
    // Adding the edge introduces a cycle because we found a path from v to u
    return false;
  }
  symtab_append_bytes(recreate_group_deps, group_name, &new_dependent_group_name, sizeof(CSTR));
  return true;
}

// For debug/test output, pretty print a sem_type_core
static void get_sem_core(sem_t sem_type, charbuf *out) {
  switch (core_type_of(sem_type)) {
    case SEM_TYPE_NULL:    bprintf(out, "null"); break;
    case SEM_TYPE_INTEGER: bprintf(out, "integer"); break;
    case SEM_TYPE_TEXT:    bprintf(out, "text"); break;
    case SEM_TYPE_OBJECT:  bprintf(out, "object"); break;
    case SEM_TYPE_BLOB:    bprintf(out, "blob"); break;
    case SEM_TYPE_LONG_INTEGER: bprintf(out, "longint"); break;
    case SEM_TYPE_REAL:    bprintf(out, "real"); break;
    case SEM_TYPE_BOOL:    bprintf(out, "bool"); break;
    case SEM_TYPE_ERROR:   bprintf(out, "err"); break;
    case SEM_TYPE_OK:      bprintf(out, "ok"); break;
    case SEM_TYPE_REGION:  bprintf(out, "region"); break;
    case SEM_TYPE_CURSOR_FORMAL: bprintf(out, "cursor"); break;
  }
}

// For debug/test output, prettyprint the flags
static void get_sem_flags(sem_t sem_type, charbuf *out) {
  // This is never present in the AST after a top-level statement has been
  // analyzed: All initialization improvements on variables and parameters are
  // unset by then, and, unlike `SEM_TYPE_INFERRED_NOTNULL`, there is no
  // equivalent of cql_inferred_notnull that would benefit from leaving it on
  // expressions.
  Contract(!(sem_type & SEM_TYPE_INIT_COMPLETE));

  if (sem_type & SEM_TYPE_INFERRED_NOTNULL) {
    bprintf(out, " inferred_notnull");
  }
  if (sem_type & SEM_TYPE_NOTNULL) {
    bprintf(out, " notnull");
  }
  if (sem_type & SEM_TYPE_VARIABLE) {
    bprintf(out, " variable");
  }
  if (sem_type & SEM_TYPE_INIT_REQUIRED) {
    bprintf(out, " init_required");
  }
  if (sem_type & SEM_TYPE_HAS_DEFAULT) {
    bprintf(out, " has_default");
  }
  if (sem_type & SEM_TYPE_HAS_CHECK) {
    bprintf(out, " has_check");
  }
  if (sem_type & SEM_TYPE_HAS_COLLATE) {
    bprintf(out, " has_collate");
  }
  if (sem_type & SEM_TYPE_IN_PARAMETER) {
    bprintf(out, " in");
  }
  if (sem_type & SEM_TYPE_OUT_PARAMETER) {
    bprintf(out, " out");
  }
  if (sem_type & SEM_TYPE_DML_PROC) {
    bprintf(out, " dml_proc");
  }
  if (sem_type & SEM_TYPE_HAS_SHAPE_STORAGE) {
    bprintf(out, " shape_storage");
  }
  if (sem_type & SEM_TYPE_CREATE_FUNC) {
    bprintf(out, " create_func");
  }
  if (sem_type & SEM_TYPE_SELECT_FUNC) {
    bprintf(out, " select_func");
  }
  if (sem_type & SEM_TYPE_DELETED) {
    bprintf(out, " deleted");
  }
  if (sem_type & SEM_TYPE_HIDDEN_COL) {
    bprintf(out, " hidden_col");
  }
  if (sem_type & SEM_TYPE_TVF) {
    bprintf(out, " table_valued_function");
  }
  if (sem_type & SEM_TYPE_VALIDATED) {
    bprintf(out, " validated");
  }
  if (sem_type & SEM_TYPE_PK) {
    bprintf(out, " primary_key");
  }
  if (sem_type & SEM_TYPE_FK) {
    bprintf(out, " foreign_key");
  }
  if (sem_type & SEM_TYPE_AUTOINCREMENT) {
    bprintf(out, " autoinc");
  }
  if (sem_type & SEM_TYPE_UK) {
    bprintf(out, " unique_key");
  }
  if (sem_type & SEM_TYPE_USES_OUT) {
    bprintf(out, " uses_out");
  }
  if (sem_type & SEM_TYPE_USES_OUT_UNION) {
    bprintf(out, " uses_out_union");
  }
  if (sem_type & SEM_TYPE_CALLS_OUT_UNION) {
    bprintf(out, " calls_out_union");
  }
  if (sem_type & SEM_TYPE_VALUE_CURSOR) {
    bprintf(out, " value_cursor");
  }
  if (sem_type & SEM_TYPE_SENSITIVE) {
    bprintf(out, " sensitive");
  }
  if (sem_type & SEM_TYPE_IMPLICIT) {
    bprintf(out, " implicit");
  }
  if (sem_type & SEM_TYPE_DEPLOYABLE) {
    bprintf(out, " deployable");
  }
  if (sem_type & SEM_TYPE_BOXED) {
    bprintf(out, " boxed");
  }
  if (sem_type & SEM_TYPE_VIRTUAL) {
    bprintf(out, " virtual");
  }
  if (sem_type & SEM_TYPE_INLINE_CALL) {
    bprintf(out, " inline_call");
  }
  if (sem_type & SEM_TYPE_SERIALIZE) {
    bprintf(out, " serialize");
  }
  if (sem_type & SEM_TYPE_FETCH_INTO) {
    bprintf(out, " fetch_into");
  }
  if (sem_type & SEM_TYPE_WAS_SET) {
    bprintf(out, " was_set");
  }
  if (sem_type & SEM_TYPE_BACKING) {
    bprintf(out, " backing");
  }
  if (sem_type & SEM_TYPE_BACKED) {
    bprintf(out, " backed");
  }
  if (sem_type & SEM_TYPE_PARTIAL_PK) {
    bprintf(out, " partial_pk");
  }
  if (sem_type & SEM_TYPE_ALIAS) {
    bprintf(out, " alias");
  }
  if (sem_type & SEM_TYPE_QID) {
    bprintf(out, " qid");
  }
  if (sem_type & SEM_TYPE_CONSTANT) {
    bprintf(out, " constant");
  }
}

// For debug/test output, prettyprint a structure type
static void print_sem_struct(sem_struct *sptr) {
  CHARBUF_OPEN(temp);
  bprint_maybe_qname(&temp, sptr->struct_name);
  cql_output("%s: { ", temp.ptr);

  for (uint32_t i = 0; i < sptr->count; i++) {
    bclear(&temp);

    if (i != 0) {
      bprintf(&temp, ", ");
    }

    if (sptr->semtypes[i] & SEM_TYPE_QID) {
      cg_decode_qstr(&temp, sptr->names[i]);
    }
    else {
      bprintf(&temp, "%s", sptr->names[i]);
    }
    bprintf(&temp, ": ");

    get_sem_core(sptr->semtypes[i], &temp);
    if (sptr->kinds[i]) {
      bprintf(&temp, "<%s>", sptr->kinds[i]);
    }
    get_sem_flags(sptr->semtypes[i], &temp);

    cql_output("%s", temp.ptr);
  }
  cql_output(" }");
  CHARBUF_CLOSE(temp);
}

// For debug/test output, prettyprint a join type
static void print_sem_join(sem_join *jptr) {
  Contract(jptr);
  Contract(jptr->count);

  if (jptr->count == 1) {
    // If it's one join I just call it a because I feel bad calling it a join
    // until there's more than one.
    cql_output("TABLE { ");
  }
  else {
    cql_output("JOIN { ");
  }
  for (uint32_t i = 0; i < jptr->count; i++) {
    if (i != 0) {
      cql_output(", ");
    }
    CHARBUF_OPEN(temp);
    bprint_maybe_qname(&temp, jptr->names[i]);
    bprintf(&temp, ": ");
    bprint_maybe_qname(&temp, jptr->tables[i]->struct_name);
    cql_output("%s", temp.ptr);
    CHARBUF_CLOSE(temp);
  }
  cql_output(" }");
}

// This dispatches the other helpers to prettyprint the net type
cql_noexport void print_sem_type(sem_node *sem) {

  // in the event of error marking, disregard everything else
  if (is_sem_error(sem)) {
    CHARBUF_OPEN(temp);
    get_sem_core(SEM_TYPE_ERROR, &temp);
    cql_output("%s", temp.ptr);
    CHARBUF_CLOSE(temp);
    return;
  }

  if (sem->name) {
    CHARBUF_OPEN(temp);
    bprint_maybe_qname(&temp, sem->name);
    bprintf(&temp, ": ");
    cql_output("%s", temp.ptr);
    CHARBUF_CLOSE(temp);
  }

  sem_t sem_type = sem->sem_type;

  if (is_struct(sem_type)) {
     print_sem_struct(sem->sptr);
  }
  else if (is_join(sem_type)) {
    print_sem_join(sem->jptr);
  }
  else {
    CHARBUF_OPEN(temp);
    get_sem_core(sem_type, &temp);
    cql_output("%s", temp.ptr);
    CHARBUF_CLOSE(temp);
  }

  if (sem->kind) {
     cql_output("<%s>", sem->kind);
  }

  if (sem->value) {
    CHARBUF_OPEN(temp);
    eval_format_number(sem->value, EVAL_FORMAT_NORMAL, &temp);
    cql_output(" = %s", temp.ptr);
    CHARBUF_CLOSE(temp);
  }

  CHARBUF_OPEN(temp);
  get_sem_flags(sem_type, &temp);
  cql_output("%s", temp.ptr);

  if (sem->backed_table) {
    bclear(&temp);
    bprint_maybe_qname(&temp, sem->backed_table);
    cql_output(" backed_table(%s)", temp.ptr);
  }
  if (sem->create_version > 0) {
    cql_output(" @create(%d)", sem->create_version);
  }
  if (sem->delete_version > 0) {
    cql_output(" @delete(%d)", sem->delete_version);
  }

  if (sem->recreate) {
    cql_output(" @recreate");
  }

  if (sem->recreate_group_name) {
    cql_output("(%s)", sem->recreate_group_name);
  }
  CHARBUF_CLOSE(temp);
}

// The standard error reporter, the ast node is used to get the line number the
// message is logged and the subject is cited if present.  The type of node is
// also included but it's frequently useless...
cql_noexport void report_error(ast_node *ast, CSTR msg, CSTR subject) {
  CSTR subj1 = "";
  CSTR subj2 = "";
  CSTR subj3 = "";

  if (subject) {

    if (is_qname(subject)) {
       CHARBUF_OPEN(tmp);
       bprint_maybe_qname(&tmp, subject);
       subject = Strdup(tmp.ptr);
       CHARBUF_CLOSE(tmp);
    }
    subj1 = " '";
    subj2 = subject;
    subj3 = "'";
  }

  cql_error("%s:%d:1: error: in %s : %s%s%s%s\n",
      ast->filename,
      ast->lineno,
      ast->type,
      msg,
      subj1, subj2, subj3);
}

static void cql_attach_captured_errors(ast_node *stmt) {
   if (is_error(stmt)) {
      // If you hit this invariant it almost certainly means that an error was
      // attached to a node in the AST but that node did not get
      // record_error(..) called on it.  So the semantic info is still null.
      // Find the place where you reported this error and them make sure you
      // also record the error in the AST.
      Invariant(stmt->sem);
      Invariant(stmt->sem->sem_type == SEM_TYPE_ERROR);
      stmt->sem->error = Strdup(error_capture->ptr);
   }
}

// Outside of normal statement list processing you have to do your own error
// capture logic; this helper capture a single error message. the general case
// is more flexible but typically not needed.  Since these errors don't flow up
// we have to mark the root directly so that the system knows there were
// semantic errors.  This flow is only for deferred errors.
static void report_and_capture_error(
  ast_node *root,
  ast_node *ast,
  CSTR err_msg,
  CSTR name)
{
  CHARBUF_OPEN(errbuf);

  if (options.print_ast) {
    error_capture = &errbuf;
  }

  report_error(ast, err_msg, name);
  record_error(ast);
  record_error(root);

  if (error_capture) {
    cql_attach_captured_errors(ast);
    error_capture = NULL;
  }

  CHARBUF_CLOSE(errbuf);
}

// Error reporter for appending extra info on mismatched sem types where exact
// type is expected.
static void report_sem_type_mismatch(
    sem_t sem_expected_type,
    sem_t sem_actual_type,
    ast_node *node,
    CSTR prepend_error_message,
    CSTR sem_name) {
  CHARBUF_OPEN(temp);

  bprintf(&temp, "%s (expected ", prepend_error_message);
  get_sem_core(sem_expected_type, &temp);
  sem_expected_type &= (SEM_TYPE_NOTNULL | SEM_TYPE_SENSITIVE);
  get_sem_flags(sem_expected_type, &temp);

  bprintf(&temp, "; found ");
  get_sem_core(sem_actual_type, &temp);
  sem_actual_type &= (SEM_TYPE_NOTNULL | SEM_TYPE_SENSITIVE);
  get_sem_flags(sem_actual_type, &temp);
  bprintf(&temp, ")");

  report_error(node, temp.ptr, sem_name);
  CHARBUF_CLOSE(temp);
}

// This is the basic constructor for the semantic info node.
cql_noexport sem_node * new_sem(sem_t sem_type) {
  sem_node *sem = _ast_pool_new(sem_node);
  memset(sem, 0, sizeof(*sem));
  sem->sem_type = sem_type;
  sem->create_version = -1;
  sem->delete_version = -1;
  return sem;
}

// Sets additional flags for `ast->sem->sem_type` without mutating other
// copies of `ast->sem`.
cql_noexport void sem_add_flags(ast_node *ast, sem_t flags) {
  sem_node *sem = _ast_pool_new(sem_node);
  memcpy(sem, ast->sem, sizeof(sem_node));
  sem->sem_type |= flags;
  ast->sem = sem;
}

// Removes specified flags for `ast->sem->sem_type` without mutating other
// copies of `ast->sem`.
cql_noexport void sem_remove_flags(ast_node *ast, sem_t flags) {
  sem_node *sem = _ast_pool_new(sem_node);
  memcpy(sem, ast->sem, sizeof(sem_node));
  sem->sem_type &= sem_not(flags);
  ast->sem = sem;
}

// Like `sem_add_flags`, but completely replaces the flags instead of adding
// additional flags.
static void sem_replace_flags(ast_node *ast, sem_t flags) {
  sem_node *sem = _ast_pool_new(sem_node);
  memcpy(sem, ast->sem, sizeof(sem_node));
  sem->sem_type = flags;
  ast->sem = sem;
}

// For cases where we just want to record that there was no error
// we use the canonical ok node.  It must never be modified because
// it is shared.
static sem_node *sem_ok;

static sem_node *ok_sentinel(void) {
  if (sem_ok) {
    return sem_ok;
  }
  else {
    return sem_ok = new_sem(SEM_TYPE_OK);
  }
}

// Get the index of a column by name from the struct
// We need this so that we can validate the presence of columns
// in a particular struct.
int32_t sem_column_index(sem_struct *sptr, CSTR name) {
  uint32_t count = sptr->count;
  for (uint32_t i = 0; i < count; i++) {
    CSTR col = sptr->names[i];
    if (!strcmp(name, col)) {
      return (int32_t)i;
    }
  }
  return -1;
}

// Stow the ok marker somewhere.
cql_noexport void record_ok(ast_node *ast) {
  ast->sem = ok_sentinel();
}

// Errors may be annotated with information so we make a unique error
// node for every place we're placing a new error.
cql_noexport void record_error(ast_node *ast) {
  ast->sem = new_sem(SEM_TYPE_ERROR);
}

// Some math operators like << >> & | % only make sense on integers
// This function does the extra checking to ensure they do not get real values
// as arguments.  It's a post-pass after the normal math checks.
static void sem_reject_real(ast_node *ast, CSTR op) {
  if (!is_error(ast)) {
    sem_t core_type = core_type_of(ast->sem->sem_type);
    if (core_type == SEM_TYPE_REAL) {
      report_error(ast, "CQL0001: operands must be an integer type, not real", op);
      record_error(ast);
    }
  }
}

// sem_struct records the information for one "table" it's an array
// of names and primitive types.
static sem_struct * new_sem_struct(CSTR name, uint32_t count) {
  sem_struct *sptr = _ast_pool_new(sem_struct);
  sptr->struct_name = name;
  sptr->count = count;
  sptr->names = _ast_pool_new_array(CSTR, count);
  sptr->kinds = _ast_pool_new_array(CSTR, count);
  sptr->semtypes = _ast_pool_new_array(sem_t, count);
  sptr->is_backed = false;

  for (uint32_t i = 0; i < count; i++) {
    sptr->names[i] = NULL;
    sptr->semtypes[i] = SEM_TYPE_ERROR;
    sptr->kinds[i] = NULL;
  }

  return sptr;
}

// sem_join records the concatenation of 1 or more sem_structs
// note that a single table can be a "join" if it's all there is
// the current result of the FROM clause as it accumulates is
// one of these.
static sem_join * new_sem_join(uint32_t count) {
  sem_join *jptr = _ast_pool_new(sem_join);
  jptr->count = count;
  jptr->names = _ast_pool_new_array(CSTR, count);
  jptr->tables = _ast_pool_new_array(sem_struct *, count);

  for (uint32_t i = 0; i < count; i++) {
    jptr->names[i] = NULL;
    jptr->tables[i] = NULL;
  }

  return jptr;
}

// When we're joining with join types other than INNER it's
// possible to lose the notnull flag
// e.g. in "X left outer join Y" even if Y has only not-null columns
// the result of the join will have Y with all nullable columns
// because it's a left outer join.  This method produces a sem_struct
// with the indicated removals.
static sem_struct *sem_clone_struct_strip_flags(sem_struct *sptr, sem_t strip) {
  sem_struct *result = new_sem_struct(sptr->struct_name, sptr->count);
  for (uint32_t i = 0; i < sptr->count; i++) {
    result->names[i] = sptr->names[i];
    result->kinds[i] = sptr->kinds[i];
    result->semtypes[i] = sptr->semtypes[i] & sem_not(strip);
  }
  return result;
}

// When making the initial join scope for a table we want
// to get rid of other table-ish flags like HAS_DEFAULT and AUTOINCREMENT
// they don't contribute to anything and they make the tree ugly.
static sem_struct *new_sem_struct_strip_table_flags(sem_struct *sptr) {
  sem_t allowed_flags =
       SEM_TYPE_CORE |
       SEM_TYPE_NOTNULL |
       SEM_TYPE_SENSITIVE |
       SEM_TYPE_HIDDEN_COL |
       SEM_TYPE_ALIAS |
       SEM_TYPE_QID;

  sem_struct *result = sem_clone_struct_strip_flags(sptr, sem_not(allowed_flags));

  // when copying from a table, keep the is_backed flag
  result->is_backed = sptr->is_backed;

  return result;
}

// Create a base join type from a single struct.
static sem_join *sem_join_from_sem_struct(sem_struct *sptr) {
  sem_join *jptr = new_sem_join(1);
  jptr->names[0] = sptr->struct_name;
  jptr->tables[0] = new_sem_struct_strip_table_flags(sptr);

  return jptr;
}

// If either of the types is an object then produce an error on the ast.
static bool_t error_any_object(
  ast_node *ast,
  sem_t core_type_left,
  sem_t core_type_right,
  CSTR op)
{
  if (is_object(core_type_left)) {
    report_error(ast->left, "CQL0002: left operand cannot be an object in", op);
    record_error(ast);
    return true;
  }

  if (is_object(core_type_right)) {
    report_error(ast->right, "CQL0003: right operand cannot be an object in", op);
    record_error(ast);
    return true;
  }

  return false;
}

// If either of the types is a blob then produce an error on the ast.
static bool_t error_any_blob_types(
  ast_node *ast,
  sem_t core_type_left,
  sem_t core_type_right,
  CSTR op)
{
  if (is_blob(core_type_left)) {
    report_error(ast->left, "CQL0004: left operand cannot be a blob in", op);
    record_error(ast);
    return true;
  }

  if (is_blob(core_type_right)) {
    report_error(ast->right, "CQL0005: right operand cannot be a blob in", op);
    record_error(ast);
    return true;
  }

  return false;
}

// If either of the types is text then produce an error on the ast.
static bool_t error_any_text_types(
  ast_node *ast,
  sem_t core_type_left,
  sem_t core_type_right,
  CSTR op)
{
  if (is_text(core_type_left)) {
    report_error(ast->left, "CQL0007: left operand cannot be a string in", op);
    record_error(ast);
    return true;
  }

  if (is_text(core_type_right)) {
    report_error(ast->right, "CQL0008: right operand cannot be a string in", op);
    record_error(ast);
    return true;
  }

  return false;
}

// This is the work horse of semantic analysis, it checks if sem_type_needed is
// compatible with core_type_found and generates an error if it is not.
static bool_t sem_verify_compat(
  ast_node *ast,
  sem_t sem_type_needed,
  sem_t sem_type_found,
  CSTR subject)
{
  // normalize even if we weren't given core types
  sem_t core_type_needed = core_type_of(sem_type_needed);
  sem_t core_type_found = core_type_of(sem_type_found);

  // Note that SEM_TYPE_CURSOR_FORMAL never gets here... by the time we've found
  // a parameter slot that needs a cursor we already used sem_cursor and it's
  // all been verified.  So even though the param list can have a non-unitary
  // type we don't ever test non-unitary here.

  Invariant(is_unitary(core_type_needed));
  Invariant(is_unitary(core_type_found));

  switch (core_type_needed) {
    case SEM_TYPE_TEXT:
      if (!is_string_compat(core_type_found)) {
        report_error(ast, "CQL0009: incompatible types in expression", subject);
        record_error(ast);
        return false;
      }
      break;

    case SEM_TYPE_OBJECT:
      if (!is_object_compat(core_type_found)) {
        report_error(ast, "CQL0010: incompatible types in expression", subject);
        record_error(ast);
        return false;
      }
      break;

    case SEM_TYPE_BLOB:
      if (!is_blob_compat(core_type_found)) {
        report_error(ast, "CQL0011: incompatible types in expression", subject);
        record_error(ast);
        return false;
      }
      break;

    case SEM_TYPE_BOOL:
    case SEM_TYPE_INTEGER:
    case SEM_TYPE_LONG_INTEGER:
    case SEM_TYPE_REAL:
      if (!is_numeric_compat(core_type_found)) {
        report_error(ast, "CQL0012: incompatible types in expression", subject);
        record_error(ast);
        return false;
      }
      break;

    case SEM_TYPE_NULL:
      // null is compatible with everything
      break;
  }

  return true;
}

// When performing assignment either explicitly ( set X = Y ) or implicit
// (binding args to a proc call) there are additional type compat checks to be
// done beyond the normal is compat.  The above helps you with symmetric
// operations like X == Y where either side can be promoted.  In an assignment
// the left side cannot be promoted so the store can be lossy.  This checks for
// the lossy cases that are otherwise compatible.  That is, we assume that the
// above has already been called.
static bool_t sem_verify_safe_assign(
  ast_node *ast,
  sem_t sem_type_needed,
  sem_t sem_type_found,
  CSTR subject)
{
  // normalize even if we weren't given core types
  sem_t core_type_needed = core_type_of(sem_type_needed);
  sem_t core_type_found = core_type_of(sem_type_found);
  CSTR err_type = NULL;

  Invariant(is_unitary(core_type_needed));
  Invariant(is_unitary(core_type_found));

  // the target of an assignment cannot be of type null
  if (is_null_type(core_type_needed)) {
    report_error(ast, "CQL0056: variable of type NULL cannot be assigned", subject);
    record_error(ast);
    return false;
  }

  switch (core_type_needed) {
    case SEM_TYPE_TEXT:
    case SEM_TYPE_OBJECT:
    case SEM_TYPE_BLOB:
    case SEM_TYPE_BOOL:
    case SEM_TYPE_REAL:
      // this is called only after we've already verified basic compatibility
      // (see above) so these are always safe
      //  * assign to real gives you a free floating conversion
      //  * assign to bool converts to truthiness
      //  * blob, object, text require exact match for compat
      return true;

    // these are the possible lossy cases

    case SEM_TYPE_INTEGER:
    case SEM_TYPE_LONG_INTEGER:
      if (core_type_found == SEM_TYPE_REAL) {
         err_type = "REAL";
         goto error;
      }

      if (core_type_found == SEM_TYPE_LONG_INTEGER && core_type_needed == SEM_TYPE_INTEGER) {
         err_type = "LONG";
         goto error;
      }
      break;
  }

  Invariant(!err_type);
  return true;

error:
  Invariant(err_type);
  CHARBUF_OPEN(tmp);
  bprintf(&tmp, "CQL0242: lossy conversion from type '%s' in ", err_type);

  // append the text of the offensive expression we want all the text,
  // unexpanded, so NOT for sqlite output (this is raw echo) so gen_mode_echo
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_echo;
  gen_set_output_buffer(&tmp);
  gen_with_callbacks(ast, gen_root_expr, &callbacks);
  report_error(ast, tmp.ptr, NULL);
  CHARBUF_CLOSE(tmp);

  return false;
}

// This verifies that the types are compatible and that it's ok to assign the
// expression to the variable.  In practice that means:
// * the variable type core type and kind must be compatible with the expression
//   core type and kind
// * the variable must be nullable if the expression is nullable
// * the variable must be sensitive if the assignment is sensitive
// * the variable type must be bigger than the expression type Here ast is used
//   only to give a place to put any errors.
cql_noexport bool_t sem_verify_assignment(
  ast_node *ast,
  sem_t sem_type_needed,
  sem_t sem_type_found,
  CSTR var_name)
{
  if (is_constant(sem_type_needed)) {
    report_error(ast, "CQL0502: cannot re-assign value to constant variable", var_name);
    return false;
  }
  if (!sem_verify_compat(ast, sem_type_needed, sem_type_found, var_name)) {
    return false;
  }

  if (!sem_verify_safe_assign(ast, sem_type_needed, sem_type_found, var_name)) {
    return false;
  }

  if (is_nullable(sem_type_found) && is_not_nullable(sem_type_needed)) {
    report_error(ast, "CQL0013: cannot assign/copy possibly null expression to not null target", var_name);
    return false;
  }

  if (sensitive_flag(sem_type_found) && !sensitive_flag(sem_type_needed)) {
    report_error(ast, "CQL0014: cannot assign/copy sensitive expression to non-sensitive target", var_name);
    return false;
  }

  return true;
}

// The second workhorse of semantic analysis, given two types that are
// previously known to be compatible, it returns the smallest type that holds
// both.  If either is nullable the result is nullable. Note: in the few cases
// where that isn't true the normal algorithm for nullability result must be
// overridden (see coalesce for instance).
static sem_t sem_combine_types(sem_t sem_type_1, sem_t sem_type_2) {
  sem_t combined_flags = combine_flags(sem_type_1, sem_type_2);
  sem_t core_type_1 = core_type_of(sem_type_1);
  sem_t core_type_2 = core_type_of(sem_type_2);
  sem_t ret = 0;

  // early out for the easy case.
  if (core_type_1 == core_type_2) {
    return core_type_1 | combined_flags;
  }

  // We always validate that it's ok to combine types before we combine.
  switch (core_type_1) {
    case SEM_TYPE_TEXT:
      // if you combine a text with anything (text or NULL) you get TEXT
      Invariant(is_string_compat(core_type_2));
      ret = SEM_TYPE_TEXT;
      break;

    case SEM_TYPE_BLOB:
      // if you combine an object with anything (object or NULL) you get OBJECT
      Invariant(is_blob_compat(core_type_2));
      ret = SEM_TYPE_BLOB;
      break;

    case SEM_TYPE_OBJECT:
      // if you combine an object with anything (object or NULL) you get OBJECT
      Invariant(is_object_compat(core_type_2));
      ret = SEM_TYPE_OBJECT;
      break;

    case SEM_TYPE_REAL:
      // If you combine a real with any other numeric you get a real.
      Invariant(is_numeric_compat(core_type_2));
      ret = SEM_TYPE_REAL;
      break;

    case SEM_TYPE_LONG_INTEGER:
      // If you combine a long integer with a real you get real.
      // If you combine it with any other numeric type you get a long integer.
      Invariant(is_numeric_compat(core_type_2));
      if (core_type_2 == SEM_TYPE_REAL) {
        ret = SEM_TYPE_REAL;
      }
      else {
        ret = SEM_TYPE_LONG_INTEGER;
      }
      break;

    case SEM_TYPE_INTEGER:
      // If you combine an integer with a real you get real.
      // If you combine an integer with a long integer you get long integer.
      // If you combine it with any other numeric type you get an integer.
      Invariant(is_numeric_compat(core_type_2));
      if (core_type_2 == SEM_TYPE_REAL || core_type_2 == SEM_TYPE_LONG_INTEGER) {
        ret = core_type_2;
      }
      else {
        ret = SEM_TYPE_INTEGER;
      }
      break;

    case SEM_TYPE_BOOL:
      // If you combine bool with any numeric type it upgrades to that type.
      // If you combine it with null, you get a nullable bool.
      Invariant(is_numeric_compat(core_type_2));
      if (core_type_2 == SEM_TYPE_NULL) {
        ret = SEM_TYPE_BOOL;
      }
      else {
        ret = core_type_2;
      }
      break;

    case SEM_TYPE_NULL:
      // If you combine null with anything you get nullable that thing.
      Invariant(is_nullable(combined_flags));
      ret = core_type_2;
      break;
  }

  return ret | combined_flags;
}

// Recursive analysis: complain if the result is not numeric. this is the first
// method that shows the error propagation rules generally, errors bubble up but
// once one has been reported in a subtree we do not keep reporting more (saving
// insane amounts of output). the context here is used to create a better error
// location; the caller often has a good idea what line number would be a better
// choice than the expression itself.
static void sem_numeric_expr(
  ast_node *expr,
  ast_node *context,
  CSTR subject,
  uint32_t expr_context)
{
  Contract(expr);
  sem_root_expr(expr, expr_context);

  if (!is_error(expr) && !is_numeric_expr(expr)) {
    ast_node *best = context ? context : expr;
    report_error(best, "CQL0015: expected numeric expression", subject);
    record_error(expr);
  }

  if (context) {
    context->sem = expr->sem;
  }
}

// Given two table nodes attempt to produce the join of them according to the join type.
static void join_tables(ast_node *t1, ast_node *t2, ast_node *result, int32_t join_type) {
  if (is_error(t1) || is_error(t2)) {
    record_error(result);
    return;
  }

  if (enforcement.strict_table_function) {
     bool_t t1_tvf = !!(t1->sem->sem_type & SEM_TYPE_TVF);
     bool_t t2_tvf = !!(t2->sem->sem_type & SEM_TYPE_TVF);
     bool_t error = false;
     switch (join_type) {
       case JOIN_CROSS:
         // CROSS join is the same as INNER in SQLITE (only optimization
         // differences to suppress optimization) there is no full outer join
         break;
       case JOIN_LEFT_OUTER:
       case JOIN_LEFT:
         error = t2_tvf;
         break;
       case JOIN_RIGHT_OUTER:
       case JOIN_RIGHT:
         // sqlite doesn't actually have right join; attempting to use it will
         // net you syntax errors CQL is forward looking in this regard...
         error = t1_tvf;
         break;
     }

     if (error) {
       report_error(result, "CQL0371: table valued function used in a left/right/cross context; this would hit a SQLite bug.  Wrap it in a CTE instead.", NULL);
       record_error(result);
       return;
     }
  }

  sem_join *j1 = t1->sem->jptr;
  sem_join *j2 = t2->sem->jptr;
  Invariant(j1);
  Invariant(j2);

  // First make sure the resulting type could be reasonably used, no duplicate
  // table names note that the semantic names include any aliasing.
  for (uint32_t i = 0; i < j1->count; i++) {
    for (uint32_t j = 0; j < j2->count; j++) {
      CSTR n1 = j1->names[i];
      CSTR n2 = j2->names[j];

      if (!StrCaseCmp(n1, n2)) {
        report_error(t2, "CQL0016: duplicate table name in join", n1);
        record_error(result);
        return;
      }
    }
  }

  // Now create the resulting data type, at this point we're good to go.
  sem_join *jptr = new_sem_join(j1->count + j2->count);

   // the join type will tell us which side(s) need not null removed
  sem_t strip_left = 0;
  sem_t strip_right = 0;

  switch (join_type) {
    case JOIN_INNER:
    case JOIN_CROSS:
      // Cross join is the same as inner join in SQLite, the only difference is
      // the optimizer declines to reorder cross joins as a hint. There is no
      // full outer join.
      strip_left = strip_right = 0;
      break;
    case JOIN_LEFT_OUTER:
    case JOIN_LEFT:
      // Note: left outer join can result in not nulls even if there is no join
      // condition because the table on the right might be empty
      strip_left = 0;
      strip_right = SEM_TYPE_NOTNULL;
      break;
    case JOIN_RIGHT_OUTER:
    case JOIN_RIGHT:
      // Note: SQLite doesn't have right join yet so this is forward looking
      strip_left = SEM_TYPE_NOTNULL;
      strip_right = 0;
      break;
  }

  // Now just copy over the names and the tables.
  uint32_t j = 0;
  for (uint32_t i = 0; i < j1->count; i++, j++) {
    jptr->names[j] = j1->names[i];
    jptr->tables[j] = sem_clone_struct_strip_flags(j1->tables[i], strip_left);
  }
  for (uint32_t i = 0; i < j2->count; i++, j++) {
    jptr->names[j] = j2->names[i];
    jptr->tables[j] = sem_clone_struct_strip_flags(j2->tables[i], strip_right);
  }

  result->sem = new_sem(SEM_TYPE_JOIN);
  result->sem->jptr = jptr;
}

// In cases where the result of the join is now senstive we need to
// add a flag bit to the join columns.  Once you constrain on a senstive
// column all the columns become sensitive.
static void sem_add_flags_to_join(sem_join *jptr, sem_t flags) {
  for (uint32_t i = 0; i <jptr->count; i++) {
    sem_struct *sptr = jptr->tables[i];
    for (uint32_t j = 0; j < sptr->count; j++) {
      sptr->semtypes[j] |= flags;
    }
  }
}

// Given a column ast type convert it to the appropriate sem_type.
static void sem_data_type_column(ast_node *ast) {
  // The data_type could be a declare named type, therefore
  // we should rewrite the node to the real type
  rewrite_data_type_if_needed(ast);
  if (is_error(ast)) {
    record_error(ast);
    return;
  }

  if (is_ast_type_int(ast)) {
    ast->sem = new_sem(SEM_TYPE_INTEGER);
  }
  else if (is_ast_type_text(ast)) {
    ast->sem = new_sem(SEM_TYPE_TEXT);
  }
  else if (is_ast_type_blob(ast)) {
    ast->sem = new_sem(SEM_TYPE_BLOB);
  }
  else if (is_ast_type_object(ast)) {
    ast->sem = new_sem(SEM_TYPE_OBJECT);
  }
  else if (is_ast_type_long(ast)) {
    ast->sem = new_sem(SEM_TYPE_LONG_INTEGER);
  }
  else if (is_ast_type_real(ast)) {
    ast->sem = new_sem(SEM_TYPE_REAL);
  }
  else if (is_ast_type_cursor(ast)) {
    ast->sem = new_sem(SEM_TYPE_CURSOR_FORMAL);
  }
  else {
    Contract(is_ast_type_bool(ast));
    ast->sem = new_sem(SEM_TYPE_BOOL);
  }

  if (ast->left) {
    EXTRACT_STRING(kind, ast->left);
    ast->sem->kind = kind;

    bool_t is_set = !!ends_in_set(kind);
    bool_t is_cursor = !!ends_in_cursor(kind);

    if (is_set || is_cursor) {
      // <T SET> and <T CURSOR> get additional checks

      // now we extract just the type name
      CHARBUF_OPEN(tmp);
      for (int32_t i = 0; kind[i] && kind[i] != ' '; i++) {
        bputc(&tmp, kind[i]);
      }

      // We make a like node for the object type (which is itself not in AST here)
      // so that we can use the standard likeable helpers for error checking
      AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
      ast_node *type_node = new_ast_str(tmp.ptr);
      ast_node *like_node = new_ast_like(type_node, NULL);
      AST_REWRITE_INFO_RESET();

      CHARBUF_CLOSE(tmp);

      // the indicated type must be a valid shape name (one we could use in LIKE T)
      ast_node *like_target = sem_find_shape_def_base(like_node, LIKEABLE_FOR_VALUES);
      if (!like_target) {
        record_error(ast);
        return;
      }

      // it's a result set so it must also be a proc type
      if (is_set && !is_ast_create_proc_stmt(like_target) && !is_ast_declare_proc_stmt(like_target)) {
        report_error(ast, "CQL0090: object<T SET> has a T that is not a procedure with a result set", kind);
        record_error(ast);
        return;
      }

      if (is_set && (is_proc_private(like_target) || is_proc_suppress_result_set(like_target))) {
        report_error(ast, "CQL0091: object<T SET> has a T that is not a public procedure with a result set", kind);
        record_error(ast);
        return;
      }
    }
  }
}

// Create the semantic type, it might be wrapped
// in a not_null node, or @sensitive node, extract that and add to flags.
static void sem_data_type_var(ast_node *ast) {
  // The data_type could be a declare named type, therefore
  // we should rewrite the node to the real type
  rewrite_data_type_if_needed(ast);
  if (is_error(ast)) {
    record_error(ast);
    return;
  }

  if (is_ast_create_data_type(ast)) {
    ast_node *data_type = ast->left;

    sem_data_type_var(data_type);
    if (is_error(data_type)) {
      record_error(ast);
      return;
    }

    sem_t core_type = core_type_of(data_type->sem->sem_type);

    // The create data type is restricted to text, blob, object only.
    if (core_type != SEM_TYPE_TEXT && core_type != SEM_TYPE_BLOB && core_type != SEM_TYPE_OBJECT) {
      report_error(ast, "CQL0361: return data type in a create function declaration can only be text, blob or object", NULL);
      record_error(ast);
      return;
    }

    // Create a node for me using my child's type but adding func create.
    ast->sem = new_sem(SEM_TYPE_CREATE_FUNC | data_type->sem->sem_type);
    // copy object type to the sem if applicable. It's used to rewrite
    // named type ast.
    ast->sem->kind = data_type->sem->kind;
  }
  else if (is_ast_notnull(ast)) {
    EXTRACT_ANY_NOTNULL(data_type, ast->left);
    sem_data_type_var(data_type);

    if (data_type->sem->sem_type & SEM_TYPE_NOTNULL) {
      report_error(ast, "CQL0367: an attribute was specified twice", "not null");
      record_error(ast);
      return;
    }

    // Create a node for me using my child's type but adding not null.
    ast->sem = new_sem(SEM_TYPE_NOTNULL | data_type->sem->sem_type);
    // copy object type to the sem if applicable. It's used to rewrite
    // named type ast.
    ast->sem->kind = data_type->sem->kind;
  }
  else if (is_ast_sensitive_attr(ast)) {
    EXTRACT_ANY_NOTNULL(data_type, ast->left);
    sem_data_type_var(data_type);
    if (is_error(data_type)) {
      record_error(ast);
      return;
    }

    if (data_type->sem->sem_type & SEM_TYPE_SENSITIVE) {
      report_error(ast, "CQL0367: an attribute was specified twice", "@sensitive");
      record_error(ast);
      return;
    }

    // Create a node for me using my child's type but adding not null.
    ast->sem = new_sem(SEM_TYPE_SENSITIVE | data_type->sem->sem_type);
    // copy object type to the sem if applicable. It's used to rewrite
    // named type ast.
    ast->sem->kind = data_type->sem->kind;
  }
  else {
    sem_data_type_column(ast);
  }
}

// Use the standard name checker to check for valid names in this scope
// Items must be in scope and no duplicate names are allowed.
static bool_t sem_validate_name_list(ast_node *name_list, sem_join *jptr) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_name_list(name_list) || is_ast_indexed_columns(name_list));

  name_check check;
  init_name_check(&check, name_list, jptr);
  bool_t valid = sem_name_check(&check);
  destroy_name_check(&check);
  return valid;
}

// Here we check the index found in the "previous" schema against the current schema.
// There are several validations we have to do here:
//  * the index should be present (but maybe marked with @delete)
//  * the index has to have a compatible create version
//  * the index has to have a compatible delete version
static void sem_validate_previous_index(ast_node *prev_index) {
  Contract(!current_joinscope);

  Contract(is_ast_create_index_stmt(prev_index));
  EXTRACT_NOTNULL(create_index_on_list, prev_index->left);
  EXTRACT_NOTNULL(flags_names_attrs, prev_index->right);
  EXTRACT_NOTNULL(connector, flags_names_attrs->right);
  EXTRACT_NOTNULL(index_names_and_attrs, connector->left);
  EXTRACT_NOTNULL(indexed_columns, index_names_and_attrs->left);
  EXTRACT(opt_where, index_names_and_attrs->right);
  EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);
  EXTRACT_STRING(index_name, index_name_ast);
  EXTRACT_NAME_AST(table_name_ast, create_index_on_list->right);
  EXTRACT_STRING(table_name, table_name_ast);

  ast_node *ast = find_index(index_name);

  if (!ast) {
    if (options.schema_exclusive) {
      // In exclusive schema mode, unknown indices are bulk deleted
      // therefore you do not need a tombstone
      return;
    }

    // If the table the index was on is going away then we don't need
    // to verify that the index has a tombstone.  In fact it is not
    // possible to declare the tombstone now because the table name is not
    // valid.  There's no need for the tombstone anyway because when the
    // table is deleted all its indices will also be deleted.
    ast_node *table_ast = find_table_or_view_even_deleted(table_name);

    // the table must exist and be affirmatively deleted to avoid the error!
    if (table_ast && table_ast->sem->delete_version > 0) {
      return;
    }

    report_error(prev_index, "CQL0017: index was present but now it does not exist (use @delete instead)", index_name);
    record_error(prev_index);
    return;
  }

  enqueue_pending_region_validation(prev_index, ast, index_name);
}

// We often need to find the index of a particular column
cql_noexport int32_t find_col_in_sptr(sem_struct *sptr, CSTR name) {
  Contract(name);
  for (uint32_t i = 0; i < sptr->count; i++) {
    if (!StrCaseCmp(sptr->names[i], name)) {
      return (int32_t)i;
    }
  }
  return -1;
}

// Helper function to update the column type in a table node.
static void sem_update_column_type(ast_node *table_ast, ast_node *columns, sem_t type) {
  Contract(is_ast_name_list(columns) || is_ast_indexed_columns(columns));

  sem_struct *sptr = table_ast->sem->sptr;
  sem_join *jptr = table_ast->sem->jptr;
  for (ast_node *item = columns; item; item = item->right) {
    ast_node *name_ast = item->left;
    if (is_ast_indexed_column(name_ast)) {
      name_ast = name_ast->left;
    }

    // note that an indexed column could be an expression
    // if that's the case update nothing...
    if (is_ast_str(name_ast)) {
      EXTRACT_STRING(name, name_ast);

      // always a valid column name, it MUST match
      int32_t i = find_col_in_sptr(sptr, name);
      Invariant(i >= 0);
      sptr->semtypes[i] |= type;
      jptr->tables[0]->semtypes[i] |= type;
    }
  }
}

// This is only for indices and triggers, they have no @create annotation ever
// as they are always @recreate objects, but they can be deleted.  All we need to do
// is verify that they have no delete migration proc; it's not safe for them to have such
// a proc because indices and triggers must be removed entirely if their table is ever deleted
// at which point the migration proc would vanish.  To avoid this problem we don't support
// migration procs on these objects.
static bool_t sem_validate_no_delete_migration(version_attrs_info *vers_info, ast_node *ast, CSTR obj_name) {
  Contract(vers_info);
  Contract(vers_info->create_version < 0);
  Contract(!vers_info->create_proc);

  if (vers_info->delete_proc) {
    report_error(ast, "CQL0321: migration proc not allowed on object", obj_name);
    record_error(ast);
    return false;
  }

  return true;
}

// Top level index creation, we don't really do anything with indices
// in CQL but we do validate that they make sense (so we lookup all the names)
// using the helper above.
static void sem_create_index_stmt(ast_node *ast) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)

  Contract(is_ast_create_index_stmt(ast));
  EXTRACT_NOTNULL(create_index_on_list, ast->left);
  EXTRACT_NOTNULL(flags_names_attrs, ast->right);
  EXTRACT_NOTNULL(connector, flags_names_attrs->right);
  EXTRACT_NOTNULL(index_names_and_attrs, connector->left);
  EXTRACT_NOTNULL(indexed_columns, index_names_and_attrs->left);
  EXTRACT(opt_where, index_names_and_attrs->right);
  EXTRACT_ANY(attrs, connector->right);
  EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);
  EXTRACT_STRING(index_name, index_name_ast);
  EXTRACT_NAME_AST(table_name_ast, create_index_on_list->right);
  EXTRACT_STRING(table_name, table_name_ast);

  // Index declarations (i.e. outside of any proc) are totally ignored
  // in the context of a schema migration script.  This prevents us from
  // getting errors because the index refers to tables or columns that are not yet
  // in existence in the version we are migrating.  If you need an index
  // in your migration script you have to create it and use it yourself
  // since you can't rely on the presence of that index during migration anyway.
  if (schema_upgrade_version > 0 && !current_proc) {
    record_ok(ast);
    return;
  }

  if (validating_previous_schema) {
    record_ok(ast);
    sem_validate_previous_index(ast);
    return;
  }

  bool_t adding_current_entity = will_add_current_entity();

  // if there is an existing index, save it here so we can check for duplicates later.
  ast_node *existing_defn = adding_current_entity ? find_index(index_name) : NULL;

  version_attrs_info vers_info;
  init_version_attrs_info(&vers_info, index_name, ast, attrs);
  bool_t valid_version_info = sem_validate_version_attrs(&vers_info);
  Invariant(valid_version_info);  // nothing can go wrong with index version info

  if (!sem_validate_vers_ok_in_context(&vers_info)) {
    record_error(ast);
    return;
  }

  if (!sem_validate_no_delete_migration(&vers_info, ast, index_name)) {
    return;
  }

  ast_node *table_ast = NULL;
  bool_t deleting = vers_info.delete_version > 0;

  if (deleting) {
    table_ast = find_usable_table_or_view_even_deleted(
      table_name,
      table_name_ast,
      "CQL0019: create index table name not found");

    if (is_deleted(table_ast)) {
      report_error(ast, "CQL0397: object is an orphan because its table is deleted. Remove rather than @delete", index_name);
      record_error(ast);
      return;
    }
  }
  else {
    table_ast = find_usable_and_not_deleted_table_or_view(
      table_name,
      table_name_ast,
      "CQL0019: create index table name not found");
  }

  if (!table_ast) {
    record_error(ast);
    return;
  }

  sem_non_backed_table(ast, table_ast);
  if (is_error(ast)) {
    return;
  }

  sem_non_blob_storage_table(ast, table_ast);
  if (is_error(ast)) {
    return;
  }

  if (is_virtual_ast(table_ast)) {
    report_error(table_name_ast, "CQL0159: cannot add an index to a virtual table", table_name);
    record_error(ast);
    return;
  }

  // It's only interesting to check for this error in the main schema
  // declarations, not in previous schema and not in schema upgrade scripts
  // (which are driven by correct regions).  "adding_current_entity" is for
  // exactly those cases.
  if (table_ast->sem->recreate && adding_current_entity) {
    CSTR table_region = table_ast->sem->region;
    if (table_region != current_region) {
      // The only valid cases are both null or both the current not-null region
      // string. NOTE: the region string is canonical (normalized in begin
      // region) so you don't even have to check the text
      report_error(ast, "CQL0066: if a table is marked @recreate, its indices must be in its schema region", index_name);
      record_error(ast);
      return;
    }
  }

  // CREATE INDEX [index_name] ON [table-name] ( [name_list] )
  // don't check the index names if we're deleting the index, they are useless anyway
  if (!deleting && !sem_validate_name_list(indexed_columns, table_ast->sem->jptr)) {
    record_error(ast);
    return;
  }

  if (opt_where) {
    EXTRACT_ANY_NOTNULL(expr, opt_where->left);
    sem_validate_check_expr_for_table(table_ast, expr, "WHERE");
    opt_where->sem = expr->sem;
    if (is_error(expr))  {
      record_error(ast);
      return;
    }
  }

  ast->sem = new_sem(SEM_TYPE_OK);
  ast->sem->delete_version = vers_info.delete_version;
  ast->sem->region = current_region;

  if (existing_defn) {
    if (!sem_validate_identical_ddl(existing_defn, ast)) {
      report_error(index_name_ast, "CQL0018: duplicate index name", index_name);
      record_error(index_name_ast);
      record_error(ast);
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      sem_add_flags(ast, SEM_TYPE_ALIAS);
    }
    return;
  }

  if (adding_current_entity) {
    // deleted or no it goes in the main list
    add_item_to_list(&all_indices_list, ast);

    // and consume the name
    add_index(ast, index_name);

    // and record the annotation
    sem_record_annotation_from_vers_info(&vers_info);

    // add the index to the table it is on
    add_item_to_list(&table_ast->sem->table_info->index_list, ast);
  }
}

// Similar to other constraints, we don't actually do anything with this
// other than offer some validation.  Again we use the usual helpers
// for name lookup within the context of this one PK/AK
static void sem_unq_def(ast_node *table_ast, ast_node *def) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_create_table_stmt(table_ast));
  Contract(is_ast_unq_def(def));
  EXTRACT_NOTNULL(indexed_columns_conflict_clause, def->right);
  EXTRACT_NOTNULL(indexed_columns, indexed_columns_conflict_clause->left);

  if (def->left) {
    EXTRACT_STRING(name, def->left);
    if (symtab_find(table_items, name)) {
      report_error(def, "CQL0020: duplicate constraint name in table", name);
      record_error(table_ast);
      return;
    }
    symtab_add(table_items, name, def);
  }

  // check if def node is unique key compare to others in table_ast
  if (!is_unique_key_valid(table_ast, def)) {
    report_error(def, "CQL0269: at least part of this unique key is redundant with previous unique keys", NULL);
    record_error(table_ast);
    return;
  }

  // CONSTRAINT name UNIQUE [indexed_columns]
  // or UNIQUE [indexed_columns]
  if (!sem_validate_name_list(indexed_columns, table_ast->sem->jptr)) {
    record_error(table_ast);
    return;
  }
}

// If we are in strict mode, then we validate that each FK has some choice for
// on update and/or on delete.  The choice might still be "do nothing" but you
// can't just leave it blank.
static bool_t sem_validate_fk_flags(ast_node *def, int32_t flags) {
  if (enforcement.strict_fk_update) {
    if (0 == (flags & FK_ON_UPDATE)) {
      report_error(def, "CQL0237: strict FK validation requires that some ON UPDATE option be selected for every foreign key", NULL);
      record_error(def);
      return false;
    }
  }

  if (enforcement.strict_fk_delete) {
    if (0 == (flags & FK_ON_DELETE)) {
      report_error(def, "CQL0238: strict FK validation requires that some ON DELETE option be selected for every foreign key", NULL);
      record_error(def);
      return false;
    }
  }

  return true;
}

// Here we're going to find the "referenced" table in a foreign key reference
// from the current context.  That table has to exist and be appropriately
// visible.  However, it also has extra constraints because it is being used in
// the context of a foreign key.  Notably, if the referenced table is marked
// @recreate then it must be in the same @recreate group as the current table or
// it's an error because the referenced table might be recreated away leaving
// all the foreign key references in this table as orphans.
//
// So we check the following: If the referenced table is @recreate and any of
// the following:
//   * the referenced table is in no group, OR
//   * the containing table is not @recreate at all (non-recreate table can't
//     reference @recreate tables at all), OR
//   * the containing table is in no @recreate group (it's @recreate but not in
//     any group so they might not rev together), OR
//   * the recreate groups of the two tables are different (it's in an @recreate
//     group but not same one so they my not rev together) Then the reference is
//     not valid. Additionally:
//   * the referenced table must be created in an version that came before the
//     referencing table
static ast_node *find_and_validate_referenced_table(
  CSTR table_name,
  ast_node *err_target,
  version_attrs_info *table_info)
{
  // The previous schema might have different regions, @recreate groups and
  // other things than the now current schema; it was validated for self
  // consistency when it was created so we don't need to re-check it now and we
  // already validated the now current schema for @recreate violations.
  // Validating the old against the new just causes spurious errors, so don't.

  // This code doesn't get invoked in those cases.
  Contract(!validating_previous_schema);

  // The table is referring to itself, the other checks are moot and the name is
  // not yet registered as the table is currently under construction.  It can't
  // be the case that it is referring to a different recreate group or a future
  // version, because it is referring to itself.
  if (!StrCaseCmp(table_name, current_table_name)) {
    Invariant(current_table_ast);
    return current_table_ast;
  }

  ast_node *ref_table_ast;

  if (table_info->delete_version > 0 || current_proc) {
    // Create table statements inside a proc are exempt from the extra checks.
    // Those statements aren't just schema declarations they are the ones
    // creating the table, maybe to make things right in the context of schema
    // upgrade itself. These extra check just doesn't make sense there.

    // Deleted tables likewise, do not need to have FK's that make sense in the current schema

    ref_table_ast = find_table_or_view_even_deleted(table_name);

    if (!ref_table_ast) {
      report_error(err_target, "CQL0021: foreign key refers to non-existent table", table_name);
      record_error(err_target);
    }

    // this table is going away, so the fk checks are moot
    return ref_table_ast;
  }

  ref_table_ast = find_usable_and_not_deleted_table_or_view(
    table_name,
    err_target,
    "CQL0021: foreign key refers to non-existent table");

  if (!ref_table_ast) {
    return NULL;
  }

  // We have to make sure we aren't referencing the future.
  //   * Recreate tables can see any version they like, if the name is in scope
  //     that's good enough which has already been verified.
  //   * Other tables may only "see" the same version or an earlier version.
  //
  // Normal processing can't actually get into this state because if you tried
  // to create the referencing table with the smaller version number first you
  // would get errors because the name of the referenced table doesn't yet
  // exist.  But if you created them at the same time and you made a typo in the
  // version number of the referenced table such that it was accidentally bigger
  // you'd create a weirdness. So we check for that situation here and reject it
  // to prevent that sort of typo.
  if (!table_info->recreate) {
    int32_t ref_create_verison = ref_table_ast->sem->create_version;
    int32_t cur_create_version = table_info->create_version;

    if (ref_create_verison > 0 && ref_create_verison > cur_create_version) {
      report_error(err_target, "CQL0324: referenced table was created in a later version so it cannot be used in a foreign key", table_name);
      record_error(err_target);
      return NULL;
    }
  }

  // If the referenced table is @recreate then only either @recreate tables in
  // the same group or @recreate groups that don't introduce a cyclic FK
  // dependency among recreate group dependencies can use it as an FK.

  if (ref_table_ast->sem->recreate) {
    if (table_info->recreate) {
      CSTR ref_recreate_gname = create_group_id(ref_table_ast->sem->recreate_group_name, table_name);
      CSTR curr_recreate_gname = create_group_id(table_info->recreate_group_name, current_table_name);
      bool_t success = add_group_dependency_to_recreate_group(ref_recreate_gname, curr_recreate_gname);
      if (!success) {
        report_error(err_target, "CQL0060: referenced table can be independently recreated so it cannot be used in a foreign key", table_name);
        record_error(err_target);
        return NULL;
      }
    }
    // if the current table is not a recreate table
    else {
      report_error(err_target, "CQL0060: referenced table can be independently recreated so it cannot be used in a foreign key", table_name);
      record_error(err_target);
      return NULL;
    }
  }

  return ref_table_ast;
}

// find_referenceable_columns's callback. It return true if name_list includes a
// specific column name. This is used in autotest(dummy_test) to figure out if a
// column should have an explicit value to avoid sql foreign key violation
static bool_t validate_referenceable_column_callback(
  ast_node *indexed_columns,
  void *context)
{
  Contract(is_ast_indexed_columns(indexed_columns));
  CSTR column_name = (CSTR)context;

  for (; indexed_columns; indexed_columns = indexed_columns->right) {
    Invariant(is_ast_indexed_columns(indexed_columns));

    EXTRACT_NOTNULL(indexed_column, indexed_columns->left);
    ast_node *name_ast = indexed_column->left;

    // if this is an expression that is other than a simple name, it can't match
    // any identifier auto test will have no way of meeting this constraint
    // automatically
    if (is_ast_str(name_ast)) {
      EXTRACT_STRING(name, name_ast);
      if (!StrCaseCmp(column_name, name)) {
        return true;
      }
    }
  }
  return false;
}

// Check if a column is a primary or unique key
static bool_t is_column_unique_key(ast_node *ref_table_ast, CSTR column_name) {
  sem_struct *sptr = ref_table_ast->sem->sptr;
  for (uint32_t i = 0; i < sptr->count; i++) {
    if (!StrCaseCmp(column_name, sptr->names[i]) &&
        (is_primary_key(sptr->semtypes[i]) || is_unique_key(sptr->semtypes[i]))) {
      return true;
    }
  }
  return false;
}

// find_referenceable_colunns's callback
typedef bool_t (*validate_referenceable_columns_callback)(ast_node *name_list, void *context);

// Walkthrough create table node for table "table_name" and/or all the create
// index node to find :
//   - CONSTRAINT UNIQUE ([name_list]) statement
//   - CREATE INDEX name ON name([name_list]) statement
//
// The found nodes are passed to the callback to do validation. As soon as the
// callback return true the walkthrough stop otherwise it continues.
static bool_t find_referenceable_columns(
  ast_node *ref_table_ast,
  validate_referenceable_columns_callback callback,
  void *context
) {
  Contract(is_ast_create_table_stmt(ref_table_ast));

  EXTRACT_NOTNULL(create_table_name_flags, ref_table_ast->left);
  EXTRACT_STRING(ref_table_name, create_table_name_flags->right);

  EXTRACT_NOTNULL(col_key_list, ref_table_ast->right);
  for (; col_key_list; col_key_list = col_key_list->right) {
    EXTRACT_ANY_NOTNULL(col_def, col_key_list->left);
    // check if all column are in PRIMARY KEY ([name_list]) statement
    if (is_ast_pk_def(col_def)) {
      EXTRACT_NOTNULL(indexed_columns_conflict_clause, col_def->right);
      EXTRACT_NAMED_NOTNULL(indexed_columns2, indexed_columns, indexed_columns_conflict_clause->left);
      if (callback(indexed_columns2, context)) {
        return true;
      }
    }
    // check if all column are in CONSTRAINT UNIQUE ([name_list]) statement
    else if (is_ast_unq_def(col_def)) {
      EXTRACT_NOTNULL(indexed_columns_conflict_clause, col_def->right);
      EXTRACT_NAMED_NOTNULL(indexed_columns2, indexed_columns, indexed_columns_conflict_clause->left);
      if (callback(indexed_columns2, context)) {
        return true;
      }
    }
  }

  // check if all column are in CREATE UNIQUE INDEX statement
  for (uint32_t i = 0; i < indices->capacity; i++) {
    symtab_entry entry = indices->payload[i];
    if (entry.sym) {
      ast_node *index_ast = (ast_node *)entry.val;

      Contract(is_ast_create_index_stmt(index_ast));
      EXTRACT_NOTNULL(create_index_on_list, index_ast->left);
      EXTRACT_NOTNULL(flags_names_attrs, index_ast->right);
      EXTRACT_NOTNULL(connector, flags_names_attrs->right);
      EXTRACT_NOTNULL(index_names_and_attrs, connector->left);
      EXTRACT_OPTION(flags, flags_names_attrs->left);
      EXTRACT_NOTNULL(indexed_columns, index_names_and_attrs->left);
      EXTRACT(opt_where, index_names_and_attrs->right);
      EXTRACT_NAME_AST(index_name_ast, create_index_on_list->left);
      EXTRACT_STRING(index_name, index_name_ast);
      EXTRACT_NAME_AST(table_name_ast, create_index_on_list->right);
      EXTRACT_STRING(table_name, table_name_ast);

      if (!(flags & INDEX_UNIQUE)) {
        continue;
      }

      if (StrCaseCmp(ref_table_name, table_name)) {
        continue;
      }

      if (callback(indexed_columns, context)) {
        return true;
      }
    }
  }

  return false;
}

// Check whether or not a column in a table is referenceable by other table in
// foreign key statement. This is used in autotest(dummy_test) to figure out
// which columns needs to have explicit value in INSERT statement to avoid sql
// foreign key violations.
//
// A column is considered referenceable if column is :
//  - a primary e.g: create table t (a text primary key)
//  - unique key e.g: create table t (a text unique)
//  - a group of primary key e.g: create table t (a text, b text, primary key
//    (a, b))
//  - listed in CONSTRAINT UNIQUE statement e.g: create table t (a text,
//    constraint unique (a))
//  - listed in a CREATE UNIQUE INDEX statement e.g: create index unique on t(a)
cql_noexport bool_t is_referenceable_by_foreign_key(
  ast_node *ref_table_ast,
  CSTR column_name)
{
  return is_column_unique_key(ref_table_ast, column_name)
    || find_referenceable_columns(
      ref_table_ast,
      validate_referenceable_column_callback,
      (void *)column_name);
}

// find_referenceable_columns's callback. It returns true if both name lists
// have the same items (in any order). This is used to figure out a list of columns
// in a foreign key clause are referenceable.
static bool_t validate_referenceable_fk_def_callback(
  ast_node *name_list,
  void *context)
{
  Contract(is_ast_name_list(context) || is_ast_indexed_columns(context));
  return is_name_list_equal(name_list, (ast_node *)context);
}

// Validate that the columns referenced in the foreign key statement are
// referenceable. A set of columns are considered referenceable if they are
//
//  - a primary key column
//     * e.g., create table t (a text primary key)
//  - a unique key column
//     * e.g., create table t (a text unique)
//  - a group of primary key columns
//     * e.g., create table t (a text, b text, primary key (a, b))
//  - listed in CONSTRAINT UNIQUE statement
//     * e.g., create table t (a text, constraint unique (a))
//  - listed in a CREATE UNIQUE INDEX statement
//     * e.g., create index unique on t(a)
static sem_t sem_validate_referenceable_fk_def(
  ast_node *ref_table_ast,
  ast_node *name_list)
{
  Contract(is_ast_name_list(name_list));

  EXTRACT_NOTNULL(create_table_name_flags, ref_table_ast->left);
  EXTRACT_STRING(ref_table_name, create_table_name_flags->right);

  // If we only have only one column listed in name_list then we just
  // check if that column is a single primary or unique key in table
  if (!name_list->right) {
    EXTRACT_STRING(column_name, name_list->left);
    if (is_column_unique_key(ref_table_ast, column_name)) {
      return true;
    }
  }

  // otherwise we are going to check if all the column in name_list are
  // - a unique key (UNIQUE (...) OR UNIQUE CONSTRAINT (...))
  // - unique index (CREATE UNIQUE INDEX ...)
  // - a group of primary key (PRIMARY KEY (a,b,...)).
  bool_t valid = find_referenceable_columns(
    ref_table_ast,
    validate_referenceable_fk_def_callback,
    name_list);

  if (!valid) {
    EXTRACT_STRING(name, name_list->left);
    report_error(name_list, "CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table", ref_table_name);
  }
  return valid;
}

// Get the name string of the object, for a variety of objects
//  - a table
//   - a trigger
//   - a procedure
//   - a column
//   - a view
// The name can appear in a variety of places in the AST so this
// helps us to normalize things with typical names.  Typically used
// in error reporting.
cql_noexport ast_node *sem_get_name_ast(ast_node *ast) {
  if (is_ast_create_table_stmt(ast)) {
    EXTRACT_NOTNULL(create_table_name_flags, ast->left);
    EXTRACT_NAME_AST(table_name_ast, create_table_name_flags->right);
    return table_name_ast;
  }

  if (is_ast_create_trigger_stmt(ast)) {
    EXTRACT_NOTNULL(trigger_body_vers, ast->right);
    EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
    EXTRACT_NAME_AST(trigger_name_ast, trigger_def->left);
    return trigger_name_ast;
  }

  if (is_ast_create_proc_stmt(ast)) {
    EXTRACT_NAME_AST(proc_name_ast, ast->left);
    return proc_name_ast;
  }

  if (is_ast_declare_proc_stmt(ast)) {
    EXTRACT_NOTNULL(proc_name_type, ast->left);
    EXTRACT_NAME_AST(proc_name_ast, proc_name_type->left);
    return proc_name_ast;
  }

  if (is_ast_col_def(ast)) {
    EXTRACT_NOTNULL(col_def_type_attrs, ast->left);
    EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
    EXTRACT_NAME_AST(col_name_ast, col_def_name_type->left);
    return col_name_ast;
  }

  // the only other option
  Contract(is_ast_create_view_stmt(ast));
  EXTRACT_NOTNULL(view_and_attrs, ast->right);
  EXTRACT_NOTNULL(view_details_select, view_and_attrs->left);
  EXTRACT_NOTNULL(view_details, view_details_select->left);
  EXTRACT_NAME_AST(view_name_ast, view_details->left);
  return view_name_ast;
}

// as above but as a string
cql_noexport CSTR sem_get_name(ast_node *ast) {
  ast_node *name_ast = sem_get_name_ast(ast);
  EXTRACT_STRING(name, name_ast);
  return name;
}

// These symbol tables track ast dependencies by name
// This tells use which tables refer to which other tables by FK (both directions)
// And which views refer to which tables by name (both directions)
static void record_table_dependencies(
  ast_node *src_ast,
  ast_node *target_ast)
{
  Contract(is_ast_create_table_stmt(target_ast) || is_ast_create_view_stmt(target_ast));

  // note this will verify that it is one of the known dependency types also
  CSTR src_name = sem_get_name(src_ast);
  CSTR target_name = sem_get_name(target_ast);

  symtab_append_bytes(ref_sources_for_target_table, target_name, &src_ast, sizeof(src_ast));
  symtab_append_bytes(ref_targets_for_source_table, src_name, &target_ast, sizeof(target_ast));
}

// Similar to other constraints, we don't actually do anything with this other
// than offer some validation.  Again we use the usual helpers for name lookup
// within the context of this one FK.  Note that the FK has to be queried
// against two tables to fully validate it.
static void sem_fk_def(
  ast_node *table_ast,
  ast_node *def,
  version_attrs_info *table_info)
{
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_create_table_stmt(table_ast));
  Contract(is_ast_fk_def(def));
  EXTRACT_NOTNULL(fk_info, def->right);
  EXTRACT_NAMED_NOTNULL(src_list, name_list, fk_info->left);
  EXTRACT_NOTNULL(fk_target_options, fk_info->right);
  EXTRACT_NOTNULL(fk_target, fk_target_options->left);
  EXTRACT_OPTION(flags, fk_target_options->right);
  EXTRACT_STRING(ref_table_name, fk_target->left);
  EXTRACT_NAMED_NOTNULL(ref_list, name_list, fk_target->right);

  // FK's inside of a table declaration (i.e. outside of any proc) are totally ignored
  // in the context of a schema migration script.  This prevents us from
  // getting errors because the latest version of the table refers to tables or
  // columns that are not yet in existence in the version we are migrating.
  // FKs in tables created by your migration script are honored.
  // When schema_upgrade_version > 0 it means we are in a migration script looking
  // and we are looking at logical schema version from the past.
  if (schema_upgrade_version > 0 && !current_proc) {
    record_ok(def);
    return;
  }

  // If we're doing previous schema validation  we don't have to validate the columns at all.
  // The previous schema may have different regions and/or @recreate groups and this will
  // just lead to spurious errors.  The current schema was already checked for consistency
  // all we have to do is validate that the text of the columns didn't change and that
  // happens later.  Visibility rules are moot.
  if (validating_previous_schema) {
    record_ok(def);
    return;
  }

  // FOREIGN KEY ( [src_list] ) REFERENCES [table_name] ([ref_list])

  if (def->left) {
    EXTRACT_STRING(constraint_name, def->left);
    if (symtab_find(table_items, constraint_name)) {
      report_error(def, "CQL0020: duplicate constraint name in table", constraint_name);
      record_error(table_ast);
      return;
    }
    symtab_add(table_items, constraint_name, def);
  }

  if (!sem_validate_name_list(src_list, table_ast->sem->jptr)) {
    record_error(table_ast);
    return;
  }

  // Here we make sure that the target table is visible here, that it is
  // in a compatible recreate group, and it was created before the current
  // table, if appropriate.
  ast_node *ref_table_ast = find_and_validate_referenced_table(
    ref_table_name,
    def,
    table_info);
  if (!ref_table_ast) {
    record_error(table_ast);
    return;
  }

  if (!sem_validate_name_list(ref_list, ref_table_ast->sem->jptr)) {
    record_error(table_ast);
    return;
  }

  // Here, we check to make sure that the target of this FK is, in fact, a unique key
  // in the target table.
  if (!sem_validate_referenceable_fk_def(ref_table_ast, ref_list)) {
    record_error(table_ast);
    record_error(def);
    return;
  }

  sem_update_column_type(table_ast, src_list, SEM_TYPE_FK);

  for ( ; src_list && ref_list; src_list = src_list->right, ref_list = ref_list->right) {
    ast_node *key = src_list->left;
    ast_node *ref = ref_list->left;
    if (core_type_of(key->sem->sem_type) != core_type_of(ref->sem->sem_type)) {
      CSTR error_message = "CQL0022: exact type of both sides of a foreign key must match";
      report_sem_type_mismatch(
          key->sem->sem_type,
          ref->sem->sem_type,
          key,
          error_message,
          key->sem->name);
      record_error(table_ast);
      record_error(def);
      return;
    }
  }

  if (src_list || ref_list) {
    report_error(def, "CQL0023: number of columns on both sides of a foreign key must match", NULL);
    record_error(table_ast);
    record_error(def);
    return;
  }

  // flags are only checked if we are in the appropriate strict mode
  if (!sem_validate_fk_flags(def, flags)) {
    record_error(table_ast);
    return;
  }

  record_table_dependencies(table_ast, ref_table_ast);

  record_ok(def);
}

// Similar to other constraints, we don't actually do anything with this
// other than offer some validation.  Again we use the usual helpers
// for name lookup within the context of this one PK.
static void sem_pk_def(ast_node *table_ast, ast_node *def) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_create_table_stmt(table_ast));
  Contract(is_ast_pk_def(def));
  EXTRACT_NOTNULL(indexed_columns_conflict_clause, def->right);
  EXTRACT(indexed_columns, indexed_columns_conflict_clause->left);

  // PRIMARY KEY [indexed_columns]

  if (def->left) {
    EXTRACT_STRING(name, def->left);
    if (symtab_find(table_items, name)) {
      report_error(def, "CQL0020: duplicate constraint name in table", name);
      record_error(table_ast);
      return;
    }
    symtab_add(table_items, name, def);
  }

  if (!sem_validate_name_list(indexed_columns, table_ast->sem->jptr)) {
    record_error(table_ast);
    return;
  }

  // pk columns are all not null. These mutations are not visible elsewhere
  // because `sptr` and `jptr` are uniquely referenced at this point:
  // `sem_pk_def` is only called via `sem_constraints` which in turn is only
  // called from `sem_create_table_stmt` which allocates new values. All the
  // columns of a pk constraint are marked with "partial pk", although strangely
  // there might be only one such column.  Still this clarifies the origin -- a
  // PK attribute or a PK constraint.  The existing flag means the PK attribute
  // on the column so this is unambiguously a constraint and all pk columns get
  // *something* now.  This helps us navigate pk columns in other cases like
  // backing storage without re-doing complex analysis of attributes.
  sem_update_column_type(table_ast, indexed_columns, SEM_TYPE_NOTNULL | SEM_TYPE_PARTIAL_PK);
}

// Currently the only known builtin migration proc are
//  * cql:from_recreate
//  * cql:module_must_not_be_deleted_see_docs_for_CQLmmmm
//
// If this is ever generalized something fancier might be needed here like a
// name table or something.  For now, keeping it simple.
static void sem_validate_builtin_migration_proc(ast_node *ast, uint32_t code, CSTR name) {
  bool_t is_from_recreate = !StrCaseCmp(CQL_FROM_RECREATE, name);
  bool_t is_module_warn = !StrCaseCmp(CQL_MODULE_WARN, name);

  if (!is_from_recreate && !is_module_warn) {
    report_error(ast, "CQL0379: unknown built-in migration procedure", name);
    record_error(ast);
    return;
  }

  if (is_from_recreate && code != SCHEMA_ANNOTATION_CREATE_TABLE) {
    report_error(ast, "CQL0378: built-in migration procedure not valid in this context", name);
    record_error(ast);
    return;
  }

  if (is_module_warn && code != SCHEMA_ANNOTATION_DELETE_TABLE) {
    report_error(ast, "CQL0378: built-in migration procedure not valid in this context", name);
    record_error(ast);
    return;
  }

  record_ok(ast);
  return;
}

static bool_t sem_validate_version(uint32_t code, ast_node *ast, int32_t *version, CSTR *out_proc) {
  Contract(version);
  EXTRACT(version_annotation, ast->left);
  EXTRACT_OPTION(vers, version_annotation->left);

  *out_proc = NULL;

  if (vers < 1) {
    report_error(ast, "CQL0025: version number in annotation must be positive", NULL);
    record_error(ast);
    return false;
  }

  if (*version > 0) {
    report_error(ast, "CQL0026: duplicate version annotation", NULL);
    record_error(ast);
    return false;
  }

  if (version_annotation->right) {
    CSTR proc_name = NULL;

    if (is_ast_dot(version_annotation->right)) {
      EXTRACT_NOTNULL(dot, version_annotation->right);
      EXTRACT_STRING(lhs, dot->left);
      EXTRACT_STRING(rhs, dot->right);
      proc_name = dup_printf("%s:%s", lhs, rhs);
      sem_validate_builtin_migration_proc(dot, code, proc_name);
      if (is_error(dot)) {
        record_error(ast);
        return false;
      }
    }
    else {
      EXTRACT_STRING(name, version_annotation->right);
      proc_name = name;

      size_t len = strlen(name);
      if (len >= 4) {
        size_t offset = len - 4;
        if (!StrCaseCmp(name + offset, "_crc")) {
          report_error(ast, "CQL0338: the name of a migration procedure may not end in '_crc'", name);
          record_error(ast);
          return false;
        }
      }

      if (!sem_create_migration_proc_prototype(ast, proc_name)) {
        record_error(ast);
        return false;
      }
    }

    *out_proc = proc_name;
  }

  if (validating_previous_schema) {
    // During previous schema validation we track the biggest schema version we've seen
    if (vers > max_previous_schema_version) {
      bool_t excluded = current_region && excluded_regions && symtab_find(excluded_regions, current_region);

      if (!excluded) {
        max_previous_schema_version = vers;
      }
    }
  }
  else {
    // In normal operation we just look for duplicate procs, note duplicate
    // procs are not a problem when validating against previous schema.
    if (version_annotation->right && !is_ast_dot(version_annotation->right)) {
      EXTRACT_STRING(name, version_annotation->right);
      if (!symtab_add(upgrade_procs, name, ast)) {
        report_error(version_annotation->right, "CQL0027: a procedure can appear in only one annotation", name);
        record_error(ast);
        return false;
      }
    }
  }

  *version = vers;

  return true;
}

// When we find @create, @delete or @recreate we have to record that we found
// such an annotation. Later, if/when we generate schema we will be able to walk
// through these in a suitable sort order and then emit the appropriate
// migrations.
static void record_schema_annotation(
  int32_t vers,
  ast_node *target_ast,
  CSTR target_name,
  uint32_t type,
  ast_node *def,
  ast_node *ast,
  int32_t ordinal)
{
  Contract(target_ast);
  Contract(target_name);
  switch (type) {
    case SCHEMA_ANNOTATION_DELETE_INDEX:
    case SCHEMA_ANNOTATION_DELETE_VIEW:
    case SCHEMA_ANNOTATION_DELETE_TRIGGER:
      // For these items, there is no schema action needed so only record the annotation
      // if there is a migration proc.  Downstream code will Contract on this.
      if (!ast->right) {
        return;
      }
  }

  schema_annotation *note = bytebuf_alloc(schema_annotations, sizeof(*note));

  note->version = vers;
  note->annotation_type = type;
  note->column_ordinal = ordinal;
  note->target_name = target_name;
  note->target_ast = target_ast;
  note->column_ast = def;
  note->annotation_ast = ast;
}

static int32_t recreates;

// Recreate annotations get stored in a different stream, they are processed in
// order as well but they don't merge in with the others.  So we're building up
// two buffers.
static void record_recreate_annotation(
  ast_node *target_ast,
  CSTR target_name,
  CSTR group_name,
  ast_node *annotation)
{
  recreate_annotation *note = bytebuf_alloc(recreate_annotations, sizeof(*note));

  note->target_name = target_name;
  note->target_ast = target_ast;
  note->annotation_ast = annotation;
  note->group_name = group_name;
  note->ordinal = recreates++;
  // We assign group ordinal using topological sort in cg_schema.c
  note->group_ordinal = -1;
}

// This applies the validation for a FK in the context of a column, so that
// single column is the FK to the outside reference.
static void sem_col_attrs_fk(ast_node *fk, ast_node *def, col_def_info *info) {
  Contract(is_ast_col_attrs_fk(fk));
  Contract(is_ast_col_def(def));
  Contract(!current_joinscope);  // I don't belong inside a select(!)

  EXTRACT_NOTNULL(fk_target_options, fk->left);
  EXTRACT_NOTNULL(fk_target, fk_target_options->left);
  EXTRACT_STRING(table_name, fk_target->left);
  EXTRACT_NAMED_NOTNULL(ref_list, name_list, fk_target->right);

  // REFERENCES [table_name] ([ref_list]) options

  // FK's inside of a table declaration (i.e. outside of any proc) are totally
  // ignored in the context of a schema migration script.  This prevents us from
  // getting errors because the latest version of the table refers to tables or
  // columns that are not yet in existence in the version we are migrating. FKs
  // in tables created by your migration script are honored. NOTE: schema
  // migration script here means a migration proc is being defined here. This is
  // not the normal schema upgrader.  But migration procs by definition work on
  // past versions of the schema.  Sometimes the "--rt schema_upgrade" thing is
  // called the schema migration script but this is not that.  This is where
  // @SCHEMA_UPGRADE_VERSION has been specified so that we should pretend to be
  // at an older schema version because we are upgrading that version.
  if (schema_upgrade_version > 0 && !current_proc) {
    record_ok(fk);
    return;
  }

  // If we're doing previous schema validation  we don't have to validate the
  // columns at all. The previous schema may have different regions and/or
  // @recreate groups and this will just lead to spurious errors.  The current
  // schema was already checked for consistency all we have to do is validate
  // that the text of the columns didn't change and that happens later.
  // Visibility of the referenced table in the previous schema is moot.
  if (validating_previous_schema) {
    record_ok(fk);
    return;
  }

  ast_node *ref_table_ast = find_and_validate_referenced_table(
    table_name,
    def,
    info->table_info);
  if (!ref_table_ast) {
    record_error(fk);
    return;
  }

  pending_table_validation pending = {
    .ref_table_ast = ref_table_ast,
    .table_ast = info->table_info->target_ast,
    .def = def,
    .fk = fk
  };

  // If this is an FK from a table to itself then we have to defer this work
  // because the names and types of the columns are not yet computed. For
  // simplicity we just defer the work always.
  enqueue_pending_table_validation(&pending);

  // ok for now
  record_ok(fk);
}

// Now resume validation of the foreign key; Note that we never try to look up
// the name of the referenced table because the referenced table might be the
// same as the table that contains the foreign key, such as:
//
//   * create table T(id primary key, id2 references T(id))
//
// In that case T is not yet in the symbol table, as validation is incomplete.
// That's ok, we know the node for the current table without having to look it
// up. Note: these validations run in the context of the table being validated
// before that table is accepted, not later. We're still "in" the table, if you
// will.
void sem_validate_fk_attr(pending_table_validation *pending) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)

  ast_node *fk = pending->fk;
  ast_node *def = pending->def;
  ast_node *ref_table_ast = pending->ref_table_ast;
  ast_node *src_table_ast = pending->table_ast;

  Contract(is_ast_create_table_stmt(ref_table_ast));
  Contract(is_ast_create_table_stmt(src_table_ast));
  Contract(is_ast_col_attrs_fk(fk));
  Contract(is_ast_col_def(def));

  EXTRACT_NOTNULL(fk_target_options, fk->left);
  EXTRACT_NOTNULL(fk_target, fk_target_options->left);
  EXTRACT_OPTION(flags, fk_target_options->right);
  EXTRACT_NAMED_NOTNULL(ref_list, name_list, fk_target->right);

  if (!sem_validate_name_list(ref_list, ref_table_ast->sem->jptr)) {
    record_error(fk);
    return;
  }

  ast_node *ref = ref_list->left;
  if (ref_list->right || core_type_of(def->sem->sem_type) != core_type_of(ref->sem->sem_type)) {
    report_error(def, "CQL0028: FK reference must be exactly one column with the correct type", def->sem->name);
    record_error(fk);
    return;
  }

  // flags are only checked if we are in the appropriate strict mode
  if (!sem_validate_fk_flags(fk, flags)) {
    return;
  }

  // make sure this is a valid key in the target table, safe to do this now
  // since we are deferred
  if (!sem_validate_referenceable_fk_def(ref_table_ast, ref_list)) {
    record_error(fk);
    return;
  }

  record_table_dependencies(src_table_ast, ref_table_ast);

  record_ok(fk);
}

// Parse out the column information for this column and add the necessary flags
// to the semantic type.  Note that we don't care about all of these flags.
static sem_t sem_col_attrs(ast_node *def, ast_node *head, col_def_info *info) {
  Contract(head);
  Contract(info);

  bool_t adding_current_entity = will_add_current_entity();

  sem_t flags = 0;
  // For semantic analysis we only care about a subset of the attributes
  for (ast_node *ast = head; ast; ast = ast->right) {
    sem_t new_flags = 0;
    if (is_ast_create_attr(ast)) {
      if (!sem_validate_version(SCHEMA_ANNOTATION_CREATE_COLUMN, ast, &info->create_version, &info->create_proc)) {
        record_error(head);
        return false;
      }
      if (adding_current_entity) {
        record_schema_annotation(
          info->create_version,
          info->table_info->target_ast,
          info->table_info->name,
          SCHEMA_ANNOTATION_CREATE_COLUMN,
          def,
          ast->left,
          info->column_ordinal);
      }
    }
    else if (is_ast_delete_attr(ast)) {
      if (!sem_validate_version(
            SCHEMA_ANNOTATION_DELETE_COLUMN,
            ast,
            &info->delete_version,
            &info->delete_proc)) {
        record_error(head);
        return false;
      }

      if (adding_current_entity) {
        record_schema_annotation(
          info->delete_version,
          info->table_info->target_ast,
          info->table_info->name,
          SCHEMA_ANNOTATION_DELETE_COLUMN,
          def,
          ast->left,
          info->column_ordinal);
      }
    }
    else if (is_ast_col_attrs_not_null(ast)) {
      // We need this so that we can avoid generating null checks.
      new_flags = SEM_TYPE_NOTNULL; // prevent two of the same
    }
    else if (is_ast_sensitive_attr(ast)) {
      new_flags = SEM_TYPE_SENSITIVE; // prevent two of the same
    }
    else if (is_ast_col_attrs_default(ast)) {
      // We need this flag so that we can validate INSERT statements with missing columns
      sem_expr(ast->left);
      ast_node *expr = ast->left; // expr might have been rewritten so we fetch it now
      if (is_error(expr)) {
        record_error(head);
        return false;
      }
      info->default_value = expr;

      new_flags = SEM_TYPE_HAS_DEFAULT;  // prevent two of the same
    }
    else if (is_ast_col_attrs_check(ast)) {
      // we can't check the expression until the table is defined and we know all the columns so wait...
      EXTRACT_ANY_NOTNULL(expr, ast->left)
      pending_table_validation pending = {
        .table_ast = info->table_info->target_ast,
        .def = ast,
        .check = expr,
      };

      enqueue_pending_table_validation(&pending);
      new_flags = SEM_TYPE_HAS_CHECK;   // prevent two of the same
    }
    else if (is_ast_col_attrs_collate(ast)) {
      // Nothing much can go wrong here, the grammar only allows an id and it
      // can be any id In principle only some ids are valid but we have no way
      // of knowing which at compile time. We could make you declare them all
      // but that's for another time, if ever. All we're left with is make sure
      // the column is text.  You could try to collate blobs but that seems like
      // a really bad idea so we're taking a stand on that.  This could be
      // relaxed later if it proves to be a mistake.

      sem_t core_type = core_type_of(info->col_sem_type);
      if (core_type != SEM_TYPE_TEXT) {
        report_error(ast->left, "CQL0348: collate applied to a non-text column", info->col_name);
        record_error(head);
        return false;
      }

      new_flags = SEM_TYPE_HAS_COLLATE;   // prevent two of the same
    }
    else if (is_ast_col_attrs_pk(ast)) {
      // Sqilte defines all pk columns to be not null
      new_flags = SEM_TYPE_PK;
      info->primary_keys++;
      EXTRACT_NOTNULL(autoinc_and_conflict_clause, ast->left);
      EXTRACT(col_attrs_autoinc, autoinc_and_conflict_clause->left);
      if (col_attrs_autoinc) {
        // We need this so that we can validate INSERT statements
        // this column must be absent in an INSERT.
        new_flags |= SEM_TYPE_AUTOINCREMENT;
        info->autoinc_columns++;

        sem_t core_type = core_type_of(info->col_sem_type);

        if (core_type != SEM_TYPE_INTEGER && core_type != SEM_TYPE_LONG_INTEGER) {
          report_error(ast->left, "CQL0029: autoincrement column must be [LONG|INT] PRIMARY KEY", info->col_name);
          record_error(head);
          return false;
        }
      }
    }
    else if (is_ast_col_attrs_fk(ast)) {
      sem_col_attrs_fk(ast, def, info);
      if (is_error(ast)) {
        record_error(head);
        return false;
      }
      new_flags = SEM_TYPE_FK; // prevent two of the same
    }
    else if (is_ast_col_attrs_hidden(ast)) {
      // NOTE: SEM_TYPE_VIRTUAL is not yet computed so we can't use that here, later this is easier

      ast_node *table_ast = info->table_info->target_ast;
      bool_t is_virtual_table = table_ast->parent && is_ast_create_virtual_table_stmt(table_ast->parent);

      // ignored for non-virtual tables SQLite does the same e.g:
      //  * create table foo(x integer hidden, y integer);
      //  * insert into foo(x,y) values(1,2);
      //  * select * from foo;
      // 1|2

      if (flags) {
        report_error(ast, "CQL0362: HIDDEN column attribute must be the first attribute if present", NULL);
        record_error(head);
        return false;
      }

      if (is_virtual_table) {
        new_flags = SEM_TYPE_HIDDEN_COL;
      }
    }
    else {
      // this is all that's left
      Contract(is_ast_col_attrs_unique(ast));
      // while it's not normal, it is possible for exactly one row to be NULL so
      // this attribute doesn't affect nullability
      new_flags = SEM_TYPE_UK; // prevent two of the same
    }

    if (flags & new_flags) {
      report_error(ast, "CQL0030: a column attribute was specified twice on the same column", info->col_name);
      record_error(head);
      return false;
    }

    flags |= new_flags;
  }

  // these flags imply not null, add that after duplicate checking is done
  if (flags & (SEM_TYPE_PK | SEM_TYPE_AUTOINCREMENT)) {
    flags |= SEM_TYPE_NOTNULL;
  }

  Invariant(schema_upgrade_version != 0);  // -1 or positive

  if (schema_upgrade_script) {
    // no deleted columns processing, keep it all..
  }
  else if (schema_upgrade_version < 0) {
    if (info->delete_version > 0) {
      flags |= SEM_TYPE_DELETED;
    }
  }
  else {
    // The delete version is the version that the column was deleted in. If we
    // are migrating beyond that, the column is already deleted. if were on that
    // version (in a migration context) then you're allowed to look at that
    // column so that you can zero it or some such.
    if (info->delete_version > 0 && schema_upgrade_version > info->delete_version) {
      flags |= SEM_TYPE_DELETED;
    }

    // The create version ist he version that the column was created in. If we
    // are migrating to a schema before the column was created then we cannot
    // see it yet.
    if (info->create_version > 0 && schema_upgrade_version < info->create_version) {
      flags |= SEM_TYPE_DELETED;
    }
  }

  record_ok(head);
  return flags;
}

// Parse out a column definition, creating the necessary semantic type note that
// we need to carry some state here to do the validation.  We track the number
// of auto-increment columns we've seen so far and complain if we see more than
// one.
static void sem_col_def(ast_node *def, col_def_info *info) {
  Contract(is_ast_col_def(def));
  EXTRACT_NOTNULL(col_def_type_attrs, def->left);

  // We rewrite col_def_type_attrs node before reading the subtree to make sure
  // we read a rewrite subtree.
  rewrite_right_col_def_type_attrs_if_needed(col_def_type_attrs);
  if (is_error(col_def_type_attrs)) {
    record_error(def);
    return;
  }

  EXTRACT_ANY(attrs, col_def_type_attrs->right);
  EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
  EXTRACT_NAME_AST(name_ast, col_def_name_type->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY_NOTNULL(data_type, col_def_name_type->right);

  info->default_value = NULL;
  info->create_version = -1;
  info->delete_version = -1;
  info->column_ordinal++;

  // column name:  [name]
  sem_data_type_column(data_type);

  def->sem = new_sem(data_type->sem->sem_type);
  def->sem->name = name;
  def->sem->kind = data_type->sem->kind;


  info->col_sem_type = def->sem->sem_type;
  info->col_name = name;

  if (is_qid(name_ast)) {
    sem_add_flags(def, SEM_TYPE_QID);
  }

  if (attrs) {
    sem_add_flags(def, sem_col_attrs(def, attrs, info));
    if (is_error(attrs)) {
      record_error(def);
      return;
    }

    // check type compat of the default value if there is one now that flags are
    // all processed

    ast_node *expr = info->default_value;
    if (expr) {
      sem_root_expr(expr, SEM_EXPR_CONTEXT_NONE);

     // there is a common pattern TEXT DEFAULT 0 which is ok because the 0
     // converts to text so we'll allow any literal to be used for text
     if (!is_text(def->sem->sem_type)) {
       // otherwise normal assignment rules
       if (!sem_verify_assignment(expr, def->sem->sem_type, expr->sem->sem_type, "default value")) {
         record_error(def);
         return;
       }
     }
    }
  }

  if (is_primary_key(def->sem->sem_type) && is_unique_key(def->sem->sem_type)) {
    report_error(def, "CQL0031: column can't be primary key and also unique key", name);
    record_error(def);
    return;
  }

  // all the columns with a create annotation have to be at the end and in order
  if (info->create_version < info->previous_create_version) {
    report_error(def, "CQL0032: created columns must be at the end and must be in version order", name);
    record_error(def);
    return;
  }

  info->previous_create_version = info->create_version;

  if (info->delete_version > 0 || info->create_version > 0) {
    if (info->table_info->recreate) {
      report_error(def, "CQL0033: columns in a table marked @recreate cannot have @create or @delete", name);
      record_error(def);
      return;
    }

    if (!is_nullable(def->sem->sem_type) && !has_default((def->sem->sem_type))) {
      report_error(def,
        "CQL0034: create/delete version numbers can only be applied to "
        "columns that are nullable or have a default value", name);
      record_error(def);
      return;
    }
  }

  // you can't delete a column before it's been created
  if (info->delete_version > 0 && info->delete_version <= info->create_version) {
    report_error(def, "CQL0035: column delete version can't be <= column create version", name);
    record_error(def);
    return;
  }

  // sanity check the column delete version against the table versions if they
  // are present note version -1 indicates version annotation not present.

  if (info->delete_version > 0) {
    if (info->table_info->create_version > 0 && info->delete_version <= info->table_info->create_version) {
      report_error(def, "CQL0036: column delete version can't be <= the table create version", name);
      record_error(def);
      return;
    }

    if (info->table_info->delete_version > 0 && info->delete_version >= info->table_info->delete_version) {
      report_error(def, "CQL0037: column delete version can't be >= the table delete version", name);
      record_error(def);
    }
  }

  // sanity check the column create version against the table versions if they
  // are present note version -1 indicates version annotation not present.

  if (info->create_version > 0) {
    if (info->table_info->create_version > 0 && info->create_version <= info->table_info->create_version) {
      report_error(def, "CQL0038: column create version can't be <= the table create version", name);
      record_error(def);
      return;
    }

    if (info->table_info->delete_version > 0 && info->create_version >= info->table_info->delete_version) {
      report_error(def, "CQL0039: column create version can't be >= the table delete version", name);
      record_error(def);
      return;
    }
  }

  if (info->autoinc_columns > 1) {
    report_error(name_ast, "CQL0040: table can only have one autoinc column", name);
    record_error(def);
    return;
  }

  if (is_object(def->sem->sem_type)) {
    report_error(name_ast, "CQL0041: tables cannot have object columns", name);
    record_error(def);
    return;
  }

  // record the version info in the semantic type
  def->sem->create_version = info->create_version;
  def->sem->delete_version = info->delete_version;
}

// Queue a pending check validation, this is just like the columns case we could
// do this right away because constraints come after columns but we may as well
// just do the checks all the same.
static void sem_check_def(ast_node *table_ast, ast_node *def) {
  EXTRACT_ANY_NOTNULL(expr, def->right)
  pending_table_validation pending = {
      .table_ast = table_ast,
      .def = def,
      .check = expr,
   };

  enqueue_pending_table_validation(&pending);
  record_ok(def);
}

// Dispatch the correct constraint type.  Release the saved table items (used to
// find duplicates) when done.  This is always clean on entry because this can't
// nest.
static void sem_constraints(ast_node *table_ast, ast_node *col_key_list, col_def_info *info) {
  Contract(is_ast_col_key_list(col_key_list));
  Invariant(!current_joinscope && !table_items);
  table_items = symtab_new();

  for (ast_node *item = col_key_list; item; item = item->right) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(def, item->left);

    // stop if we have already found an error, the semantic info will be
    // clobbered by the error node so it's not safe to proceed
    if (is_error(table_ast)) {
      break;
    }

    if (is_ast_col_def(def)) {
      // column defs already processed
    }
    else if (is_ast_pk_def(def)) {
      sem_pk_def(table_ast, def);
      info->primary_keys++;
    }
    else if (is_ast_fk_def(def)) {
      sem_fk_def(table_ast, def, info->table_info);
    }
    else if (is_ast_check_def(def)) {
      sem_check_def(table_ast, def);
    }
    else {
      Contract(is_ast_unq_def(def));
      sem_unq_def(table_ast, def);
    }
  }

  symtab_delete(table_items);
  table_items = NULL;
}

// All the binary ops do the same preparation, they evaluate the left and the
// right expression, then they check those for errors.  Then they need the types
// of those expressions and the combined_flags of the result.  This does exactly
// that for its various callers.  Returns true if all is well.
static bool_t sem_binary_prep(
  ast_node *ast,
  sem_t *core_type_left,
  sem_t *core_type_right,
  sem_t *combined_flags)
{
  EXTRACT_ANY_NOTNULL(left, ast->left);
  EXTRACT_ANY_NOTNULL(right, ast->right);

  // left op right
  sem_expr(left);
  sem_expr(right);

  return sem_binary_prep_helper(ast, left, right, core_type_left, core_type_right, combined_flags);
}

// Same as sem_binary_prep, but with flow analysis for AND/OR logical operators.
static bool_t sem_binary_prep_with_flow_analysis(
  ast_node *ast,
  sem_t *core_type_left,
  sem_t *core_type_right,
  sem_t *combined_flags,
  CSTR op)
{
  Contract(!strcmp(op, "OR") || !strcmp(op, "AND"));

  EXTRACT_ANY_NOTNULL(left, ast->left);
  EXTRACT_ANY_NOTNULL(right, ast->right);

  FLOW_PUSH_CONTEXT_BRANCH();
  sem_expr(left);
  if (!strcmp(op, "AND")) {
    sem_set_improvements_for_true_condition(left);
  }
  else if (!strcmp(op, "OR")) {
    sem_set_improvements_for_false_condition(left);
  }
  sem_expr(right);
  FLOW_POP_CONTEXT_BRANCH();

  return sem_binary_prep_helper(ast, left, right, core_type_left, core_type_right, combined_flags);
}

static bool_t sem_binary_prep_helper(
  ast_node *ast,
  ast_node *left,
  ast_node *right,
  sem_t *core_type_left,
  sem_t *core_type_right,
  sem_t *combined_flags)
{
  if (is_error(left) || is_error(right)) {
    record_error(ast);
    *core_type_left = SEM_TYPE_ERROR;
    *core_type_right = SEM_TYPE_ERROR;
    *combined_flags = 0;
    return false;
  }

  *core_type_left = core_type_of(left->sem->sem_type);
  *core_type_right = core_type_of(right->sem->sem_type);
  *combined_flags = combine_flags(left->sem->sem_type, right->sem->sem_type);

  Invariant(is_unitary(*core_type_left));
  Invariant(is_unitary(*core_type_right));

  return true;
}

// Validates string compatible left and right and computes the result type.
// Works for like and not like, and helper for match, glob, and regexp.
static void sem_binary_like(ast_node *ast, CSTR op) {
  sem_t core_type_left, core_type_right, combined_flags;
  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {
    return;
  }

  if (!is_string_compat(core_type_left)) {
    report_error(ast->left, "CQL0042: left operand must be a string in", op);
    record_error(ast);
    return;
  }

  if (!is_string_compat(core_type_right)) {
    report_error(ast->right, "CQL0043: right operand must be a string in", op);
    record_error(ast);
    return;
  }

  ast->sem = new_sem(SEM_TYPE_BOOL | combined_flags);
}

// validates the left arg of collate, the right arg can be any id
static void sem_collate(ast_node *ast, CSTR op) {
  Contract(is_ast_collate(ast));
  Contract(is_ast_str(ast->right));
  EXTRACT_ANY_NOTNULL(left, ast->left);

  // [left] COLLATE name
  sem_expr(left);

  if (is_error(left)) {
    record_error(ast);
    return;
  }

  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {
    report_error(ast, "CQL0241: COLLATE may only appear in the context of a SQL statement", NULL);
    record_error(ast);
    return;
  }

  ast->sem =left->sem;
}

// Validates string/number compatible left and right and the result type should always be string
static void sem_jex1(ast_node *ast, CSTR op) {
  Contract(is_ast_jex1(ast));
  EXTRACT_ANY_NOTNULL(left, ast->left);
  EXTRACT_ANY_NOTNULL(right, ast->right);

  // [ast->left] -> [ast->right];
  sem_expr(left);
  sem_expr(right);

  if (is_error(left) || is_error(right)) {
    record_error(ast);
    return;
  }

  if (try_rewrite_op_as_call(ast, "arrow")) {
    sem_expr(ast);
    return;
  }

  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {
    report_error(ast, "CQL0044: operator may only appear in the context of a SQL statement", op);
    record_error(ast);
    return;
  }

  sem_t sem_type_left = left->sem->sem_type;
  sem_t sem_type_right = right->sem->sem_type;

  if (!is_text(sem_type_right) && !is_any_int(sem_type_right)) {
    report_error(right, "CQL0504: right operand must be json text path or integer", op);
    record_error(ast);
    return;
  }

  if (!is_blob(sem_type_left) && !is_text(sem_type_left)) {
    report_error(left, "CQL0503: left operand must be json text or json blob", op);
    record_error(ast);
    return;
  }

  // the result is always nullable and may be sensitive
  // -> always returns TEXT per the spec See https://sqlite.org/json1.html $4.9
  ast->sem = new_sem(SEM_TYPE_TEXT | sensitive_flag(sem_type_left));
}

// Validates string/number compatible left and right and the result type should
// always be string
static void sem_jex2(ast_node *ast, CSTR op) {
  Contract(is_ast_jex2(ast));
  EXTRACT_ANY_NOTNULL(left, ast->left);
  EXTRACT_ANY_NOTNULL(data_type, ast->right->left);
  EXTRACT_ANY_NOTNULL(right, ast->right->right);

  // [ast->left] -> [ast->right];
  sem_expr(left);
  sem_expr(right);

  if (is_error(left) || is_error(right)) {
    record_error(ast);
    return;
  }

  sem_data_type_column(data_type);
  if (is_error(data_type)) {
    record_error(ast);
    return;
  }


  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {
    report_error(ast, "CQL0044: operator may only appear in the context of a SQL statement", op);
    record_error(ast);
    return;
  }

  sem_t sem_type_left = left->sem->sem_type;
  sem_t sem_type_right = right->sem->sem_type;

  if (!is_text(sem_type_right) && !is_any_int(sem_type_right)) {
    report_error(right, "CQL0504: right operand must be json text path or integer", op);
    record_error(ast);
    return;
  }

  if (!is_blob(sem_type_left) && !is_text(sem_type_left)) {
    report_error(left, "CQL0503: left operand must be json text or json blob", op);
    record_error(ast);
    return;
  }

  // The result is always nullable and may be sensitive. The core type must be
  // provided.
  ast->sem = new_sem( core_type_of(data_type->sem->sem_type) | sensitive_flag(sem_type_left));
}

// Validates string/number compatible left and right and the result type should
// always be string
static void sem_concat(ast_node *ast, CSTR op) {
  Contract(is_ast_concat(ast));
  EXTRACT_ANY_NOTNULL(left, ast->left);
  EXTRACT_ANY_NOTNULL(right, ast->right);

  // [ast->left] || [ast->right];
  sem_expr(left);
  sem_expr(right);

  if (is_error(left) || is_error(right)) {
    record_error(ast);
    return;
  }

  if (try_rewrite_op_as_call(ast, "concat")) {
    sem_expr(ast);
    return;
  }

  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {
    report_error(ast, "CQL0241: CONCAT may only appear in the context of a SQL statement", NULL);
    record_error(ast);
    return;
  }

  sem_t sem_type_left = left->sem->sem_type;
  sem_t sem_type_right = right->sem->sem_type;
  sem_t combined_flags = combine_flags(left->sem->sem_type, right->sem->sem_type);

  if (is_blob(sem_type_left) || is_blob(sem_type_right)) {
    ast_node *operand = is_blob(sem_type_left) ? left : right;
    report_error(operand, "CQL0243: blob operand must be converted to string first in", op);
    record_error(ast);
    return;
  }

  // There's nothing left but these types, all else is excluded because of SQL
  // expression context and explicit blob reject.
  Invariant(is_string_compat(sem_type_left) || is_numeric_compat(sem_type_left));
  Invariant(is_string_compat(sem_type_right) || is_numeric_compat(sem_type_right));

  ast->sem = new_sem(SEM_TYPE_TEXT | combined_flags);
}

// match/glob/regexp are just like 'like' but it can only appear inside of SQL
static void sem_binary_match(ast_node *ast, CSTR op) {
  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {
    report_error(ast, "CQL0044: operator may only appear in the context of a SQL statement", op);
    record_error(ast);
    return;
  }
  sem_binary_like(ast, op);
}

// For all math operations, we combine the types and yield the type that holds
// both using the helper.  If any text, that's an error.
static void sem_binary_math(ast_node *ast, CSTR op) {
  sem_t core_type_left, core_type_right, combined_flags;
  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {
    return;
  }

  if (error_any_object(ast, core_type_left, core_type_right, op)) {
    return;
  }

  if (error_any_blob_types(ast, core_type_left, core_type_right, op)) {
    return;
  }

  if (error_any_text_types(ast, core_type_left, core_type_right, op)) {
    return;
  }

  sem_t core_type = sem_combine_types(core_type_left, core_type_right);

  // all math operations combine to at least integers (e.g. bool + bool = integer)
  if (core_type == SEM_TYPE_BOOL) {
    core_type = SEM_TYPE_INTEGER;
  }

  CSTR kind = sem_combine_kinds(ast->right, ast->left->sem->kind);
  if (is_error(ast->right)) {
    record_error(ast);
    return;
  }

  ast->sem = new_sem(core_type | combined_flags);
  ast->sem->kind = kind;
}

// For all math operations, we combine the types and yield the type that holds
// both using the helper.  If any text, that's an error.
static void sem_binary_integer_math(ast_node *ast, CSTR op) {
  sem_t core_type_left, core_type_right, combined_flags;
  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {
    return;
  }

  CSTR remap = NULL;
  if (!strcmp(op, ">>")) remap = "rshift";
  if (!strcmp(op, "<<")) remap = "lshift";
  if (remap && try_rewrite_op_as_call(ast, remap)) {
    sem_expr(ast);
    return;
  }

  sem_binary_math(ast, op);
  sem_reject_real(ast, op);
}

// For all the logical operands, the result is always a boolean.  Again
// text type inputs result in an error.
static void sem_binary_logical(ast_node *ast, CSTR op) {
  sem_t core_type_left, core_type_right, combined_flags;

  bool_t has_error;
  if (enforcement.strict_and_or_not_null_check) {
    FLOW_PUSH_CONTEXT_BRANCH_GROUP();
    has_error = !sem_binary_prep_with_flow_analysis(ast, &core_type_left, &core_type_right, &combined_flags, op);
    FLOW_POP_CONTEXT_BRANCH_GROUP();
  }
  else {
    has_error = !sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags);
  }
  if (has_error) {
    return;
  }

  if (error_any_text_types(ast, core_type_left, core_type_right, op)) {
    return;
  }

  ast->sem = new_sem(SEM_TYPE_BOOL | combined_flags);
}

static void sem_binary_eq_or_ne(ast_node *ast, CSTR op) {
  sem_t core_type_left, core_type_right, combined_flags;

  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {
    return;
  }

  if (is_ast_null(ast->left) || is_ast_null(ast->right)) {
    report_error(ast, "CQL0373: comparing against NULL always yields NULL; use IS and IS NOT instead", NULL);
    record_error(ast);
    return;
  }

  if (!sem_verify_compat(ast, core_type_left, core_type_right, op)) {
    return;
  }

  sem_combine_kinds(ast->right, ast->left->sem->kind);
  if (is_error(ast->right)) {
    record_error(ast);
    return;
  }

  ast->sem = new_sem(SEM_TYPE_BOOL | combined_flags);
  // the result is a normal bool, not a bool of any particular kind
}

// The comparison types always return a boolean and can accept anything
// that is compatible on the left or the right.
static void sem_binary_compare(ast_node *ast, CSTR op) {
  sem_t core_type_left, core_type_right, combined_flags;
  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {
    return;
  }

  if (error_any_object(ast, core_type_left, core_type_right, op)) {
    return;
  }

  if (error_any_blob_types(ast, core_type_left, core_type_right, op)) {
    return;
  }

  if (!sem_verify_compat(ast, core_type_left, core_type_right, op)) {
    return;
  }

  sem_combine_kinds(ast->right, ast->left->sem->kind);
  if (is_error(ast->right)) {
    record_error(ast);
    return;
  }

  ast->sem = new_sem(SEM_TYPE_BOOL | combined_flags);
  // the result is a normal bool, not a bool of any particular kind
}

// Any const node is evaluated at compile time.  The kinds of sub-expressions
// that are allowed are limited.  See the "eval" function for more on this.
static void sem_expr_const(ast_node *ast, CSTR op) {
  Contract(is_ast_const(ast));

  sem_root_expr(ast->left, SEM_EXPR_CONTEXT_NONE);
  if (is_error(ast->left)) {
    record_error(ast);
    return;
  }

  eval_node result = EVAL_NIL;
  eval(ast->left, &result);

  if (result.sem_type == SEM_TYPE_ERROR) {
    report_error(ast, "CQL0353: evaluation of constant failed", NULL);
    record_error(ast);
    return;
  }

  ast_node *ast_new = eval_set(ast, &result);
  sem_root_expr(ast_new, SEM_EXPR_CONTEXT_NONE);
  ast->sem = ast_new->sem;
}

// The unary operators all have a similar prep to the binary.  We need to visit
// the left side (it's always the left node even if the operator goes on the
// right) if that's ok then we need the combined_flags and core type.  There is
// only the one.  Returns true if everything is ok.
static bool_t sem_unary_prep(ast_node *ast, sem_t *core_type, sem_t *combined_flags) {
  // op left | left op
  sem_expr(ast->left);

  if (is_error(ast->left)) {
    *core_type = SEM_TYPE_ERROR;
    *combined_flags = 0;
    record_error(ast);
    return false;
  }

  sem_node *sem = ast->left->sem;
  sem_t sem_type = sem->sem_type;

  *core_type = core_type_of(sem_type);
  *combined_flags = not_nullable_flag(sem_type) | sensitive_flag(sem_type);

  Invariant(is_unitary(*core_type));
  return true;
}

static bool_t sem_validate_numeric(ast_node *ast, sem_t core_type, CSTR op) {
  if (is_blob(core_type)) {
    report_error(ast->left, "CQL0045: blob operand not allowed in", op);
    record_error(ast);
    return false;
  }

  if (is_object(core_type)) {
    report_error(ast->left, "CQL0046: object operand not allowed in", op);
    record_error(ast);
    return false;
  }

  if (is_text(core_type)) {
    report_error(ast->left, "CQL0047: string operand not allowed in", op);
    record_error(ast);
    return false;
  }

  return true;
}

// The only unary math operators are '-' and '~'. Reference types are not allowed.
static void sem_unary_math(ast_node *ast, CSTR op) {
  sem_t core_type, combined_flags;
  if (!sem_unary_prep(ast, &core_type, &combined_flags)) {
    return;
  }

  if (!sem_validate_numeric(ast, core_type, op)) {
    return;
  }

  // The result of unary math promotes to integer.  Basically this converts bool
  // to integer.  Long integer and Real stay as they are.  Text is already ruled
  // out.
  sem_t sem_type_result = sem_combine_types(
      (SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL),
      (core_type | combined_flags));

  ast->sem = new_sem(sem_type_result);
  ast->sem->kind = ast->left->sem->kind;

  // note ast->sem->name is NOT propagated because SQLite doesn't let you refer
  // to the column 'x' in 'select -x' -- the column name is actually '-x' which
  // is useless so we have no name once you apply unary math (unless you use
  // 'as') hence ast->sem->name = ast->left->sem->name is WRONG here and it is
  // not missing on accident
}

static void sem_unary_integer_math(ast_node *ast, CSTR op) {
  sem_unary_math(ast, op);
  sem_reject_real(ast, op);
}

// The only logical unary operator is 'NOT' but there might be others some day.
// Text is not allowed.
static void sem_unary_logical(ast_node *ast, CSTR op) {
  sem_t core_type, combined_flags;
  if (!sem_unary_prep(ast, &core_type, &combined_flags)) {
    return;
  }

  if (!sem_validate_numeric(ast, core_type, op)) {
    return;
  }

  // For logical always returns a bool or null
  // the canonical example is NOT.
  ast->sem = new_sem(SEM_TYPE_BOOL | combined_flags);
}

// This is used for IS TRUE and IS FALSE
static void sem_unary_is_true_or_false(ast_node *ast, CSTR op) {
  if (enforcement.strict_is_true) {
    report_error(ast, "CQL0403: operator may not be used because it is not supported on old versions of SQLite", op);
    record_error(ast);
    return;
  }

  sem_t core_type, combined_flags;
  if (!sem_unary_prep(ast, &core_type, &combined_flags)) {
    return;
  }

  if (!sem_validate_numeric(ast, core_type, op)) {
    return;
  }

  // IS forms always return BOOL NOT NULL
  ast->sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL | combined_flags);
}

// IS and IS NOT are special in that they return a not null boolean.
static void sem_binary_is_or_is_not(ast_node *ast, CSTR op) {
  sem_t core_type_left, core_type_right, combined_flags;

  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {
    return;
  }

  if (!sem_verify_compat(ast, core_type_left, core_type_right, op)) {
    return;
  }

  if (is_ast_null(ast->right) && is_not_nullable(ast->left->sem->sem_type)) {
    report_error(
      ast,
      "CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type",
      expr_as_text(ast->left));
    record_error(ast);
    return;
  }

  // the result of is or is not is always a bool and never null
  ast->sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL | sensitive_flag(combined_flags));
}

// Do analysis on an argument, notably * can only appear in count(*) so this is
// where that validation happens.  Otherwise recurse.
static void sem_arg_expr(ast_node *ast, bool_t is_count) {
  if (is_ast_star(ast)) {
    if (is_count) {
      ast->sem = new_sem(SEM_TYPE_INTEGER);
    }
    else {
      report_error(ast, "CQL0051: argument can only be used in count(*)", "*");
      record_error(ast);
    }
  }
  else {
    sem_expr(ast);
  }
}

// Walk an entire argument list and do the type inference on each argument. Not
// that this happens in the context of a function call and depending on what the
// function is, there may be rules for compatibility of the arguments with the
// function and each other.  That doesn't happen here. This just gets the type
// of each arg and makes sure independently they are not bogus.
static void sem_arg_list(ast_node *head, bool_t is_count) {
  Contract(!head || is_ast_arg_list(head));

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_ANY_NOTNULL(arg, ast->left)
    sem_arg_expr(arg, is_count);
    if (is_error(arg)) {
      record_error(head);
      return;
    }
  }

  if (head) {
    record_ok(head);
  }
}

// Helper to get the first arg out of an arg list because we do that a lot.
cql_noexport ast_node *first_arg(ast_node *arg_list) {
  Contract(is_ast_arg_list(arg_list));
  EXTRACT_ANY_NOTNULL(arg, arg_list->left);

  return arg;
}

// Helper to get the second arg out of an arg list
cql_noexport ast_node *second_arg(ast_node *arg_list) {
  Contract(is_ast_arg_list(arg_list));
  EXTRACT_ANY_NOTNULL(arg, arg_list->right->left);

  return arg;
}

// Helper to get the third arg out of an arg list
cql_noexport ast_node *third_arg(ast_node *arg_list) {
  Contract(is_ast_arg_list(arg_list));
  EXTRACT_ANY_NOTNULL(arg, arg_list->right->right->left);

  return arg;
}

// This verifies all the columns have a name.
// This check is important for a variety of cases, but the main ones are:
//  - select * or select T.*  -> we can't expand the start if there aren't names
//  - select results -> we can't make the getters if the columns don't have names
static void sem_verify_no_anon_columns(ast_node *ast) {
   // Sanity check our arguments, it is for sure a struct type.
  Invariant(is_struct(ast->sem->sem_type));
  sem_struct *sptr = ast->sem->sptr;
  uint32_t count = ast->sem->sptr->count;

  for (uint32_t i = 0; i < count; i++) {
    const char *col = sptr->names[i];
    if (!strcmp(col, "_anon")) {
      report_error(ast, "CQL0055: all columns in the select must have a name", NULL);
      record_error(ast);
      return;
    }
  }
}

// ensure none of the columns have null type
static void sem_verify_no_null_columns(ast_node *ast) {
   // Sanity check our arguments, it is for sure a struct type.
  Invariant(is_struct(ast->sem->sem_type));
  sem_struct *sptr = ast->sem->sptr;
  uint32_t count = ast->sem->sptr->count;

  for (uint32_t i = 0; i < count; i++) {
    if (is_null_type(sptr->semtypes[i])) {
      report_error(ast, "CQL0056: NULL expression has no type to imply the type of the select result", sptr->names[i]);
      record_error(ast);
    }
  }
}

// In various contexts we have to verify that the result of a select statement
// is well formed for re-use.  That means every column must have a name and a
// type This is so that we know, for instance, the name and type of every column
// in a result set from the select statement.
cql_noexport void sem_verify_no_anon_no_null_columns(ast_node *ast) {
  sem_verify_no_anon_columns(ast);
  if (!is_error(ast)) {
    sem_verify_no_null_columns(ast);
  }
  // if there is an error it will be on the ast on exit as is normal
}

static void sem_emit_one_sptr_type(charbuf *output, sem_struct *sptr, uint32_t i) {
  bprintf(output, "%s ", sptr->names[i]);
  sem_t sem_type = sptr->semtypes[i];
  get_sem_core(sem_type, output);

  // the bits that matter
  sem_type &= SEM_TYPE_NOTNULL;
  get_sem_flags(sem_type, output);
}

// given that we found sptr differences in one of the places that the types must
// match we use this helper to tell the user what's different in detail
static void sem_emit_column_diff_diagnostics(ast_node *left, ast_node *right) {
  sem_struct *sptr_left = left->sem->sptr;
  Contract(sptr_left);
  sem_struct *sptr_right = right->sem->sptr;
  Contract(sptr_right);

  CHARBUF_OPEN(report);
  CHARBUF_OPEN(tmp);

  bprintf(&report, "additional difference diagnostic info:\n\n");
  bprintf(&report, "%s:%d:1: error: likely end location of the 1st item\n", left->filename, left->lineno);
  bprintf(&report, "  this item has %d columns\n", sptr_left->count);
  bprintf(&report, "%s:%d:1: error: likely end location of the 2nd item\n", right->filename, right->lineno);
  bprintf(&report, "  this item has %d columns\n", sptr_right->count);
  bprintf(&report, "\n");

  symtab *left_symbols = symtab_new();
  symtab *right_symbols = symtab_new();

  uint32_t i;
  for (i = 0; i < sptr_left->count; i++) {
    bclear(&tmp);
    sem_emit_one_sptr_type(&tmp, sptr_left, i);
    if (!symtab_add(left_symbols, Strdup(tmp.ptr), NULL)) {
      bprintf(&report, "duplicate column in 1st: %s\n", tmp.ptr);
    }
  }

  for (i = 0; i < sptr_right->count; i++) {
    bclear(&tmp);
    sem_emit_one_sptr_type(&tmp, sptr_right, i);
    if (!symtab_add(right_symbols, Strdup(tmp.ptr), NULL)) {
      bprintf(&report, "duplicate column in 2nd: %s\n", tmp.ptr);
    }
  }

  for (i = 0; i < sptr_left->count; i++) {
    bclear(&tmp);
    sem_emit_one_sptr_type(&tmp, sptr_left, i);
    if (!symtab_find(right_symbols, tmp.ptr)) {
      bprintf(&report, "only in 1st: %s\n", tmp.ptr);
    }
  }

  for (i = 0; i < sptr_right->count; i++) {
    bclear(&tmp);
    sem_emit_one_sptr_type(&tmp, sptr_right, i);
    if (!symtab_find(left_symbols, tmp.ptr)) {
      bprintf(&report, "only in 2nd: %s\n", tmp.ptr);
    }
  }

  symtab_delete(left_symbols);
  symtab_delete(right_symbols);
  report_error(left, report.ptr, NULL);
  CHARBUF_CLOSE(tmp);
  CHARBUF_CLOSE(report);
}

static sem_struct *sem_unify_compatible_columns(ast_node *left, ast_node *right) {
  Invariant(is_struct(left->sem->sem_type));
  sem_struct *sptr_left = left->sem->sptr;
  Invariant(is_struct(right->sem->sem_type));
  sem_struct *sptr_right = right->sem->sptr;

  // Count, and names of columns must be an *exact* match.

  if (sptr_left->count != sptr_right->count) {
    report_error(left, "CQL0057: if multiple selects, all must have the same column count", NULL);
    sem_emit_column_diff_diagnostics(left, right);
    record_error(left);
    record_error(right);
    return NULL;
  }

  for (uint32_t i = 0; i < sptr_left->count; i++) {
    const char *col1 = sptr_left->names[i];
    const char *col2 = sptr_right->names[i];

    Invariant(col1 && col2);
    if (strcmp(col1, col2)) {
      CSTR err_msg = dup_printf(
           "CQL0058: if multiple selects,"
           " all column names must be identical so they have unambiguous names; error"
           " in column %d: '%s' vs. '%s'", i+1, col1, col2);
      report_error(left, err_msg, NULL);
      sem_emit_column_diff_diagnostics(left, right);
      record_error(left);
      record_error(right);
      return NULL;
    }
  }

  // Column types must be compatible
  sem_struct *sptr = new_sem_struct("union", sptr_left->count);

  for (uint32_t i = 0; i < sptr_left->count; i++) {
    sem_t sem_type_1 = sptr_left->semtypes[i];
    sem_t sem_type_2 = sptr_right->semtypes[i];
    const char *col = sptr_left->names[i];

    if (!sem_verify_compat(left, sem_type_1, sem_type_2, col)) {
      record_error(left);
      record_error(right);
      return NULL;
    }

    CSTR kind_1 = sptr_left->kinds[i];
    CSTR kind_2 = sptr_right->kinds[i];

    CSTR kind = sem_combine_kinds_general(left, kind_1, kind_2);
    if (is_error(left)) {
      record_error(left);
      record_error(right);
      return NULL;
    }

    sptr->semtypes[i] = sem_combine_types(sem_type_1, sem_type_2);
    sptr->names[i] = sptr_left->names[i];
    sptr->kinds[i] = kind;
  }

  return sptr;
}

cql_noexport void sem_verify_identical_columns(
  ast_node *expected,
  ast_node *actual,
  CSTR target)
{
  Contract(actual);
  Contract(expected);
  sem_struct *sptr_expected = expected->sem->sptr;
  sem_struct *sptr_actual = actual->sem->sptr;
  Contract(sptr_expected);
  Contract(sptr_actual);

  // Count, type, and names of columns must be an *exact* match.

  if (sptr_expected->count != sptr_actual->count) {
    CSTR errmsg = dup_printf("CQL0057: %s, all must have the same column count", target);
    report_error(actual, errmsg, NULL);
    sem_emit_column_diff_diagnostics(expected, actual);
    record_error(actual);
    return;
  }

  for (uint32_t i = 0; i < sptr_expected->count; i++) {
    sem_t sem_type_1 = sptr_expected->semtypes[i];
    sem_t sem_type_2 = sptr_actual->semtypes[i];
    const char *col1 = sptr_expected->names[i];
    const char *col2 = sptr_actual->names[i];

    if (strcmp(col1, col2)) {
      CSTR errmsg = dup_printf(
        "CQL0058: %s,"
        " all column names must be identical so they have unambiguous names; error"
        " in column %d: '%s' vs. '%s'", target, i+1, col1, col2);
      report_error(actual, errmsg, NULL);
      sem_emit_column_diff_diagnostics(expected, actual);
      record_error(actual);
      return;
    }

    if (core_type_of(sem_type_1) != core_type_of(sem_type_2)) {
      CSTR error_message = dup_printf("CQL0061: %s, all columns must be an exact type match", target);
      report_sem_type_mismatch(sem_type_1, sem_type_2, actual, error_message, col2);
      record_error(actual);
      return;
    }

    if (is_nullable(sem_type_1) != is_nullable(sem_type_2)) {
      CSTR error_message =
        dup_printf("CQL0062: %s, all columns must be "
        "an exact type match (including nullability)", target);
      report_sem_type_mismatch(
          sem_type_1, sem_type_2, actual, error_message, col2);
      record_error(actual);
      return;
    }
  }
}


// If a procedure is returning a select statement then we need to attach that
// type to the procedures semantic info.  We have to do some extra validation at
// this point, especially if the proc already has some other select return. This
// is where we make sure all the kinds of selects that might be returned are
// 100% compatible.
static void sem_update_proc_type_for_select(ast_node *ast) {
  bool_t is_out = is_ast_out_stmt(ast);
  bool_t is_out_union = is_ast_out_union_stmt(ast);
  bool_t is_stmt_source = is_row_source(ast);
  bool_t is_calling_out_union = false;

  if (is_ast_call_stmt(ast)) {
     // still nothing
      Invariant(!(is_out || is_out_union || is_stmt_source));

     // the type of result is based on the call type
     sem_t sem_call = ast->sem->sem_type;

     is_out = !!(sem_call & SEM_TYPE_USES_OUT);
     is_calling_out_union = !!(sem_call & SEM_TYPE_USES_OUT_UNION);
     is_stmt_source = !(is_calling_out_union || is_out);
  }

  Contract(is_out || is_out_union || is_stmt_source || is_calling_out_union);

  // Ignore any row sources that try to set the procedure return code
  // in the context of an EXPLAIN statement. The result will be set
  // by the EXPLAIN itself rather than the target of the explain.
  // The explain target could be anything but only row sources will
  // try to set the return type of the procedure.
  if (current_explain_stmt && !is_ast_explain_stmt(ast)) {
    // explainable things like DROP and DELETE do not come here
    // they are not row sources, they have no business calling
    // sem_update_proc_type_for_select
    Contract(is_row_source(ast));
    return;
  }

  // We might get called after any select, if it's a loose select (no proc) or
  // if the current proc already has errors, or we're in a trigger, we can stop
  // here...
  if (!current_proc || is_error(current_proc) || is_error(ast) || in_trigger) {
    return;
  }

  // Sanity check our arguments, it is for sure a select.
  Invariant(is_struct(ast->sem->sem_type));

  // Sanity check the state, the current proc is a proc.
  Invariant(is_proc(current_proc));
  EXTRACT_STRING(name, current_proc->left);

  // It's at least got an OK record
  Invariant(current_proc->sem);

  // If the select we were given has any un-named columns we can't use it.
  sem_verify_no_anon_no_null_columns(ast);
  if (is_error(ast)) {
    return;
  }

  // If we haven't seen any other result type, then we're good to go, use this
  // one.
  if (core_type_of(current_proc->sem->sem_type) == SEM_TYPE_OK) {

    // start with the source of the data for the shape
    current_proc->sem = ast->sem;

    // strip the out/out union flag from the source of the select instead use
    // the correct flag for the current proc
    sem_t sem_type = current_proc->sem->sem_type;
    sem_type &= sem_not(SEM_TYPE_USES_OUT | SEM_TYPE_USES_OUT_UNION);

    // add back what we need
    if (is_out_union) {
      sem_type |= SEM_TYPE_USES_OUT_UNION;
    }

    if (is_calling_out_union) {
      sem_type |= SEM_TYPE_CALLS_OUT_UNION | SEM_TYPE_USES_OUT_UNION;
    }

    if (is_out) {
      sem_type |= SEM_TYPE_USES_OUT;
    }

    // this clones the sem entirely, replacing the flags
    sem_replace_flags(current_proc, sem_type);

    // what follows is a no-op but it double checks important invariants so just
    // let it go
  }

  // This code is the only code that sets the sem type so it must be struct
  Invariant(is_struct(current_proc->sem->sem_type));

  // Now we do the hard work of verifying that this select is compatible with
  // the previous select.  We check pretty much everything.

  // Note: we are not ever going to change the type, either it matches or it's
  // an error the only time we change the type to one of these is in the above
  // case where the type was not yet set.

  bool_t did_out = has_out_stmt_result(current_proc);
  bool_t did_call_out_union = has_out_union_call(current_proc);
  bool_t did_out_union = has_out_union_stmt_result(current_proc) && !did_call_out_union;
  bool_t did_make_stmt = has_result_set(current_proc) && !did_call_out_union;

  Invariant(did_out + did_out_union + did_make_stmt + did_call_out_union == 1);

  if (is_out != did_out ||
      is_out_union != did_out_union ||
      is_stmt_source != did_make_stmt ||
      is_calling_out_union != did_call_out_union) {
    report_error(ast, "CQL0063: can't mix and match out, out union, or select/call for return values", name);
    record_error(ast);
    return;
  }

  sem_verify_identical_columns(current_proc, ast, "in multiple select/out statements");
}

static ast_node *get_named_param(ast_node *params, CSTR name) {
  for (; params; params = params->right) {
    EXTRACT_NOTNULL(param, params->left);

    // args already evaluated and no errors
    Invariant(param->sem);

    if (!StrCaseCmp(name, param->sem->name)) {
      return param;
    }
  }

  return NULL;
}

// Like `report_error`, but does nothing if `ast` is NULL. Used to make it
// easier to handle a NULL AST in the `sem_try_resolve_*` family of functions.
static void report_resolve_error(ast_node *ast, CSTR msg, CSTR subject) {
  if (ast) {
    report_error(ast, msg, subject);
  }
}

// Like `record_error`, but does nothing if `ast` is NULL. Used to make it
// easier to handle a NULL AST in the `sem_try_resolve_*` family of functions.
static void record_resolve_error(ast_node *ast) {
  if (ast) {
    record_error(ast);
  }
}

// "LOCALS" is a virtual arg bundle that has all of the locals, this lets
// you do (e.g. call foo(from locals like foo arguments) to forward it
// all your locals that match.  Very useful...
static sem_resolve sem_try_resolve_locals_bundle(
  ast_node *ast,
  CSTR name,
  CSTR scope,
  sem_t **type_ptr)
{
  Contract(name);
  Contract(type_ptr);

  if (!scope || StrCaseCmp(scope, "LOCALS")) {
    return SEM_RESOLVE_CONTINUE;
  }

  symtab_entry *entry = symtab_find(locals, name);
  if (!entry) {
    CHARBUF_OPEN(tmp);
      bprintf(&tmp, "%s_", name);
      entry = symtab_find(locals, tmp.ptr);
    CHARBUF_CLOSE(tmp);

    if (!entry) {
      report_resolve_error(ast, "CQL0201: expanding FROM LOCALS, there is no local matching", name);
      record_resolve_error(ast);
      return SEM_RESOLVE_STOP;
    }
  }

  ast_node *var = (ast_node *)entry->val;

  if (ast) {
    ast->sem = new_sem(var->sem->sem_type);
    ast->sem->name = var->sem->name;
    ast->sem->kind = var->sem->kind;
    // Needed for cursors.
    ast->sem->sptr = var->sem->sptr;
  }

  *type_ptr = &var->sem->sem_type;

  return SEM_RESOLVE_STOP;
}

// Here we look for @PROC and @ID, there are various places where @RC or @PROC
// could appear and an id is expected, not an expression. So they have to be
// detected as identifiers. Previously there was special case code in
// sem_expr_str but that isn't good enough.
static sem_resolve sem_try_resolve_at_ids(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {
  Contract(name);
  Contract(type_ptr);

  if (scope) {
    return SEM_RESOLVE_CONTINUE;  // we only care about the global scope
  }

  // @rc is like a builtin variable, it refers to the _rc_ state note, use of
  // @rc forces you to become a dml proc which isn't very onerous because rc
  // makes no sense if it isn't a dml proc. We do it this way because it's
  // possible that you're using @rc in a loop or some such and you haven't run
  // any DML yet so we don't yet know that you are a DML proc.  Generating an
  // error would be annoying. This also has the useful property that you can
  // force a proc to be dml with "if @rc then endif;" which is useful when you
  // are trying to create mocks.  Note that @rc is normalized to @RC everywhere.
  if (!strcmp("@RC", name)) {
    ast->sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL| SEM_TYPE_VARIABLE);
    ast->sem->name = "@rc";
    *type_ptr = &ast->sem->sem_type;
    has_dml = 1; // use of result code implies DML proc
    return SEM_RESOLVE_STOP;
  }

  return SEM_RESOLVE_CONTINUE;
}

static sem_resolve sem_try_resolve_arguments_bundle(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {
  Contract(name);
  Contract(type_ptr);

  if (!scope || StrCaseCmp(scope, "ARGUMENTS")) {
    return SEM_RESOLVE_CONTINUE;
  }

  Invariant(current_proc);

  ast_node *params = get_proc_params(current_proc);
  Invariant(params);

  // these are always synthetically generated so they are 100% sure to match
  ast_node *param = get_named_param(params, name);
  if (!param) {
    CHARBUF_OPEN(tmp);
      bprintf(&tmp, "%s_", name);
      param = get_named_param(params, tmp.ptr);
    CHARBUF_CLOSE(tmp);
  }

  if (param) {
    if (ast) {
      ast->sem = new_sem(param->sem->sem_type);
      ast->sem->name = param->sem->name;
      ast->sem->kind = param->sem->kind;
      // Needed for cursors.
      ast->sem->sptr = param->sem->sptr;
    }

    *type_ptr = &param->sem->sem_type;

    return SEM_RESOLVE_STOP;
  }

  report_resolve_error(ast, "CQL0201: expanding FROM ARGUMENTS, there is no argument matching", name);
  record_resolve_error(ast);
  return SEM_RESOLVE_STOP;
}

static bool_t try_find_possible_dot_overload(charbuf *sym, ast_node *expr, CSTR name) {
  Contract(sym);
  Contract(expr);
  Contract(name);

  bclear(sym);
  sem_t sem_type = expr->sem->sem_type;
  CSTR kind = expr->sem->kind;

  if (!kind || !is_unitary(sem_type)) {
    return false;
  }

  bprintf(sym, "%s<%s>:get:%s", rewrite_type_suffix(sem_type), kind, name);
  if (find_op(sym->ptr)) {
    return true;
  }

  bclear(sym);
  bprintf(sym, "%s<%s>:get:all", rewrite_type_suffix(sem_type), kind);
  return !!find_op(sym->ptr);
}

static sem_resolve sem_try_resolve_dot_rewrite(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {
  Contract(name);
  Contract(type_ptr);

  if (!scope) {
    return SEM_RESOLVE_CONTINUE;
  }

  ast_node *var = find_local_or_global_variable(scope);

  if (!var) {
    return SEM_RESOLVE_CONTINUE;
  }

  CHARBUF_OPEN(sym);

  bool_t found = try_find_possible_dot_overload(&sym, var, name);
  if (found) {
    *type_ptr = &var->sem->sem_type;
    if (ast) {
      ast->sem = var->sem;
      sem_add_flags(ast, 0);    // no flags added this is a clone
      ast->sem->name = "$rewrite";
    }
  }

  CHARBUF_CLOSE(sym);

  return found ? SEM_RESOLVE_STOP : SEM_RESOLVE_CONTINUE;
}

// This helper adds new variables global or local, it also tracks the unitary
// locals so that we can do the LOCALS shape
static void add_variable(CSTR name, ast_node *variable) {
  // We could be working on locals and not unitary_locals inside of proc
  // declarations so we have to check both things.
  if (current_variables == locals && unitary_locals) {
    if (is_unitary(variable->sem->sem_type)) {
      bytebuf_append(unitary_locals, &variable, sizeof(variable));
    }
  }

  symtab_add(current_variables, name, variable);
}

// Look for the given name as a local or global variable.  First local.
cql_noexport ast_node *find_local_or_global_variable(CSTR name) {
  // look in the two variable tables, in order, first match wins
  symtab_entry *entry = symtab_find(locals, name);

  if (!entry) {
    entry = symtab_find(globals, name);
  }

  return entry ? entry->val : NULL;
}

// Given a name we try to find it as a local or global variable.  If we find it
// and its _type_ is "null" then we rewrite it to be a null literal.
static sem_resolve sem_try_resolve_variable(
  ast_node *ast,
  CSTR name,
  CSTR scope,
  sem_t **type_ptr)
{
  Contract(name);
  Contract(type_ptr);

  if (scope) {
    return SEM_RESOLVE_CONTINUE;
  }

  ast_node *variable = find_local_or_global_variable(name);
  if (!variable) {
    return SEM_RESOLVE_CONTINUE;
  }

  sem_t sem_type = variable->sem->sem_type;

  if (core_type_of(sem_type) == SEM_TYPE_NULL) {
    if (ast) {
      AST_REWRITE_INFO_SET(ast->lineno, ast->filename);

      // this is a null alias, rewrite it
      ast_node *null = new_ast_null();
      null->sem = new_sem(SEM_TYPE_NULL);
      ast->sem = null->sem;
      replace_node(ast, null);

      AST_REWRITE_INFO_RESET();
    }
    *type_ptr = &variable->sem->sem_type;

    return SEM_RESOLVE_STOP;
  }

  if (is_object(sem_type) &&
      CURRENT_EXPR_CONTEXT_IS_NOT(SEM_EXPR_CONTEXT_NONE | SEM_EXPR_CONTEXT_UDF)) {
    report_resolve_error(
      ast,
      "CQL0064: object variables may not appear in the context of a SQL statement (except table-valued functions)",
      name);
    record_resolve_error(ast);
    return SEM_RESOLVE_STOP;
  }

  if (ast) {
    ast->sem = new_sem(sem_type);
    ast->sem->name = variable->sem->name;
    ast->sem->kind = variable->sem->kind;
    // Needed for cursors.
    ast->sem->sptr = variable->sem->sptr;
  }

  *type_ptr = &variable->sem->sem_type;

  return SEM_RESOLVE_STOP;
}

// It is an error if a column hides a local/global. This is only a problem if
// the table is not scoped. The form T1.x is always the table column so it's
// always safe. However T1.x == x will give an error if there is a local 'x'
// because the 'x' could be either.
static bool_t sem_resolve_column_does_not_conflict_with_variable(
  ast_node *ast,
  CSTR column_name,
  CSTR table_name)
{
  Contract(column_name);

  if (!table_name && find_local_or_global_variable(column_name)) {
    report_resolve_error(
      ast,
      "CQL0059: a variable name might be ambiguous with a column name, this is an anti-pattern",
      column_name);
    record_resolve_error(ast);
    return false;
  }

  return true;
}

// Given a column name and optional scope (table name), try to find it as one of
// the columns in the current join scope or else in one of the parent
// join-scopes. If the name is ambiguous at any given level then it is an error,
// but inner scopes are allowed to hide the names of outer scopes.
static sem_resolve sem_try_resolve_column(
  ast_node *ast,
  CSTR name,
  CSTR scope,
  sem_t **type_ptr)
{
  Contract(name);
  Contract(type_ptr);

  sem_t sem_type = 0;
  CSTR col = NULL;
  CSTR kind = NULL;
  CSTR backed_table = NULL;
  sem_join *found_jptr = NULL;
  sem_t *type = NULL;

  // We walk the chain of scopes until we find a stop frame or else we run out
  // this allows nested joins to see their parent scopes.
  for (sem_joinscope *jscp = current_joinscope; jscp; jscp = jscp->parent) {
    sem_join *jptr = jscp->jptr;

    // an empty jptr has no names, skip it
    if (!jptr) {
      continue;
    }

    // stop if we find the sentinel
    if (jptr == &join_block) {
      break;
    }

    bool_t found_in_this_joinscope = false;
    for (uint32_t i = 0; i < jptr->count; i++) {
      if (scope == NULL || !StrCaseCmp(scope, jptr->names[i])) {
        sem_struct *table = jptr->tables[i];
        for (uint32_t j = 0; j < table->count; j++) {
          if (!StrCaseCmp(name, table->names[j])) {
            if (found_in_this_joinscope) {
              // Since we found two candidates in the same joinscope, we have an
              // ambiguity. It doesn't matter if we check for this before or
              // after we check for aliases as all aliases are in their own
              // join-scopes anyway.
              report_resolve_error(ast, "CQL0065: identifier is ambiguous", name);
              record_resolve_error(ast);
              if (!strcmp(name, "_anon")) {
                 report_error(ast, "additional info: more than one anonymous column in a result, likely all columsn need a name", NULL);
              }
              return SEM_RESOLVE_STOP;
            }
            if (table->semtypes[j] & SEM_TYPE_ALIAS) {
              if (col) {
                // We already found a column, and that column was found in a
                // child joinscope. It must be the case that the found column
                // shadows an alias.
                report_resolve_error(
                  ast,
                  "CQL0435: must use qualified form to avoid ambiguity with alias",
                  name);
              }
              else {
                // An alias is being referred to directly. Since we can only
                // have `SEM_TYPE_ALIAS` when analyzing one of the
                // below-mentioned clauses (for which referencing an alias is
                // not allowed), we have an error.
                report_resolve_error(
                  ast,
                  "CQL0436: alias referenced from WHERE, GROUP BY, HAVING, or WINDOW clause",
                  name);
              }
              record_resolve_error(ast);
              return SEM_RESOLVE_STOP;
            }
            if (col) {
              // We already have our result column, but we continue to search to
              // check for shadowed aliases.
              continue;
            }
            found_in_this_joinscope = true;
            sem_type = table->semtypes[j];
            col = table->names[j];
            kind = table->kinds[j];
            backed_table = table->is_backed ? table->struct_name : NULL;
            found_jptr = jptr;
            // Store this for setting type_ptr later, if successful.
            type = &table->semtypes[j];

            // Insert table alias name override if enabled.
            if (keep_table_name_in_aliases && !in_trigger && !in_trigger_when_expr && ast && scope) {
              Invariant(is_ast_dot(ast));
              insert_table_alias_string_overide(ast->left, table->struct_name);
            }
          }
        }
      }
    }
  }

  if (!col) {
    return SEM_RESOLVE_CONTINUE;
  }

  if (!sem_resolve_column_does_not_conflict_with_variable(ast, name, scope)) {
    return SEM_RESOLVE_STOP;
  }

  if (ast) {
    ast->sem = new_sem(sem_type);
    ast->sem->name = col; // be sure to use the canonical name
    ast->sem->kind = kind; // use the kind if there is one
    ast->sem->backed_table = backed_table;  // remember the backed table if there is one
    if (found_jptr && found_jptr == monitor_jptr) {
      symtab_add(monitor_symtab, col, NULL);
    }
  }

  *type_ptr = type;

  return SEM_RESOLVE_STOP;
}

// rowid is a special name (with 2 aliases) that exists in every table.
static sem_resolve sem_try_resolve_rowid(
  ast_node *ast,
  CSTR name,
  CSTR scope,
  sem_t **type_ptr)
{
  Contract(name);
  Contract(type_ptr);

  sem_t sem_type = 0;
  CSTR col = NULL;
  CSTR kind = NULL;

  if (!current_joinscope) {
    return SEM_RESOLVE_CONTINUE;
  }

  // there are 3 valid names for the rowid, any will do. If it isn't one of
  // them, we're done.
  if (StrCaseCmp(name, "_rowid_") && StrCaseCmp(name, "rowid") && StrCaseCmp(name, "oid")) {
    return SEM_RESOLVE_CONTINUE;
  }

  // Now we have to make sure it is a specific rowid that we can infer, directly or indirectly.

  sem_join *jptr = current_joinscope->jptr;
  if (scope == NULL && jptr && jptr->count == 1) {
    // if only one table then that's the rowid
    col = name;
    sem_type = SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL;
  }
  else if (scope != NULL) {
    // We walk the chain of scopes until we find a stop frame or else we run out
    // this allows nested joins to see their parent scopes.
    for (sem_joinscope *jscp = current_joinscope; jscp; jscp = jscp->parent) {
      jptr = jscp->jptr;

      // an empty jptr has no names, skip it
      if (!jptr) {
        continue;
      }

      // stop if we find the sentinel
      if (jptr == &join_block) {
        break;
      }

      // more than one table but the name is scoped, still have a chance
      for (uint32_t i = 0; i < jptr->count; i++) {
        if (!StrCaseCmp(scope, jptr->names[i])) {
          col = name;
          kind = NULL;
          sem_type = SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL;

          // Insert table alias name override if enabled.
          if (keep_table_name_in_aliases && !in_trigger && !in_trigger_when_expr && ast && scope) {
            Invariant(is_ast_dot(ast));
            insert_table_alias_string_overide(ast->left, jptr->tables[i]->struct_name);
          }

          break;
        }
      }

      if (col) {
        break;
      }
    }
  }
  else {
    report_resolve_error(ast, "CQL0066: identifier is ambiguous", name);
    record_resolve_error(ast);
    return SEM_RESOLVE_STOP;
  }

  if (!col) {
    return SEM_RESOLVE_CONTINUE;
  }

  if (!sem_resolve_column_does_not_conflict_with_variable(ast, name, scope)) {
    return SEM_RESOLVE_STOP;
  }

  if (ast) {
    ast->sem = new_sem(sem_type);
    ast->sem->name = col;
    ast->sem->kind = kind;
  }

  return SEM_RESOLVE_STOP;
}

// Similar to `sem_try_resolve_column`, but used outside of the
// `sem_try_resolve_*` family of functions a way of looking up a column given
// only a column name. Intentionally allows situations in which the name of a
// column shadows a variable. Returns `true` if the column was found, else
// `false`. Returning `true` does not imply that semantic analysis was
// successful.
static bool_t sem_find_column_for_name(ast_node *ast, CSTR name) {
  Contract(ast);
  Contract(name);

  sem_t *type = NULL;

  // We want to bypass checking for conflicts with locals and globals.
  symtab *saved_locals = locals;
  symtab *saved_globals = globals;
  locals = NULL;
  globals = NULL;

  bool_t found = sem_try_resolve_column(ast, name, NULL, &type) == SEM_RESOLVE_STOP;
  if (!found) {
    found = sem_try_resolve_rowid(ast, name, NULL, &type) == SEM_RESOLVE_STOP;
  }

  locals = saved_locals;
  globals = saved_globals;

  return found;
}

static void sem_resolve_cursor_field(ast_node *ast, ast_node *cursor, CSTR field, sem_t **type_ptr) {
  Contract(cursor);
  Contract(field);
  Contract(type_ptr);

  sem_t sem_type = cursor->sem->sem_type;
  CSTR scope = cursor->sem->name;

  // We don't do this if the cursor was not used with the auto syntax
  if (!is_auto_cursor(sem_type)) {
    report_resolve_error(ast, "CQL0067: cursor was not used with 'fetch [cursor]'", scope);
    record_resolve_error(ast);
    return;
  }

  // Find the name if it exists;  emit the canonical field name, which
  // has the exact case from the declaration.  The user might have used
  // something like C.VaLuE when the field is "value". The local has to match.

  sem_struct *sptr = cursor->sem->sptr;
  Invariant(sptr->count > 0);

  for (uint32_t i = 0; i < sptr->count; i++) {
    if (!StrCaseCmp(sptr->names[i], field)) {
      if (ast) {
        ast->sem = new_sem(sptr->semtypes[i] | SEM_TYPE_VARIABLE);
        ast->sem->name = dup_printf("%s.%s", scope, sptr->names[i]);
        ast->sem->kind = sptr->kinds[i];
      }
      *type_ptr = &sptr->semtypes[i];
      return;
    }
  }

  report_resolve_error(ast, "CQL0068: field not found in cursor", field);
  record_resolve_error(ast);
}

static sem_resolve sem_try_resolve_cursor_field(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {
  Contract(name);
  Contract(type_ptr);

  if (!scope) {
    return SEM_RESOLVE_CONTINUE;
  }

  ast_node *variable = find_local_or_global_variable(scope);
  if (!variable || !is_cursor(variable->sem->sem_type)) {
    return SEM_RESOLVE_CONTINUE;
  }

  sem_resolve_cursor_field(ast, variable, name, type_ptr);
  return SEM_RESOLVE_STOP;
}

static sem_resolve sem_try_resolve_enum(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {
  Contract(name);
  Contract(type_ptr);

  if (!scope) {
    return SEM_RESOLVE_CONTINUE;
  }

  ast_node *enum_stmt = find_enum(scope);
  if (!enum_stmt) {
    return SEM_RESOLVE_CONTINUE;
  }

  Invariant(is_ast_declare_enum_stmt(enum_stmt));

  // Find the name if it exists;  if it does then this becomes a rewrite

  EXTRACT_NOTNULL(enum_values, enum_stmt->right);

  while (enum_values) {
    EXTRACT_NOTNULL(enum_value, enum_values->left);
    EXTRACT_STRING(enum_member, enum_value->left);

    if (!StrCaseCmp(enum_member, name)) {
      if (ast) {
        ast_node *ast_new = eval_set(ast, enum_value->left->sem->value);
        sem_root_expr(ast_new, SEM_EXPR_CONTEXT_NONE);
        ast->sem = ast_new->sem;
        ast->sem->kind = enum_stmt->sem->kind;
      }
      return SEM_RESOLVE_STOP;
    }
    enum_values = enum_values->right;
  }

  report_resolve_error(ast, "CQL0357: enum does not contain", name);
  record_resolve_error(ast);

  return SEM_RESOLVE_STOP;
}

static sem_resolve sem_try_resolve_global_constant(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {
  Contract(name);
  Contract(type_ptr);

  if (scope) {
    return SEM_RESOLVE_CONTINUE;
  }

  ast_node *const_value = find_constant(name);
  if (!const_value) {
    return SEM_RESOLVE_CONTINUE;
  }

  if (ast) {
    if (is_numeric(const_value->sem->sem_type)) {
      ast_node *ast_new = eval_set(ast, const_value->left->sem->value);
      sem_root_expr(ast_new, SEM_EXPR_CONTEXT_NONE);
      ast->sem = ast_new->sem;
    }
    else {
      *ast = *const_value->right;
    }
  }

  return SEM_RESOLVE_STOP;
}

static sem_resolve sem_try_resolve_arg_bundle(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {
  Contract(name);
  Contract(type_ptr);

   if (!scope) {
     return SEM_RESOLVE_CONTINUE;
   }

   ast_node *shape = find_arg_bundle(scope);
   if (!shape) {
     return SEM_RESOLVE_CONTINUE;
   }

  // Find the name if it exists;  emit the canonical field name, which
  // has the exact case from the declaration.  The user might have used
  // something like C.VaLuE when the field is "value". The local has to match.

  sem_struct *sptr = shape->sem->sptr;
  Invariant(sptr->count > 0);

  for (uint32_t i = 0; i < sptr->count; i++) {
    if (!StrCaseCmp(sptr->names[i], name)) {
      // We found the dot form of the name (e.g., 'bundle.foo') in the argument
      // bundle. The underscore version of the name (e.g., 'bundle_foo')
      // therefore must exist in `locals`: We always create both versions of the
      // name, and the local is not allowed to be redefined.
      //
      // It's important that we set the same `sem_t` pointer for both the dot
      // form and the underscore-separated form of references to parameters
      // within argument bundles. If we didn't, `find_mutable_type` would be
      // less useful: Getting up the type pointer for the dot form of the name
      // and setting an improvement on it wouldn't affect the underscore form,
      // and vice versa.
      //
      // The easiest way to set the same type pointer for both is to simply
      // resolve the underscore form.
      CHARBUF_OPEN(underscore_name);
      bprintf(&underscore_name, "%s_%s", scope, name);
      sem_resolve result = sem_try_resolve_variable(ast, underscore_name.ptr, NULL, type_ptr);
      CHARBUF_CLOSE(underscore_name);

      Invariant(result == SEM_RESOLVE_STOP);

      return SEM_RESOLVE_STOP;
    }
  }

  report_resolve_error(ast, "CQL0068: field not found in shape", name);
  record_resolve_error(ast);

  return SEM_RESOLVE_STOP;
}

// This function is responsible for resolving both unqualified identifiers (ids)
// and qualified identifiers (dots). It performs the following two roles:
//
// - If an optional `ast` is provided, it works the same way most semantic
//   analysis functions work: semantic information will be written into into the
//   ast, errors will be reported to the user, and errors will be recorded in
//   the AST.
//
// - `*type_ptr` will be set to mutable type (`sem_t *`) in the current
//   environment if the identifier successfully resolves to a type. (There are,
//   unfortunately, a few exceptions in which a type will be successfully
//   resolved and yet `*type_ptr` will not be set. These include when the
//   expression is `rowid` (or similar) and when the id resolves to an enum
//   case. The reason no mutable type is returned in these cases is that a new
//   type is allocated as part of semantic analysis, and there exists no single,
//   stable type in the environment to which a pointer could be returned. This
//   is a limitation of this function, albeit one that's currently not
//   problematic.)
//
//  Resolution is attempted in the order that the `sem_try_resolve_*` functions
//  appear in the `resolver` array. Each takes the same arguments: An (optional)
//  AST, a mandatory name, an optional scope, and mandatory type pointer. If the
//  identifier provided to one of these resolvers is resolved successfully, *or*
//  if the correct resolver was found but there was an error in the program,
//  `SEM_RESOLVE_STOP` is returned and resolution is complete, successful or
//  not. If a resolver is tried and it determines that it is not the correct
//  resolver for the identifier in question, `SEM_RESOLVE_CONTINUE` is returned
//  and the next resolver is tried.
//
// This function should not be called directly. If one is interested in
// performing semantic analysis, call `sem_resolve_id` (or, if within an
// expression, `sem_resolve_id_expr`). Alternatively, if one wants to get a
// mutable type from the environment, call `find_mutable_type`.
static void sem_resolve_id_with_type(ast_node *ast, CSTR name, CSTR scope, sem_t **type_ptr) {
  Contract(name);
  Contract(type_ptr);

  *type_ptr = NULL;

  sem_resolve (*resolver[])(ast_node *ast, CSTR, CSTR, sem_t **) = {
    sem_try_resolve_at_ids,
    sem_try_resolve_arguments_bundle,
    sem_try_resolve_locals_bundle,
    sem_try_resolve_column,
    sem_try_resolve_rowid,
    sem_try_resolve_variable,
    sem_try_resolve_enum,
    sem_try_resolve_global_constant,
    sem_try_resolve_cursor_field,
    sem_try_resolve_arg_bundle,
    sem_try_resolve_dot_rewrite,
  };

  for (uint32_t i = 0; i < sizeof(resolver) / sizeof(void *); i++) {
    if (resolver[i](ast, name, scope, type_ptr) == SEM_RESOLVE_STOP) {
      return;
    }
  }

  if (scope) {
    // this name is what we can use as the variable name in code gen
    // so we don't escape it for qnames or anything, it has to be the
    // unescaped names, e.g. C.XaX20b for C.`a b`
    name = dup_printf("%s.%s", scope, name);
  }

  report_resolve_error(ast, "CQL0069: name not found", name);
  record_resolve_error(ast);
}

// Resolves a (potentially qualified) identifier, writing semantic information
// into `ast` if successful, or reporting and recording an error for `ast` if
// not.
cql_noexport void sem_resolve_id(ast_node *ast, CSTR name, CSTR scope) {
  Contract(is_id_or_dot(ast));
  Contract(name);

  // We have no use for `type` and simply throw it away.
  sem_t *type = NULL;
  sem_resolve_id_with_type(ast, name, scope, &type);
}

// Checks that the variable provided has been initialized, if required. As this
// is to be used only for *references* to a previously declared variable, the
// combination of flags indicating a completed initialization, if present, will
// be removed as they serve no purpose outside of declarations.
static void sem_validate_variable_referenced_is_initialized_if_required(ast_node *ast) {
  Contract(is_id_or_dot(ast));
  Contract(ast->sem);
  Contract(is_variable(ast->sem->sem_type));

  sem_t sem_type = ast->sem->sem_type;

  if (sem_type & SEM_TYPE_INIT_REQUIRED && !(sem_type & SEM_TYPE_INIT_COMPLETE)) {
    report_error(ast, "CQL0438: variable possibly used before initialization", ast->sem->name);
    record_error(ast);
    return;
  }

  // `SEM_TYPE_INIT_COMPLETE` and `SEM_TYPE_INIT_REQUIRED` are only useful on
  // declarations. We can remove these to avoid noise in the --ast output.
  ast->sem->sem_type &= sem_not(SEM_TYPE_INIT_REQUIRED | SEM_TYPE_INIT_COMPLETE);
}

// Returns true if the type of a cursor field requires checking that the cursor
// itself has a row before the field is accessed, else false.
static bool_t auto_cursor_field_requires_has_row_check(sem_t sem_type) {
  // Since cursor fields are technically variables and we want to use the same
  // policy for has-row checks as we use for initialization (because, after all,
  // fetching a cursor is just another form of initialization), we delegate
  // accordingly.
  return variable_should_require_initialization(sem_type);
}

// Given the AST of an auto cursor field access and the type of the auto cursor
// itself, returns true if a has-row check has been performed appropriately (if
// required), else false.
static void sem_validate_auto_cursor_field_accessed_has_row_check_if_required(ast_node *ast, sem_t cursor_type) {
  Contract(is_ast_dot(ast));
  Contract(ast->sem);
  Contract(is_variable(ast->sem->sem_type));
  Contract(!is_cursor(ast->sem->sem_type));
  Contract(is_auto_cursor(cursor_type));

  if (cursor_type & SEM_TYPE_HAS_ROW) {
    // The cursor has a row, so we're good.
    return;
  }

  if (!auto_cursor_field_requires_has_row_check(ast->sem->sem_type)) {
    // The cursor may not have a row, but having a row is not required to access
    // this particular field. All is well.
    return;
  }

  // The cursor has *not* been verified to have a row and the field being
  // accessed is of a type which requires it to have one. This is unsafe: If the
  // cursor does not have a row at runtime, the field will be NULL despite the
  // nonnull type. We issue an error accordingly.
  report_error(
    ast,
    "CQL0460: field of a nonnull reference type accessed before verifying that the cursor has a row",
    ast->sem->name
  );
  record_error(ast);
}

// Given an AST that may represent a cursor field reference, validate that the
// requirements for has-row checks have been met.
static void sem_validate_has_row_check_requirements_if_applicable(ast_node *ast) {
  Contract(ast);
  Contract(ast->sem);

  if (enforcement.strict_cursor_has_row) {
    if (is_ast_dot(ast)) {
      // Since this is a dot, `ast` might refer to a cursor field. To check if
      // it does, we have to look up the type of `scope`.
      EXTRACT_STRING(scope, ast->left);
      sem_t *type = find_mutable_type(scope, NULL);
      if (type && is_cursor(*type)) {
        // `scope` corresponds to a cursor (and thus `ast` refers to a cursor
        // field). It must, therefore, be the case that the cursor is an auto
        // cursor.
        Invariant(is_auto_cursor(*type));
        sem_validate_auto_cursor_field_accessed_has_row_check_if_required(ast, *type);
      }
    }
  }
}

// Given an AST that may represent a variable reference, validate that the
// requirements for initialization have been met.
static void sem_validate_initialization_requirements_if_applicable(ast_node *ast) {
  Contract(ast);
  Contract(ast->sem);

  sem_t sem_type = ast->sem->sem_type;

  if (is_variable(sem_type)) {
    // The name/scope pair refers to a variable. Ensure that it has been
    // appropriately initialized before use.
    sem_validate_variable_referenced_is_initialized_if_required(ast);
  }
}

// Analyze a cursor used as an expression; this is the has-row boolean case.
static void sem_cursor_as_expression(ast_node *ast) {
  Contract(ast);
  Contract(ast->sem);
  Contract(is_cursor(ast->sem->sem_type));

  // When the name of a cursor appears in an expression context, it doesn't
  // refer to the cursor itself. Instead, it refers to a boolean indicating
  // whether or not the cursor has a row. We adjust things here accordingly.
  CSTR vname = NULL;
  if (is_auto_cursor(ast->sem->sem_type)) {
    vname = dup_printf("%s._has_row_", ast->sem->name);
  }
  else {
    if (!(ast->sem->sem_type & SEM_TYPE_FETCH_INTO)) {
      report_error(ast, "CQL0067: cursor was not used with 'fetch [cursor]'", ast->sem->name);
      record_error(ast);
      return;
    }
    vname = dup_printf("_%s_has_row_", ast->sem->name);
  }
  ast->sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_VARIABLE | SEM_TYPE_NOTNULL);
  ast->sem->name = vname;
}

// Analyze an expression subject to a nonnull improvement and rewrite it, if
// appropriate.
static void sem_notnull_improved_expr(ast_node *ast) {
  Contract(is_id_or_dot(ast));
  Contract(ast->sem);
  Contract(ast->sem->sem_type & SEM_TYPE_INFERRED_NOTNULL);

  if (is_analyzing_notnull_rewrite) {
    // If we're analyzing the product of a rewrite and we're already inside of a
    // call to `cql_inferred_notnull`, do not expand again.
    // forever.
    return;
  }

  if (current_loop_analysis_state == LOOP_ANALYSIS_STATE_ANALYZE) {
    // We're inside of a loop that we're going going to analyze again. If we
    // were to rewrite now, we could rewrite something to be nonnull that we'll
    // later find out is actually nullable.
    //
    // To avoid ending up with a bogus call to `cql_inferred_notnull`, we skip
    // the rewrite and optimistically make it nonnull directly. This poses no
    // problems for codegen if we turn out to be right because we'll perform the
    // rewrite as usual during the next stage of loop analysis, and it poses no
    // problems for semantic analysis if we're wrong because we'll catch the
    // error on the next phase.
    ast->sem->sem_type |= SEM_TYPE_NOTNULL;

    // Prevent this from propagating needlessly to keep --ast clean.
    ast->sem->sem_type &= u64_not(SEM_TYPE_INFERRED_NOTNULL);
    return;
  }

  // If we've made it here, it's safe and appropriate to do the rewrite.
  rewrite_nullable_to_notnull(ast);
}

// Like `sem_resolve_id`, but specific to expression contexts.
static void sem_resolve_id_expr(ast_node *ast, CSTR name, CSTR scope) {
  Contract(is_id_or_dot(ast));
  Contract(name);

  // Perform resolution, as for ids and dots outside of expressions.
  sem_resolve_id(ast, name, scope);
  if (is_error(ast)) {
    return;
  }

  sem_validate_has_row_check_requirements_if_applicable(ast);
  if (is_error(ast)) {
    return;
  }

  sem_validate_initialization_requirements_if_applicable(ast);
  if (is_error(ast)) {
    return;
  }

  sem_t sem_type = ast->sem->sem_type;

  if (is_cursor(sem_type)) {
    // Cursors themselves cannot have improved nullability.
    Invariant(!(sem_type & SEM_TYPE_INFERRED_NOTNULL));
    sem_cursor_as_expression(ast);
    return;
  }

  if (sem_type & SEM_TYPE_INFERRED_NOTNULL) {
    // Things with improved nullability must not be cursors.
    Invariant(!is_cursor(sem_type));
    sem_notnull_improved_expr(ast);
  }
}

// Returns the *mutable* type (`sem_t *`) for a given (potentially qualified)
// identifier if one exists in the environment. The type pointer returned is for
// the original binding and thus corresponds to the type set via
// `sem_resolve_id`, *not* the type set via `sem_resolve_id_expr`. See the
// documentation for `sem_resolve_id_with_type` for limitations.
static sem_t *find_mutable_type(CSTR name, CSTR scope) {
  Contract(name);

  sem_t *type = NULL;
  sem_resolve_id_with_type(NULL, name, scope, &type);

  return type;
}

// Like `find_mutable_type`, but sets `is_global` to true if the name/scope pair
// refers to either a global variable or the field of a global auto cursor
// (i.e., anything that is both global and mutable).
static sem_t *find_mutable_type_and_global_status(CSTR name, CSTR scope, bool_t *is_global) {
  Contract(name);
  Contract(is_global);

  *is_global = false;

  // First, we perform resolution as we normally would.
  sem_t *type = NULL;
  sem_resolve_id_with_type(NULL, name, scope, &type);

  // This function is presently only used for setting nullability improvements.
  // Given that nullability improvements are only set after an expression or
  // statement has been analyzed successfully, and given that there exists no
  // nullable type for which `sem_resolve_id_with_type` will ever fail to set a
  // type pointer -- the things for which it can fail, e.g., enum cases, all
  // have nonnull types -- we must have `type`. Should this ever change, it
  // would be appropriate to return here when `type` is NULL: We only do not do
  // that now for the sake of maintaining code coverage.
  Invariant(type);

  // Resolving was successful. Now, we need to check whether or not it resolved
  // to either a global variable or a field of a global auto cursor.
  if (scope) {
    // We have a name and a scope: The name/scope pair might refer to a global
    // auto cursor field.
    symtab_entry *entry = symtab_find(globals, scope);
    if (!entry) {
      // `scope` does not appear in globals, so we know this cannot be the
      // global case.
      return type;
    }

    ast_node *ast = entry->val;

    if (!is_cursor(ast->sem->sem_type)) {
      // We found something in `globals` that supports dot syntax, but it's not
      // a cursor. It must be the case that `scope` refers to something that
      // both shadows the name in `globals` and also supports dot syntax (e.g.,
      // a local cursor or an argument bundle).
      return type;
    }

    // There is global cursor named `scope`. We resolve `name` as though it were
    // one of its fields, then compare that resolution to the one above to
    // determine whether the name/scope pair refers to a field of the global
    // auto cursor (the equal case) or whether it refers to something that
    // shadows it (the non-equal case).
    sem_t *global_type = NULL;
    sem_resolve_cursor_field(NULL, ast, name, &global_type);

    *is_global = type == global_type;
  }
  else {
    // We only have a name: The name might refer to a global variable.
    symtab_entry *entry = symtab_find(globals, name);
    if (!entry) {
      // `name` does not appear in globals, so we know this cannot be the global
      // case.
      return type;
    }

    ast_node *ast = entry->val;

    // There is a global variable named `name`. Now, we just need to compare the
    // address of its `sem_t` to what we resolved above to determine whether
    // `name` refers to the global variable (the equal case) or whether it
    // refers to something that shadows it (the non-equal case).
    *is_global = type == &ast->sem->sem_type;
  }

  return type;
}

// Here we check that type<Foo> only combines with type<Foo> or type.
// If there is a current object type, then the next item must match
// If there is no such type, then an object type that arrives becomes the required type
// if they ever don't match record an error
static CSTR sem_combine_kinds_general(ast_node *ast, CSTR kind_left, CSTR kind_right) {
  if (kind_right) {
    if (kind_left) {
      if (StrCaseCmp(kind_left, kind_right)) {
        CSTR errmsg = dup_printf("CQL0070: expressions of different kinds can't be mixed: '%s' vs. '%s'", kind_right, kind_left);
        report_error(ast, errmsg, NULL);
        record_error(ast);
      }
    }
    return kind_right;
  }

  return kind_left;
}

// helper to crack the ast nodes first and then call the normal comparisons
static CSTR sem_combine_kinds(ast_node *ast, CSTR kind_right) {
  CSTR kind_left = ast->sem->kind;
  return sem_combine_kinds_general(ast, kind_left, kind_right);
}

// Validate the contents of the case list of a case expression.
//
// There are two parts to each element the list: the "when" expression and the
// "then" expression. We compute the aggregate type of the when expressions as
// we go, promoting it up to a larger type if needed (e.g., if one when is an
// int and the other is a real, then the result is a real). Likewise,
// nullability is computed as the aggregate. Note that if nothing matches, the
// result is null; we always get a nullable result unless there is an "else"
// expression.
//
// If we started with "case expr" (indicated by `has_expression_to_match`), then
// each when expression must be comparable to the case expression. If we started
// with "case when xx then yy", then each case expression must be numeric
// (typically boolean).
//
// As with IF, CASE can improve nullability. This is only possible when
// `has_expression_to_match` is false though. This is because something like
// "CASE 0 WHEN x IS NOT NULL THEN x ELSE y" will only ever take the first
// branch when "x" IS null despite the "IS NOT NULL" check.
static void sem_case_list(
  ast_node *head,
  bool_t has_expression_to_match,
  sem_t sem_type_required_for_when,
  CSTR kind_required_for_when,
  bool_t is_iif)
{
  Contract(is_ast_case_list(head));
  Contract(has_expression_to_match || sem_type_required_for_when == SEM_TYPE_BOOL);
  sem_t sem_type_result = SEM_TYPE_PENDING;
  CSTR then_kind = NULL;

  sem_t sem_sensitive  = 0;

  for (ast_node *ast = head; ast; ast = ast->right) {
    EXTRACT_NOTNULL(when, ast->left);
    // WHEN [when_expr] THEN [then_expr]
    EXTRACT_ANY_NOTNULL(when_expr, when->left);
    EXTRACT_ANY_NOTNULL(then_expr, when->right);

    sem_expr(when_expr);
    if (is_error(when_expr)) {
      record_error(ast);
      record_error(head);
      return;
    }

    if (is_null_type(when_expr->sem->sem_type)) {
      report_error(ast, "CQL0501: WHEN expression must not be a constant NULL but can be of a nullable type", NULL);
      record_error(ast);
      return;
    }

    if (!sem_verify_compat(when_expr, sem_type_required_for_when, when_expr->sem->sem_type, is_iif ? "iif" : "when")) {
      record_error(ast);
      record_error(head);
      return;
    }

    sem_combine_kinds(when_expr, kind_required_for_when);
    if (is_error(when_expr)) {
      record_error(ast);
      record_error(head);
      return;
    }

    FLOW_PUSH_CONTEXT_BRANCH();
    if (!has_expression_to_match) {
      sem_set_improvements_for_true_condition(when_expr);
    }
    sem_expr(then_expr);
    FLOW_POP_CONTEXT_BRANCH();

    if (is_error(then_expr)) {
      record_error(ast);
      record_error(head);
      return;
    }

    sem_set_improvements_for_false_condition(when_expr);

    sem_sensitive |= sensitive_flag(when_expr->sem->sem_type);
    sem_sensitive |= sensitive_flag(then_expr->sem->sem_type);

    if (sem_type_result == SEM_TYPE_PENDING) {
      sem_type_result = then_expr->sem->sem_type;
      then_kind = then_expr->sem->kind;
    }
    else {
      sem_t sem_type_current = then_expr->sem->sem_type;

      if (!sem_verify_compat(then_expr, sem_type_result, sem_type_current, "then")) {
        record_error(ast);
        record_error(head);
        return;
      }

      then_kind = sem_combine_kinds(then_expr, then_kind);
      if (is_error(then_expr)) {
        record_error(ast);
        record_error(head);
        return;
      }

      // upgrade the result type to a bigger type if needed
      sem_type_result = sem_combine_types(sem_type_result, sem_type_current);
    }

    when->sem = then_expr->sem;
    ast->sem = when->sem;
  }

  head->sem = new_sem(sem_type_result | sem_sensitive);
  head->sem->kind = then_kind;
}

// Performs analysis of case expressions, including those rewritten from an IIF.
// The case list is handled in the above function; in this part, we find the
// type of the expr in "case [expr]" if there is one, then we do the else
// handling. Note that the absence of an else forces the case to have a possibly
// null result.
cql_noexport void sem_case(ast_node *ast, bool_t is_iif) {
  Contract(is_ast_case_expr(ast));
  EXTRACT_ANY(expr, ast->left);
  EXTRACT_NOTNULL(connector, ast->right);
  EXTRACT_NOTNULL(case_list, connector->left);
  EXTRACT_ANY(else_expr, connector->right);

  // CASE [expr]? [case_list] ELSE [else_expr] END

  sem_t sem_type_required_for_when = SEM_TYPE_BOOL;
  sem_t sem_sensitive = 0;
  CSTR kind_required_for_when = NULL;

  if (expr) {
    // case can have expression or just when clauses
    sem_expr(expr);
    if (is_error(expr)) {
      record_error(ast);
      return;
    }
    kind_required_for_when = expr->sem->kind;
    sem_type_required_for_when = core_type_of(expr->sem->sem_type);
    sem_sensitive |= sensitive_flag(expr->sem->sem_type);
  }

  // Each WHEN expression may improve its corresponding THEN expression when we
  // are not using the matching form of CASE (i.e, when we're not using the
  // "CASE expr case_list ..." form). We create a new context here to contain
  // all of the contingent contexts created within `sem_case_list`.
  //
  // The reason we create this context here instead of within `sem_case_list` is
  // that we do not want to pop it until after we've analyzed `else_expr`. Doing
  // so would allow un-improvements within the case list to negatively affect
  // `else_expr`; that would be incorrect, because if `else_expr` ends up being
  // evaluated, none of the THEN expressions within `case_list` could have been
  // evaluated.
  FLOW_PUSH_CONTEXT_BRANCH_GROUP();

  sem_case_list(case_list, !!expr, sem_type_required_for_when, kind_required_for_when, is_iif);
  if (is_error(case_list)) {
    goto error;
  }

  ast->sem = case_list->sem;
  sem_sensitive |= sensitive_flag(case_list->sem->sem_type);

  if (else_expr) {
    flow_set_context_branch_group_covers_all_cases(true);
    FLOW_PUSH_CONTEXT_BRANCH();
    sem_expr(else_expr);
    FLOW_POP_CONTEXT_BRANCH();
    if (is_error(else_expr)) {
      goto error;
    }

    sem_t sem_type_else = else_expr->sem->sem_type;
    sem_t sem_type_result = ast->sem->sem_type;

    sem_sensitive |= sensitive_flag(sem_type_else);

    if (!sem_verify_compat(else_expr, sem_type_result, sem_type_else, is_iif ? "iif" : "else")) {
      goto error;
    }

    CSTR else_kind = sem_combine_kinds(else_expr, ast->sem->kind);
    if (is_error(else_expr)) {
      goto error;
    }

    sem_type_result = sem_combine_types(sem_type_result, sem_type_else);
    ast->sem = new_sem(sem_type_result | sem_sensitive);
    ast->sem->kind = else_kind;
  }
  else {
    // If there is no else clause then you get null if you miss all the cases
    // so it has to be nullable return type.
    sem_t new_flags = ast->sem->sem_type;
    new_flags &= sem_not(SEM_TYPE_NOTNULL);
    new_flags |= sem_sensitive;
    sem_replace_flags(ast, new_flags);
  }

  connector->sem = ast->sem;

cleanup:
  FLOW_POP_CONTEXT_BRANCH_GROUP();
  return;

error:
  record_error(ast);
  goto cleanup;
}

static void sem_expr_case(ast_node *ast, CSTR cstr) {
  Contract(is_ast_case_expr(ast));

  sem_case(ast, IS_CASE);
}

// if we get here we are re-evaluating a subtree, this rewritten bit
// is necessarily processed so we don't have to do it again
static void sem_expr_between_rewrite(ast_node *ast, CSTR cstr) {
  Contract(is_ast_between_rewrite(ast));
  return;
}

// Between requires type compatibility between all three of its arguments.
// Nullability follows the usual rules, if any might be null then the result
// type might be null.  In any case the result's core type is BOOL.
static void sem_expr_between_or_not_between(ast_node *ast, CSTR cstr) {
  Contract(is_ast_between(ast) || is_ast_not_between(ast));
  EXTRACT_NOTNULL(range, ast->right);

  bool_t between = is_ast_between(ast);

  // [ast->left] [NOT] BETWEEN [range->left] AND [range->right]");
  sem_expr(ast->left);
  sem_expr(range->left);
  sem_expr(range->right);

  if (is_error(ast->left) || is_error(range->left) || is_error(range->right)) {
    record_error(ast);
    return;
  }

  sem_t sem_type_item = ast->left->sem->sem_type;
  sem_t sem_type_min = range->left->sem->sem_type;
  sem_t sem_type_max = range->right->sem->sem_type;

  CSTR operation = between ? "BETWEEN" : "NOT BETWEEN";
  CSTR operation_or_and = between ? "BETWEEN/AND" : "NOT BETWEEN/AND";
  if (is_blob(sem_type_item)) {
    report_error(ast->left, "CQL0071: first operand cannot be a blob in", operation);
    record_error(ast);
    return;
  }

  if (is_object(sem_type_item)) {
    report_error(ast->left, "CQL0072: first operand cannot be an object in", operation);
    record_error(ast);
    return;
  }

  // the min can't be compared with the item
  if (!sem_verify_compat(ast, sem_type_item, sem_type_min, operation)) {
    return;
  }

  // the max can't be compared with the item
  if (!sem_verify_compat(ast, sem_type_item, sem_type_max, operation)) {
    return;
  }

  // the right and left aren't compatible with each other even though they are both compatible with the main operand
  // e.g. null between 1 and 'x'
  if (!sem_verify_compat(ast, sem_type_min, sem_type_max, operation_or_and)) {
    return;
  }

  // check for compatible kinds between item and the min
  sem_combine_kinds(range->left, ast->left->sem->kind);
  if (is_error(range->left)) {
    record_error(ast);
    return;
  }

  // check for compatible kinds between item and the max
  sem_combine_kinds(range->right, ast->left->sem->kind);
  if (is_error(range->right)) {
    record_error(ast);
    return;
  }

  // check for compatible kinds between min and max
  // this can fail if the item is generic and the left and right have kind
  // e.g.   12 between min_dollars and max_euros
  sem_combine_kinds(range->right, range->left->sem->kind);
  if (is_error(range->right)) {
    record_error(ast);
    return;
  }

  // If we're going to be doing this not to SQL then we rewrite the between operation
  // as follows:
  //  * x between y and z ==> temp = x, temp >= y AND temp <= z
  //  * x not between y and z ==>  temp = x, temp < y OR temp > z
  // We do this to get the right short circuit behavior for between without having
  // to duplicate the highly complex codge for shortcut AND/OR
  if (current_expr_context == SEM_EXPR_CONTEXT_NONE) {
    ast_node *expr = ast->left;

    AST_REWRITE_INFO_SET(expr->lineno, expr->filename);

    symtab *scope = locals ? locals : globals;
    Invariant(scope);
    CSTR name = dup_printf("_between_%d_", between_count++);

    // Implicitly declare the local variable we need
    ast_node *asts = new_ast_str(name);
    asts->sem = new_sem(expr->sem->sem_type | SEM_TYPE_VARIABLE);
    asts->sem->name = name;
    symtab_add(scope, name, asts);

    ast_node *left_item = new_ast_str(name);
    ast_node *right_item = new_ast_str(name);
    ast_node *left_cmp;
    ast_node *right_cmp;
    ast_node *combine;

    if (between) {
      left_cmp = new_ast_ge(left_item, range->left);
      right_cmp = new_ast_le(right_item, range->right);
      combine = new_ast_and(left_cmp, right_cmp);
    }
    else {
      left_cmp = new_ast_lt(left_item, range->left);
      right_cmp = new_ast_gt(right_item, range->right);
      combine = new_ast_or(left_cmp, right_cmp);
    }

    ast_set_right(range, combine);
    ast_set_left(range, new_ast_str(name));

    AST_REWRITE_INFO_RESET();

    sem_expr(range->left);
    sem_expr(range->right);

    ast->type = k_ast_between_rewrite;
  }

  sem_t combined_flags = not_nullable_flag(sem_type_item) & both_notnull_flag(sem_type_min, sem_type_max);
  combined_flags |= sensitive_flag(sem_type_item) | sensitive_flag(sem_type_min) | sensitive_flag(sem_type_max);
  ast->sem = new_sem(SEM_TYPE_BOOL | combined_flags);
}

// For cast expressions we use the type provided for the semantic type
// the only trick is that we preserve the combined_flags of the input argument.
static void sem_expr_cast(ast_node *ast, CSTR cstr) {
  Contract(is_ast_cast_expr(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_ANY_NOTNULL(data_type, ast->right);

  // CAST ( expr, data_type )

  sem_expr(expr);
  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  sem_data_type_column(data_type);
  if (is_error(data_type)) {
    record_error(ast);
    return;
  }

  // We allow conversion between numeric types without going to SQLite, the text conversions
  // are crazy complex and basically impossible to clone so you have to do (select cast(...))
  // for those. A no-op cast to change kind is ok too.

  sem_t sem1 = data_type->sem->sem_type;
  sem_t sem2 = expr->sem->sem_type;

  // null can be cast to anything to create a nullable of that type
  if (core_type_of(sem2) == SEM_TYPE_NULL) {
    ast->sem = new_sem(data_type->sem->sem_type);
    ast->sem->kind = data_type->sem->kind;
    return;
  }

  if (core_type_of(sem1) != core_type_of(sem2)) {
    if (!is_numeric(sem1) || !is_numeric(sem2)) {
      if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {
        report_error(ast, "CQL0073: CAST may only appear in the context of SQL statement", NULL);
        record_error(ast);
        return;
      }
    }
  }

  if (enforcement.strict_cast) {
    if (core_type_of(data_type->sem->sem_type) == core_type_of(expr->sem->sem_type)) {
      // if the core type is the same and the kind is the same then the cast did nothing
      CSTR k1 = data_type->sem->kind;
      CSTR k2 = expr->sem->kind;

      // either both are null, or both are not null and they match
      bool_t same = (!k1 && !k2) || (k1 && k2 && !StrCaseCmp(k1, k2));

      if (same) {
        CSTR err_msg = dup_expr_text(ast);
        report_error(expr, "CQL0170: cast is redundant, remove to reduce code size", err_msg);
        record_error(ast);
        return;
      }
    }
  }

  sem_t combined_flags = not_nullable_flag(expr->sem->sem_type) | sensitive_flag(expr->sem->sem_type);

  ast->sem = new_sem(data_type->sem->sem_type | combined_flags);
  ast->sem->kind = data_type->sem->kind;
}

static void sem_expr_type_check(ast_node *ast, CSTR cstr) {
  Contract(is_ast_type_check_expr(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_ANY_NOTNULL(type, ast->right);

  sem_expr(expr);
  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  sem_data_type_var(type);
  if (is_error(type)) {
    record_error(ast);
    return;
  }

  sem_t sem_type_1 = expr->sem->sem_type;
  sem_t sem_type_2 = type->sem->sem_type;

  if (core_type_of(sem_type_1) != core_type_of(sem_type_2)
     || is_nullable(sem_type_1) != is_nullable(sem_type_2)
     || is_sensitive(sem_type_1) != is_sensitive(sem_type_2)) {

    CSTR err_expr = dup_expr_text(expr);
    CSTR error_message = "CQL0009: incompatible types in expression";
    report_sem_type_mismatch(sem_type_2, sem_type_1, expr, error_message, err_expr);
    record_error(expr);
    record_error(ast);
    return;
  }

  CSTR kind_left = expr->sem->kind;
  CSTR kind_right = type->sem->kind;

  if (!kind_left && !kind_right) {
  }
  else if (kind_left && kind_right && !StrCaseCmp(kind_left, kind_right)) {
  }
  else {
    kind_left = kind_left ? kind_left : "[none]";
    kind_right = kind_right ? kind_right : "[none]";

    CSTR errmsg = dup_printf("CQL0070: expressions of different kinds can't be mixed: '%s' vs. '%s'", kind_left, kind_right);
    report_error(ast, errmsg, NULL);
    record_error(ast);
    return;
  }

  ast->sem = expr->sem;
}

// Coalesce requires type compatibility between all of its arguments.  The result
// is a not null type if we find a not null item in the list.  There should be
// nothing after that item.  Note that ifnull and coalesce are really the same thing
// except ifnull must have exactly two arguments.
static void sem_func_concat_helper(ast_node *call_ast, uint32_t arg_count, bool_t is_concat_ws) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // concat functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(call_ast));

  call_ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);

  if (is_concat_ws) {
    copy_nullability(call_ast, first_arg(arg_list)->sem->sem_type);
  }
  else {
    copy_nullability(call_ast, SEM_TYPE_NOTNULL);
  }
}

static void sem_func_concat(ast_node *ast, uint32_t arg_count) {
  // concat ( X, [arg_list] )
  if (!sem_validate_arg_pattern("fildsb,[fildsb,*]", ast, arg_count)) {
    return;
  }

  sem_func_concat_helper(ast, arg_count, false);
}

static void sem_func_concat_ws(ast_node *ast, uint32_t arg_count) {
  // concat_ws ( SEP, X, [arg_list] )
  if (!sem_validate_arg_pattern("s,fildsb,[fildsb,*]", ast, arg_count)) {
    return;
  }

  sem_func_concat_helper(ast, arg_count, true);
}

// Coalesce requires type compatibility between all of its arguments.  The result
// is a not null type if we find a not null item in the list.  There should be
// nothing after that item.  Note that ifnull and coalesce are really the same thing
// except ifnull must have exactly two arguments.
static void sem_coalesce(ast_node *call_ast, bool_t is_ifnull) {
  Contract(is_ast_call(call_ast));
  EXTRACT_NAME_AST(name_ast, call_ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, call_ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // ifnull ( [arg_list] )
  // coalesce ( [arg_list] )

  sem_t sem_sensitive = 0;

  uint32_t arg_count = 0;
  for (ast_node *ast = arg_list; ast; ast = ast->right) arg_count++;

  if (arg_count < 2) {
    report_error(name_ast, "CQL0074: too few arguments provided", name);
    record_error(call_ast);
    return;
  }

  if (is_ifnull && arg_count != 2) {
    report_error(name_ast, "CQL0075: incorrect number of arguments", name);
    record_error(call_ast);
    return;
  }

  sem_t sem_type_result = SEM_TYPE_PENDING;
  CSTR kind_result = NULL;

  for (ast_node *ast = arg_list; ast; ast = ast->right) {
    ast_node *expr = ast->left;

    if (is_ast_null(expr)) {
      report_error(expr, "CQL0076: NULL literal is useless in function", name);
      record_error(expr);
      record_error(call_ast);
      return;
    }

    // arg list already already analyzed for us by sem_expr_call
    // sem_expr(expr);
    Invariant(expr->sem);

    sem_sensitive |= sensitive_flag(expr->sem->sem_type);

    if (sem_type_result == SEM_TYPE_PENDING) {
      sem_type_result = expr->sem->sem_type;
    }
    else {
      sem_t sem_type_current = expr->sem->sem_type;
      if (!sem_verify_compat(expr, sem_type_result, sem_type_current, name)) {
        record_error(expr);
        record_error(call_ast);
        return;
      }

      // Note that if we are still here the result is not yet nullable
      // the combined result will therefore not be nullable, this is ok
      // because the next thing we do is improve the type.
      Invariant(!is_not_nullable(sem_type_result));
      sem_type_result = sem_combine_types(sem_type_result, sem_type_current);

      // This is the magic right here: upgrade the result type to not null
      // and stop at this point.  There should be nothing after the first item
      // that is known to be not null.
      if (is_not_nullable(sem_type_current)) {
        sem_type_result |= SEM_TYPE_NOTNULL;
      }
    }

    // Even the first arg might be not-nullable so we check every time through
    if (is_not_nullable(sem_type_result) && ast->right) {
      CSTR err_msg = dup_expr_text(expr);
      report_error(expr,
        "CQL0077: encountered arg known to be not null"
        " before the end of the list, rendering the rest useless.", err_msg);
      record_error(call_ast);
      return;
    }

    kind_result = sem_combine_kinds(expr, kind_result);
    if (is_error(expr)) {
      record_error(call_ast);
      return;
    }
  }

  call_ast->sem = new_sem(sem_type_result | sem_sensitive);
  call_ast->sem->kind = kind_result;
}

// The in predicate is like many of the other multi-argument operators.  All the
// items must be type compatible.  Note that in this case the nullability of
// the items does not matter, only the nullability of the item being tested.
// Note that null in (null) is null, not true.
static void sem_expr_in_pred_or_not_in(ast_node *ast, CSTR cstr) {
  Contract(is_ast_in_pred(ast) || is_ast_not_in(ast));
  EXTRACT_ANY_NOTNULL(needle, ast->left);

  // [needle] [NOT] IN ( [expr_list | select_stmt] )

  sem_expr(needle);
  if (is_error(needle)) {
    record_error(ast);
    return;
  }

  sem_t sem_type_needed = needle->sem->sem_type;
  CSTR kind_needed = needle->sem->kind;
  sem_t combined_flags = not_nullable_flag(sem_type_needed) | sensitive_flag(sem_type_needed);

  if (ast->right == NULL) {
    // empty in list, nothing to validate
  }
  else if (is_ast_expr_list(ast->right)) {
    EXTRACT_NOTNULL(expr_list, ast->right);

    // make sure the items are all of some comparable type
    for (ast_node *item = expr_list; item; item = item->right) {
      ast_node *expr = item->left;

      sem_expr(expr);
      item->sem = expr->sem;

      if (is_error(expr)) {
        record_error(ast);
        return;
      }

      sem_t sem_type_current = expr->sem->sem_type;
      if (!sem_verify_compat(ast, sem_type_needed, sem_type_current, is_ast_in_pred(ast) ? "IN" : "NOT IN")) {
        return;
      }

      sem_combine_kinds(expr, kind_needed);
      if (is_error(expr)) {
        record_error(ast);
        return;
      }

      combined_flags |= sensitive_flag(sem_type_current);
      sem_type_needed = sem_combine_types(sem_type_needed, sem_type_current);
    }
  }
  else {
    uint32_t valid =
      SEM_EXPR_CONTEXT_SELECT_LIST
      |SEM_EXPR_CONTEXT_WHERE
      |SEM_EXPR_CONTEXT_ON
      |SEM_EXPR_CONTEXT_HAVING
      |SEM_EXPR_CONTEXT_UDF;

    if (CURRENT_EXPR_CONTEXT_IS_NOT(valid)) {
      report_error( ast,
        "CQL0078: [not] in (select ...) is only allowed inside "
        "of select lists, where, on, and having clauses", NULL);
      record_error(ast);
      return;
    }

    EXTRACT_ANY_NOTNULL(select_stmt, ast->right);

    sem_expr_select((ast_node *)select_stmt, "SELECT");
    if (is_error(select_stmt)) {
      record_error(ast);
      return;
    }

    // make sure the select statement is of some comparable type
    if (!sem_verify_compat(ast, sem_type_needed, select_stmt->sem->sem_type, is_ast_in_pred(ast) ? "IN" : "NOT IN")) {
      return;
    }

    sem_combine_kinds(select_stmt, kind_needed);
    if (is_error(select_stmt)) {
      record_error(ast);
      return;
    }

    combined_flags |= sensitive_flag(select_stmt->sem->sem_type);
  }

  ast->sem = new_sem(SEM_TYPE_BOOL | combined_flags);
}

// This is a helper method that logs an error if the indicated counts
// do not match.  It doesn't actually walk the list.  We always have to
// do that for other reasons anyway so there is no additional walk here.
static bool_t sem_validate_arg_count(ast_node *ast, uint32_t count, uint32_t expected) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);

  if (count != expected) {
    report_error(name_ast, "CQL0079: function got incorrect number of arguments", name);
    record_error(name_ast);
    record_error(ast);
    return false;
  }

  return true;
}
// This is a helper method that tells us if the EXISTS function can be used
// in the current expression context.  Exists cannot be used in GROUP BY
// for instance.  Nor does it make sense in a loose expression outside of
// a select.
static bool_t sem_validate_exists_context(ast_node *ast) {
  Contract(is_ast_exists_expr(ast));

  return sem_validate_context(ast, "exists",
            SEM_EXPR_CONTEXT_SELECT_LIST |
            SEM_EXPR_CONTEXT_HAVING |
            SEM_EXPR_CONTEXT_WHERE |
            SEM_EXPR_CONTEXT_ON |
            SEM_EXPR_CONTEXT_UDF);
}

// Compute the type of an exists subexpression.  The context must be valid
// the nested select must be ok.  The result will be a not null boolean.
static void sem_expr_exists(ast_node *ast, CSTR cstr) {
  Contract(is_ast_exists_expr(ast));
  EXTRACT_ANY_NOTNULL(select_stmt, ast->left);

  if (!sem_validate_exists_context(ast)) {
    return;
  }

  // this handles more than select but that's ok
  sem_any_select(select_stmt);
  if (is_error(select_stmt)) {
    record_error(ast);
    return;
  }

  sem_t sem_sensitive = any_sensitive(select_stmt->sem->sptr);
  ast->sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL | sem_sensitive);
}

static bool_t sem_validate_window_context(ast_node *ast) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);

  // check the context first, better error message
  if (!sem_validate_function_context(ast, SEM_EXPR_CONTEXT_WINDOW)) {
    return false;
  }

  return true;
}

// Aggregate functions can only be used in certain places.  For instance
// they may not appear in a WHERE clause.  Validate the current context.
static bool_t sem_validate_aggregate_context(ast_node *ast) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);

  // check the context first, better error message
  if (!sem_validate_function_context(ast,
        SEM_EXPR_CONTEXT_SELECT_LIST |
        SEM_EXPR_CONTEXT_HAVING |
        SEM_EXPR_CONTEXT_ORDER_BY |
        SEM_EXPR_CONTEXT_WINDOW |
        SEM_EXPR_CONTEXT_WINDOW_FILTER)) {
    return false;
  }

  if (!current_joinscope || !current_joinscope->jptr) {
    report_error(ast, "CQL0081: aggregates only make sense if there is a FROM clause", name);
    record_error(ast);
    return false;
  }

  return true;
}

// cql_blob_get_type(blob) -- this will ultimately expand into
// user_defined_blob_get_type(blob).  We have this helper because it returns nullable or not
// nullable depending on the input blob.  Otherwise this is very nearly a normal function.
static void sem_special_func_cql_blob_get_type(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_STRING(name, name_ast);

  *is_aggregate = false;

  // cql_blob_get_type can only appear inside of SQL
  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  if (!sem_validate_arg_count(ast, arg_count, 2)) {
    return;
  }

  ast_node *table_name_ast = first_arg(arg_list);
  ast_node *blob_expr = second_arg(arg_list);

  if (!is_ast_str(table_name_ast)) {
    report_error(table_name_ast, "CQL0491: argument 1 must be a table name that is a backed table", name);
    record_error(table_name_ast);
    return;
  }

  EXTRACT_STRING(table_name, table_name_ast);

  // give a better error if the table is not found
  ast_node *ref_table_ast = find_usable_and_not_deleted_table_or_view(
      table_name,
      table_name_ast,
      "CQL0095: table/view not defined");
  if (!ref_table_ast) {
    record_error(ast);
    return;
  }

  sem_t sem_type = ref_table_ast->sem->sem_type;

  if (!is_backed(sem_type) && !is_backing(sem_type)) {
    report_error(ast,
      "CQL0488: the indicated table is not declared for backed or backing storage",
      table_name);
    record_error(ast);
    return;
  }

  sem_expr(blob_expr);
  if (is_error(blob_expr)) {
    record_error(ast);
    return;
  }

  if (!sem_verify_compat(blob_expr, blob_expr->sem->sem_type, SEM_TYPE_BLOB, name)) {
    record_error(ast);
    return;
  }

  // compute the usual semantic type preserving sensitivity etc.
  // but skip the table name hence ->right
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_LONG_INTEGER, arg_list->right);
}

// cql_blob_create(backed_type, value, backed_type.col, value2, backed_type.col, ...),
// this will ultimately expand into something like
//
// blob_create(12345 /* blob type */, value, 5 /* field type */, etc.)
// or
// blob_create(12345 /* blob type */, value, 12345 /* field hash*/, 5 /* field type */, etc.)
//
// All we have to do here is ensure that count of columns is 2n+1
// All the types are from the same backed type
// all the values are type compatible with the indicated column type
// normally this is generated by an automatic rewrite so that basically always happens
// but it is possible to call the function directly -- the rewrite is only sugar after all
// we we have to check even if it's usually redundant.
//
static void sem_special_func_cql_blob_create(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  *is_aggregate = false;

  // cql_blob_create can only appear inside of SQL
  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  // at least one column and the type
  if (arg_count % 2 != 1) {
    // force arg count error
    sem_validate_arg_count(ast, arg_count, arg_count + 1);
    return;
  }

  ast_node *backed_name_ast = first_arg(arg_list);

  if (!is_ast_str(backed_name_ast)) {
    report_error(backed_name_ast, "CQL0491: argument 1 must be a table name that is a backed table", "cql_blob_create");
    record_error(ast);
    return;
  }

  EXTRACT_STRING(backed_table_name, backed_name_ast);

  // give a better error if the table is not found
  ast_node *backed_table_ast = find_usable_and_not_deleted_table_or_view(
      backed_table_name,
      backed_name_ast,
      "CQL0095: table/view not defined");
  if (!backed_table_ast) {
    record_error(ast);
    return;
  }

  if (!is_backed(backed_table_ast->sem->sem_type)) {
    report_error(backed_table_ast, "CQL0488: the indicated table is not declared for backed storage", backed_table_name);
    record_error(ast);
    return;
  }

  // already verified 2n + 1 args so this is safe!
  for (ast_node *next_arg = arg_list->right; next_arg; next_arg = next_arg->right->right) {
    EXTRACT_ANY_NOTNULL(val_expr, next_arg->left);
    EXTRACT_ANY_NOTNULL(table_expr, next_arg->right->left);

    sem_expr(val_expr);
    if (is_error(val_expr)) {
      record_error(ast);
      return;
    }

    if (!is_ast_dot(table_expr) || !is_ast_str(table_expr->left) || !is_ast_str(table_expr->right)) {
      report_error(table_expr, "CQL0490: argument must be table.column where table is a backed table", "cql_blob_create");
      record_error(ast);
      return;
    }

    EXTRACT_STRING(t_name, table_expr->left);
    EXTRACT_STRING(c_name, table_expr->right);

    // give a better error if the table is not found
    ast_node *table_ast = find_usable_and_not_deleted_table_or_view(
        t_name,
        table_expr->left,
        "CQL0095: table/view not defined");
    if (!table_ast) {
      record_error(ast);
      return;
    }

    if (backed_table_ast != table_ast) {
      report_error(table_expr, "CQL0488: the indicated table is not consistently used through all of cql_blob_create", t_name);
      record_error(ast);
      return;
    }

    sem_t sem_type = find_column_type(t_name, c_name);
    if (!sem_type) {
      CSTR err_data = dup_printf("%s.%s", t_name, c_name);
      report_error(table_expr, "CQL0489: the indicated column is not present in the named backed storage", err_data);
      record_error(ast);
      return;
    }

    if (!sem_verify_compat(val_expr, val_expr->sem->sem_type, sem_type, "cql_blob_create")) {
      record_error(ast);
      return;
    }

    table_expr->sem = new_sem(sem_type);
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_BLOB | SEM_TYPE_NOTNULL);
}

// cql_blob_update(backed_type, value, backed_type.col, value2, backed_type.col, ...),
// this will ultimately expand into something like
//
// blob_update(blob, value, value, ...)
// or
// blob_update(blob, value, 12345 /* field hash*/, 5 /* field type */, etc.)
//
// All we have to do here is ensure that count of columns is 2n+1
// All the types are from the same backed type
// all the values are type compatible with the indicated column type
// normally this is generated by an automatic rewrite so that basically always happens
// but it is possible to call the function directly -- the rewrite is only sugar after all
// we we have to check even if it's usually redundant.
//
static void sem_special_func_cql_blob_update(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  *is_aggregate = false;

  // cql_blob_update can only appear inside of SQL
  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  // at least one column and the type
  if (arg_count % 2 != 1 || arg_count < 3) {
    // force arg count error
    sem_validate_arg_count(ast, arg_count, arg_count + 1);
    return;
  }

  ast_node *blob_expr = first_arg(arg_list);

  sem_expr(blob_expr);
  if (is_error(blob_expr)) {
    record_error(ast);
    return;
  }

  if (!sem_verify_compat(blob_expr, blob_expr->sem->sem_type, SEM_TYPE_BLOB, "cql_blob_update")) {
    record_error(ast);
    return;
  }

  ast_node *dot = third_arg(arg_list);

  if (!is_ast_dot(dot) || !is_ast_str(dot->left) || !is_ast_str(dot->right)) {
    report_error(dot, "CQL0490: argument must be table.column where table is a backed table", "cql_blob_update");
    record_error(ast);
    return;
  }

  EXTRACT_STRING(backed_table_name, dot->left);

  // give a better error if the table is not found
  ast_node *backed_table_ast = find_usable_and_not_deleted_table_or_view(
      backed_table_name,
      dot->left,
      "CQL0095: table/view not defined");
  if (!backed_table_ast) {
    record_error(ast);
    return;
  }

  if (!is_backed(backed_table_ast->sem->sem_type)) {
    report_error(backed_table_ast, "CQL0488: the indicated table is not declared for backed storage", backed_table_name);
    record_error(ast);
    return;
  }

  // already verified 2n + 1 args so this is safe!
  for (ast_node *next_arg = arg_list->right; next_arg; next_arg = next_arg->right->right) {
    EXTRACT_ANY_NOTNULL(val_expr, next_arg->left);
    EXTRACT_ANY_NOTNULL(table_expr, next_arg->right->left);

    sem_expr(val_expr);
    if (is_error(val_expr)) {
      record_error(ast);
      return;
    }

    if (!is_ast_dot(table_expr) || !is_ast_str(table_expr->left) || !is_ast_str(table_expr->right)) {
      report_error(table_expr, "CQL0257: argument must be table.column where table is a backed table", "cql_blob_update");
      record_error(ast);
      return;
    }

    EXTRACT_STRING(t_name, table_expr->left);
    EXTRACT_STRING(c_name, table_expr->right);

    // give a better error if the table is not found
    ast_node *table_ast = find_usable_and_not_deleted_table_or_view(
        t_name,
        table_expr->left,
        "CQL0095: table/view not defined");
    if (!table_ast) {
      record_error(ast);
      return;
    }

    if (backed_table_ast != table_ast) {
      report_error(table_expr, "CQL0488: the indicated table is not consistently used through all of cql_blob_update", t_name);
      record_error(ast);
      return;
    }

    sem_t sem_type = find_column_type(t_name, c_name);
    if (!sem_type) {
      CSTR err_data = dup_printf("%s.%s", t_name, c_name);
      report_error(table_expr, "CQL0489: the indicated column is not present in the named backed storage", err_data);
      record_error(ast);
      return;
    }

    if (!sem_verify_compat(val_expr, val_expr->sem->sem_type, sem_type, "cql_blob_update")) {
      record_error(ast);
      return;
    }

    table_expr->sem = new_sem(sem_type);
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_BLOB | SEM_TYPE_NOTNULL);
}

// cql_blob_get(blob, table.column) -- this will ultimately expand into
// user_defined_blob_get(blob, hash_code) but we need the table form so that we know the
// result type accurately.  The rewrite happens when we use gen_sql with for_sqlite true.
// In all other stages, it stays as is.  As a consequence, we also get a dependency on the
// backed table.  When we visit this kind of node we also want to create a dependency on
// the backing table.
static void sem_special_func_cql_blob_get(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  *is_aggregate = false;

  // cql_blob_get can only appear inside of SQL
  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  if (!sem_validate_arg_count(ast, arg_count, 2)) {
    return;
  }

  ast_node *blob_expr = first_arg(arg_list);

  sem_expr(blob_expr);
  if (is_error(blob_expr)) {
    record_error(ast);
    return;
  }

  if (!sem_verify_compat(blob_expr, blob_expr->sem->sem_type, SEM_TYPE_BLOB, "cql_blob_get")) {
    record_error(ast);
    return;
  }

  ast_node *table_expr = second_arg(arg_list);

  if (!is_ast_dot(table_expr) || !is_ast_str(table_expr->left) || !is_ast_str(table_expr->right)) {
    report_error(table_expr, "CQL0490: argument must be table.column where table is a backed table", "cql_blob_get");
    record_error(ast);
    return;
  }

  EXTRACT_STRING(t_name, table_expr->left);
  EXTRACT_STRING(c_name, table_expr->right);

  // give a better error if the table is not found
  ast_node *table_ast = find_usable_and_not_deleted_table_or_view(
      t_name,
      table_expr->left,
      "CQL0095: table/view not defined");
  if (!table_ast) {
    record_error(ast);
    return;
  }

  if (!is_backed(table_ast->sem->sem_type)) {
    report_error(table_expr, "CQL0488: the indicated table is not declared for backed storage", t_name);
    record_error(ast);
    return;
  }

  sem_t sem_type = find_column_type(t_name, c_name);
  if (!sem_type) {
    CSTR err_data = dup_printf("%s.%s", t_name, c_name);
    report_error(table_expr, "CQL0489: the indicated column is not present in the named backed storage", err_data);
    record_error(ast);
    return;
  }

  sem_t combined_flags = not_nullable_flag(sem_type) | sensitive_flag(sem_type);

  combined_flags = combine_flags(combined_flags, blob_expr->sem->sem_type);

  table_expr->sem = name_ast->sem = ast->sem = new_sem(sem_type | combined_flags);

  table_expr->sem->kind = find_column_kind(t_name, c_name);
}

// You can count anything, you always get an integer
static void sem_special_func_count(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  *is_aggregate = true;

  sem_arg_list(arg_list, IS_COUNT);
  if (arg_list && is_error(arg_list)) {
    record_error(ast);
    return;
  }

  if (!sem_validate_aggregate_context(ast)) {
    return;
  }

  if (!sem_validate_arg_count(ast, arg_count, 1)) {
    return;
  }

  sem_node *sem = first_arg(arg_list)->sem;
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL | sensitive_flag(sem->sem_type));

  // ast->sem->name is not set here because e.g. sum(x) is not named "x"
}

// You can min/max numerics and strings, you get what you started with.
static void sem_aggr_func_min_or_max(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_arg_pattern("filds,[filds,*]", ast, arg_count)) {
    return;
  }

  sem_node *sem = first_arg(arg_list)->sem;
  sem_t core_type = core_type_of(sem->sem_type);

  // If the one arg version then only in an aggregate context
  if (arg_count == 1) {
    if (!sem_validate_aggregate_context(ast)) {
      return;
    }

    // sensitivity is preserved but nullability is not because (e.g.)
    // select max(1) from sqlite_master where 0;  ->  NULL not zero rows
    name_ast->sem = ast->sem = new_sem(core_type | sensitive_flag(sem->sem_type));

    // ast->sem->name is not set here because e.g. min(x) is not named "x"

    return;
  }

  // min/max can only appear inside of SQL, the multi-column version can be anywhere
  // because it's not an aggregation
  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  sem_t sem_type_needed = sem->sem_type;
  sem_t combined_flags = not_nullable_flag(sem_type_needed) | sensitive_flag(sem_type_needed);

  // we know there are at least two args
  ast_node *ast_args = arg_list->right;
  Invariant(ast_args);

  for (; ast_args; ast_args = ast_args->right) {
    EXTRACT_ANY_NOTNULL(arg, ast_args->left);
    sem_t sem_type_current = arg->sem->sem_type;

    if (!sem_verify_compat(ast, sem_type_needed, sem_type_current, name)) {
      return;
    }

    combined_flags |= sensitive_flag(sem_type_current);
    sem_type_needed = sem_combine_types(sem_type_needed, sem_type_current);
  }

  name_ast->sem = ast->sem = new_sem(sem_type_needed | combined_flags);
  // the new node is does not keep any of the names of the members, just the net type
}

// You can round real numbers, you may specify a precision
static void sem_func_round(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // round rewritten to only appear inside of SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  // round ( value, [digits] )
  if (!sem_validate_arg_pattern("d,[fil]", ast, arg_count)) {
    return;
  }

  if (arg_count == 2) {
    name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_REAL, arg_list);
  }
  else {
    name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_LONG_INTEGER, arg_list);
  }
}

// Min and Max are the same validation
static void sem_aggr_func_max(ast_node *ast, uint32_t arg_count) {
  sem_aggr_func_min_or_max(ast, arg_count);
}

// Min and Max are the same validation
static void sem_aggr_func_min(ast_node *ast, uint32_t arg_count) {
  sem_aggr_func_min_or_max(ast, arg_count);
}

// Avg validation -> any numeric is ok, but you get a real back.
static void sem_aggr_func_avg(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_aggregate_context(ast)) {
    return;
  }

  // Note: avg does not have a multi-arg form like min/max, only
  // the single arg form is legal in Sqlite
  if (!sem_validate_arg_pattern("fild", ast, arg_count)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_REAL, arg_list);

  // avg will be real, sensitivity preserved, nullability NOT preserved
  // because all aggregates can return NULL if there are zero rows
  // e.g. select avg(1) from sqlite_master where 0;   -> NULL
  copy_nullability(ast, 0);
}

static void sem_func_ifnull(ast_node *ast, uint32_t arg_count) {
  sem_coalesce(ast, 1);  // set "ifnull"
}

// This is a wrapper function that tells the code generator to compress
// the string literal into fragments like we do for statements.  This
// will do nothing unless --compress has been selected
static void sem_func_cql_compressed(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_context(ast, name, SEM_EXPR_CONTEXT_NONE)) {
    return;
  }

  // only one argument
  if (!sem_validate_arg_count(ast, arg_count, 1)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);

  if (!is_strlit(arg)) {
    report_error(ast, "CQL0421: first argument must be a string literal", name);
    record_error(ast);
    return;
  }

  // the literal type flows through
  name_ast->sem = ast->sem = arg->sem;
}

// The usual blob verification stuff.  Note that cql_get_blob_size
// returns not null (blob size of nil is zero).
// We can't declare this function with the normal syntax because it
// has to prop sensitivity.  We should probably have a syntax for
// nullable args get nullable results and sensitive args get sensitive
// results but we don't have one at this time.
static void sem_func_cql_get_blob_size(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_context(ast, name, SEM_EXPR_CONTEXT_NONE)) {
    return;
  }

  // only one argument and it's a blob
  if (!sem_validate_arg_pattern("b", ast, arg_count)) {
    return;
  }

  // long integer result, always not null
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_LONG_INTEGER, arg_list);
  copy_nullability(ast, SEM_TYPE_NOTNULL);
}

static void sem_func_unicode(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // unicode rewritten to only appear inside of SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("s", ast, arg_count)) {
    return;
  }

  // integer result
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_INTEGER, arg_list);
}

static void sem_func_typeof(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // unicode can only appear inside of SQL
  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  if (!sem_validate_arg_pattern("fildsb", ast, arg_count)) {
    return;
  }

  // text result
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_TEXT | SEM_TYPE_NOTNULL);
}

static void sem_func_length(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // length rewritten to only appear inside of SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("sb", ast, arg_count)) {
    return;
  }

  // integer result
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_INTEGER, arg_list);
}

static void sem_func_sqlite_compileoption_used(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // rewritten to be always in SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("s", ast, arg_count)) {
    return;
  }

  // bool notnull result
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_BOOL|SEM_TYPE_NOTNULL);
}

static void sem_func_sqlite_compileoption_get(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // rewritten to be always in SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("i", ast, arg_count)) {
    return;
  }

  // text nullable result (index too high -> null)
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_TEXT);
}

static void sem_func_octet_length(ast_node *ast, uint32_t arg_count) {
  sem_func_length(ast, arg_count);
}

static void sem_func_trim(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // trim rewritten to only appear inside of SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("s,[s]", ast, arg_count)) {
    return;
  }

  ast_node *arg1 = first_arg(arg_list);

  // integer result
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);

  // type text, not null if arg1 is not null
  copy_nullability(ast, arg1->sem->sem_type);

  // preserve the string kind of the main arg, otherwise no kind checks needed for trim
  ast->sem->kind = arg1->sem->kind;
}

static void sem_func_matcher(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  Contract(sem_validate_appear_inside_sql_stmt(ast));

  ast_node *arg1 = first_arg(arg_list);

  // sensitive if any are sensitive and not null if all are not null
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_BOOL, arg_list);

  // preserve the string kind of the main arg, otherwise no kind checks needed for trim
  ast->sem->kind = arg1->sem->kind;
}

static void sem_func_like(ast_node *ast, uint32_t arg_count) {
  if (!sem_validate_arg_pattern("s,s,[s]", ast, arg_count)) {
    return;
  }

  sem_func_matcher(ast, arg_count);
}

static void sem_func_glob(ast_node *ast, uint32_t arg_count) {
  if (!sem_validate_arg_pattern("s,s", ast, arg_count)) {
    return;
  }

  sem_func_matcher(ast, arg_count);
}

static void sem_func_quote(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_arg_pattern("fildsb", ast, arg_count)) {
    return;
  }

  // standard sensitivity and nullability
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);
}

static void sem_func_soundex(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("s", ast, arg_count)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);
  copy_nullability(ast, SEM_TYPE_NOTNULL);
}

static void sem_func_hex(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("sb", ast, arg_count)) {
    return;
  }

  // standard sensitivity and nullability
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);
}

static void sem_func_unhex(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("s,[s]", ast, arg_count)) {
    return;
  }

  // only arg1 contributes to sensitivity and nullability
  ast_node *arg = first_arg(arg_list);
  sem_t flags = arg->sem->sem_type & (SEM_TYPE_NOTNULL | SEM_TYPE_SENSITIVE);
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_BLOB | flags);
}

// ltrim has the same semantics as trim
static void sem_func_ltrim(ast_node *ast, uint32_t arg_count) {
  sem_func_trim(ast, arg_count);
}

// helper for json() and jsonb()
static void sem_func_json_helper(ast_node *ast, uint32_t arg_count, sem_t result_type) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("sb", ast, arg_count)) {
    return;
  }

  ast_node *arg1 = first_arg(arg_list);

  // sensitivity and nullability come from the one argument
  name_ast->sem = ast->sem = new_sem_std(result_type, arg_list);

  // preserve the string kind of the main arg, otherwise no kind checks needed for json
  ast->sem->kind = arg1->sem->kind;
}

static void sem_func_json(ast_node *ast, uint32_t arg_count) {
  sem_func_json_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_jsonb(ast_node *ast, uint32_t arg_count) {
  sem_func_json_helper(ast, arg_count, SEM_TYPE_BLOB);
}

static void sem_func_json_pretty(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("sb,[s]", ast, arg_count)) {
    return;
  }

  ast_node *arg1 = first_arg(arg_list);

  // sensitivity and nullability come from the one argument
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);

  // preserve the string kind of the main arg, otherwise no kind checks needed for json
  ast->sem->kind = arg1->sem->kind;
}

// helper for json_array() and jsonb_array()
static void sem_func_json_array_helper(ast_node *ast, uint32_t arg_count, sem_t sem_type_result) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("[filds,*]", ast, arg_count)) {
    return;
  }

  // kind is not preserved, there is normally more than one
  name_ast->sem = ast->sem = new_sem_std(sem_type_result, arg_list);

  // result is nullable, arguments might be badly formed
  copy_nullability(ast, 0);
}

static void sem_func_json_array(ast_node *ast, uint32_t arg_count) {
  sem_func_json_array_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_jsonb_array(ast_node *ast, uint32_t arg_count) {
  sem_func_json_array_helper(ast, arg_count, SEM_TYPE_BLOB);
}

static void sem_func_json_item_path_helper(ast_node *ast, uint32_t arg_count, sem_t sem_type_result) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("sb,[s]", ast, arg_count)) {
    return;
  }

  if (arg_count == 1) {
    sem_type_result |= SEM_TYPE_NOTNULL;
  }

  // kind is not preserved
  name_ast->sem = ast->sem = new_sem(sem_type_result);
}

static void sem_func_json_array_length(ast_node *ast, uint32_t arg_count) {
  sem_func_json_item_path_helper(ast, arg_count, SEM_TYPE_INTEGER);
}

static void sem_func_json_type(ast_node *ast, uint32_t arg_count) {
  sem_func_json_item_path_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_json_error_position(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("sb", ast, arg_count)) {
    return;
  }

  // kind is not preserved, there is normally more than one
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);
}

// helper for json_extract() jsonb_extract() as well as json_remove() and jsonb_remove()
static void sem_func_json_extract_helper(ast_node *ast, uint32_t arg_count, sem_t sem_type_result) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("sb,s,[s,*]", ast, arg_count)) {
    return;
  }

  // kind is not preserved
  name_ast->sem = ast->sem = new_sem_std(sem_type_result, arg_list);
  // nullable result
  copy_nullability(ast, 0);
}

static void sem_func_json_extract(ast_node *ast, uint32_t arg_count) {
  sem_func_json_extract_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_jsonb_extract(ast_node *ast, uint32_t arg_count) {
  sem_func_json_extract_helper(ast, arg_count, SEM_TYPE_BLOB);
}

// helper for json_insert(), json_set(), json_replace() and jsonb_ of the same
static void sem_func_json_mod_helper(ast_node *ast, uint32_t arg_count, sem_t sem_type_result) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  // any even number of args is wrong including zero
  if (!sem_validate_arg_pattern("sb,[s,nfilds,*]", ast, arg_count)) {
    return;
  }

  // kind is not preserved, there is normally more than one
  name_ast->sem = ast->sem = new_sem_std(sem_type_result, arg_list);

  // nullability comes from the first arg, sensitivity as usual
  ast_node *arg = first_arg(arg_list);
  copy_nullability(ast, arg->sem->sem_type);
}

static void sem_func_json_insert(ast_node *ast, uint32_t arg_count) {
  // insert, set, replace all have the same rules
  sem_func_json_mod_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_json_replace(ast_node *ast, uint32_t arg_count) {
  // insert, set, replace all have the same rules
  sem_func_json_mod_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_json_set(ast_node *ast, uint32_t arg_count) {
  // insert, set, replace all have the same rules
  sem_func_json_mod_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_jsonb_insert(ast_node *ast, uint32_t arg_count) {
  // insert, set, replace all have the same rules
  sem_func_json_mod_helper(ast, arg_count, SEM_TYPE_BLOB);
}

static void sem_func_jsonb_replace(ast_node *ast, uint32_t arg_count) {
  // insert, set, replace all have the same rules
  sem_func_json_mod_helper(ast, arg_count, SEM_TYPE_BLOB);
}

static void sem_func_jsonb_set(ast_node *ast, uint32_t arg_count) {
  // insert, set, replace all have the same rules
  sem_func_json_mod_helper(ast, arg_count, SEM_TYPE_BLOB);
}

static void sem_func_json_remove(ast_node *ast, uint32_t arg_count) {
  // same rules as extract
  sem_func_json_extract_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_jsonb_remove(ast_node *ast, uint32_t arg_count) {
  // same rules as extract
  sem_func_json_extract_helper(ast, arg_count, SEM_TYPE_BLOB);
}

// helper for json_object() and jsonb_object()
static void sem_func_json_object_helper(ast_node *ast, uint32_t arg_count, sem_t sem_type_result) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("[s,nfilds,*]", ast, arg_count)) {
    return;
  }

  // kind is not preserved, there is normally more than one
  name_ast->sem = ast->sem = new_sem_std(sem_type_result, arg_list);
  copy_nullability(ast, SEM_TYPE_NOTNULL);
}

static void sem_func_json_object(ast_node *ast, uint32_t arg_count) {
  sem_func_json_object_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_jsonb_object(ast_node *ast, uint32_t arg_count) {
  sem_func_json_object_helper(ast, arg_count, SEM_TYPE_BLOB);
}

// helper for json_patch() and jsonb_patch()
static void sem_func_json_patch_helper(ast_node *ast, uint32_t arg_count, sem_t sem_type_result) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  // exactly two arguments both json
  if (!sem_validate_arg_pattern("sb,sb", ast, arg_count)) {
    return;
  }

  // kind is not preserved, there is normally more than one
  name_ast->sem = ast->sem = new_sem_std(sem_type_result, arg_list);
}

static void sem_func_json_patch(ast_node *ast, uint32_t arg_count) {
  sem_func_json_patch_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_func_jsonb_patch(ast_node *ast, uint32_t arg_count) {
  sem_func_json_patch_helper(ast, arg_count, SEM_TYPE_BLOB);
}

static void sem_func_json_valid(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  // exactly two arguments first json, second numeric
  if (!sem_validate_arg_pattern("sb,[fild]", ast, arg_count)) {
    return;
  }

  // kind and sensitivity is not preserved
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_BOOL, arg_list);
  copy_sensitivity(ast, 0);
}

static void sem_func_json_quote(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // json functions can only appear inside of SQL, they are rewritten if elsewhere
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  // exactly two arguments first json, second numeric
  if (!sem_validate_arg_pattern("nfilds", ast, arg_count)) {
    return;
  }

  // kind is not preserved
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);
}

static void sem_aggr_func_json_group_array_helper(ast_node *ast, uint32_t arg_count, sem_t sem_type_result) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_aggregate_context(ast)) {
    return;
  }

  if (!sem_validate_arg_pattern("nfildsb", ast, arg_count)) {
    return;
  }

  // kind is not preserved
  name_ast->sem = ast->sem = new_sem_std(sem_type_result, arg_list);
}

static void sem_aggr_func_json_group_array(ast_node *ast, uint32_t arg_count) {
  sem_aggr_func_json_group_array_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_aggr_func_jsonb_group_array(ast_node *ast, uint32_t arg_count) {
  sem_aggr_func_json_group_array_helper(ast, arg_count, SEM_TYPE_BLOB);
}

static void sem_aggr_func_json_group_object_helper(ast_node *ast, uint32_t arg_count, sem_t sem_type_result) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_aggregate_context(ast)) {
    return;
  }

  if (!sem_validate_arg_pattern("nfildsb,nfildsb", ast, arg_count)) {
    return;
  }

  // kind is not preserved
  name_ast->sem = ast->sem = new_sem_std(sem_type_result, arg_list);
}

static void sem_aggr_func_json_group_object(ast_node *ast, uint32_t arg_count) {
  sem_aggr_func_json_group_object_helper(ast, arg_count, SEM_TYPE_TEXT);
}

static void sem_aggr_func_jsonb_group_object(ast_node *ast, uint32_t arg_count) {
  sem_aggr_func_json_group_object_helper(ast, arg_count, SEM_TYPE_BLOB);
}

// rtrim has the same semantics as trim
static void sem_func_rtrim(ast_node *ast, uint32_t arg_count) {
  sem_func_trim(ast, arg_count);
}

static void sem_func_nullif(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // nullif can only appear inside of SQL
  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  if (!sem_validate_arg_count(ast, arg_count, 2)) {
    return;
  }

  ast_node *arg1 = first_arg(arg_list);
  ast_node *arg2 = second_arg(arg_list);

  if (!sem_verify_compat(arg1, arg1->sem->sem_type, arg2->sem->sem_type, "NULLIF")) {
    return;
  }

  sem_combine_kinds(arg2, arg1->sem->kind);
  if (is_error(arg2)) {
    record_error(ast);
    return;
  }

  // nullif will be the same type as arg1, sensitivity preserved; nullability
  // added because nullif() can (obviously) return NULL
  name_ast->sem = ast->sem = new_sem(arg1->sem->sem_type & sem_not(SEM_TYPE_NOTNULL));
  ast->sem->kind = arg1->sem->kind;

  // ast->sem->name is not set here because e.g. nullif(x) is not named "x"
}

static void sem_func_instr(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // instr rewritten to only appear inside of SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  // two text arguments
  if (!sem_validate_arg_pattern("s,s", ast, arg_count)) {
    return;
  }

  // instr() is integer type, sensitivity, nullability preserved;
  // the kind of instr is generic, the integer returned has no kind even if the strings do
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_INTEGER, arg_list);
}

static void sem_func_randomblob(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // rewritten to only appear inside of SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  // one numeric arg
  if (!sem_validate_arg_pattern("bild", ast, arg_count)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_BLOB | SEM_TYPE_NOTNULL);
}

static void sem_func_zeroblob(ast_node *ast, uint32_t arg_count) {
  sem_func_randomblob(ast, arg_count);
}

static void sem_func_sign(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // one numeric arg
  if (!sem_validate_arg_pattern("ild", ast, arg_count)) {
    return;
  }

  if (enforcement.strict_sign_function) {
    if (CURRENT_EXPR_CONTEXT_IS_NOT(SEM_EXPR_CONTEXT_NONE)) {
      report_error(
        ast,
        "CQL0452: function may not be used in SQL because it is not supported on old versions of SQLite",
        name
      );
      record_error(ast);
      return;
    }
  }

  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_INTEGER, arg_list);
}

static void sem_func_abs(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_arg_pattern("ild", ast, arg_count)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);

  // abs() will be the same type as arg, sensitivity, nullability preserved;
  name_ast->sem = ast->sem = new_sem_std(arg->sem->sem_type, arg_list);

  // preserve the kind of the arg
  ast->sem->kind = arg->sem->kind;
}

static void sem_func_char(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // char rewritten to only appear inside of SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("fil,[fil,*]", ast, arg_count)) {
    return;
  }

  // char() will always return a string, sensitivity param is preserved.
  // char return null if params doesn't have a character representation
  // of the unicode code point values of integers table
  // e.g: select char(1) -> NULL; select char(67); -> "C"
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);
  copy_nullability(ast, 0);

  // ast->sem->name is not set here because e.g. char(x) is not named "x"
  // the result has no 'kind'
}

// The attest notnull family are CQL builtin functions that return a value of a
// nonnull type when given a nullable value, either after some runtime check is
// performed (in the case of ifnull_throw and ifnull_crash, which are used
// directly by the programmer), or not (in the case of cql_inferred_notnull, which
// will only show up as the product of rewrite rules).
static void sem_func_attest_notnull(ast_node *ast, uint32_t arg_count, uint32_t valid_contexts) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_context(ast, name, valid_contexts)) {
    return;
  }

  if (!sem_validate_arg_pattern("fildsbo", ast, arg_count)) {
    return;
  }

  ast_node *arg1 = first_arg(arg_list);
  sem_t sem_type = arg1->sem->sem_type;

  if (is_null_type(sem_type) || is_not_nullable(sem_type)) {
    report_error(arg1, "CQL0344: argument must be a nullable type (but not constant NULL) in", name);
    record_error(ast);
    return;
  }

  ast->sem = arg1->sem;
  sem_add_flags(ast, SEM_TYPE_NOTNULL); // note this makes a copy
  name_ast->sem = ast->sem;
}

// uses attest notnull semantic helper
static void sem_func_ifnull_throw(ast_node *ast, uint32_t arg_count) {
  sem_func_attest_notnull(ast, arg_count, SEM_EXPR_CONTEXT_NONE);

  // "throw" implies that we have a return code which implies all of the proc
  // things as surely as if we had used the database.  We need to be a proc
  // with a result code.
  has_dml = 1;
}

// uses attest notnull semantic helper
static void sem_func_ifnull_crash(ast_node *ast, uint32_t arg_count) {
  sem_func_attest_notnull(ast, arg_count, SEM_EXPR_CONTEXT_NONE);
}

// Special function that tells us the expression as been already verified to be not null
// due to control flow or other context.
static void sem_special_func_cql_inferred_notnull(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT_NOTNULL(arg_list, call_arg_list->right);

  // Since we're checking a call to `cql_inferred_notnull`, its arguments have
  // already been rewritten and we don't want to do it again. Setting
  // `is_analyzing_notnull_rewrite` prevents that.
  is_analyzing_notnull_rewrite = true;
  sem_arg_list(arg_list, IS_NOT_COUNT);
  is_analyzing_notnull_rewrite = false;

  // Our argument is just a reference to something already analyzed previously,
  // so we could not have possibly failed.
  Invariant(!is_error(arg_list));

  // This compiles to nothing for SQLite so we can allow all contexts.
  sem_func_attest_notnull(ast, arg_count, SEM_EXPR_CONTEXT_FLAGS);
  Invariant(ast->sem->sem_type & SEM_TYPE_INFERRED_NOTNULL);
  // Prevent this from propagating needlessly to keep --ast clean.
  ast->sem->sem_type &= u64_not(SEM_TYPE_INFERRED_NOTNULL);
}

// validate expression with cql_cursor_diff_xxx func is semantically correct.
// cql_cursor_diff_xxx is a CQL builtin function that compare the values of a
// row between two cursors.
// Note cql_cursor_diff_xxx is also rewritten to a case_expr node
static bool_t validate_cql_cursor_diff(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // basic call already verified
  Contract(!is_error(ast));

  // already verified
  Contract(arg_count == 2);

  ast_node *arg1 = first_arg(arg_list);
  ast_node *arg2 = second_arg(arg_list);

  // already verified by function prototype
  Contract(is_auto_cursor(arg1->sem->sem_type));
  Contract(is_auto_cursor(arg2->sem->sem_type));

  // we're making sure the two argument cursors have the same shape, because we can
  // only do diffing with cursors with the same shape.
  CSTR target = dup_printf("in %s", name);
  sem_verify_identical_columns(arg1, arg2, target);
  if (is_error(arg2)) {
    record_error(ast);
    return false;
  }

  return true;
}

// This is a special function because we do not want to analyze the arguments
// until after the rewrite to a CASE expression.
static void sem_special_func_iif(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {
  Contract(is_ast_call(ast));

  if (!sem_validate_arg_count(ast, arg_count, 3)) {
    return;
  }

  // We have the right number of arguments, so we proceed to rewrite the AST to
  // a (possibly semantically invalid) case_expr node, then analyze it.
  rewrite_iif(ast);
  sem_case(ast, IS_IIF);
}

static void sem_func_upper(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // upper is rewritten to only appear in sql
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("s", ast, arg_count)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);

  // upper() will be the same type as arg, sensitivity, nullability, and kind preserved;
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);
  ast->sem->kind = arg->sem->kind;
}

// lower has the same rules as upper
static void sem_func_lower(ast_node *ast, uint32_t arg_count) {
  sem_func_upper(ast, arg_count);
}

static void sem_func_coalesce(ast_node *ast, uint32_t arg_count) {
  sem_coalesce(ast, 0);  // do not set "ifnull"
}

// This is the common part of sum and total, we just verify that
// we're dealing with numerics, we are in the right context,
// and have one arg.  Note sum with more than one arg is not supported
// in SQLite, so there's no "non-aggregate" case like min/max.
static void sem_validate_sum_or_total(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));

  if (!sem_validate_aggregate_context(ast)) {
    return;
  }

  if (!sem_validate_arg_pattern("fild", ast, arg_count)) {
    return;
  }

  record_ok(ast);
}

// Sum validation -> any numeric is ok
static void sem_aggr_func_sum(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  sem_validate_sum_or_total(ast, arg_count);
  if (is_error(ast)) {
    return;
  }

  // Sum has slightly different validation than total because of the weird
  // rules about sum over zero rows. e.g. even "select sum(1) where 0"
  // gives null.

  ast_node *arg = first_arg(arg_list);

  // This will give us a sensitive result if the argument is sensitive
  // the output will always be nullable (because SEM_TYPE_INTEGER is nullable)
  // the result will be at least integer sized, but bigger if the argument
  // is long integer or real.
  sem_t result = sem_combine_types(SEM_TYPE_INTEGER, arg->sem->sem_type);

  // set the result type accordingly
  name_ast->sem = ast->sem = new_sem(result);

  // ast->sem->name is not set here because e.g. sum(x) is not named "x"
}

// Total validation -> any numeric is ok
static void sem_aggr_func_total(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  sem_validate_sum_or_total(ast, arg_count);
  if (is_error(ast)) {
    return;
  }

  // Total has slightly different validation than sum because of the weird
  // rules about sum over zero rows. e.g. even "select sum(1) where 0"
  // gives null but "select total(1) where 0" gives 0.0.  total() always gives
  // a number.

  ast_node *arg = first_arg(arg_list);

  // set the result type accordingly
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_REAL | SEM_TYPE_NOTNULL | sensitive_flag(arg->sem->sem_type));

  // ast->sem->name is not set here because e.g. total(x) is not named "x"
}

// Substr validation -> 2 or 3 args, first arg is a string, the others are integers
static void sem_func_substr(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // substr is rewritten to only appear inside of SQL
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  if (!sem_validate_arg_pattern("s,fild,[fild]", ast, arg_count)) {
    return;
  }

  ast_node *arg1 = first_arg(arg_list);
  ast_node *arg2 = second_arg(arg_list);

  // We try to evaluate arg2 as a constant, if we can do so and if we get zero
  // then the user has made a mistake.  The indices are 1 based.
  eval_node result = EVAL_NIL;
  eval(arg2, &result);
  if (result.sem_type != SEM_TYPE_ERROR && result.sem_type != SEM_TYPE_NULL) {
    eval_cast_to(&result, SEM_TYPE_LONG_INTEGER);
    if (result.int64_value == 0) {
      report_error(arg2, "CQL0406: substr uses 1 based indices, the 2nd argument of substr may not be zero", NULL);
      record_error(arg2);
      record_error(ast);
      return;
    }
  }

  // The result is nonnull if all arguments are nonnull, and sensitive if any
  // arguments are sensitive.
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);
  // applying substr loses the name, SQLite doesn't recognize substr(foo, ..) as foo

  // preserve the string 'kind' even though it's a substring (that seems the most sensible)
  ast->sem->kind = arg1->sem->kind;
}

static void sem_func_substring(ast_node *ast, uint32_t arg_count) {
  sem_func_substr(ast, arg_count);
}

// Validates SQLite's replace(input, find, replace_with) function.
static void sem_func_replace(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // All three arguments must be provided.
  if (!sem_validate_arg_pattern("s,s,s", ast, arg_count)) {
    return;
  }

  // The replace function is rewritten to only appear in SQL.
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  ast_node *arg1 = first_arg(arg_list);

  // The result is nonnull if all arguments are nonnull, and sensitive if any
  // arguments are sensitive.
  name_ast->sem = ast->sem = new_sem_std(SEM_TYPE_TEXT, arg_list);

  // The result has the same kind as arg1
  ast->sem->kind = arg1->sem->kind;
}

// generic function to do basic validation for builtin window functions.
static void sem_validate_window_func(
  ast_node *ast,
  uint32_t arg_count_actual,
  uint32_t arg_count_needed_min,
  uint32_t arg_count_needed_max,
  sem_t sem_func_return) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)

  if (!sem_validate_window_context(ast)) {
    return;
  }

  if (arg_count_actual < arg_count_needed_min || arg_count_actual > arg_count_needed_max) {
    // this will fail, but it generates the error for us nicely
    sem_validate_arg_count(ast, arg_count_needed_max, arg_count_actual);
    return;
  }

  name_ast->sem = ast->sem = new_sem(sem_func_return);
}

// Validation of the builtin window function row_number(...). It takes 0 arguments
static void sem_func_row_number(ast_node *ast, uint32_t arg_count) {
  sem_validate_window_func(ast, arg_count, 0, 0, SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);
}

// Validation of the builtin window function rank(...). It takes 0 arguments
static void sem_func_rank(ast_node *ast, uint32_t arg_count) {
  sem_validate_window_func(ast, arg_count, 0, 0, SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);
}

// Validation of the builtin window function dense_rank(...). It takes 0 arguments
static void sem_func_dense_rank(ast_node *ast, uint32_t arg_count) {
  sem_validate_window_func(ast, arg_count, 0, 0, SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);
}

// Validation of the builtin window function percent_rank(...). It takes 0 arguments
static void sem_func_percent_rank(ast_node *ast, uint32_t arg_count) {
  sem_validate_window_func(ast, arg_count, 0, 0, SEM_TYPE_REAL | SEM_TYPE_NOTNULL);
}

// Validation of the builtin window function cume_dist(...). It takes 0 arguments
static void sem_func_cume_dist(ast_node *ast, uint32_t arg_count) {
  sem_validate_window_func(ast, arg_count, 0, 0, SEM_TYPE_REAL | SEM_TYPE_NOTNULL);
}

// Validation of the builtin window function ntile(...). It takes one integer argument
static void sem_func_ntile(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  sem_validate_window_func(ast, arg_count, 1, 1, SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);
  if (is_error(ast)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);
  if (!is_num_int_in_range(arg, 1, INT_MAX)) {
    report_error(ast, "CQL0300: argument must be an integer (between 1 and max integer) in function", name);
    record_error(ast);
    record_error(arg_list);
    return;
  }

  ast->sem->sem_type |= sensitive_flag(arg->sem->sem_type);

  // ast->sem->name is not set here because e.g. ntile(x) is not named "x"
}

// Validation of the builtin window function lag(...). It takes three parameters
// with two of them optional.
static void sem_func_lag(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  sem_t combined_flags = 0;

  sem_validate_window_func(ast, arg_count, 1, 3, SEM_TYPE_OK);
  if (is_error(ast)) {
    return;
  }

  // all args have already had their own semantic check done in sem_expr_call, we don't do it again.
  // we're only going to check how the args relate to each other and compute the final semantic type.
  ast_node *arg1 = first_arg(arg_list);

  if (arg_count > 1) {
    ast_node *arg2 = second_arg(arg_list);
    if (!is_num_int_in_range(arg2, 0, INT_MAX)) {
      report_error(ast, "CQL0301: second argument must be an integer (between 0 and max integer) in function", name);
      record_error(ast);
      record_error(arg_list);
      return;
    }
  }

  if (arg_count > 2) {
    ast_node *arg3 = third_arg(arg_list);

    // Note arg3 is a default value for arg1, to be used if the offset in arg2 results in us going off the
    // end of the partition, so arg1 can't be evaluated.  This means we aren't truly doing an assignment
    // assignment here.  But we are trying to keep the save result type though because if arg3 caused the
    // result type to get bigger (e.g. arg3 is real and arg1 is an integer) that's probably just wrong.
    // But, we are allowing the nullability and sensitivity bits to mix.  So if arg3 is sensitive the
    // entire result becomes sensitive.  And if arg3 is nullable the result becomes nullable.  Note that
    // because arg2 might be out of the buffer the only way to get not nullable is if arg2 is not nullable
    // AND arg3 is not nullable.  This is actually just the normal not null combination logic.  And sensitivity
    // will combine in the normal way too.
    // So what we're about to do here is do the normal assignment checks but suppress the error if arg3 is
    // sensitive and arg1 isn't by pretending arg1 is sensitive. And suppress the error if arg3 is nullable
    // and arg1 isn't by pretending arg3 is not nullable. This leaves us with the numeric compatibility checks
    // and lossy conversions and such.  Note that if arg1 is a real, then arg3 can be an integer, that's fine!
    // Exact type match isn't required and that's what this logic is all about.

    sem_t arg1_effective = arg1->sem->sem_type | SEM_TYPE_SENSITIVE;
    sem_t arg3_effective = arg3->sem->sem_type | SEM_TYPE_NOTNULL;

    bool_t ok = sem_verify_assignment(arg3, arg1_effective, arg3_effective, "arg3 used as default value for arg1");

    // now check the type<kind>

    if (ok) {
      sem_combine_kinds(arg3, arg1->sem->kind);
      ok = !is_error(arg3);
    }

    if (!ok) {
      report_error(ast, "CQL0302: first and third arguments must be compatible in function", name);
      record_error(ast);
      record_error(arg_list);
      return;
    }

    // sensitivity and nullability combine as usual.  Note that if arg1 is nullable and arg3 is not nullable
    // even though it is the default value for arg1 it is NOT USED unless arg1 and offset is outside the window
    // so normal nulls in the window can stay.  As a result this is no coalesce or anything like that. This is
    // just a normal nullability and sensitivity combo.
    combined_flags = combine_flags(arg1->sem->sem_type, arg3->sem->sem_type);
  }
  else {
    // with no default value, we might get nulls if we are out of the window, so notnull is stripped!
    combined_flags = sensitive_flag(arg1->sem->sem_type);
  }

  // we only copy core type to strip extra flag like not nullable. e.g: even though arg1 may
  // not be nullable, lag() should still be nullable unless the third argument is not.
  sem_t type = core_type_of(arg1->sem->sem_type);

  ast->sem = arg1->sem;
  sem_replace_flags(ast, type | combined_flags);
  name_ast->sem = ast->sem;
}

// Validation of the builtin window function lead(...). It takes three parameters
// with two of them optional.
static void sem_func_lead(ast_node *ast, uint32_t arg_count) {
  // semantically lead() is the same as lag() therefore we can use the same code.
  sem_func_lag(ast, arg_count);
}

// Validation of the builtin window function first_value(...). It takes one expression parameter
static void sem_func_first_value(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  sem_validate_window_func(ast, arg_count, 1, 1, SEM_TYPE_OK);
  if (is_error(ast)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);
  ast->sem->sem_type = arg->sem->sem_type;

  ast->sem->kind = arg->sem->kind;
  // ast->sem->name is not set here because e.g. first_value(x) is not named "x"
}

// Validation of the builtin window function last_value(...). It takes one expression parameter
static void sem_func_last_value(ast_node *ast, uint32_t arg_count) {
  sem_func_first_value(ast, arg_count);
}

// Validation of the builtin window function nth_value(...). It takes two parameters
static void sem_func_nth_value(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  sem_validate_window_func(ast, arg_count, 2, 2, SEM_TYPE_OK);
  if (is_error(ast)) {
    return;
  }

  ast_node *arg1 = first_arg(arg_list);
  ast_node *arg2 = second_arg(arg_list);
  if (!is_num_int_in_range(arg2, 1, INT_MAX)) {
    report_error(ast, "CQL0303: second argument must be an integer between 1 and max integer in function", name);
    record_error(ast);
    record_error(arg_list);
    return;
  }

  sem_t sem_type = arg1->sem->sem_type;
  // we only copy core type to strip extra flag like not null. e.g: even though arg1 may
  // not be nullable, nth_value() should still be nullable.
  ast->sem->sem_type = core_type_of(sem_type) | sensitive_flag(sem_type);

  name_ast->sem->kind = arg1->sem->kind;
  // ast->sem->name is not set here because e.g. nth_value(x) is not named "x"
}

// The group_concat function has an optional separator, otherwise
// it accepts anything and it results in a string.
static void sem_aggr_func_group_concat(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_aggregate_context(ast)) {
    return;
  }

  if (!sem_validate_arg_pattern("fildsb,[s]", ast, arg_count)) {
    return;
  }

  // Note that group concat should preserve sensitivity but it cannot
  // preserve nullability, because even an non-null text field
  // might group_concat into null.  Example:
  //   select group_concat('not_null') from sqlite_master where 0;
  //   -> NULL
  // i.e. if there are no rows to concat you get NULL not an empty string
  // so we have to assume group_concat might return null.
  // All SQL systems I tested agree on this, it's not even unique to SQLite

  ast_node *arg1 = first_arg(arg_list);
  sem_t sem_type = arg1->sem->sem_type;
  sem_t combined_flags = sensitive_flag(sem_type);

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_TEXT | combined_flags);

  // ast->sem->name is not set here because e.g. group_concat(x) is not named "x"
  // group_concat has no kind, leave that null too
}

// All of the date formats are strings until converted to something else.
// Validate the format args, nothing else is really needed.
static void sem_strftime(ast_node *ast, uint32_t arg_count, bool_t has_format, sem_t sem_type) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // strftime can appear reasonably in most places, notably not as a LIMIT or
  // OFFSET; also not supported without a context

  // these are all rewritten to sql context
  Contract(sem_validate_appear_inside_sql_stmt(ast));

  CSTR arg_pattern = has_format ? "s,s,[s,*]" : "s,[s,*]";

  if (!sem_validate_arg_pattern(arg_pattern, ast, arg_count)) {
    return;
  }

  // Handling the very special case of strftime('%s', 'now') as returning not null
  // this is super common.  This is just a format, and the known safe format.
  if (arg_count == 2 && has_format) {
    ast_node *first = first_arg(arg_list);
    ast_node *second = second_arg(arg_list);
    if (is_ast_str(first) && is_ast_str(second)) {
       EXTRACT_STRING(arg1, first);
       EXTRACT_STRING(arg2, second);
       if (!strcmp(arg1, "'%s'") && !strcmp(arg2, "'now'")) {
         // 'now' can't be used in a contraint, not deterministic
         if (!sem_validate_sql_not_constraint(ast)) {
           return;
         }

         sem_type |= SEM_TYPE_NOTNULL;
      }
    }
  }

  // the common special case of just a time string and it's the 'now' literal
  if (arg_count == 1 && !has_format) {
    ast_node *first = first_arg(arg_list);
    if (is_ast_str(first)) {
      EXTRACT_STRING(arg1, first);
      if (!strcmp(arg1, "'now'")) {
        // 'now' can't be used in a contraint, not deterministic
        if (!sem_validate_sql_not_constraint(ast)) {
          return;
        }

        sem_type |= SEM_TYPE_NOTNULL;
      }
    }
  }

  // Without validating a lot of logic for strftime, we must assume that the
  // result is nullable, as any modifier param may render the result NULL.
  name_ast->sem = ast->sem = new_sem(sem_type);
}

#define HAS_FORMAT true
#define NO_FORMAT false

static void sem_func_strftime(ast_node *ast, uint32_t arg_count) {
  sem_strftime(ast, arg_count, HAS_FORMAT, SEM_TYPE_TEXT);
}

static void sem_func_date(ast_node *ast, uint32_t arg_count) {
  sem_strftime(ast, arg_count, NO_FORMAT, SEM_TYPE_TEXT);
}

static void sem_func_time(ast_node *ast, uint32_t arg_count) {
  sem_strftime(ast, arg_count, NO_FORMAT, SEM_TYPE_TEXT);
}

static void sem_func_datetime(ast_node *ast, uint32_t arg_count) {
  sem_strftime(ast, arg_count, NO_FORMAT, SEM_TYPE_TEXT);
}

static void sem_func_julianday(ast_node *ast, uint32_t arg_count) {
  sem_strftime(ast, arg_count, NO_FORMAT, SEM_TYPE_REAL);
}

// The "ptr" function is used to get the memory address of an object at runtime
// as a LONG INT. This is useful when calling SQLite functions as they are
// unable to deal with objects directly.
static void sem_special_func_ptr(ast_node *ast, uint32_t arg_count, bool_t *is_aggregate) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  PUSH_EXPR_CONTEXT(SEM_EXPR_CONTEXT_UDF);
  sem_arg_list(arg_list, IS_NOT_COUNT);
  if (arg_list && is_error(arg_list)) {
    record_error(ast);
    return;
  }
  POP_EXPR_CONTEXT();

  if (!sem_validate_arg_count(ast, arg_count, 1)) {
    return;
  }

  // this method is really only interesting for passing pointers around sql stuff
  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);
}

// The "sensitive" function is used to take something that is
// not sensitive  and have it be treated as sensitive.  This is really
// only needed to get argument types to match in compound select
// statements or other similar situations.
static void sem_func_sensitive(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_arg_count(ast, arg_count, 1)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);

  // add sensitive
  ast->sem = arg->sem;
  sem_add_flags(ast, SEM_TYPE_SENSITIVE); // note this makes a copy
  name_ast->sem = ast->sem;
}

// The "nullable" function is used to take something that is
// not nullable and have it be treated as nullable.  This is really
// only needed to get argument types to match in compound select
// statements or other similar situations.
static void sem_func_nullable(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_arg_pattern("fildsbo", ast, arg_count)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);

  // strip away not null if present, keep other flags (like sensitive)
  ast->sem = arg->sem;
  sem_remove_flags(ast, SEM_TYPE_NOTNULL); // note this makes a copy
  name_ast->sem = ast->sem;
}

// This is a helper method that performs validation for builtin functions that have no arguments
// and only require a database connection. They are fair game in most places and since they take
// no args, not a lot can go wrong.
static bool sem_validate_db_func_with_no_args(ast_node *ast, uint32_t arg_count) {
  has_dml = true;

  if (!sem_validate_arg_pattern("", ast, arg_count)) {
    return false;
  }

  // DB functions can appear reasonably in most places, but not for grouping or limiting
  // and not in constraints (not deterministic) (this is for 'changes' and 'last_insert_rowid'
  if (!sem_validate_function_context(ast,
          SEM_EXPR_CONTEXT_SELECT_LIST |
          SEM_EXPR_CONTEXT_ON |
          SEM_EXPR_CONTEXT_WHERE |
          SEM_EXPR_CONTEXT_HAVING |
          SEM_EXPR_CONTEXT_UDF |
          SEM_EXPR_CONTEXT_NONE)) {
            return false;
  }

  return true;
}

// The random function gives you a random long_int
static void sem_func_random(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);

  if (!sem_validate_arg_count(ast, arg_count, 0)) {
    return;
  }

  if (!sem_validate_sql_not_constraint(ast)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);
}

// The likelihood function is a no-op function used for query optimizations.
// It tells the query planner how probable this expression is
static void sem_func_likelihood(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_arg_pattern("fildsb,d", ast, arg_count)) {
    return;
  }

  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);

  // the function return type matches the argument type
  name_ast->sem = ast->sem = new_sem_std(arg->sem->sem_type, arg_list);
  ast->sem->kind = arg->sem->kind;
}

// sqlite_offset returns the offset of the expression. Kind of like
// &foo in its storage. If foo is not a thing that has an "lvalue"
// you get null.  e.g. foo+1
static void sem_func_sqlite_offset(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)

  // no object, no null literal
  if (!sem_validate_arg_pattern("fildsb", ast, arg_count)) {
    return;
  }

  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  // long nullable return type
  // expressions that are not columns in a table return null
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_LONG_INTEGER);
}

// loads the named extension using the given entry point if provided
static void sem_func_load_extension(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)

  // no object, no null literal
  if (!sem_validate_arg_pattern("s,[s]", ast, arg_count)) {
    return;
  }

  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  // this function actually always returns null but there is
  // no good way to encode that.  SEM_TYPE_NULL means the
  // NULL literal. So arbitarily we use a nullable bool.
  // The bool will always be null.
  name_ast->sem = ast->sem = new_sem(SEM_TYPE_BOOL);
}

// The likely function is a no-op function used for query optimizations.
// It tells the query planner that the given (one) argument is probably a boolean value of `true`.
static void sem_func_likely(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (!sem_validate_arg_pattern("fildsb", ast, arg_count)) {
    return;
  }

  if (!sem_validate_appear_inside_sql_stmt(ast)) {
    return;
  }

  ast_node *arg = first_arg(arg_list);

  // the function return type matches the argument type
  name_ast->sem = ast->sem = new_sem_std(arg->sem->sem_type, arg_list);
  ast->sem->kind = arg->sem->kind;
}

// same rules as "likely"
static void sem_func_unlikely(ast_node *ast, uint32_t arg_count) {
   sem_func_likely(ast, arg_count);
}

// The changes function is used to get the integer number of rows changed
// by the most recent update/insert/delete.
static void sem_func_changes(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);

  if (!sem_validate_db_func_with_no_args(ast, arg_count)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);
}

// The total_changes() function returns the number of row changes caused by
// INSERT, UPDATE or DELETE statements since the current database connection was
// opened. This function is a wrapper around the sqlite3_total_changes64() C/C++
// interface.
static void sem_func_total_changes(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);

  if (!sem_validate_db_func_with_no_args(ast, arg_count)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);
}

// The sqlite_source_id() function returns a string that identifies the specific
// version of the source code that was used to build the SQLite library. The
// string returned by sqlite_source_id() is the date and time that the source
// code was checked in followed by the SHA3-256 hash for that check-in. This
// function is an SQL wrapper around the sqlite3_sourceid() C interface
static void sem_func_sqlite_source_id(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);

  if (!sem_validate_db_func_with_no_args(ast, arg_count)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_TEXT | SEM_TYPE_NOTNULL);
}

// The sqlite_version() function returns the version string for the SQLite
// library that is running. This function is an SQL wrapper around the
// sqlite3_libversion() C-interface
static void sem_func_sqlite_version(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);

  if (!sem_validate_db_func_with_no_args(ast, arg_count)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_TEXT | SEM_TYPE_NOTNULL);
}

// The last_insert_rowid function is used to get the rowid of the most recently inserted row with a rowid.
static void sem_func_last_insert_rowid(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);

  if (!sem_validate_db_func_with_no_args(ast, arg_count)) {
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);
}

// Given an already analyzed argument list, an AST to use for reporting errors
// in the format string, the decoded format string itself, and the name of the
// procedure being called, verify that the format string is valid and that the
// arguments provided match up appropriately. Returns `true` if successful, else
// `false`.
static bool_t sem_validate_args_for_format(
  ast_node *arg_list,
  ast_node *format_strlit,
  CSTR format_string,
  CSTR proc_name)
{
  Contract(!arg_list || is_ast_arg_list(arg_list));
  Contract(is_strlit(format_strlit));

  // Allocate space for a `printf_iterator`, then initialize it with
  // `format_strlit` (so any errors in the format string itself will report the
  // location of the string literal) and the decoded format string.
  printf_iterator *iterator = minipool_alloc(ast_pool, (uint32_t)sizeof_printf_iterator);
  printf_iterator_init(iterator, format_strlit, format_string);

  // Iterate over the arguments, checking them against the format string (and
  // validating the format string itself) as we go.
  for (ast_node *arg_item = arg_list; arg_item; arg_item = arg_item->right) {
    sem_t sem_type = printf_iterator_next(iterator);
    if (sem_type == SEM_TYPE_ERROR) {
      return false;
    }
    if (sem_type == SEM_TYPE_OK) {
      report_error(arg_list, "CQL0422: more arguments provided than expected by format string", proc_name);
      return false;
    }
    ast_node *arg = arg_item->left;
    if (!sem_verify_assignment(arg, sem_type, core_type_of(arg->sem->sem_type), proc_name)) {
      return false;
    }
  }

  // We're out of arguments. Verify that we're out of substitutions too and that
  // no errors are lurking later in the format string.
  sem_t sem_type = printf_iterator_next(iterator);
  if (sem_type == SEM_TYPE_ERROR) {
    return false;
  }
  if (sem_type != SEM_TYPE_OK) {
    report_error(arg_list, "CQL0423: fewer arguments provided than expected by format string", proc_name);
    return false;
  }

  return true;
}

// Returns the decoded format string (i.e., the string literal absent the
// surrounding quotes) for initializing a `printf_iterator`.
static CSTR format_string_from_format_strlit(ast_node *format_strlit) {
  Contract(is_ast_str(format_strlit));

  CSTR result;

  EXTRACT_STRING(encoded_format_string, format_strlit);
  CHARBUF_OPEN(format_string_buf);
  cg_decode_string_literal(encoded_format_string, &format_string_buf);
  result = Strdup(format_string_buf.ptr);
  CHARBUF_CLOSE(format_string_buf);

  return result;
}

// The printf function converts its arguments to a string. It must be called
// with a string literal containing the format string as its first argument.
static void sem_func_printf(ast_node *ast, uint32_t arg_count) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  if (arg_count == 0) {
    // use the standard helper to report the error
    sem_validate_arg_count(ast, arg_count, 1);
    return;
  }

  // printf can appear reasonably in most places, notably not as a LIMIT or OFFSET
  if (!sem_validate_function_context(ast,
        SEM_EXPR_CONTEXT_SELECT_LIST |
        SEM_EXPR_CONTEXT_ON |
        SEM_EXPR_CONTEXT_HAVING |
        SEM_EXPR_CONTEXT_WHERE |
        SEM_EXPR_CONTEXT_GROUP_BY |
        SEM_EXPR_CONTEXT_ORDER_BY |
        SEM_EXPR_CONTEXT_CONSTRAINT |
        SEM_EXPR_CONTEXT_UDF |
        SEM_EXPR_CONTEXT_NONE))
  {
    return;
  }

  // Verify that the first argument is a string literal.
  ast_node *format_strlit = first_arg(arg_list);
  if (!is_strlit(format_strlit)) {
    report_error(ast, "CQL0421: first argument must be a string literal", name);
    record_error(ast);
    return;
  }

  CSTR format_string = format_string_from_format_strlit(format_strlit);

  // Verify that the arguments are appropriate for the format string provided.
  ast_node *args_for_format = arg_list->right;
  if (!sem_validate_args_for_format(args_for_format, format_strlit, format_string, name)) {
    record_error(ast);
    return;
  }

  name_ast->sem = ast->sem = new_sem(SEM_TYPE_TEXT | SEM_TYPE_NOTNULL);

  // We do not require that the types implied by the format string match the
  // types of the arguments exactly -- the former is allowed to be larger than
  // the latter -- but they must match in the generated code when we're using
  // printf outside SQL. Calling `rewrite_printf_inserting_casts_as_needed` will
  // insert casts appropriately such that the types match up exactly.
  if (current_expr_context == SEM_EXPR_CONTEXT_NONE) {
    // We use a static variable to keep track of whether or not we're currently
    // in the process of a rewrite: `rewrite_printf_inserting_casts_as_needed`
    // will call `sem_expr` to validate the rewrite and we don't want to loop
    // forever.
    static bool_t is_rewriting = false;
    if (!is_rewriting) {
      is_rewriting = true;
      rewrite_printf_inserting_casts_as_needed(ast, format_string);
      is_rewriting = false;
    }
  }
}

static void sem_func_format(ast_node *ast, uint32_t arg_count) {
  sem_func_printf(ast, arg_count);
}

// Compute the semantic type of each argument, this is minimally necessary
// If any arguments are not internally consistent report that error.
static void sem_validate_args(ast_node *ast, ast_node *arg_list) {
  for (ast_node *item = arg_list; item; item = item->right) {
    EXTRACT_ANY(expr, item->left);
    sem_expr(expr);
    if (is_error(expr)) {
      record_error(ast);
      record_error(arg_list);
      return;
    }
  }
  record_ok(ast);
}

// User defined function, this is an external function
// There are a few things to check:
//  * If this is declared without the select keyword then
//     * we can't use these in SQL, so this has to be a loose expression
//  * If this is declared with the select keyword then
//     * we can ONLY use these in SQL, not in a loose expression
//  * args have to be checked and compatible with formals
static void sem_user_func(ast_node *ast, ast_node *user_func) {
  Contract(is_ast_call(ast));
  Contract(user_func);
  bool_t select_func = is_ast_declare_select_func_no_check_stmt(user_func) || is_ast_declare_select_func_stmt(user_func);
  bool_t non_select_func = is_ast_declare_func_no_check_stmt(user_func) || is_ast_declare_func_stmt(user_func);
  bool_t no_check = is_ast_declare_select_func_no_check_stmt(user_func) || is_ast_declare_func_no_check_stmt(user_func);
  Contract(select_func || non_select_func);
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_NOTNULL(func_params_return, user_func->right);
  EXTRACT(params, func_params_return->left);
  EXTRACT_ANY_NOTNULL(ret_data_type, func_params_return->right);
  bool_t sql_udf_context = false;


  if (!select_func) {
    if (CURRENT_EXPR_CONTEXT_IS_NOT(SEM_EXPR_CONTEXT_NONE)) {
      report_error(ast, "CQL0088: user function may not appear in the context of a SQL statement", name);
      record_error(ast);
      return;
    }

    // normal declare function call
    sql_udf_context = false;
  }
  else {
    // Must be a select func (is_ast_declare_select_func or is_ast_declare_select_func_no_check) case (verified above)
    if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {
      report_error(ast, "CQL0089: user function may only appear in the context of a SQL statement", name);
      record_error(ast);
      return;
    }

    EXTRACT_MISC_ATTRS(user_func, misc_attrs);
    bool_t deterministic = misc_attrs && !!find_named_attr(misc_attrs, "deterministic");

    // forbid non-deterministic UDF in an constraint
    if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_CONSTRAINT) && !deterministic) {
      report_error(ast, "CQL0393: not deterministic user function cannot appear in a constraint expression ", name);
      record_error(ast);
      return;
    }

    sql_udf_context = true;
  }

  if (is_struct(user_func->sem->sem_type)) {
    report_error(ast, "CQL0395: table valued functions may not be used in an expression context", name);
    record_error(ast);
    return;
  }

  // Skip argument type checking for select_func_no_check
  if (no_check) {
    record_ok(ast);
  }
  else {
    if (sql_udf_context) {
      PUSH_EXPR_CONTEXT(SEM_EXPR_CONTEXT_UDF);
        sem_validate_args_vs_formals(ast, name, arg_list, params, NORMAL_CALL);
      POP_EXPR_CONTEXT();
    }
    else {
      sem_validate_args_vs_formals(ast, name, arg_list, params, NORMAL_CALL);
    }
  }

  if (!is_error(ast)) {
    ast->sem = ret_data_type->sem;
  }
}

// We're looking for this shape, simple select with just the skeleton
// We already have a helper for most of this...
//  | {select_stmt}: select: { sum: integer }
//    | {select_core_list}: select: { sum: integer }
//    | | {select_core}: select: { sum: integer }
//    |   | {select_expr_list_con}: select: { sum: integer }
//    |     | {select_expr_list}: select: { sum: integer }
//    |       | ....
//    |     | {select_from_etc}:
//    | {select_orderby}
//      | {select_limit}
//        | {select_offset}
bool_t is_no_clause_simple_select(ast_node *select_stmt) {
  // accept only if simple select statement (no WITH variants etc.)
  if (is_ast_select_stmt(select_stmt)) {
    EXTRACT_NOTNULL(select_core_list, select_stmt->left);

    // accept only if not compound select
    if (!select_core_list->right) {
      EXTRACT_NOTNULL(select_core, select_core_list->left);
      EXTRACT_NOTNULL(select_expr_list_con, select_core->right);
      EXTRACT_NOTNULL(select_from_etc, select_expr_list_con->right);
      EXTRACT_NOTNULL(select_orderby, select_stmt->right);

      // no from clause and none of the extras either (WHERE, HAVING, ORDER BY etc.)
      return !select_from_etc->left && !sem_has_extra_clauses(select_from_etc, select_orderby);
    }
  }

  return false;
}

static bool_t find_shared_cte_with_args(ast_node *cte_body, void *context, charbuf *buffer) {
  EXTRACT_NOTNULL(call_stmt, cte_body->left);
  EXTRACT(arg_list, call_stmt->right);
  *(bool_t *)context |= arg_list != NULL;

  return false;
}

static bool_t has_nested_shared_cte_with_args(ast_node *stmt) {
  Contract(is_ast_select_stmt(stmt));
  bool_t found_nested_shared_cte_with_args = false;

  CHARBUF_OPEN(sql);
  gen_set_output_buffer(&sql);
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.cte_proc_context = &found_nested_shared_cte_with_args;
  callbacks.cte_proc_callback = find_shared_cte_with_args;
  gen_statement_with_callbacks(stmt, &callbacks);
  CHARBUF_CLOSE(sql);

  return found_nested_shared_cte_with_args;
}

// validate shared fragment call:
//  * target has no errors
//  * target is a shared fragment
//    * target therefore a single select statement
//    * target therefore has no out-arguments
//  * target has no select clauses like FROM etc.
//  * target has one column, it's just a SQL expression
static void sem_validate_expression_fragment(ast_node *ast, ast_node *proc) {
  Contract(is_ast_call(ast));
  Contract(is_proc(proc));

  EXTRACT_STRING(proc_name, get_proc_name(proc));
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);
  EXTRACT_NOTNULL(proc_params_stmts, proc->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);

  // check if we are calling a shared fragment
  if (!is_proc_shared_fragment(proc)) {
    report_error(ast,
      "CQL0224: a function call to a procedure inside SQL may call "
      "only a shared fragment i.e. [[shared_fragment]]", proc_name);
    record_error(ast);
    return;
  }

  Invariant(proc->sem->sptr);
  sem_struct *sptr = proc->sem->sptr;
  if (sptr->count > 1) {
      report_error(ast, "CQL0232: nested select expression must return exactly one column", proc_name);
      record_error(ast);
      return;
  }

  EXTRACT_ANY_NOTNULL(select_stmt, stmt_list->left);

  if (!is_no_clause_simple_select(select_stmt)) {
    report_error(ast, "CQL0450: a shared fragment used like a function must be a simple SELECT with no FROM clause", proc_name);
    record_error(ast);
    return;
  }

  if (has_nested_shared_cte_with_args(select_stmt)) {
    report_error(ast, "CQL0467: a shared fragment used like a function cannot nest fragments that use arguments", proc_name);
    record_error(ast);
    return;
  }

  sem_validate_args_vs_formals(ast, proc_name, arg_list, params, NORMAL_CALL);
  if (is_error(ast)) {
    return;
  }

  Invariant(ast->sem->sem_type == SEM_TYPE_OK);

  Invariant(sptr->count == 1);
  ast->sem = new_sem(sptr->semtypes[0]);
  ast->sem->kind = sptr->kinds[0];

  // we don't want the inline-ness to run up the tree so we just put that flag
  // bit on the proc name. The point of this is for us to note where we made an
  // inline call to a shared fragment, "inline" in a SQL context.  We will
  // need to notice this an emit it properly when we do codegen.

  ast->left->sem = new_sem(ast->sem->sem_type);
  *ast->left->sem = *ast->sem;
  ast->left->sem->sem_type |= SEM_TYPE_INLINE_CALL;
}

// Calling a stored procedure as a function
// There are a few things to check:
//  * it has to be a loose expression or else a shared fragment
//    * in this case regular arg matching happens on all arguments
//  * it returns a result set (via out union, out, or select)
//    * all args must match in this case also
//  * scalar proc as func case
//    * the last formal must be an OUT arg and it must be a scalar type
//    * that out arg will be treated as the return value of the "function"
//    * in code-gen we will create a temporary for it, semantic analysis doesn't care
static void sem_proc_as_func(ast_node *ast, ast_node *proc) {
  Contract(is_ast_call(ast));
  Contract(is_proc(proc));

  EXTRACT_STRING(proc_name, get_proc_name(proc));

  // no calling procs that had errors...
  if (is_error(proc)) {
    report_error(ast, "CQL0213: procedure had errors, can't call", proc_name);
    record_error(ast);
    return;
  }

  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT(arg_list, call_arg_list->right);

  // Ensure we have none of these forms.  There is general checking for this
  // later but by checking here we can give a more specific error message
  EXTRACT_NOTNULL(call_filter_clause, call_arg_list->left);
  EXTRACT(distinct, call_filter_clause->left);
  EXTRACT(opt_filter_clause, call_filter_clause->right);

  if (distinct || opt_filter_clause) {
    report_error(ast, "CQL0451: procedure as function call is not compatible with DISTINCT or filter clauses", proc_name);
    record_error(ast);
    return;
  }

  EXTRACT_NOTNULL(proc_params_stmts, proc->right);
  EXTRACT(params, proc_params_stmts->left);

  if (CURRENT_EXPR_CONTEXT_IS_NOT(SEM_EXPR_CONTEXT_NONE)) {
    // evaluation proceeds as an expression fragment, it fails or not
    // either way we're done with it.
    sem_validate_expression_fragment(ast, proc);
    return;
  }

  bool_t result_set_return = has_out_stmt_result(proc) || has_result_set(proc) || has_out_union_stmt_result(proc);

  bool_t validation_type = result_set_return ?  NORMAL_CALL : PROC_AS_FUNC;

  sem_validate_args_vs_formals(ast, proc_name, arg_list, params, validation_type);
  Invariant(ast->sem);  // either an error or a result

  if (result_set_return && !is_error(ast)) {
    // this call will return the result set object
    ast->sem = new_sem(SEM_TYPE_OBJECT | SEM_TYPE_NOTNULL);
    ast->sem->kind = dup_printf("%s SET", proc_name);
  }

  // The call may have mutated any or all of the currently improved globals, so
  // we simply invalidate all of them.
  sem_unset_global_notnull_improvements();

  has_dml |= is_dml_proc(proc->sem->sem_type);
}

// This validates that RAISE is being used in the context of a trigger and that
// it has the correct args.
static void sem_expr_raise(ast_node *ast, CSTR cstr) {
  Contract(is_ast_raise(ast));
  EXTRACT_OPTION(flags, ast->left);
  EXTRACT_ANY(expr, ast->right);

  Contract(flags >= RAISE_IGNORE && flags <= RAISE_FAIL);

  if (!in_trigger) {
    report_error(ast, "CQL0092: RAISE may only be used in a trigger statement", NULL);
    record_error(ast);
    return;
  }

  if (expr) {
    sem_expr(expr);
    if (is_error(expr)) {
      record_error(ast);
      return;
    }

    if (!is_text(expr->sem->sem_type)) {
      report_error(expr, "CQL0093: RAISE 2nd argument must be a string", NULL);
      record_error(ast);
      return;
    }
  }

  ast->sem = new_sem(SEM_TYPE_NULL);
}

// All we have to do is verify that the thing that is playing the role of the array
// has a type kind.  If it does then we can rewrite it into a function call.  The
// call might be to an invalid function but that's ok.  The next level of errors
// checks all that and the arguments.  The mapping gets all the usual benefits
static void sem_validate_array_transform(ast_node *ast,  CSTR op) {
  EXTRACT_ANY_NOTNULL(array, ast->left);
  sem_expr(array);
  if (is_error(array)) {
    record_error(ast);
    return;
  }

  if (!array->sem->kind) {
    report_error(array, "CQL0470: operation is only available for types with a declared type kind like object<something>", "[]");
    record_error(array);
    record_error(ast);
    return;
  }

  rewrite_array_as_call(ast, op);
  record_ok(ast);
}

// If the array transform is legal then set it up
static void sem_expr_array(ast_node *ast,  CSTR op) {
  sem_validate_array_transform(ast, "get");
  if (!is_error(ast)) {
    sem_expr(ast);
  }
}

// This validates that the call is to one of the functions that we know and
// then delegates to the appropriate shared helper function for that type
// of call for additional validation.
static void sem_expr_call(ast_node *ast, CSTR cstr) {
  Contract(is_ast_call(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast->right);
  EXTRACT_NOTNULL(call_filter_clause, call_arg_list->left);
  EXTRACT(distinct, call_filter_clause->left);
  EXTRACT(opt_filter_clause, call_filter_clause->right);
  EXTRACT(arg_list, call_arg_list->right);
  bool_t call_aggr_or_user_def_func = 0;

  // Only aggregated/user defined function can use DISTINCT keyword
  // and filter clause.
  //
  // name( [arg_list] ) filter (where expr)

  if (opt_filter_clause) {
    sem_opt_filter_clause(opt_filter_clause);
    if (is_error(opt_filter_clause)) {
      record_error(ast);
      return;
    }
  }

  // expand any FROM forms in the arg list
  if (!rewrite_shape_forms_in_list_if_needed(arg_list)) {
    record_error(ast);
    return;
  }

  uint32_t arg_count = 0;
  for (ast_node *item = arg_list; item; item = item->right) arg_count++;

  // In any aggregate function that takes a single argument, that argument can be preceded by the keyword DISTINCT
  if (distinct && (arg_count != 1 || is_ast_star(first_arg(arg_list)))) {
    report_error(ast, "CQL0304: DISTINCT may only be used with one explicit argument in an aggregate function", name);
    record_error(ast);
    return;
  }

  // check for functions
  symtab_entry *entry = symtab_find(builtin_funcs, name);
  if (!entry) {
    // check for aggregate functions
    entry = symtab_find(builtin_aggregated_funcs, name);
    if (entry) {
      call_aggr_or_user_def_func = 1;
    }
  }
  if (entry) {
     if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE) && symtab_find(builtin_sql_rewrites, name)) {
       rewrite_as_select_expr(ast);
       sem_expr(ast);
       return;
     }
  }
  if (entry) {
    sem_arg_list(arg_list, IS_NOT_COUNT);
    if (arg_list && is_error(arg_list)) {
      record_error(ast);
      return;
    }
    ((sem_func *)entry->val)(ast, arg_count);
    goto additional_checks;
  }

  // check for special functions which do their own analysis of their arguments
  entry = symtab_find(builtin_special_funcs, name);
  if (entry) {
    ((sem_special_func *)entry->val)(ast, arg_count, &call_aggr_or_user_def_func);
    goto additional_checks;
  }

  // check for user defined functions
  ast_node *user_func = find_func(name);
  if (user_func) {
    sem_user_func(ast, user_func);
    call_aggr_or_user_def_func = 1;
    goto additional_checks;
  }

  ast_node *unchecked_user_func = find_unchecked_func(name);
  if (unchecked_user_func) {
    sem_arg_list(arg_list, IS_NOT_COUNT);
    if (arg_list && is_error(arg_list)) {
      record_error(ast);
      return;
    }

    sem_user_func(ast, unchecked_user_func);
    call_aggr_or_user_def_func = 1;
    goto additional_checks;
  }

  // check for a proc that can be called as a function
  ast_node *proc = find_proc(name);
  if (proc) {
    sem_proc_as_func(ast, proc);
    if (is_error(ast)) {
      return;
    }
    goto additional_checks;
  }

  // check for an attempt to use an unchecked proc in an expression context
  ast_node *unchecked_proc = find_unchecked_proc(name);
  if (unchecked_proc) {
    report_error(name_ast, "CQL0405: procedure of an unknown type used in an expression", name);
    record_error(ast);
    return;
  }

  report_error(name_ast, "CQL0094: function not builtin and not declared", name);
  record_error(ast);
  return;

additional_checks:
  if (!StrCaseCmp(name, "cql_cursor_to_blob")) {
     Contract(arg_count == 1); // already failed if wrong
     sem_infer_result_blob_type(ast, arg_list);
  }
  else if (!is_error(ast) && (
     !StrCaseCmp(name, "cql_cursor_diff_col") ||
     !StrCaseCmp(name, "cql_cursor_diff_val") ||
     !StrCaseCmp(name, "cql_cursor_diff_index"))) {
    // the cursor diff functions need the same compatible cursor validation
    if (!validate_cql_cursor_diff(ast, arg_count)) {
      record_error(ast);
      return;
    }
  }
  if (!call_aggr_or_user_def_func) {
    if (distinct) {
      // Only aggregated functions and user defined functions that take one parameter
      // can use DISTINCT keyword e.g: SELECT COUNT(DISTINCT X)
      report_error(ast, "CQL0305: DISTINCT may only be used in function that are aggregated or user defined", name);
      record_error(ast);
      return;
    }

    if (opt_filter_clause) {
      // FILTER clause may only be used in aggregated function, user defined function and window function
      report_error(ast, "CQL0306: FILTER clause may only be used in function that are aggregated or user defined", name);
      record_error(ast);
      return;
    }
  }
}

// cql_cursor_to_blob was used in the proc_as_func form, meaning no second argument
// We have to infer the correct return type.  This code verifies that we can do that.
// We can look for the origin of the cursor and if it was a blob storage table
// then we're in good shape.
static void sem_infer_result_blob_type(ast_node *ast, ast_node *arg_list) {
  EXTRACT_ANY_NOTNULL(cursor, arg_list->left);

  CSTR sname = cursor->sem->sptr->struct_name;

  if (!sname || !find_table_or_view_even_deleted(sname)) {
     record_error(ast);
     report_error(cursor,
       "CQL0024: cursor not declared with 'LIKE table_name', blob type can't be inferred",
       cursor->sem->name);
     return;
  }

  AST_REWRITE_INFO_SET(cursor->lineno, cursor->filename);

  ast_node *blob = new_ast_str("$");
  blob->sem = new_sem(SEM_TYPE_BLOB|SEM_TYPE_NOTNULL);
  blob->sem->name = "$";
  blob->sem->kind = cursor->sem->sptr->struct_name;

  AST_REWRITE_INFO_RESET();

  // the final error is set by the helper, 'ast' will have the code regardless
  sem_validate_cursor_blob_compat(ast, cursor, blob, cursor, blob);

  if (!is_error(ast)) {
    ast->sem = blob->sem;
  }
}

#define SEM_REVERSE_APPLY_ANALYZE_CALL 1
#define SEM_REVERSE_APPLY_REWRITE_ONLY 0

static bool_t sem_reverse_apply_if_needed(ast_node *ast, bool_t analyze) {
  symtab_entry *entry = symtab_find(exprs, ast->type);
  Invariant(entry);
  sem_expr_dispatch *disp = (sem_expr_dispatch*)entry->val;
  CSTR op = disp->str;

  bool_t hard_fail = false;

  if (!strcmp(op, ":")) {
    // we need the type of the left argument to do the reverse apply
    // because the polymorphic forms want the type info.  So we try
    // to get it.  If we get any errors, we're done here, no need to rewrite
    if (!sem_try_as_cursor(ast->left, &hard_fail) && !hard_fail) {
      sem_expr(ast->left);
      hard_fail = is_error(ast->left);
    }
    if (!hard_fail) {
      if (is_ast_reverse_apply_poly_args(ast)) {
        EXTRACT_ANY_NOTNULL(arg, ast->left);
        EXTRACT_ANY(arg_list, ast->right);

        // we attempt thee replacement if the left is a cursor type or has a kind
        // struct types don't have a kind
        if (!is_struct(arg->sem->sem_type) && (!arg->sem->kind || !arg->sem->kind[0])) {
          report_error(arg, "CQL0506: left argument must have a type kind", NULL);
          record_error(ast);
          return true;
        }

        if (arg_list) {
          sem_arg_list(arg_list, IS_NOT_COUNT);
          if (is_error(arg_list)) {
            record_error(ast);
            return true;
          }
        }

        // no function name form  x:(args)
        rewrite_reverse_apply_polymorphic(ast);
      }
      else {
        // function name form  x:foo(args)
        rewrite_reverse_apply(ast);
      }

      if (analyze) {
        sem_expr_call(ast, op);
        hard_fail = is_error(ast);
      }
    }
  }

  return hard_fail;
}

// Validates the right arg of ':', and then rewrites the ast node
static void sem_reverse_apply(ast_node *ast, CSTR op) {
  Contract(is_ast_reverse_apply(ast) || is_ast_reverse_apply_poly_args(ast));
  bool_t failed = sem_reverse_apply_if_needed(ast, SEM_REVERSE_APPLY_ANALYZE_CALL);
  if (failed) {
    // error already reported if any
    record_error(ast);
  }
}

static void sem_opt_filter_clause(ast_node *ast) {
  Contract(is_ast_opt_filter_clause(ast));
  EXTRACT_NOTNULL(opt_where, ast->left);

  // FILTER ([opt_where])
  sem_opt_where(opt_where);

  ast->sem = opt_where->sem;
}

static void sem_opt_partition_by(ast_node *ast) {
  Contract(is_ast_opt_partition_by(ast));
  EXTRACT_NOTNULL(expr_list, ast->left);

  PUSH_EXPR_CONTEXT(SEM_EXPR_CONTEXT_WHERE);

  // compute semantic type of each expr, reporting errors
  sem_validate_args(ast, expr_list);

  POP_EXPR_CONTEXT();
}

static void sem_opt_frame_spec(ast_node *ast) {
  Contract(is_ast_opt_frame_spec(ast));
  EXTRACT_OPTION(flags, ast->left);
  EXTRACT_NOTNULL(expr_list, ast->right);
  EXTRACT_ANY(left_expr, expr_list->left);
  EXTRACT_ANY(right_expr, expr_list->right);

  int32_t frame_type_flags = flags & FRAME_TYPE_FLAGS;
  int32_t frame_boundary_flags = flags & FRAME_BOUNDARY_FLAGS;
  int32_t frame_boundary_start_flags = flags & FRAME_BOUNDARY_START_FLAGS;
  int32_t frame_boundary_end_flags = flags & FRAME_BOUNDARY_END_FLAGS;
  int32_t frame_exclude_flags = flags & FRAME_EXCLUDE_FLAGS;
  bool_t error = false;

  Contract(frame_type_flags && frame_exclude_flags);
  if (frame_boundary_flags) {
    Contract(!frame_boundary_start_flags && !frame_boundary_end_flags);
    if (left_expr) {
      sem_root_expr(left_expr, SEM_EXPR_CONTEXT_WHERE);
      error = is_error(left_expr);
    }
  }
  else {
    Contract(frame_boundary_start_flags && frame_boundary_end_flags);
    if (left_expr) {
      sem_root_expr(left_expr, SEM_EXPR_CONTEXT_WHERE);
      error |= is_error(left_expr);
    }
    if (right_expr) {
      sem_root_expr(right_expr, SEM_EXPR_CONTEXT_WHERE);
      error |= is_error(right_expr);
    }
  }

  if (error) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

static void sem_window_defn(ast_node *ast) {
  Contract(is_ast_window_defn(ast));
  EXTRACT(opt_partition_by, ast->left);
  EXTRACT_NOTNULL(window_defn_orderby, ast->right);
  EXTRACT(opt_orderby, window_defn_orderby->left);
  EXTRACT(opt_frame_spec, window_defn_orderby->right);
  bool_t error = false;

  if (opt_partition_by) {
    sem_opt_partition_by(opt_partition_by);
    error = is_error(opt_partition_by);
  }
  if (opt_orderby) {
    sem_opt_orderby(opt_orderby);
    error |= is_error(opt_orderby);
  }
  if (opt_frame_spec) {
    sem_opt_frame_spec(opt_frame_spec);
    error |= is_error(opt_frame_spec);
  }

  if (error) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// Check whether a window name definition was referenced
static void sem_window_reference(ast_node *ast) {
  Contract(is_ast_window_name_defn(ast));
  EXTRACT_STRING(window_name, ast->left);

  ast_node *select_expr_list_con = ast->parent;
  while (!is_ast_select_expr_list_con(select_expr_list_con)) {
    select_expr_list_con = select_expr_list_con->parent;
  }

  EXTRACT_NOTNULL(select_expr_list, select_expr_list_con->left);
  for (ast_node *item = select_expr_list; item; item = item->right) {
    EXTRACT_NOTNULL(select_expr, item->left);
    EXTRACT_ANY_NOTNULL(any_expr, select_expr->left);
    if (is_ast_window_func_inv(any_expr)) {
      EXTRACT_ANY_NOTNULL(window_name_or_defn, any_expr->right);
      if (is_ast_str(window_name_or_defn)) {
        EXTRACT_STRING(name, window_name_or_defn);
        if (!StrCaseCmp(window_name, name)) {
          record_ok(ast);
          return;
        }
      }
    }
  }

  report_error(ast->left, "CQL0296: window name definition is not used", window_name);
  record_error(ast->left);
  record_error(ast);
}

static void sem_window_name_defn(ast_node *ast) {
  Contract(is_ast_window_name_defn(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(window_defn, ast->right);

  // name AS [window_defn]
  sem_window_reference(ast);
  if (is_error(ast)) {
    return;
  }

  sem_window_defn(window_defn);
  if (is_error(window_defn)) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

static bool_t sem_window_name_defn_list(ast_node *ast) {
  Contract(is_ast_window_name_defn_list(ast));
  EXTRACT_NOTNULL(window_name_defn, ast->left);
  EXTRACT(window_name_defn_list, ast->right);
  bool_t error = false;

  if (window_name_defn_list) {
    sem_window_name_defn_list(window_name_defn_list);
    error = is_error(window_name_defn_list->left);
  }

  sem_window_name_defn(window_name_defn);
  error |= is_error(window_name_defn);

  return error;
}

static void sem_window_clause(ast_node *ast) {
  Contract(is_ast_window_clause(ast));
  EXTRACT_NOTNULL(window_name_defn_list, ast->left);
  bool_t error =false;

  // WINDOW [window_name_defn_list]
  error = sem_window_name_defn_list(window_name_defn_list);

  if (error) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// Check whether a window name was defined.
static void sem_window_name(ast_node *ast) {
  Contract(is_ast_str(ast));
  EXTRACT_STRING(window_name, ast);
  EXTRACT_NOTNULL(window_func_inv, ast->parent);

  ast_node *select_expr_list_con = window_func_inv->parent;
  while (!is_ast_select_expr_list_con(select_expr_list_con)) {
    select_expr_list_con = select_expr_list_con->parent;
  }
  EXTRACT_NOTNULL(select_from_etc, select_expr_list_con->right);
  EXTRACT_NOTNULL(select_where, select_from_etc->right);
  EXTRACT_NOTNULL(select_groupby, select_where->right);
  EXTRACT_NOTNULL(select_having, select_groupby->right);
  EXTRACT(opt_select_window, select_having->right);
  bool_t valid = false;
  if (opt_select_window) {
    EXTRACT_NOTNULL(window_clause, opt_select_window->left);
    EXTRACT_NOTNULL(window_name_defn_list, window_clause->left);
    for (ast_node *item = window_name_defn_list; item; item = item->right) {
      EXTRACT_NOTNULL(window_name_defn, item->left);
      EXTRACT_STRING(name, window_name_defn->left);
      if (!StrCaseCmp(window_name, name)) {
        valid = true;
        break;
      }
    }
  }

  if (!valid) {
    report_error(ast, "CQL0295: window name is not defined", window_name);
    record_error(ast);
    return;
  }
  record_ok(ast);
}

static void sem_window_name_or_defn(ast_node *ast) {
  bool_t error = false;

  if (is_ast_str(ast)) {
    sem_window_name(ast);
    error = is_error(ast);
  }
  else {
    Contract(is_ast_window_defn(ast));
    sem_window_defn(ast);
    error = is_error(ast);
  }

  if (error) {
    record_error(ast);
    return;
  }
  record_ok(ast);
}

// This validates that the window function call is to one of the window functions
// that we know and then delegates to the appropriate shared helper function for
// that type of window function call for additional validation. We compute the
// semantic type of all the arguments before we validate the particular function.
static void sem_expr_window_func_inv(ast_node *ast, CSTR cstr) {
  if (enforcement.strict_window_func) {
    report_error(ast, "CQL0312: window function invocation are forbidden if strict window function mode is enabled", NULL);
    record_error(ast);
    return;
  }

  Contract(is_ast_window_func_inv(ast));
  EXTRACT_NOTNULL(call, ast->left);
  EXTRACT_NOTNULL(call_arg_list, call->right);
  EXTRACT_NOTNULL(call_filter_clause, call_arg_list->left);
  EXTRACT(opt_filter_clause, call_filter_clause->right);
  EXTRACT_ANY_NOTNULL(window_name_or_defn, ast->right);

  if (CURRENT_EXPR_CONTEXT_IS_NOT(SEM_EXPR_CONTEXT_SELECT_LIST)) {
    report_error(ast, "CQL0294: window function invocations can only appear in the select list of a select statement", NULL);
    record_error(ast);
    return;
  }

  bool_t error = false;
  // We're making deferentiation between "window" context and "window filter" context because
  // FILTER clause in may only be used with aggregate window functions.
  uint32_t expr_context = opt_filter_clause ? SEM_EXPR_CONTEXT_WINDOW_FILTER : SEM_EXPR_CONTEXT_WINDOW;

  // Set expression context because some function calls may only be valid when called in a window context
  PUSH_EXPR_CONTEXT(expr_context);
  sem_expr_call(call, cstr);
  error = is_error(call);
  POP_EXPR_CONTEXT();

  sem_window_name_or_defn(window_name_or_defn);
  error |= is_error(window_name_or_defn);

  if (error) {
    record_error(ast);
    return;
  }

  ast->sem = call->sem;
}

// A top level expression defines the context for this evaluation.
// There are cases where nesting can happen that changes the context,
// e.g. you can put a nested select in a where clause and that nested select
// could legally have aggregates.  This keeps the stack of contexts.
cql_noexport void sem_root_expr(ast_node *ast, uint32_t expr_context) {
  PUSH_EXPR_CONTEXT(expr_context);
  sem_expr(ast);
  POP_EXPR_CONTEXT();
}

// This is the primary dispatch for all expression types.  We find the
// type of expression and then dispatch to the appropriate helper.  This
//  is also where the leaf types are handled (e.g. literals)
cql_noexport void sem_expr(ast_node *ast) {

  // These are all the expressions there are, we have to find it in this table
  // or else someone added a new expression type and it isn't supported yet.
  symtab_entry *entry = symtab_find(exprs, ast->type);
  Invariant(entry);
  sem_expr_dispatch *disp = (sem_expr_dispatch*)entry->val;
  disp->func(ast, disp->str);
}

// Naming of the an expression can happen in a number of places.  The way
// this is done is that whoever should get the alias remembers themselves
// as the alias target and that person then is renamed.  This is almost always
// someone's sem->name field.
static void sem_as_alias(ast_node *ast, CSTR *alias_target, ast_node *ast_target) {
  EXTRACT_STRING(name, ast->left);
  // AS [name]
  if (alias_target) {
    *alias_target = name;
  }

  if (is_qid(ast->left) && ast_target) {
    sem_add_flags(ast_target, SEM_TYPE_QID);
  }
}

// This is a possibly aliased element in the select list.  A "select expression"
// The current joinscope is already set appropriately for this evaluation by
// the caller.  There may be none (if there is no from clause).
static void sem_select_expr(ast_node *ast) {
  Contract(is_ast_select_expr(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(opt_as_alias, ast->right);

  // expr [AS alias]
  sem_root_expr(expr, SEM_EXPR_CONTEXT_SELECT_LIST);

  if (is_error(expr)) {
    ast->sem = expr->sem;
    return;
  }

  Invariant(is_unitary(expr->sem->sem_type));
  ast->sem = new_sem(expr->sem->sem_type);
  ast->sem->name = expr->sem->name;
  ast->sem->kind = expr->sem->kind;

  if (opt_as_alias) {
    sem_as_alias(opt_as_alias, &ast->sem->name, ast);
  }
}

// This validates the select list, getting the type of each element.
// If the select list is the special "*" select list, it must be the only
// element and that is handled with a special helper.
// Otherwise, get each item and validate.  At this point we compute the
// net result type of the select from the select list.
static void sem_select_expr_list(ast_node *ast) {
  Contract(ast);

  uint32_t count = 0;
  ast_node *node = ast;
  for (; node; node = node->right) {
    EXTRACT_NOTNULL(select_expr, node->left);
    sem_select_expr(select_expr);

    if (is_error(select_expr)) {
      record_error(ast);
      return;
    }

    count++;
  }

  // Here we make the struct type for this select, by enumerating
  // the types of all the columns and using the aliased name if any.
  sem_struct *sptr = new_sem_struct("_select_", count);
  ast->sem = new_sem(SEM_TYPE_STRUCT);
  ast->sem->sptr = sptr;

  int32_t i = 0;
  for (ast_node *snode = ast; snode; snode = snode->right) {
    // these have already been rewritten away
    Invariant(!is_ast_table_star(snode->left));
    Invariant(!is_ast_star(snode->left));

    EXTRACT_NOTNULL(select_expr, snode->left);

    if (select_expr->sem->name) {
      sptr->names[i] = select_expr->sem->name;
    }
    else {
      // If you do "select 1" it has no name.
      sptr->names[i] = "_anon";
    }

    // get the kind if there is one (null is ok) as that means the type has no kind
    sptr->kinds[i] = select_expr->sem->kind;

    sptr->semtypes[i] = select_expr->sem->sem_type;
    i++;
  }

  Invariant(count == i);
}

// Helper function for looking up a table in a table factor context
// This is the normal context where tables are found inside of select
// statements.  We have to search the cte space as well as the normal
// table names.  Note this is not a table alias, but an actual table
// or cte.  So we don't use this for instance to resolve "T1.x" that's
// done by normal name resolution rules.
static ast_node *sem_find_table(CSTR name, ast_node *ast_error) {
  ast_node *table_ast = find_cte(name);
  if (!table_ast) {
    table_ast = find_usable_and_not_deleted_table_or_view(
      name,
      ast_error,
      "CQL0095: table/view not defined");
    if (!table_ast) {
      record_error(ast_error);
    }
    else {
      sem_non_blob_storage_table(ast_error, table_ast);
      if (is_error(ast_error)) {
        return NULL;
      }
    }
  }
  return table_ast;
}

// A table factor is one of three things:
// * a table name (a string)  select * from X
// * a select subquery (select X,Y from..) as T2
// * a list of table references select * from (X, Y, Z)
// Here we dispatch to the appropriate helper for each case.
static void sem_table_or_subquery(ast_node *ast) {
  Contract(is_ast_table_or_subquery(ast));

  EXTRACT_ANY_NOTNULL(factor, ast->left);

  CSTR *alias_target = NULL;

  if (is_ast_str(factor)) {
    // [name]
    EXTRACT_STRING(name, factor);
    ast_node *table_ast = sem_find_table(name, ast);
    if (!table_ast) {
      return;
    }

    // If we find a backed table we need to add it to the list. We'll rewrite
    // these references at the end of the current statement.  The rewrite
    // happens only once even if a table is in this list several times.
    if (is_backed(table_ast->sem->sem_type)) {
      add_item_to_list(&backed_tables_list, ast);
    }

    sem_node *sem = new_sem(SEM_TYPE_JOIN);
    sem->jptr = sem_join_from_sem_struct(table_ast->sem->sptr);
    ast->sem = factor->sem = sem;
    alias_target = &ast->sem->jptr->names[0];
  }
  else if (is_select_variant(factor)) {
    // [SELECT ...]
    sem_any_select(factor);
    if (is_error(factor)) {
      record_error(ast);
      return;
    }

    ast->sem = new_sem(SEM_TYPE_JOIN);
    ast->sem->jptr = sem_join_from_sem_struct(factor->sem->sptr);
    alias_target = &ast->sem->jptr->names[0];
  }
  else if (is_ast_shared_cte(factor)) {
    // [CALL shared_fragment ...]
    sem_shared_cte(factor);

    if (is_error(factor)) {
      record_error(ast);
      return;
    }

    ast->sem = new_sem(SEM_TYPE_JOIN);
    ast->sem->jptr = sem_join_from_sem_struct(factor->sem->sptr);

    // shared fragment within a subquery doesn't have an alias unless
    // explicitly declared with opt_as_alias.
    ast->sem->jptr->names[0] = "_select_";
    alias_target = &ast->sem->jptr->names[0];
  }
  else if (is_ast_table_function(factor)) {
    sem_table_function(factor);

    if (is_error(factor)) {
      record_error(ast);
      return;
    }

    ast->sem = factor->sem;
    alias_target = &ast->sem->jptr->names[0];
  }
  else {
    // this is all that's left...
    sem_query_parts(factor);
    ast->sem = factor->sem;
  }

  EXTRACT(opt_as_alias, ast->right);
  if (opt_as_alias) {
    sem_as_alias(opt_as_alias, alias_target, NULL);

    // Rename this alias definition if it is aliasing a name string (i.e. not subquery, table function)
    // for query plan analysis if enabled.
    if (is_ast_str(factor) && keep_table_name_in_aliases && !in_trigger && !in_trigger_when_expr) {
      EXTRACT_STRING(table_name, factor);
      EXTRACT_STRING(original_alias_name, opt_as_alias->left)
      insert_table_alias_string_overide(opt_as_alias->left, table_name);
    }
  }
}

// When specifying joins, one of the alternatives is to give the shared
// columns in the join e.g. select * from X inner join Y using (a,b).
// This method validates that all the columns are present on both sides of the
// join, that they are unique, and they are comparable.
// The return code tells us if any columns had SENSITIVE data.
static sem_t sem_join_using_columns(ast_node *join, ast_node *join_cond, sem_join *left, sem_join *right) {
  EXTRACT_ANY_NOTNULL(cond_type, join_cond->left);
  EXTRACT_NOTNULL(name_list, join_cond->right);
  Contract(is_ast_using(cond_type));

  sem_t sem_sensitive = 0;

  if (!sem_verify_no_duplicate_names(name_list)) {
    record_error(join_cond);
    record_error(join);
    return false;
  }

  for (ast_node *ast = name_list; ast; ast = ast->right) {
    Contract(is_ast_name_list(ast));
    EXTRACT_STRING(name, ast->left);
    // [name]

    sem_t sem_type_left;
    sem_t sem_type_right;

    // check left (and only the left!)
    {
      PUSH_JOIN_BLOCK();
      PUSH_JOIN(left_join, left);
      if (!sem_find_column_for_name(ast, name)) {
        report_error(ast, "CQL0096: join using column not found on the left side of the join", name);
        record_error(join_cond);
        record_error(join);
      }
      POP_JOIN();
      POP_JOIN();

      if (is_error(join)) {
        return false;
      }

      sem_type_left = ast->sem->sem_type;
      sem_sensitive |= sensitive_flag(sem_type_left);
    }

    // and then right (and only the right!)
    {
      PUSH_JOIN_BLOCK();
      PUSH_JOIN(right_join, right);
      if (!sem_find_column_for_name(ast, name)) {
        report_error(ast, "CQL0097: join using column not found on the right side of the join", name);
        record_error(join_cond);
        record_error(join);
      }
      POP_JOIN();
      POP_JOIN();

      if (is_error(join)) {
        return false;
      }

      sem_type_right = ast->sem->sem_type;
      sem_sensitive |= sensitive_flag(sem_type_right);
    }

    if (core_type_of(sem_type_left) != core_type_of(sem_type_right)) {
      report_error(ast, "CQL0098: left/right column types in join USING(...) do not match exactly", name);
      record_error(join);
      return false;
    }
  }

  join_cond->sem = join->sem;
  return sem_sensitive;
}

// The most explicit join condition is a full expression in an ON clause
// this is like select a,b from X inner join Y on X.id = Y.id;
// The on expression should be something that can be used as a bool
// so any numeric will do.
// The return code tells us if the ON condition used SENSITIVE data.
static sem_t sem_join_cond_on(ast_node *join, ast_node *join_cond) {
  EXTRACT_ANY_NOTNULL(cond_type, join_cond->left);
  EXTRACT_ANY_NOTNULL(expr, join_cond->right);
  Contract(is_ast_on(cond_type));

  PUSH_JOIN(j, join->sem->jptr);
  sem_numeric_expr(expr, cond_type, "ON", SEM_EXPR_CONTEXT_ON);
  POP_JOIN();

  if (is_error(expr)) {
    record_error(join_cond);
    record_error(join);
    return false;
  }

  join_cond->sem = join->sem;
  return expr->sem->sem_type;
}

// A join_clause is an ast notion, it includes logically
// a table_or_subquery on the left
// the join target list on the right, which is a list of join target.
// the join target comprises
//  * the type of join
//  * the join condition (using or ON)
//  * the table factor that is to be joined (see above for legal table factors)
// We have to assemble these things and validate that the parts are all legal.
// This is where the actual join type can be computed.
static void sem_join_target(ast_node *ast) {
  Contract(is_ast_join_target(ast));

  // find the left table reference of the join
  EXTRACT_NOTNULL(join_target_list, ast->parent);
  EXTRACT_ANY_NOTNULL(parent, join_target_list->parent);
  Contract(is_ast_join_clause(parent) || is_ast_join_target_list(parent));
  EXTRACT_ANY_NOTNULL(table_ref, parent->left);
  // if this is the first join_target node under the join_clause node then the
  // left table is a table_or_subquery node otherwise is a join_target node
  Contract(is_ast_table_or_subquery(table_ref) || is_ast_join_target(table_ref));

  EXTRACT_OPTION(join_type, ast->left);
  EXTRACT_NOTNULL(table_join, ast->right);
  EXTRACT_NOTNULL(table_or_subquery, table_join->left);
  sem_table_or_subquery(table_or_subquery);

  if (is_error(table_ref)) {
    return;
  }

  // We will need the result of the join to evaluate the ON clause
  // so compute it aggressively.  We use the join type to modify
  // nullability of the results.
  join_tables(table_ref, table_or_subquery, ast, join_type);

  if (is_error(ast)) {
    return;
  }

  // Now do validation on the join condition, we get different results
  // depending on the factor.
  EXTRACT(join_cond, table_join->right);
  if (join_cond) {
    EXTRACT_ANY_NOTNULL(cond_type, join_cond->left);

    sem_t sem_type = 0;

    if (is_ast_on(cond_type)) {
      sem_type = sem_join_cond_on(ast, join_cond);
    }
    else {
      Contract(is_ast_using(cond_type)); // only other type
      sem_type = sem_join_using_columns(ast, join_cond, table_ref->sem->jptr, table_or_subquery->sem->jptr);
    }

    // We have to mark the entire join result as SENSITIVE if the join condition used SENSITIVE
    if (sensitive_flag(sem_type)) {
      sem_add_flags_to_join(ast->sem->jptr, SEM_TYPE_SENSITIVE);
    }
  }
}

static void sem_table_or_subquery_list(ast_node *ast) {
  Contract(is_ast_table_or_subquery_list(ast));
  EXTRACT_NOTNULL(table_or_subquery, ast->left);
  EXTRACT_ANY(table_or_subquery_list, ast->right);

  sem_table_or_subquery(table_or_subquery);

  if (!table_or_subquery_list) {
    ast->sem = table_or_subquery->sem;
  }
  else {
    if (enforcement.strict_join) {
      report_error(ast, "CQL0263: non-ANSI joins are forbidden if strict join mode is enabled", NULL);
      record_error(ast);
      return;
    }

    sem_table_or_subquery_list(table_or_subquery_list);

    // not really an inner join but that gives the correct nullability
    join_tables(table_or_subquery, table_or_subquery_list, ast, JOIN_INNER);
  }
}

static void sem_join_target_list(ast_node *ast) {
  Contract(is_ast_join_target_list(ast));
  do {
    EXTRACT_NOTNULL(join_target, ast->left);
    EXTRACT_ANY(join_target_list, ast->right);
    sem_join_target(join_target);
    ast = join_target_list;
  } while (ast);
}

// join clause subtree comprises all the join statement of the select statement.
// hold a table_or_subquery node on the left and join target list on the right
static void sem_join_clause(ast_node *ast) {
  Contract(is_ast_join_clause(ast));
  EXTRACT_NOTNULL(table_or_subquery, ast->left);
  EXTRACT_NOTNULL(join_target_list, ast->right);

  sem_table_or_subquery(table_or_subquery);
  sem_join_target_list(join_target_list);

  if (is_error(table_or_subquery) || is_error(join_target_list->left)) {
    record_error(ast);
    return;
  }

  // | |     | | {join_clause}:
  // | |     |   | {table_or_subquery}    #0
  // | |     |   | | ...
  // | |     |   | {join_target_list}     #1
  // | |     |     | {join_target}        #2
  // | |     |     | | ...
  // | |     |     | {join_target_list}   #3
  // | |     |       | {join_target}      #4
  // | |     |       | | ...
  // - join_target_list node #1 compute the join of #2 join_target node and the
  // precedent #0 table_or_subquery node.
  // - join_target_list node #3 compute the join of #4 join_target node and the
  // precedent #1 join_target_list node.
  // - Therefore the last join_target_list node under join_clause subtree compute
  // the join on all the table and the ast->sem value from that node is transfered
  // to join_clause node.
  ast_node * previous_join_target_list = join_target_list;
  while (previous_join_target_list->right) {
    previous_join_target_list = previous_join_target_list->right;
  }
  ast->sem = previous_join_target_list->left->sem;
}

// Whenever you see (X, Y, Z) in the from clause that is an unconstrained join of
// those tables.  Since no join condition is specified there presumably
// there will be something in the WHERE clause later.  This is non-ansi
// legacy join syntax.  You don't get extra nulls so it's like an inner join in
// that regard, it's not an OUTER join as there is no column correlation at all
// it's just the cross product.  INNER join is used here to get the right
// nullabilty result but actually it's not really an inner join in any
// other respect.
static void sem_query_parts(ast_node *ast) {
  Contract(is_ast_table_or_subquery_list(ast) || is_ast_join_clause(ast));
  if (is_ast_table_or_subquery_list(ast)) {
    sem_table_or_subquery_list(ast);
  }
  else {
    Contract(is_ast_join_clause(ast)); // this is all that's left
    sem_join_clause(ast);
  }
}


// Table valued functions can appear anywhere a table is allowed.
// The validation rules are:
// * must be a valid function
// * must return a struct type (i.e. a table-valued-function)
// * must have valid arg expressions
// * arg expressions must match formal parameters
// The name of the resulting table is the name of the function
//  * but it can be aliased later with "AS"
static void sem_table_function(ast_node *ast) {
  Contract(is_ast_table_function(ast));

  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT(arg_list, ast->right);

  // name( [arg_list] )

  // check for user defined functions
  ast_node *user_func = find_func(name);
  ast_node *unchecked_user_func = find_unchecked_func(name);
  user_func = user_func ? user_func : unchecked_user_func;
  if (!user_func) {
    report_error(name_ast, "CQL0250: table-valued function not declared", name);
    record_error(ast);
    return;
  }

  if (!is_struct(user_func->sem->sem_type)) {
    report_error(name_ast, "CQL0249: function is not a table-valued-function", name);
    record_error(ast);
    return;
  }

  Contract(is_ast_declare_select_func_stmt(user_func) || is_ast_declare_select_func_no_check_stmt(user_func));
  EXTRACT_NOTNULL(func_params_return, user_func->right);
  EXTRACT(params, func_params_return->left);

  // expand any FROM forms in the arg list
  if (!rewrite_shape_forms_in_list_if_needed(arg_list)) {
    record_error(ast);
    return;
  }

  if (is_ast_declare_select_func_no_check_stmt(user_func)) {
    sem_arg_list(arg_list, IS_NOT_COUNT);
    if (arg_list && is_error(arg_list)) {
      record_error(ast);
      return;
    }
    record_ok(ast);
  }
  else {
    // SQL Func context is basically the same the ON context but allows for Object types
    PUSH_EXPR_CONTEXT(SEM_EXPR_CONTEXT_UDF);
    sem_validate_args_vs_formals(ast, name, arg_list, params, NORMAL_CALL);
    POP_EXPR_CONTEXT();
  }

  if (is_error(ast)) {
    return;
  }

  sem_node *sem = new_sem(SEM_TYPE_JOIN|SEM_TYPE_TVF);
  sem->jptr = sem_join_from_sem_struct(user_func->sem->sptr);
  sem->jptr->names[0] = name;
  ast->sem = name_ast->sem = sem;
}

// A group-by list is a list of [expression].  These each
// need to be validated.  Note this is a place where the expression context
// changes.
static void sem_groupby_list(ast_node *head) {
  Contract(is_ast_groupby_list(head));

  for (ast_node *ast = head; ast; ast = ast->right) {
    Contract(is_ast_groupby_list(ast));
    EXTRACT_NOTNULL(groupby_item, ast->left);
    EXTRACT_ANY_NOTNULL(expr, groupby_item->left);

    sem_root_expr(expr, SEM_EXPR_CONTEXT_GROUP_BY);
    if (is_error(expr)) {
      record_error(head);
      return;
    }
  }

  record_ok(head);
}


// A order-by list is a list of [expression, ASC/DESC].  These each
// need to be validated.  Note this is a place where the expression context
// changes.
static void sem_orderby_list(ast_node *head) {
  Contract(is_ast_orderby_list(head));

  for (ast_node *ast = head; ast; ast = ast->right) {
    Contract(is_ast_orderby_list(ast));
    EXTRACT_NOTNULL(orderby_item, ast->left);
    EXTRACT_ANY_NOTNULL(expr, orderby_item->left);

    sem_root_expr(expr, SEM_EXPR_CONTEXT_ORDER_BY);
    if (is_error(expr)) {
      record_error(head);
      return;
    }
  }

  record_ok(head);
}

// Simple numeric expression will do for where;  set a new context.
static void sem_opt_where(ast_node *ast) {
  Contract(is_ast_opt_where(ast));

  // WHERE [ast->left]
  sem_numeric_expr(ast->left, ast, "WHERE", SEM_EXPR_CONTEXT_WHERE);
}

// Simple numeric expression will do for having;  set a new context.
static void sem_opt_having(ast_node *ast) {
  Contract(is_ast_opt_having(ast));

  // HAVING [ast->left]
  sem_numeric_expr(ast->left, ast, "HAVING", SEM_EXPR_CONTEXT_HAVING);
}

// Window clause in the select stmt
static void sem_opt_select_window(ast_node *ast) {
  Contract(is_ast_opt_select_window(ast));
  EXTRACT_NOTNULL(window_clause, ast->left);

  // WINDOW [ast->left]
  sem_window_clause(window_clause);

  ast->sem = window_clause->sem;
}

// The group-by node, if present, simply delegates to the groupby_list helper.
static void sem_opt_groupby(ast_node *ast) {
  Contract(is_ast_opt_groupby(ast));
  EXTRACT_NOTNULL(groupby_list, ast->left);

  // GROUP BY [groupby_list]
  sem_groupby_list(groupby_list);
  if (is_error(groupby_list)) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// The order-by node, if present, simply delegates to the orderby_list helper.
static void sem_opt_orderby(ast_node *ast) {
  Contract(is_ast_opt_orderby(ast));
  EXTRACT_NOTNULL(orderby_list, ast->left);

  // ORDER BY [group_list] [opt_asc_desc]
  sem_orderby_list(orderby_list);
  if (is_error(orderby_list)) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// Limit can be any numeric.  It may not refer to any columns, only variables.
static void sem_opt_limit(ast_node *ast) {
  Contract(is_ast_opt_limit(ast));

  PUSH_JOIN_BLOCK();

  // LIMIT [ast->left]
  sem_numeric_expr(ast->left, ast, "LIMIT", SEM_EXPR_CONTEXT_LIMIT);

  POP_JOIN();
}

// Offset can be any numeric.  It may not refer to any columns, only variables.
static void sem_opt_offset(ast_node *ast) {
  Contract(is_ast_opt_offset(ast));

  PUSH_JOIN_BLOCK();

  // LIMIT [ast->left]
  sem_numeric_expr(ast->left, ast, "OFFSET", SEM_EXPR_CONTEXT_OFFSET);

  POP_JOIN();
}

// The select_from_etc node is the meat of the select statement.  Basically
// all the stuff that starts with FROM.  You can do select 1,2 without going
// here but after that you get all the goodness.  Here we extract each of
// the fragments and pass them along to the appropriate helper.
static void sem_select_from(ast_node *ast) {
  Contract(is_ast_select_from_etc(ast));
  EXTRACT_ANY(query_parts, ast->left);

  // FROM [query_parts]
 if (query_parts) {
    sem_query_parts(query_parts);
    ast->sem = query_parts->sem;
    return;
  }

  // It's ok to have not any query_parts. If none, then it's just "ok"
  // e.g. select 1 where 0;
  record_ok(ast);
}

// Do the semantic analysis of ORDER BY ... LIMIT ... OFFSET nodes.
// It also expect that the join table infos are already pushed into the join stack by the callsite.
static bool_t sem_select_orderby(ast_node *ast) {
  Contract(is_ast_select_orderby(ast));
  EXTRACT(opt_orderby, ast->left);
  EXTRACT_NOTNULL(select_limit, ast->right);
  EXTRACT(opt_limit, select_limit->left);
  EXTRACT_NOTNULL(select_offset, select_limit->right);
  EXTRACT(opt_offset, select_offset->left);
  bool_t error = false;

  sem_t sem_sensitive = 0;

  if (opt_orderby) {
    sem_opt_orderby(opt_orderby);
    error |= is_error(opt_orderby);
  }

  // These parts may not refer to columns, they will block the join.
  // Blocking is necessary because this select could be nested in a larger
  // select and we don't want to refer to any of THOSE columns either.

  if (opt_limit) {
    sem_opt_limit(opt_limit);
    error |= is_error(opt_limit);
    sem_sensitive |= sensitive_flag(opt_limit->sem->sem_type);
  }

  if (opt_offset) {
    if (!opt_limit) {
      report_error(opt_offset, "CQL0271: OFFSET clause may only be used if LIMIT is also present", NULL);
      record_error(opt_offset);
      error = true;
    }
    else {
      sem_opt_offset(opt_offset);
      error |= is_error(opt_offset);
      sem_sensitive |= sensitive_flag(opt_offset->sem->sem_type);
    }
  }

  if (sem_sensitive) {
    // Not really a fan of reaching up the tree to set the core list from here
    // but flowing this computation would be pretty complicated and the AST
    // is a fixed shape here (hence the strict extracts) so we'll do this the
    // easy way for now.  If this gets more complicated then this case should
    // be fused with the WHERE and HAVING case and happen at a higher level with
    // some flow.
    EXTRACT_NOTNULL(select_stmt, ast->parent);
    EXTRACT_NOTNULL(select_core_list, select_stmt->left);

    sem_struct *sptr = select_core_list->sem->sptr;
    for (uint32_t i = 0; i < sptr->count; i++) {
      sptr->semtypes[i] |= sem_sensitive;
    }
  }

  if (error) {
    record_error(ast);
  }
  return error;
}

static sem_t sem_select_where_etc(ast_node *ast) {
  Contract(is_ast_select_from_etc(ast));

  EXTRACT_NOTNULL(select_where, ast->right);
  EXTRACT(opt_where, select_where->left);
  EXTRACT_NOTNULL(select_groupby, select_where->right);
  EXTRACT(opt_groupby, select_groupby->left);
  EXTRACT_NOTNULL(select_having, select_groupby->right);
  EXTRACT(opt_having, select_having->left);
  EXTRACT(opt_select_window, select_having->right);

  bool_t error = false;
  sem_t sem_sensitive = 0;

  if (opt_where) {
    sem_opt_where(opt_where);
    error |= is_error(opt_where);
  }

  if (opt_groupby) {
    sem_opt_groupby(opt_groupby);
    error |= is_error(opt_groupby);
  }

  if (opt_having && !opt_groupby) {
    error = true;
    report_error(opt_having, "CQL0099: HAVING clause requires GROUP BY clause", NULL);
    record_error(opt_having);
  }

  if (opt_having) {
    // HAVING
    sem_opt_having(opt_having);
    error |= is_error(opt_having);
  }

  if (opt_select_window) {
    // WINDOW
    sem_opt_select_window(opt_select_window);
    error |= is_error(opt_select_window);
  }

  if (error) {
    record_error(ast);
  }
  else {
    if (opt_where) {
      sem_sensitive |= sensitive_flag(opt_where->sem->sem_type);
    }
    if (opt_having) {
      sem_sensitive |= sensitive_flag(opt_having->sem->sem_type);
    }
  }
  return sem_sensitive;
}

// Given a select expression list, return a `sem_struct` containing only the
// aliases present in the expression list with all types set to
// `SEM_TYPE_ALIAS`. This is used by `sem_select_expr_list_con` to catch any
// references to an alias, or references to a column that shadows an alias, from
// a WHERE, GROUP BY, HAVING, or WINDOW clause.
static sem_struct *select_expr_list_alias_sptr(ast_node *select_expr_list) {
  Contract(is_ast_select_expr_list(select_expr_list));

  list_item *aliases = NULL;
  uint32_t alias_count = 0;
  for (ast_node *item = select_expr_list; item; item = item->right) {
    Invariant(is_ast_select_expr_list(item));

    // These have been rewritten away by the time we ever get here
    Invariant(!is_ast_star(item->left));
    Invariant(!is_ast_table_star(item->left));

    EXTRACT_NOTNULL(select_expr, item->left);
    EXTRACT(opt_as_alias, select_expr->right);
    if (opt_as_alias) {
      add_item_to_list(&aliases, opt_as_alias);
      alias_count++;
    }
  }

  sem_struct *sptr = new_sem_struct("aliases", alias_count);

  for (uint32_t i = 0; aliases; aliases = aliases->next, i++) {
    EXTRACT_NOTNULL(opt_as_alias, aliases->ast);
    EXTRACT_STRING(name, opt_as_alias->left);
    sptr->names[i] = name;
    sptr->semtypes[i] = SEM_TYPE_ALIAS;
  }

  return sptr;
}

// The select ast below the statement starts with this construction node.
// It has the select list and the query_parts.  The query_parts being the
// tail of the select (after the FROM).  Here we simply dispatch the appropriate
// helpers for both of these.  Note that if there is a FROM clause we push
// that joinscope so that evaluations of the select list can use the results of
// the join.  Otherwise you get your parent's chain, or nothing.
static void sem_select_expr_list_con(ast_node *ast) {
  Contract(is_ast_select_expr_list_con(ast));
  EXTRACT_NOTNULL(select_expr_list, ast->left);
  EXTRACT_NOTNULL(select_from_etc, ast->right);
  EXTRACT_ANY(query_parts, select_from_etc->left);
  EXTRACT_NOTNULL(select_where, select_from_etc->right);
  EXTRACT(opt_where, select_where->left);

  bool_t error = false;
  sem_t sem_sensitive = 0;
  sem_join *from_jptr = NULL;

  // Analyze the FROM portion (if it exists).
  sem_select_from(select_from_etc);
  error = is_error(select_from_etc);

  if (!error) {
    from_jptr = select_from_etc->sem->jptr;
    Invariant((from_jptr && query_parts) || (!from_jptr && !query_parts));

    rewrite_select_expr_list(select_expr_list, from_jptr);
    error = is_error(select_expr_list);
  }

  // Push a flow context to contain improvements made via the WHERE clause that
  // will be in effect for the SELECT expression list.
  FLOW_PUSH_CONTEXT_NORMAL();

  if (!error) {

    // Analyze the WHERE clause. We first push on the result of
    // `select_expr_list_alias_sptr(select_expr_list)` which is simply all
    // aliases present in `select_expr_list` with a sem_type of
    // `SEM_TYPE_ALIAS`. If a reference to a column in the WHERE, GROUP BY,
    // HAVING, or WINDOW portion of the SELECT resolves to something in
    // `alias_scope`, or resolves to something that shadows something in
    // `alias_scope`, we'll issue an error in `sem_try_resolve_column`.
    //
    // The background here is that SQLite allows the above-mentioned clauses to
    // reference aliases of the SELECT expression list by replacing all such
    // references with the expression to which they refer. It only does this,
    // however, if the alias is not shadowed by something in the FROM. For
    // example, in 'SELECT a + b AS x FROM t WHERE x IS NOT NULL', it's
    // impossible to know if 'WHERE x IS NOT NULL' refers to the alias 'x' or to
    // a column in 't' without first knowing whether 't' has a column 'x':
    //
    // * If there is such a column 't.x' and the programmer meant to refer to
    //   it, the programmer should have instead written 'WHERE t.x IS NOT NULL'
    //   instead for the sake of clarity and we'll issue an error indicating
    //   exactly that.
    //
    // * If there is no such column 't.x' and the programmer meant to refer to
    //   the alias, the programmer should have instead written 'WHERE a + b IS
    //   NOT NULL' (which is what SQLite would normally do for them) and we'll
    //   issue an error about the WHERE clause refering to an alias.
    //
    // It's easy to see why we issue the first error indicating the need for
    // 't.x', but why do we also issue the second error that disallows referring
    // to aliases in WHERE clauses entirely? The reason is that, if we did not,
    // we could not analyze the WHERE clause before we analyzed the SELECT
    // expression list, and we'd therefore have no easy way to set the
    // appropriate nonnull improvements in time. Previous versions of CQL worked
    // around this fact, but they did so at the cost of a fair amount of
    // complexity. Given that most other databases (e.g. PostgreSQL, SQL Server,
    // and MySQL) disallow references to the SELECT expression list from a WHERE
    // clause, disallowing it in CQL seemed a better solution than continuing to
    // accommodate SQLite's above-mentioned quirk. See the user-facing
    // documentation for errors CQL0427 and CQL0428 for further justification.
    PUSH_JOIN(alias_scope, sem_join_from_sem_struct(select_expr_list_alias_sptr(select_expr_list)));
    {
      if (query_parts) {
        PUSH_JOIN(from_scope, from_jptr);
        sem_sensitive = sem_select_where_etc(select_from_etc);
        error = is_error(select_from_etc);
        if (!error && opt_where) {
          EXTRACT_ANY_NOTNULL(where_expr, opt_where->left);
          sem_set_improvements_for_true_condition(where_expr);
        }
        POP_JOIN();
      }
      else {
        sem_sensitive = sem_select_where_etc(select_from_etc);
        error = is_error(select_from_etc);
        if (!error && opt_where) {
          EXTRACT_ANY_NOTNULL(where_expr, opt_where->left);
          sem_set_improvements_for_true_condition(where_expr);
        }
      }
    }
    POP_JOIN();
  }

  if (!error) {
    // Analyze the SELECT expression list with any applicable improvements from
    // the WHERE clause.
    if (query_parts) {
      PUSH_JOIN(from_scope, from_jptr);
      sem_select_expr_list(select_expr_list);
      POP_JOIN();
    }
    else {
      sem_select_expr_list(select_expr_list);
    }
    error = is_error(select_expr_list);
  }

  FLOW_POP_CONTEXT_NORMAL();

  if (!error) {
    ast->sem = select_expr_list->sem;

    if (select_level == 1) {
      // This is a top-level select which means it's eligable for alias
      // minification. Leaving `ast->sem->used_symbols` as NULL would
      // incorrectly indicate otherwise, so we set it to an empty symbol table
      // here. See `gen_select_expr` to understand why this is needed.
      symtab *used_symbols = symtab_new();
      add_pending_symtab_free(used_symbols);
      ast->sem->used_symbols = used_symbols;
    }

    if (sem_sensitive) {
      // Propagate sensitivity.
      sem_struct *sptr = ast->sem->sptr;
      for (uint32_t i = 0; i < sptr->count; i++) {
        sptr->semtypes[i] |= sem_sensitive;
      }
    }
  }

  if (error) {
    record_error(ast);
    record_error(select_expr_list);
  }
}

// Semantic analysis of the select_values node.
// * aliases are not allowed.
// * all expressions in the same column should be of compatible types
// * if any exression is senstive its entire column becomes senstive

static void sem_values(ast_node *ast) {
  Contract(is_ast_values(ast));
  EXTRACT(insert_list, ast->left);

  // if there are any FROM C(like shape) thing in the values list, expand them
  // we do the first row of values if there is one... we need this to get the count
  // so that we know that they all match
  if (!rewrite_shape_forms_in_list_if_needed(insert_list)) {
    record_error(ast);
    return;
  }

  uint32_t total_count = 0;
  ast_node *items = insert_list;
  while (items) {
    total_count++;
    items = items->right;
  }
  sem_struct *sptr = new_sem_struct("values", total_count);

  // We're walking through each value list to:
  // 1- validate the value expressions
  // 2- validate/combine the type with the struct type of values clause
  for (ast_node *values = ast; values; values = values->right) {
    EXTRACT_NAMED(values_insert_list, insert_list, values->left);

    if (values_insert_list == NULL) {
      report_error(ast, "CQL0336: select statement with VALUES clause requires a non empty list of values", NULL);
      record_error(ast);
      return;
    }

    // if there are any FROM C(like shape) thing in the values list, expand them
    if (!rewrite_shape_forms_in_list_if_needed(values_insert_list)) {
      record_error(ast);
      return;
    }

    // To compute the type of each column in the VALUES clause we have to
    // visit each node.  As we go along we're going to accumulate the type
    // that best fits what we have seen so far or else produce an error
    // if there is no type that can hold all the values in a column.
    // Once this is done the values clause can be made to look just like a select
    // result including the synthetic column names.

    uint32_t values_count = 0;
    ast_node *last_expr = NULL;
    for (ast_node *node = values_insert_list; node; node = node->right) {
      EXTRACT_ANY_NOTNULL(expr, node->left);
      last_expr = expr;

      if (values_count >= total_count) {
        report_error(expr, "CQL0337: the number of columns values for each row should be identical in VALUES clause", NULL);
        record_error(expr);
        record_error(ast);
        return;
      }

      // expr
      sem_root_expr(expr, SEM_EXPR_CONTEXT_SELECT_LIST);
      if (is_error(expr)) {
        record_error(ast);
        return;
      }

      Invariant(is_unitary(expr->sem->sem_type));

      sem_t sem_type = sptr->semtypes[values_count];
      CSTR sem_name = sptr->names[values_count];

      sem_name = dup_printf("column%d", values_count + 1);

      if (sem_type == SEM_TYPE_ERROR) {
        sem_type = expr->sem->sem_type;
      }
      else {
        if (!sem_verify_compat(expr, sem_type, expr->sem->sem_type, "VALUES clause")) {
          record_error(ast);
          return;
        }
        // In a values clause the sem type of column is the combination of compatible sem type of
        // all the values for that column. We've verified the compatibility of the values clause struct type
        // with the column value. Now we need combine both sem type and flags.
        // eg: VALUES (1), (2.2); the values statement has one column with an integer at the first
        // row and real at the second raw. The final sem type of this column should be real.
        sem_type = sem_combine_types(sem_type, expr->sem->sem_type);
      }

      sptr->semtypes[values_count] = sem_type;
      sptr->names[values_count] = sem_name;
      sptr->kinds[values_count] = NULL;
      values_count++;
    }

    Invariant(last_expr);
    if (total_count != values_count) {
      report_error(last_expr, "CQL0337: the number of columns values for each row should be identical in VALUES clause", NULL);
      record_error(last_expr);
      record_error(ast);
      return;
    }
  }

  // Here we make the struct type for this select, by enumerating
  // the types of all the columns and using the aliased name if any.
  ast->sem = new_sem(SEM_TYPE_STRUCT);
  ast->sem->sptr = sptr;
  ast->sem->used_symbols = NULL;
}

// select_core is the core component of the select statement diagram. It comprises
// [SELECT ... FROM ... WHERE ... GROUP BY ...] or [VALUES (...), ...]. It does not
// include [WITH ...], [ORDERBY ... LIMIT OFFSET ...]. Note that most of the clauses
// in a select statement are optional. This function execute the semantic
// anlysis of the select-core component.
static void sem_select_core(ast_node *ast) {
  Contract(is_ast_select_core(ast));

  EXTRACT_ANY(any_select_opts, ast->left);
  EXTRACT_ANY_NOTNULL(select_core_right, ast->right);

  if (is_ast_select_values(any_select_opts)) {
    // VALUES [values]
    Contract(is_ast_values(select_core_right));
    sem_values(select_core_right);
  }
  else {
    // SELECT [select_opts] [select_expr_list_con]
    // select options not needed for semantic analysis
    Contract(is_ast_select_expr_list_con(select_core_right));
    sem_select_expr_list_con(select_core_right);
  }

  ast->sem = select_core_right->sem;
  has_dml = 1;
}

// Merge two used symbols list into one.
// This is called to merge the symbols used in [select_orderby] to the symbols used
// in [select_core]. If we dont do that then the list of used symbols in a
// select statement will be incomplete and minify_aliases feature (CG_MINIFY_ALIASES)
// won't work correctly
static void sem_add_used_symbols(symtab **used_symbols, symtab *add_symbols) {
  if (*used_symbols == NULL) {
    *used_symbols = add_symbols;
  }
  else if (add_symbols) {
    for (uint32_t i = 0; i < add_symbols->capacity; i++) {
      if (add_symbols->payload[i].sym) {
        symtab_add(*used_symbols, add_symbols->payload[i].sym, NULL);
      }
    }
  }
}

// Like sem_select_orderby, but with the restriction that ordering can only be
// specified via indices (e.g., 2) and simple name expressions (e.g, x), not
// arbitrary expressions (e.g., x + y).
static bool_t sem_select_orderby_with_simple_ordering_only(ast_node *ast) {
  Contract(is_ast_select_orderby(ast));

  if (sem_select_orderby(ast)) {
    return 1;
  }

  EXTRACT(opt_orderby, ast->left);
  if (!opt_orderby) {
    return 0;
  }

  EXTRACT_NOTNULL(orderby_list, opt_orderby->left);
  for (ast_node *list = orderby_list; list; list = list->right) {
    Contract(is_ast_orderby_list(list));
    EXTRACT_NOTNULL(orderby_item, list->left);
    EXTRACT_ANY_NOTNULL(expr, orderby_item->left);
    if (is_ast_num(expr)) {
      continue;
    }
    if (is_id(expr)) {
      continue;
    }
    report_error(expr, "CQL0398: compound select cannot be ordered by the result of an expression", NULL);
    record_error(ast);
    return 1;
  }

  return 0;
}

// A select statement in any context, it has the options (which we don't care
// about for semantic analysis) plus the statement itself.
static void sem_select_no_with(ast_node *ast) {
  Contract(is_ast_select_stmt(ast));
  EXTRACT_NOTNULL(select_core_list, ast->left);
  EXTRACT_NOTNULL(select_orderby, ast->right);
  EXTRACT_NOTNULL(select_core, select_core_list->left);
  EXTRACT(select_core_compound, select_core_list->right);

  bool_t error = false;
  symtab *used_symbols = NULL;

  sem_select_core_list(select_core_list);
  if (is_error(select_core_list)) {
    record_error(ast);
    return;
  }

  // The select_core node can be "SELECT" or "VALUES" clause statement.
  Contract(is_ast_select_expr_list_con(select_core->right) || is_ast_values(select_core->right));
  EXTRACT_ANY_NOTNULL(select_core_right, select_core->right);

  Contract(select_core_right->sem);
  Contract(select_core_right->sem->sptr);
  PUSH_JOIN(list_scope, sem_join_from_sem_struct(select_core_right->sem->sptr));
  {
    PUSH_MONITOR_SYMTAB();
    if (select_core_compound || is_ast_values(select_core->right)) {
      // [SELECT ... UNION SELECT ...]
      // For compounded select statement, the [select_orderby] can only reference the columns
      // listed in [select_expr_list] therefore we should not push into the JOIN stack
      // the columns from the table ([select_from_etc]).
      // e.g: SELECT col1, col2 from t1 UNION SELECT col1, col2 FROM t2 ORDER BY t1.col3;
      // You can not reference in ORDER BY statement a column from t1 table that is not
      // listed in the [select_expr_list]. Below is a comand line execution to explain
      // the above
      // ------------------------------------------------------------------------
      // sqlite> create table t1(id int, name text);
      // sqlite> create table t2(id int, name text);
      // sqlite> SELECT id FROM t1 UNION SELECT id from t2 ORDER BY t1.name;
      // Error: 1st ORDER BY term does not match any column in the result set
      // sqlite> SELECT id FROM t1 UNION SELECT id from t2 ORDER BY t1.id;
      // sqlite>
      // ------------------------------------------------------------------------
      // Sqilte produce an error on ORDER BY t1.name because column t1.name is not
      // part of the result set of each compounded SELECT statement.
      // This is the reason why we don't push the table(select_from_etc) sem_struct
      // into the stack before semantic analysis of select_orderby ast.
      //
      // [VALUES (...), (...), ...]
      // For select values statement you can not reference the columns listed in [select_insert_list]
      // because they are anonimous. Therefore we should not push into the JOIN stack the columns from
      // [select_insert_list].
      error = sem_select_orderby_with_simple_ordering_only(select_orderby);
    }
    else {
      // [SELECT ...]
      // For non compounded select statement we need both columns in [select_expr_list]
      // and columns in the table [select_from_etc] to accurately validate the [select_orderby]
      // ast because columns from [select_expr_list] and columns in the table [select_from_etc]
      // can be referenced in the [select_orderby] statement
      Contract(is_ast_select_expr_list_con(select_core_right));
      EXTRACT_NOTNULL(select_from_etc, select_core_right->right);

      PUSH_JOIN(from_scope, select_from_etc->sem->jptr);
      error = sem_select_orderby(select_orderby);
      POP_JOIN();
    }
    POP_MONITOR_SYMTAB();
  }
  POP_JOIN();

  if (error) {
    record_error(ast);
    return;
  }
  // merge used_symbols from [select_orderby] to the [select_core] node.
  sem_add_used_symbols(&select_core_list->sem->used_symbols, used_symbols);

  ast->sem = select_core_list->sem;
}

// Compound select statements must have compatible columns and exact name
// match of the columns in the select list.  We enforce that here.
static void sem_select_core_list(ast_node *ast) {
  Contract(is_ast_select_core_list(ast));
  EXTRACT_NOTNULL(select_core, ast->left);
  EXTRACT(select_core_compound, ast->right);

  sem_select_core(select_core);
  if (is_error(select_core)) {
    record_error(ast);
    return;
  }

  // This means the select statement only have one select_core node. which mean
  // select_core_list node is in a non compound select statement
  // e.g: SELECT * FROM table
  if (select_core_compound == NULL) {
    ast->sem = select_core->sem;
    return;
  }

  // This means we have more than one select_core node. Which means select_core_list node
  // is in a compounded select statement
  // e.g: SELECT ... UNION SELECT ...
  EXTRACT_NOTNULL(select_core_list, select_core_compound->right);
  sem_select_core_list(select_core_list);
  if (is_error(select_core_list)) {
    record_error(ast);
    return;
  }

  sem_struct *sptr = sem_unify_compatible_columns(select_core, select_core_list);
  if (!sptr) {
    record_error(ast);
    return;
  }

  sem_add_used_symbols(&select_core->sem->used_symbols, select_core_list->sem->used_symbols);

  ast->sem = new_sem(SEM_TYPE_STRUCT);
  ast->sem->sptr = sptr;
  EXTRACT_OPTION(compound_operator, select_core_compound->left);
  ast->sem->sptr->struct_name = get_compound_operator_name(compound_operator);

  // We have no used symbols yet, but it's still important to set
  // `ast->sem->used_symbols` to `select_core->sem->used_symbols` here otherwise
  // any reference to an aliased column in an ORDER BY would not properly
  // prevent removal of the referenced alias during minification.
  Invariant(!select_core->sem->used_symbols || select_core->sem->used_symbols->count == 0);
  Invariant(!select_core_list->sem->used_symbols || select_core_list->sem->used_symbols->count == 0);
  ast->sem->used_symbols = select_core->sem->used_symbols;
}

// Just like it sounds, this handles the two select variants
// this is where we tracked nested selects for minifaction
static void sem_any_select(ast_node *ast) {
  Contract(is_select_variant(ast));

  // alias minification on the top level select only, this tracks nested selects
  select_level++;

  if (is_ast_with_select_stmt(ast)) {
    sem_with_select(ast);
  }
  else {
    Contract(is_ast_select_stmt(ast));
    sem_select_no_with(ast);
  }

  select_level--;
}

// Any row source in any context (used when a select appears within another statement)
// This is called only for the top level statements, nested selects are handled by sem_any_select
cql_noexport void sem_any_row_source(ast_node *ast) {
  if (is_select_variant(ast)) {
    sem_select_rewrite_backing(ast);
  }
  else if (is_ast_explain_stmt(ast)) {
    sem_explain(ast);
  }
  else if (is_ast_insert_returning_stmt(ast)) {
    sem_insert_returning(ast);
  }
  else if (is_ast_delete_returning_stmt(ast)) {
    sem_delete_returning(ast);
  }
  else if (is_ast_upsert_returning_stmt(ast)) {
    sem_upsert_returning(ast);
  }
  else {
    Contract(is_ast_update_returning_stmt(ast));
    sem_update_returning(ast);
  }
}

// Top level select statements can trigger the backing actions,
// nested selects contribute to the tables needing backing but
// they don't do their own rewrite.
static void sem_select_rewrite_backing(ast_node *ast) {
  Contract(is_select_variant(ast));

  BEGIN_BACKING_REWRITE();

  sem_any_select(ast);

  // select doesn't have a target table like INSERT/UPDATE/DELETE just FROM tables
  ast_node *target_table = NULL;

  // This will do the rewrite as needed.  The backed_tables_list will have been
  // accumulated from the FROM clauses of the select statement and the FROM clauses
  // of any nested selects, or selects in CTEs.
  if (BACKING_REWRITE_NEEDED(ast, target_table)) {
    rewrite_select_for_backed_tables(ast, backed_tables_list);
  }

  END_BACKING_REWRITE();
}

// This can only be used in the ELSE clause of a conditional fragment
// it will expand into "select 0, 0, 0, 0 where 0" when we generate SQL.
// But since it is known to generate zero rows the data types are
// irrelevant.  We just make it go along for the ride so that it doesn't
// cause errors in the fragment but creates errors elsewhere.
static void sem_select_nothing_stmt(ast_node *ast) {
  Contract(is_ast_select_nothing_stmt(ast));

  if (!current_proc) goto error;

  if (!is_proc_shared_fragment(current_proc)) goto error;

  if (!ast->parent) goto error;

  if (!is_ast_stmt_list(ast->parent)) goto error;

  if (!ast->parent->parent) goto error;

  if (!is_ast_else(ast->parent->parent)) goto error;

  // this might still be an error if the proc has errors
  // that's ok, we return an error code in that case.

  ast->sem = new_sem(current_proc->sem->sem_type);
  ast->sem->sptr = current_proc->sem->sptr;
  return;

error:
  report_error(ast, "CQL0496: SELECT NOTHING may only appear in the ELSE clause of a shared fragment", NULL);
  record_error(ast);
}

// Top level statement list processing for select, note that a select *statement*
// can't appear in other places (such as a nested expression).  This is only for
// select in the context of a statement list.  Others use just 'sem_any_select'
static void sem_select_stmt(ast_node *stmt) {
  sem_select_rewrite_backing(stmt);
  sem_update_proc_type_for_select(stmt);
}

// Any explain in any context (used when a explain appears within another statement)
// e.g: declare c cursor for explain query plan ...
static void sem_explain(ast_node *stmt) {
  Contract(is_ast_explain_stmt(stmt) && current_explain_stmt == NULL);
  EXTRACT_OPTION(query_plan, stmt->left);
  EXTRACT_ANY_NOTNULL(sql_stmt, stmt->right);

  current_explain_stmt = stmt;

  // EXPLAIN [explain_op] [explain_target] is only available in dev mode
  if (!options.dev) {
    report_error(stmt, "CQL0292: explain statement is only available in `--dev` mode because its result set may vary between SQLite versions", NULL);
    record_error(stmt);
    goto cleanup;
  }

  if (query_plan != EXPLAIN_QUERY_PLAN) {
    report_error(stmt, "CQL0293: only [EXPLAIN QUERY PLAN ...] statement is supported", NULL);
    record_error(stmt);
    goto cleanup;
  }

  symtab_entry *entry = symtab_find(sql_stmts, sql_stmt->type);
  Contract(entry);
  ((void (*)(ast_node*))entry->val)(sql_stmt);

  if (is_error(sql_stmt)) {
    record_error(stmt);
    goto cleanup;
  }

  // Warning: The data returned by the EXPLAIN QUERY PLAN command is intended for
  // interactive debugging only. The output format may change between SQLite releases.
  // Applications should not depend on the output format of the EXPLAIN QUERY
  // PLAN command.
  // An EXPLAIN QUERY PLAN command returns zero or more rows of four columns each.
  // The column names are "selectid", "order", "from", "detail". The first three columns
  // contain an integer value. The final column, "detail", contains a text value which
  // carries most of the useful information.
  // EXPLAIN QUERY PLAN is most useful on a SELECT statement, but may also be appear with
  // other statements that read data from database tables (e.g. UPDATE, DELETE, INSERT INTO ... SELECT)
  //
  // Because of the above explain statement will only be available in dev mode in CQL.
  // Explain statement statement behave like a statement but does not list explicitely
  // the column result there we have to manually build the sem_struct and sem_join that
  // reflex the exact output of EXPLAIN QUERY PLAN [stmt] statement
  sem_struct *sptr = new_sem_struct("explain_query", 4);
  sptr->semtypes[0] = SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL;
  sptr->names[0] = "iselectid";
  sptr->semtypes[1] = SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL;
  sptr->names[1] = "iorder";
  sptr->semtypes[2] = SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL;
  sptr->names[2] = "ifrom";
  sptr->semtypes[3] = SEM_TYPE_TEXT | SEM_TYPE_NOTNULL;
  sptr->names[3] = "zdetail";

  stmt->sem = new_sem(SEM_TYPE_STRUCT);
  stmt->sem->sptr = sptr;

cleanup:
  Contract(current_explain_stmt != NULL);
  current_explain_stmt = NULL;
}

// Top level statement list processing for explain stmt, note that an explain
// statement can't appear in other places (such as a cursor stmt).  This is only
// for explain in the context of a statement list.  Others use just 'sem_explain'
static void sem_explain_stmt(ast_node *stmt) {
  sem_explain(stmt);
  sem_update_proc_type_for_select(stmt);
}

// This adds a common table expression to the current CTE context.
// select statement must already have been analyzed.  The validations
// are :
//  * CTE name unique
//  * no duplicate columns
//  * number of CTE columns matches number of select columns
//
// The type of the CTE is inferred from the column types of the select.
static void sem_cte_decl(ast_node *ast, ast_node *select_core)  {
  Contract(is_ast_cte_decl(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY_NOTNULL(name_list, ast->right)

  if (find_cte(name)) {
    report_error(ast, "CQL0100: duplicate common table name", name);
    record_error(ast);
    return;
  }

  if (name_hides_root_table(name)) {
    report_error(ast, "CQL0437: common table name shadows previously declared table or view", name);
    record_error(ast);
    return;
  }

  if (is_ast_star(name_list)) {
    rewrite_cte_name_list_from_columns(ast, select_core);
    if (is_error(ast)) {
      return;
    }
    name_list = ast->right;
  }

  if (!sem_verify_no_duplicate_names(name_list)) {
    record_error(ast);
    return;
  }

  Invariant(is_struct(select_core->sem->sem_type));
  sem_struct *sptr = new_sem_struct_strip_table_flags(select_core->sem->sptr);

  ast_node *item = name_list;

  for (uint32_t i = 0; i < sptr->count; i++) {
    if (!item) {
      report_error(ast, "CQL0101: too few column names specified in common table expression", name);
      record_error(ast);
      return;
    }

    // use the names from the CTE decl rather than the select
    EXTRACT_STRING(col_name, item->left);
    sptr->names[i] = col_name;

    // This is something like WITH A(`foo bar`, baz) as (select 1 x, 2 y)
    if (is_qid(item->left)) {
      sptr->semtypes[i] |= SEM_TYPE_QID;
    }

    item = item->right;
  }

  if (item) {
    report_error(ast, "CQL0102: too many column names specified in common table expression", name);
    record_error(ast);
    return;
  }

  ast->sem = new_sem(SEM_TYPE_STRUCT);
  ast->sem->sptr = sptr;
  ast->sem->sptr->struct_name = name;

  add_cte(ast);
}

// When accumulating cte info this structure holds the various discoveries and
// provides the callback for any per CTE actions
typedef struct shared_cte_info {
  void *context;
  void (*callback)(void *context, CSTR cte_name, ast_node *cte_decl);

  // information for errors detected during walk
  ast_node *missing_else;
  ast_node *bad_statement_form;
  ast_node *non_select_stmt;
} shared_cte_info;

// Now we get the top level CTE tables out of the target procedure.
// We need to scan the CTEs for entries that use LIKE, those are the table arguments
// we will check the details those later, for now we just need the names
// and the AST.  Note that we previously checked that any duplicate parameter
// names were identically typed. e.g. in the below "source" must be identical
// in both cases.
//
//   if bb == 1 then
//     with source(*) like (select 1 x)
//     select * from source;
//   else
//     with source(*) like (select 1 x)
//     select * from source where x = bb;
//   end if;
static void sem_accumulate_cte_info(ast_node *stmt, shared_cte_info *info)
{
  Contract(is_ast_with_select_stmt(stmt));
  EXTRACT_ANY_NOTNULL(with_prefix, stmt->left)
  EXTRACT(cte_tables, with_prefix->left);

  for (ast_node *ast = cte_tables; ast; ast = ast->right) {
    EXTRACT_NOTNULL(cte_table, ast->left);
    EXTRACT_NOTNULL(cte_decl, cte_table->left);
    EXTRACT_ANY_NOTNULL(cte_body, cte_table->right);

    if (is_ast_like(cte_body)) {
      EXTRACT_STRING(cte_name, cte_decl->left);
      if (info->callback) {
        info->callback(info->context, cte_name, cte_decl);
      }
    }
  }
}

// Walk a statement list inside of a shared fragment
// in all such cases there can only be one statement in the list
// anything else is an error and is dutifully recorded.
static void sem_accumulate_stmt_list(ast_node *ast, shared_cte_info *info) {
  Contract(is_ast_stmt_list(ast));

  // all the statement lists must have exactly one statement
  if (ast->right) {
    info->bad_statement_form = ast->right;
    return;
  }

  // note the representation of statement lists is such that they always have
  // at least one statement, an empty statement list is represented by null
  // statement lists not null statements.
  EXTRACT_ANY_NOTNULL(stmt, ast->left);
  if (is_ast_with_select_stmt(stmt)) {
    sem_accumulate_cte_info(stmt, info);
  }
  else if (is_ast_select_nothing_stmt(stmt)) {
    // nothing to do here, no info
    // note that select nothing is not considered a select variant because
    // it can only go in this one place, it's generally useless and cannot
    // be used as say a row sourde or in other places a select might go
    // If you look at sem_select_nothing_stmt you'll see the analysis will
    // fail if it appears anywhere but exactly in else caluse of a conditional
    // shared fragment. So this is literally the only place it is allowed to be.
    // It was made to do this one job. An `else` clause or empty else rewrite that
    // produces the correct shaped empty row.
  }
  else if (!is_select_variant(stmt)) {
    info->non_select_stmt = stmt;
    return;
  }
}

// The cond_action node is the predicate of an IF/ELSEIF and its statement list
// the statement list must be non-empty.  The expression doesn't contribute
// to the CTEs and is therefore ignored (it's checked elsewhere)
static void sem_accumulate_cond_action(ast_node *ast, shared_cte_info *info) {
  Contract(is_ast_cond_action(ast));
  EXTRACT(stmt_list, ast->right);
  if (!stmt_list) {
    // empty statement list is not allowed
    info->bad_statement_form = ast;
    return;
  }
  sem_accumulate_stmt_list(stmt_list, info);
}

// Here we simply walk the elseif chain processing each statement list
static void sem_accumulate_elseif_list(ast_node *ast, shared_cte_info *info) {
  Contract(is_ast_elseif(ast));

  while (ast) {
    Contract(is_ast_elseif(ast));
    EXTRACT(cond_action, ast->left);
    sem_accumulate_cond_action(cond_action, info);
    ast = ast->right;
  }
}

// The if statement form has the main cond_action then an optional
// elseif chain and then an optional else node.  The else node is not
// actually optional for shared fragments so we will give an error
// if it is absent.  Otherwise the helpers above descend into the pieces.
// In each case we record the ast_node that should get the error if there is one.
static void sem_accumulate_if_stmt(ast_node *ast, shared_cte_info *info) {
  Contract(is_ast_if_stmt(ast));
  EXTRACT_NOTNULL(cond_action, ast->left);
  EXTRACT_NOTNULL(if_alt, ast->right);
  EXTRACT(elseif, if_alt->left);
  EXTRACT_NAMED(elsenode, else, if_alt->right);

  sem_accumulate_cond_action(cond_action, info);

  if (elseif) {
    sem_accumulate_elseif_list(elseif, info);
  }

  if (elsenode) {
    EXTRACT(stmt_list, elsenode->left);
    if (!stmt_list) {
      info->bad_statement_form = ast;
      return;
    }
    sem_accumulate_stmt_list(stmt_list, info);
  }
  else {
    info->missing_else = ast;
  }
}

// The presence of a migration proc is an indirect declaration of its signature
// make a declare proc for that migration out of thin air and add it to the
// known proc decls as usual so that we can report errors later if the migration
// proc we find does not match.
static bool sem_create_migration_proc_prototype(ast_node *origin, CSTR name)
{
 /*
  {declare_proc_stmt}
  | {proc_name_type}
  | | {name foo}
  | | {int PROC_FLAG_USES_DML}
  | {proc_params_stmts}
 */

  AST_REWRITE_INFO_SET(origin->lineno, origin->filename);

  ast_node *ast_name = new_ast_str(name);
  ast_node *proc_name_flags = new_ast_proc_name_type(ast_name, new_ast_option(PROC_FLAG_USES_DML));
  ast_node *declare_proc_stmt = new_ast_declare_proc_stmt(proc_name_flags, new_ast_proc_params_stmts(NULL, NULL));

  AST_REWRITE_INFO_RESET();

  sem_declare_proc_stmt(declare_proc_stmt);
  return !is_error(declare_proc_stmt);
}

// The procedure is already known to be of the correct shape
// that is, either one select, or else an if statement with one select
// in each branch. We figure out which case we're in and then accumulate the
// pieces using the callback to tell our caller what we found.
static void sem_accumulate_proc_cte_info(ast_node *create_proc_stmt, shared_cte_info *info) {
  Contract(is_ast_create_proc_stmt(create_proc_stmt));

  EXTRACT_NOTNULL(proc_params_stmts, create_proc_stmt->right);
  EXTRACT_NOTNULL(stmt_list, proc_params_stmts->right);
  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  if (is_ast_with_select_stmt(stmt)) {
    sem_accumulate_cte_info(stmt, info);
  }
  else if (is_ast_if_stmt(stmt)) {
    sem_accumulate_if_stmt(stmt, info);
  }
  // note, it might be a normal select, in which case there is nothing to do.
  // a normal select has no CTE LIKE forms because it has no CTEs.
  // We know it's one of the legal forms by the time we are here.
}

// Save the name of the first table parameter that we find, this is
// used in a context were we just want to know that there are none
// so if we find one that's the error.
static void found_any_table_params_callback(void *context, CSTR name, ast_node *cte_decl) {
  // save the first name we find
  if (!*(CSTR *)context) {
    *(CSTR*)context = name;
  }
}

// Here we ensure that the called shared fragment does not need any table bindings
// because none were provided!
static void sem_shared_fragment_ensure_no_table_binding(
  ast_node *call_stmt,
  ast_node *create_proc_stmt)
{
  Contract(is_ast_create_proc_stmt(create_proc_stmt));

  // the procedure exists, and it is not in an error state (already checked)
  Contract(!is_error(create_proc_stmt));

  // and furthermore it's got a result type, again this is already checked.
  Contract(is_struct(create_proc_stmt->sem->sem_type));

  CSTR cte_name = NULL;
  shared_cte_info info;
  memset(&info, 0, sizeof(info));
  info.callback = found_any_table_params_callback;
  info.context = &cte_name;

  sem_accumulate_proc_cte_info(create_proc_stmt, &info);

  if (cte_name) {
    report_error(call_stmt, "CQL0430: no actual table was provided for the table parameter", cte_name);
    record_error(call_stmt);
  }
}

// Add the cte_decl to the list provided in context but de-duplicate
// we're doing this because we will want this list to know if all of the required table parameters
// are covered by the USING clause of the call.  We will have previously checked that
// any duplicated table parameter names have exactly the same type.
static void make_distinct_table_params_list_callback(void *context, CSTR cte_name, ast_node *cte_decl) {
  list_item **head = (list_item**)context;

  // check for duplicates, ignore any, we only need one copy
  list_item *item = *head;
  while (item) {
    EXTRACT_NAMED_NOTNULL(decl, cte_decl, item->ast);
    EXTRACT_STRING(existing_name, decl->left);
    if (!StrCaseCmp(existing_name, cte_name)) {
      break;
    }
    item = item->next;
  }

  // duplicate not found
  if (!item) {
     add_item_to_list(head, cte_decl);
  }
}


// This is a recursive check for any embedded CTEs that have names that will conflict with a given binding
// this can get quite complicated.  Here's an example:
//
// [[shared_fragment]]
// create proc too()
// begin
//  with
//    source(*) like (select 1 x),
//    foo(*) as (select * from source)
//    select * from foo;
// end;
//
// [[shared_fragment]]
// create proc goo()
// begin
//  with
//    source(*) like (select 1 x),
//    (call too() using source as source)
//    select * from too;
// end;
//
// with foo(*) as (select 1 x)
//   select * from (call goo() using foo as source);
//
// here the call to "goo" must fail because it tries to bind "foo" as source
// and there is a "foo" inside of "too". This is a problem because "goo" calls "too"
// and forwards its "source" formal to too.
//
// To find these we have to recursively walk procedure bindings to get to the deepest
// shared fragment.  Note that we don't have to walk where there is no binding
// nor do we have to walk if the binding does not forward an argument that is provided
// externally.
cql_noexport void sem_check_bound_cte_name_conflict(ast_node *node, binding_info *info) {
  if (is_ast_cte_table(node)) {
    EXTRACT_NOTNULL(cte_decl, node->left);
    EXTRACT_ANY_NOTNULL(cte_body, node->right);

    // this is a proxy node, it isn't a source of conflicts
    // this name will be replaced, it's even ok if the arg name matches the formal name
    if (is_ast_like(cte_body)) {
      return;
    }

    EXTRACT_STRING(cte_name, cte_decl->left);

    if (!StrCaseCmp(cte_name, info->actual)) {
      bprintf(info->err, "Procedure '%s' has a different CTE that is also named '%s'\n", info->proc, info->actual);
      bprintf(info->err, "The above originated from CALL %s USING %s AS %s\n", info->proc, info->actual, info->formal);
      return;
    }
  }

  if (is_ast_cte_binding(node)) {
    EXTRACT_STRING(actual, node->left);
    EXTRACT_STRING(formal, node->right);

    // if we are forwarding the table parameter then we have to analyze what's under us.
    // for this analysis we don't use the formal name since that name is itself replaced
    if (!StrCaseCmp(info->formal, actual)) {
      binding_info new;
      new.err = info->err;
      new.proc = info->proc_calling;
      new.proc_calling = NULL;
      new.actual = info->actual;
      new.formal = formal;

      ast_node *proc_ast = find_proc(new.proc);
      Invariant(proc_ast);

      sem_check_bound_cte_name_conflict(proc_ast, &new);

      if (info->err->used > 1) {
         bprintf(info->err, "The above originated from CALL %s USING %s AS %s\n", info->proc, info->actual, info->formal);
      }
    }

    // nothing underneath a cte_binding anyway, so either it's an error or we're done, either way.
    return;
  }

  // declare the new info in case we need it
  // this has to be outside of the test below so it survives that block
  binding_info new_info;

  // if we're on a shared CTE usage, then we recurse into the CALL
  if (is_ast_shared_cte(node)) {
    EXTRACT_NOTNULL(call_stmt, node->left);
    EXTRACT(cte_binding_list, node->right);

    EXTRACT_NAME_AST(name_ast, call_stmt->left);
    EXTRACT_STRING(name, name_ast);

    new_info = *info;
    new_info.proc_calling = name;

    // we're going to recurse with the new info, the calling target is populated now
    info = &new_info;
  }

  // Recurse left and right if there are nodes and no errors already

  if (info->err->used == 1 && ast_has_left(node)) {
    sem_check_bound_cte_name_conflict(node->left, info);
  }

  if (info->err->used == 1 && ast_has_right(node)) {
    sem_check_bound_cte_name_conflict(node->right, info);
  }
}

// Here we ensure that the table binding for any given shared CTE is correct
// This means that the number of table args has to match and the provided names
// have to exist and be compatible with the table parameters. There can be no
// extras and no conflicts.
static void sem_shared_fragment_table_binding(
  ast_node *call_stmt,
  ast_node *create_proc_stmt,
  ast_node *cte_binding_list)
{
  Contract(is_ast_call_stmt(call_stmt));
  Contract(is_ast_create_proc_stmt(create_proc_stmt));
  Contract(is_ast_cte_binding_list(cte_binding_list));

  CHARBUF_OPEN(tmp);

  // the procedure exists, and it is not in an error state (already checked)
  Contract(!is_error(create_proc_stmt));

  // and furthermore it's got a result type, again this is already checked.
  Contract(is_struct(create_proc_stmt->sem->sem_type));

  EXTRACT_STRING(proc_name, call_stmt->left);

  symtab *bindings = symtab_new();
  symtab *formals = symtab_new();
  symtab *cols = NULL;
  ast_node *item = NULL;

  for (item = cte_binding_list ; item; item = item->right) {
    EXTRACT_NOTNULL(cte_binding, item->left);
    EXTRACT_STRING(actual, cte_binding->left);
    EXTRACT_STRING(formal, cte_binding->right);

    bool_t added = symtab_add(bindings, formal, cte_binding);
    if (!added) {
      report_error(cte_binding->right, "CQL0428: duplicate binding of table in CALL/USING clause", formal);
      record_error(call_stmt);
      goto cleanup;
    }
  }

  EXTRACT_NOTNULL(proc_params_stmts, create_proc_stmt->right);

  // setup to get the list of unique table parameters required for this call
  list_item *parms_head = NULL;
  shared_cte_info info;
  memset(&info, 0, sizeof(info));
  info.callback = make_distinct_table_params_list_callback;
  info.context = &parms_head;

  sem_accumulate_proc_cte_info(create_proc_stmt, &info);

  if (!parms_head) {
    report_error(cte_binding_list, "CQL0429: called procedure has no table arguments but a USING clause is present", proc_name);
    record_error(call_stmt);
    goto cleanup;
  }

  // We need to scan the table arguments
  // for each one of those we then need to ensure that the of the actual table is compatible
  // with the type of the formal table and that the total number of columns is a match.
  // Note that there cannot be extra columns because if there were that might create ambiguities
  // in the result.

  for (list_item *it = parms_head; it; it = it->next) {
    EXTRACT_NOTNULL(cte_decl, it->ast);

    EXTRACT_STRING(cte_name, cte_decl->left);
    symtab_entry *entry = symtab_find(bindings, cte_name);

    if (!entry) {
      report_error(cte_binding_list, "CQL0430: no actual table was provided for the table parameter", cte_name);
      record_error(call_stmt);
      goto cleanup;
    }

    EXTRACT_NOTNULL(cte_binding, entry->val);
    ast_node *ast_formal = cte_binding->right;
    ast_node *ast_actual = cte_binding->left;
    EXTRACT_STRING(actual, ast_actual);
    EXTRACT_STRING(formal, ast_formal);

    // sanity check, the name matches, we just looked it up...
    Invariant(!StrCaseCmp(formal, cte_name));

    bool_t added = symtab_add(formals, cte_name, cte_decl);
    Contract(added); // known to be unique due to previous checks

    // We have to bind the name of the actual table in the current context
    // sem_find_table does exactly this -- this is the code used for a table_ref
    // inside of a from clause
    ast_node *table = sem_find_table(actual, ast_actual);
    if (!table) {
      // errors already reported
      record_error(call_stmt);
      goto cleanup;
    }

    sem_struct *sptr_formals = cte_decl->sem->sptr;
    sem_struct *sptr_actuals = table->sem->sptr;
    ast_formal->sem = cte_decl->sem;
    ast_actual->sem = table->sem;
    sem_add_flags(ast_formal, 0); // forces the sem info to be copied but change nothing
    sem_add_flags(ast_actual, 0); // forces the sem info to be copied but change nothing

    // Both are known to be struct types
    Invariant(sptr_formals);
    Invariant(sptr_actuals);

    if (sptr_formals->count != sptr_actuals->count) {
      report_error(ast_actual, "CQL0432: table provided must have the same number of columns as the table parameter", actual);
      record_error(call_stmt);
      goto cleanup;
    }

    cols = symtab_new();

    for (uint32_t i = 0; i < sptr_actuals->count; i++) {
      // we're adding the address of the name as a surrogate for the index 'i'
      // we can easily undo this to get 'i' back when we look it up
      symtab_add(cols, sptr_actuals->names[i], &sptr_actuals->names[i]);
    }

    for (uint32_t i = 0; i < sptr_formals->count; i++) {
      CSTR name = sptr_formals->names[i];
      symtab_entry *col_entry = symtab_find(cols, name);
      if (!col_entry) {
        CSTR msg = dup_printf(
          "CQL0433: table argument '%s' requires column '%s' but it is missing in provided table",
          formal, name);
        report_error(ast_actual, msg, actual);
        record_error(call_stmt);
        goto cleanup;
      }

      CSTR *pname = col_entry->val;

      uint32_t j = (uint32_t)(pname - &sptr_actuals->names[0]);

      sem_t sem_type_formal = sptr_formals->semtypes[i];
      sem_t sem_type_actual = sptr_actuals->semtypes[j];
      CSTR kformal = sptr_formals->kinds[i];
      CSTR kactual = sptr_actuals->kinds[j];

      if (!sem_verify_assignment(ast_actual, sem_type_formal, sem_type_actual, name)) {
        CSTR msg = dup_printf(
          "additional info: provided table column '%s.%s' is not compatible with target '%s.%s'",
          actual, name, formal, name);
        report_error(ast_actual, msg, NULL);
        record_error(call_stmt);
        goto cleanup;
      }

      sem_combine_kinds_general(ast_actual, kformal, kactual);
      if (is_error(ast_actual)) {
        record_error(call_stmt);
        goto cleanup;
      }
    }

    symtab_delete(cols);
    cols = NULL;
  }

  for (item = cte_binding_list ; item; item = item->right) {
    EXTRACT_NOTNULL(cte_binding, item->left);
    EXTRACT_ANY_NOTNULL(ast_formal, cte_binding->right);
    EXTRACT_ANY_NOTNULL(ast_actual, cte_binding->left);

    EXTRACT_STRING(actual, ast_actual);
    EXTRACT_STRING(formal, ast_formal);

    if (!symtab_find(formals, formal)) {
      report_error(ast_formal, "CQL0431: an actual table was provided for a table parameter that does not exist", formal);
      record_error(call_stmt);
      goto cleanup;
    }
  }

  for (item = cte_binding_list ; item; item = item->right) {
    EXTRACT_NOTNULL(cte_binding, item->left);
    EXTRACT_STRING(actual, cte_binding->left);
    EXTRACT_STRING(formal, cte_binding->right);

    binding_info bind_info;
    bind_info.err = &tmp;
    bind_info.proc = proc_name;
    bind_info.proc_calling = NULL;
    bind_info.actual = actual;
    bind_info.formal = formal;

    ast_node *cte_decl = find_cte(actual);

    // if the actual name is not a cte (i.e. it's a global) then it can't conflict
    // because any CTE in our subtree is not allowed to conflict with any global name
    if (!cte_decl) {
      continue;
    }

    EXTRACT_NOTNULL(cte_table, cte_decl->parent);
    EXTRACT_ANY_NOTNULL(cte_body, cte_table->right);

    // If this CTE declares a table parameter then this binding  will be checked when we invoke this
    // shared fragment and an actual value is provided.  It would be meaningless to check if the name of the
    // formal causes a conflict, that name won't be used unless the actual happens to match
    // the formal.  In any case it is the actual parameter that matters.  We have to be in a shared fragment
    // or the like form would be illegal in the first place and we wouldn't be here.
    if (is_ast_like(cte_body)) {
      continue;
    }

    sem_check_bound_cte_name_conflict(create_proc_stmt, &bind_info);

    if (tmp.used > 1) {
      CSTR err_msg =
        dup_printf("CQL0444: this use of the named shared fragment is not legal because of a name conflict '%s'\n%s",
          proc_name,
          tmp.ptr);
      report_error(cte_binding, err_msg, NULL);
      record_error(call_stmt);
      goto cleanup;
    }
  }


cleanup:
  CHARBUF_CLOSE(tmp);

  if (cols) {
    symtab_delete(cols);
  }
  symtab_delete(bindings);
  symtab_delete(formals);
}

// We've found a shared fragment call site, process the fragment
static void sem_shared_cte(ast_node *cte_body) {
  EXTRACT_NOTNULL(call_stmt, cte_body->left);
  EXTRACT(cte_binding_list, cte_body->right);

  bool_t in_shared_fragment_call_saved = in_shared_fragment_call;
  in_shared_fragment_call = true;

  // The semantic info for this kind of call looks just like any other
  // we use the helper directly because this is not a loose call statement
  // but there is no cursor.  We don't want the procedure we are in (if any)
  // to become a result-set procedure.
  sem_call_stmt_opt_cursor(call_stmt, NULL);
  if (is_error(call_stmt)) {
    record_error(cte_body);
    goto cleanup;
  }

  // check if we are calling a shared fragment
  EXTRACT_NAME_AST(proc_name_ast, call_stmt->left);
  EXTRACT_STRING(proc_name, proc_name_ast);
  ast_node *proc_stmt = find_proc(proc_name);
  if (!is_proc_shared_fragment(proc_stmt)) {
    report_error(proc_name_ast, "CQL0224: a CALL statement inside SQL may call only a shared fragment i.e. [[shared_fragment]]", proc_name);
    record_error(cte_body);
    goto cleanup;
  }

  if (!is_ast_create_proc_stmt(proc_stmt)) {
    report_error(proc_name_ast, "CQL0468: [[shared_fragment]] may only be placed on a CREATE PROC statement", proc_name);
    record_error(cte_body);
    goto cleanup;
  }

  if (cte_binding_list) {
    // if there is a binding list we have to ensure the number and type of bindings are correct
    sem_shared_fragment_table_binding(call_stmt, proc_stmt, cte_binding_list);
    if (is_error(call_stmt)) {
      record_error(cte_body);
      goto cleanup;
    }
  }
  else {
    // if there is no binding list we still have to ensure that there are no bindings required
    sem_shared_fragment_ensure_no_table_binding(call_stmt, proc_stmt);
    if (is_error(call_stmt)) {
      record_error(cte_body);
      goto cleanup;
    }
  }

  cte_body->sem = call_stmt->sem;

cleanup:
  in_shared_fragment_call = in_shared_fragment_call_saved;
}

// Here we process the CTE and the select it is associated with:
//  * analyze the select
//    * if it is compound analyze only the first part of the union;
//      that part is not allowed to have recursive mention to the CTE
//  * bind the CTE to the analyzed select
//  * analyze the rest of the select if we only analyzed the first part
static void sem_cte_table(ast_node *ast)  {
  Contract(is_ast_cte_table(ast));
  EXTRACT(cte_decl, ast->left);
  EXTRACT_ANY_NOTNULL(cte_body, ast->right);

  if (is_ast_like(cte_body)) {
    EXTRACT_NAMED_NOTNULL(like_ast, like, cte_body);

    if (!in_shared_fragment || sem_with_depth() > 1) {
      CSTR name = NULL;
      if (current_proc) {
        EXTRACT_STRING(proc_name, current_proc->left);
        name = proc_name;
      }

      report_error(cte_body,
          "CQL0427: LIKE CTE form may only be used inside a shared fragment at the top level"
          " i.e. [[shared_fragment]]", name);

      record_error(ast);
      return;
    }

    if (is_id(like_ast->left)) {
      // name alias

      // must be a valid shape
      ast_node *found_shape = sem_find_shape_def_base(like_ast, LIKEABLE_FOR_VALUES);
      if (!found_shape) {
        record_error(ast);
        return;
      }

      // now process the declaration using the types from the select
      sem_cte_decl(cte_decl, found_shape);
      if (is_error(cte_decl)) {
        record_error(ast);
        return;
      }

      ast->sem = cte_decl->sem;
      return;
    }
    else {
      // this is the LIKE (select ..) case, we just evaluate the select as usual
      cte_body = cte_body->left;
    }
  }

  // the simple select form is allowed to be recursive

  if (is_ast_select_stmt(cte_body)) {
    ast_node *select_stmt = cte_body;
    // To handle possible recursive references we check if the cte is being
    // defined by a union or union all.  If it, we create the type information
    // for the CTE from just the top half of the union.  Which must not have
    // recursive references.  Otherwise we use the whole thing.
    EXTRACT_NOTNULL(select_core, select_stmt->left->left);

    // analyze just the top half of the union
    sem_select_core(select_core);
    if (is_error(select_core)) {
      record_error(ast);
      return;
    }

    // now process the declaration using the types from the base select
    sem_cte_decl(cte_decl, select_core);
    if (is_error(cte_decl)) {
      record_error(ast);
      return;
    }

    // at this point the cte is defined, we can analyze the entire select
    // for the CTE.  This allows recursive references other parts of the select.
    // However the type defined for the CTE is provisional, we haven't yet
    // considered the effect of the union on nullability.  But what we have
    // is what we will use for the recurrence.

    sem_select_no_with(select_stmt);
    if (is_error(select_stmt)) {
      record_error(ast);
      return;
    }

    // Once this is done we have to revise the semantic type to account for
    // possible nulls in the other branches of the union.  This is the type
    // we will expose to the world.

    // replace the types but not the names!
    sem_struct *sptr1 = cte_decl->sem->sptr;
    sem_struct *sptr2 = select_stmt->sem->sptr;
    sem_t *semtypes = sptr1->semtypes;

    sptr1->semtypes = sptr2->semtypes;

    // if any of the names are QID, we have to save that
    for (int i = 0; i < sptr1->count; i++) {
       if (semtypes[i] & SEM_TYPE_QID) {
         sptr1->semtypes[i] |= SEM_TYPE_QID;
       }
    }
  }
  else if (is_ast_shared_cte(cte_body)) {
    sem_shared_cte(cte_body);
    if (is_error(cte_body)) {
      record_error(ast);
      return;
    }

    // now process the declaration using the types from call
    sem_cte_decl(cte_decl, cte_body);
    if (is_error(cte_decl)) {
      record_error(ast);
      return;
    }
  }
  else {
    // all the other forms are treated directly like a "local view"
    // which is basically what a CTE is.  No special processing of the top half etc.

    ast_node *select_stmt = cte_body;

    sem_any_select(select_stmt);
    if (is_error(select_stmt)) {
      record_error(ast);
      return;
    }

    // now process the declaration using the types from the select
    sem_cte_decl(cte_decl, select_stmt);
    if (is_error(cte_decl)) {
      record_error(ast);
      return;
    }
  }

  ast->sem = cte_decl->sem;
}

// Walk the list of CTE tables in the WITH clause and set up each one.
static void sem_cte_tables(ast_node *head)  {
  Contract(is_ast_cte_tables(head));

  for (ast_node *ast = head; ast; ast = ast->right) {
    sem_cte_table(ast->left);
    if (is_error(ast->left)) {
      record_error(ast);
      record_error(head);
      return;
    }
  }

  record_ok(head);
}

// This tells us how deeply nested we are in CTE expressions at the moment
static uint32_t sem_with_depth() {
  uint32_t depth = 0;
  cte_state *head = cte_cur;
  while (head) {
    depth++;
    head = head->prev;
  }
  return depth;
}

// Add a new set of tables to the stack
// Needed because WITH statements can be nested due to nested selects
// So there can be multiple scopes within one select statement.
static void sem_push_cte_state() {
  cte_state *new_state = _ast_pool_new(cte_state);

  new_state->prev = cte_cur;
  new_state->ctes = symtab_new();
  cte_cur = new_state;
}

// Remove this CTE from the stack
static void sem_pop_cte_state() {
  Contract(cte_cur);
  Contract(cte_cur->ctes);

  symtab_delete(cte_cur->ctes);
  cte_cur = cte_cur->prev;

  // the CTE state is pool allocated so we don't have to free it
}

// Set up a new CTE context, chaining to the previous one (in case of
// nested selects) and then do semantic analysis of the select that
// was scoped by the WITH.
static void sem_with_select(ast_node *ast) {
  Contract(is_ast_with_select_stmt(ast));
  EXTRACT_ANY_NOTNULL(with_prefix, ast->left)
  EXTRACT(cte_tables, with_prefix->left);
  EXTRACT_ANY_NOTNULL(select_stmt, ast->right);

  sem_push_cte_state();

  sem_cte_tables(cte_tables);
  if (is_error(cte_tables)) {
    record_error(ast);
    goto cleanup;
  }

  sem_select_no_with(select_stmt);
  if (is_error(select_stmt)) {
    record_error(ast);
    goto cleanup;
  }

  ast->sem = select_stmt->sem;

cleanup:
  sem_pop_cte_state();
}

// top level with-select stmt
static void sem_with_select_stmt(ast_node *stmt) {
  Contract(is_ast_with_select_stmt(stmt));

  Invariant(cte_cur == NULL);
  sem_select_rewrite_backing(stmt);
  sem_update_proc_type_for_select(stmt);
  Invariant(cte_cur == NULL);
}

// Here we check the view found in the "previous" schema against the current schema.
// There are several validations we have to do here:
//  * the view should be present (but maybe marked with @delete)
//  * the view must not be a table now
//  * the view has to have a compatible create version
//  * the view has to have a compatible delete version
//  * the view create flags (like TEMP, or IF NOT EXISTS) must be the same
static void sem_validate_previous_view(ast_node *prev_view) {
  Contract(!current_joinscope);

  Contract(is_ast_create_view_stmt(prev_view));
  EXTRACT_OPTION(prev_flags, prev_view->left);
  EXTRACT_NAMED(prev_view_and_attrs, view_and_attrs, prev_view->right);
  EXTRACT_NAMED(prev_view_details_select, view_details_select, prev_view_and_attrs->left);
  EXTRACT_NAMED(prev_view_details, view_details, prev_view_details_select->left);
  EXTRACT_NAME_AST(prev_name_ast, prev_view_details->left);
  EXTRACT_STRING(name, prev_name_ast);

  bool_t is_temp = !! (prev_flags & VIEW_IS_TEMP);

  ast_node *ast = find_table_or_view_even_deleted(name);

  if (!ast) {
    if (is_temp || options.schema_exclusive) {
      // temp view totally deleted -> that's ok
      // In exclusive mode views  are bulk deleted, so no tombstones are needed
      return;
    }
  }

  if (!ast) {
    report_error(prev_view, "CQL0104: view was present but now it does not exist (use @delete instead)", name);
    record_error(prev_view);
    return;
  }

  if (is_ast_create_table_stmt(ast)) {
    report_error(ast, "CQL0105: object was a view but is now a table", name);
    record_error(prev_view);
    record_error(ast);
    return;
  }

  enqueue_pending_region_validation(prev_view, ast, name);
}

// Here we check the trigger found in the "previous" schema against the current schema.
// There are several validations we have to do here:
//  * the trigger should be present (but maybe marked with @delete)
//  * the trigger has to have a compatible delete version
//  * the create flags (like TEMP, or IF NOT EXISTS) must be the same
static void sem_validate_previous_trigger(ast_node *prev_trigger) {
  Contract(!current_joinscope);
  Contract(is_ast_create_trigger_stmt(prev_trigger));

  EXTRACT_OPTION(prev_flags, prev_trigger->left);
  EXTRACT_NAMED_NOTNULL(prev_trigger_body_vers, trigger_body_vers, prev_trigger->right);
  EXTRACT_NAMED_NOTNULL(prev_trigger_def, trigger_def, prev_trigger_body_vers->left);
  EXTRACT_NAME_AST(prev_trigger_name_ast, prev_trigger_def->left);
  EXTRACT_STRING(name, prev_trigger_name_ast);

  bool_t is_temp = !! (prev_flags & TRIGGER_IS_TEMP);

  ast_node *ast = find_trigger(name);
  if (!ast) {
    if (is_temp || options.schema_exclusive) {
      // Temp totally deleted -> that's ok, they always go away
      // In exclusive mode triggers are bulk deleted, so no tombstones are needed
      return;
    }

    // If the table the trigger was on is going away then we don't need
    // to verify that the trigger has a tombstone.  In fact is it not
    // possible to declare the tombstone now because the table name is not
    // valid.  There's no need for the tombstone anyway because when the
    // table is deleted all its triggers will also be deleted.

    EXTRACT_NAMED_NOTNULL(prev_trigger_condition, trigger_condition, prev_trigger_def->right);
    EXTRACT_NAMED_NOTNULL(prev_trigger_op_target, trigger_op_target, prev_trigger_condition->right);
    EXTRACT_NAMED_NOTNULL(prev_trigger_target_action, trigger_target_action, prev_trigger_op_target->right);
    EXTRACT_STRING(prev_table_name, prev_trigger_target_action->left);
    ast_node *ast_table = find_table_or_view_even_deleted(prev_table_name);

    // the table must exist and be affirmatively deleted to avoid the error!
    if (ast_table && ast_table->sem->delete_version > 0) {
      return;
    }

    report_error(prev_trigger, "CQL0106: trigger was present but now it does not exist (use @delete instead)", name);
    record_error(prev_trigger);
    return;
  }

  enqueue_pending_region_validation(prev_trigger, ast, name);
}

// When we locate a table used by a view we simply add that info to the dependency map in both directions
static void sem_found_dep_in_view(CSTR _Nonnull name, ast_node *_Nonnull target_ast, void *_Nullable context) {
  Contract(is_ast_create_table_stmt(target_ast) || is_ast_create_view_stmt(target_ast));
  EXTRACT_NOTNULL(create_view_stmt, context);

  record_table_dependencies(create_view_stmt, target_ast);
}

// Here we peek into the view body and find the tables that it uses.
// We're going to record those so that if a table is unsubscribed we can make sure
// there are no lingering views still using it. We don't have to worry about nested views
// because if the main view uses a nested view and that nested view uses the table then the nested view itself
// will cause an error to be reported.
static void sem_record_view_dependencies(ast_node *ast) {
  Contract(is_ast_create_view_stmt(ast));

  table_callbacks callbacks = {
    .callback_any_table = sem_found_dep_in_view,
    .callback_any_view = sem_found_dep_in_view,
    .callback_context = ast,
    .do_not_recurse_views = true,
  };

  find_table_refs(&callbacks, ast);
}

// Create view analysis is very simple because select does the heavy lifting.  All we
// have to do is validate that the view is unique then validate the select statement.
// The view will be added to the table/view list.
// Views must not be allowed to have any NULL type columns, all nulls must be converted to
// some type with a CAST.
static void sem_create_view_stmt(ast_node *ast) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_create_view_stmt(ast));
  EXTRACT(view_and_attrs, ast->right);
  EXTRACT_NOTNULL(view_details_select, view_and_attrs->left);
  EXTRACT_NOTNULL(view_details, view_details_select->left);
  EXTRACT_ANY(attrs, view_and_attrs->right);
  EXTRACT_ANY_NOTNULL(select_stmt, view_details_select->right);
  EXTRACT_NAME_AST(name_ast, view_details->left);
  EXTRACT(name_list, view_details->right);
  EXTRACT_STRING(name, name_ast);

  // if we're validating a previous view we don't want to parse the contents, we only want
  // to verify that this view has resonable name and version markings and so forth.
  // We can't try to analyze the previous version because, like with migration below
  // the view may refer to previous view might refer to now deleted columns and so forth.
  if (validating_previous_schema) {
    // begin in the ok state, validate (which may add errors) and then we're done here
    record_ok(ast);
    sem_validate_previous_view(ast);
    return;
  }

  bool_t adding_current_entity = will_add_current_entity();

  // if there is an existing view, save it here so we can check for duplicates later.
  ast_node *existing_defn = adding_current_entity ? find_table_or_view_even_deleted(name) : NULL;

  // View declarations (i.e. outside of any proc) are totally ignored
  // in the context of a schema migration script.  This prevents us from
  // getting errors because the view refers to tables or columns that are not yet
  // in existence in the version we are migrating.  If you need a view
  // in your migration script you have to create it and use it yourself
  // since you can't rely on the presence of that view during migration anyway.
  if (schema_upgrade_version > 0 && !current_proc) {
    // burn the name, creating a bogus view, views are not allowed to be used in migration scripts anyway
    // we add this stub so that we can produce a superior error if you try to refer to this view
    symtab_add(tables, name, ast);
    // no other processing of semantics
    record_ok(ast);
    return;
  }

  // CREATE [opt_temp] VIEW [name] AS [select_stmt]
  sem_any_select(select_stmt);
  if (is_error(select_stmt)) {
    record_error(ast);
    return;
  }

  if (name_list && !sem_verify_no_duplicate_names(name_list)) {
    record_error(ast);
    return;
  }

  if (name_list) {
    sem_verify_no_null_columns(select_stmt);
    if (is_error(select_stmt)) {
      record_error(ast);
      return;
    }
  }
  else {
    sem_verify_no_anon_no_null_columns(select_stmt);
    if (is_error(select_stmt)) {
      record_error(ast);
      return;
    }
  }

  version_attrs_info vers_info;
  init_version_attrs_info(&vers_info, name, ast, attrs);

  bool_t valid_version_info = sem_validate_version_attrs(&vers_info);
  Invariant(valid_version_info);  // nothing can go wrong with view version info

  if (!sem_validate_vers_ok_in_context(&vers_info)) {
    record_error(ast);
    return;
  }

  Invariant(is_struct(select_stmt->sem->sem_type));
  Invariant(select_stmt->sem->sptr);

  select_stmt->sem->sptr->struct_name = name;
  select_stmt->sem->jptr = sem_join_from_sem_struct(select_stmt->sem->sptr);

  ast->sem = new_sem(select_stmt->sem->sem_type);
  ast->sem->sptr = select_stmt->sem->sptr;
  ast->sem->jptr = select_stmt->sem->jptr;
  ast->sem->sem_type |= vers_info.flags;
  ast->sem->delete_version = vers_info.delete_version;
  ast->sem->region = current_region;

  if (name_list) {
    sem_struct *sptr = ast->sem->sptr;
    ast_node *item = name_list;

    for (uint32_t i = 0; i < sptr->count; i++) {
      if (!item) {
        report_error(ast, "CQL0101: too few column names specified in view", name);
        record_error(ast);
        return;
      }

      // use the names from the VIEW decl rather than the select
      EXTRACT_STRING(col_name, item->left);
      sptr->names[i] = col_name;

      item = item->right;
    }

    if (item) {
      report_error(ast, "CQL0102: too many column names specified in view", name);
      record_error(ast);
      return;
    }
  }

  if (ast->sem->delete_version > 0) {
    ast->sem->sem_type |= SEM_TYPE_DELETED;
  }

  if (existing_defn) {
    if (!sem_validate_identical_ddl(existing_defn, ast)) {
      report_error(name_ast, "CQL0103: duplicate table/view name", name);
      record_error(name_ast);
      record_error(ast);
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      sem_add_flags(ast, SEM_TYPE_ALIAS);
    }
    return;
  }

  if (adding_current_entity) {
    // deleted or no it goes in the main list
    add_item_to_list(&all_views_list, ast);

    // The name is consumed, some clients will use find_usable_and_not_deleted_table_or_view
    // to not see deleted views (e.g. select) others don't (e.g. drop)
    add_table_or_view(ast);

    // and record the annotation
    sem_record_annotation_from_vers_info(&vers_info);

    // record the tables used by this view (and cross link)
    sem_record_view_dependencies(ast);
  }
}

// Parse out the version attributes for this target for use in the semantic type
// Returns true if all is well, false if there was an error.
static bool_t sem_validate_version_attrs(version_attrs_info *vers_info) {
  Contract(vers_info);
  Contract(vers_info->target_ast);

  for (ast_node *ast = vers_info->attrs_ast; ast; ast = ast->right) {
    if (is_ast_recreate_attr(ast)) {
      // recreate attributes come in exactly this one order; enforced by syntax
      // we get the recreate node and an optional delete, nothing else
      Contract(ast == vers_info->attrs_ast);
      vers_info->recreate = true;
      vers_info->recreate_version_ast = ast;

      if (ast->left) {
        EXTRACT_STRING(group_name, ast->left);
        vers_info->recreate_group_name = group_name;
      }

      // optional delete node is present, it has shape, enforced by parser
      // cons up a fake v1 delete annotation for the vers_info
      if (ast->right) {
        AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
        ast_node *version_annotation = new_ast_version_annotation(new_ast_option(1), NULL);
        AST_REWRITE_INFO_RESET();

        vers_info->delete_version_ast = version_annotation;
        vers_info->delete_version = 1;
        vers_info->flags |= SEM_TYPE_DELETED;
      }

      // either way, we're done now
      return true;
    }
    if (is_ast_create_attr(ast)) {
      if (!sem_validate_version(vers_info->create_code, ast, &vers_info->create_version, &vers_info->create_proc)) {
        record_error(vers_info->target_ast);
        return false;
      }
      EXTRACT(version_annotation, ast->left);
      vers_info->create_version_ast = version_annotation;
    }
    else {
      Contract (is_ast_delete_attr(ast));
      if (!sem_validate_version(vers_info->delete_code, ast, &vers_info->delete_version, &vers_info->delete_proc)) {
        record_error(vers_info->target_ast);
        return false;
      }
      EXTRACT(version_annotation, ast->left);
      vers_info->delete_version_ast = version_annotation;
    }
  }

  if (vers_info->delete_version > 0 && vers_info->delete_version <= vers_info->create_version) {
    report_error(vers_info->target_ast, "CQL0107: delete version can't be <= create version", vers_info->name);
    return false;
  }

  if (schema_upgrade_version == -1) {
    if (vers_info->delete_version > 0) {
      vers_info->flags |= SEM_TYPE_DELETED;
    }
  }
  else {
    // The delete version is the version that the column was deleted in.
    // If we are migrating beyond that, the column is already deleted.
    // if were on that version (in a migration context) then you're allowed
    // to look at that column so that you can zero it or some such.
    if (vers_info->delete_version != -1 && schema_upgrade_version > vers_info->delete_version) {
      vers_info->flags |= SEM_TYPE_DELETED;
    }

    // The create version is the version that the column was created in.
    // If we are migrating to a schema before the column was created then we
    // cannot see it yet.
    if (vers_info->create_version != -1 && schema_upgrade_version < vers_info->create_version) {
      vers_info->flags |= SEM_TYPE_DELETED;
    }
  }

  return true;
}

// Ensure that the table parameter is not a backed table, if it is
// then mark an error at the indicated location
static void sem_non_backed_table(ast_node *ast_error, ast_node *ast_table) {
  Contract(ast_error);
  Contract(ast_table);

  if (is_ast_create_table_stmt(ast_table) && is_table_backed(ast_table)) {
    EXTRACT_NOTNULL(create_table_name_flags, ast_table->left);
    EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
    EXTRACT_STRING(name, name_ast);

    report_error(ast_error, "CQL0493: backed storage tables may not be used in indexes/triggers/drop", name);
    record_error(ast_error);
    return;
  }

  record_ok(ast_error);
}

// Ensure that the table parameter is not blob storage, if it is
// then mark an error at the indicated location
static void sem_non_blob_storage_table(ast_node *ast_error, ast_node *ast_table) {
  Contract(ast_error);
  Contract(ast_table);

  if (is_ast_create_table_stmt(ast_table) && is_table_blob_storage(ast_table)) {
    EXTRACT_NOTNULL(create_table_name_flags, ast_table->left);
    EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
    EXTRACT_STRING(name, name_ast);

    report_error(ast_error, "CQL0458: the indicated table may only be used for blob storage", name);
    record_error(ast_error);
    return;
  }

  record_ok(ast_error);
}

// This is the basic checking for the drop table statement
// * the table must exist in some version
// * it has to be a table and not a view
static void sem_drop_table_stmt(ast_node *ast) {
  Contract(is_ast_drop_table_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->right);
  EXTRACT_STRING(name, name_ast);

  // we might be making the dropped table a reality so it's ok to try to drop @deleted tables
  ast_node *table_ast = find_usable_table_or_view_even_deleted(name, name_ast, "CQL0108: table in drop statement does not exist");
  if (!table_ast) {
    record_error(ast);
    return;
  }

  sem_non_backed_table(ast, table_ast);
  if (is_error(ast)) {
    return;
  }

  sem_non_blob_storage_table(ast, table_ast);
  if (is_error(ast)) {
    return;
  }

  name_ast->sem = table_ast->sem;

  if (!is_ast_create_table_stmt(table_ast)) {
    report_error(name_ast, "CQL0109: cannot drop a view with drop table", name);
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// This is the basic checking for the drop view statement
// * the view must exist in some version
// * it has to be a view and not a table
static void sem_drop_view_stmt(ast_node *ast) {
  Contract(is_ast_drop_view_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->right);
  EXTRACT_STRING(name, name_ast);

  // we might be making the dropped view a reality so it's ok to try to drop @deleted views
  ast_node *view_ast = find_usable_table_or_view_even_deleted(name, name_ast, "CQL0110: view in drop statement does not exist");
  if (!view_ast) {
    record_error(ast);
    return;
  }

  name_ast->sem = view_ast->sem;

  if (!is_ast_create_view_stmt(view_ast)) {
    report_error(name_ast, "CQL0111: cannot drop a table with drop view", name);
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// This is the basic checking for the drop index statement
// * the index must exist (have been declared) in some version
// * it could be deleted now, that's ok, but the name has to be valid
static void sem_drop_index_stmt(ast_node *ast) {
  Contract(is_ast_drop_index_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->right);
  EXTRACT_STRING(name, name_ast);

  ast_node *index_ast = find_usable_index(name, name_ast, "CQL0112: index in drop statement was not declared");
  if (!index_ast) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// This is the basic checking for the drop trigger statement
// * the trigger must exist (have been declared) in some version
// * it could be deleted now, that's ok, but the name has to be valid
static void sem_drop_trigger_stmt(ast_node *ast) {
  Contract(is_ast_drop_trigger_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->right);
  EXTRACT_STRING(name, name_ast);

  ast_node *trigger_ast = find_usable_trigger(
    name,
    name_ast,
    "CQL0113: trigger in drop statement was not declared");
  if (!trigger_ast) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// Validate that a delete version is compatible with the previous delete version
static bool_t sem_validate_delete_prev_cur(int32_t prev, int32_t cur) {
  // version numbers (-1, 1 and 2) gives all combos of = > <
  //
  // previous   -1  -1  -1  |   1   1   1  |  2    2   2
  // current    -1   1   2  |  -1   1   2  | -1    1   2
  // result     ok  ok  ok  | err  ok  err | err  err ok
  //
  // so -1 (no versioning) can go to anything (becomes versioned)
  // and any other version must match exactly (can't change version after defined)

  return  prev < 0 || prev == cur;
}

// Validate that a create version is compatible with the previous create version
static bool_t sem_validate_create_prev_cur(int32_t prev, int32_t cur) {
  // version numbers (-1, 1 and 2) gives all combos of = > <
  //
  // previous   -1  -1  -1   |   1   1   1  |  2    2   2
  // current    -1   1   2   |  -1   1   2  | -1    1   2
  // result     ok  err err  | err  ok  err | err  err ok
  //
  // if the table was in the original it has to stay in the original it can't be created later
  // if it was created later it has to stay created later in the same version

  return  prev == cur;
}


// Both null is ok, or exact match of contents is ok.  Only one null or different is not ok.
static bool_t sem_match_optional_string(CSTR prev, CSTR cur) {
  // identical (or both null is ok)
  if (cur == prev) {
    return true;
  }

  // either null is a failure
  if (!cur || !prev) {
    return false;
  }

  return !strcmp(prev, cur);
}

// Looking at two version attribute lists for two different versions of the same
// entity, we validate that they are compatible:
//  * create versions compatible (using sem_validate_create_prev_cur)
//  * delete versions compatible (using sem_validate_delete_prev_cur)
//  * create migration proc identical (both have none or both the same)
//  * delete migration proc identical (both have none or both the same)
//
// Errors are attached here.
static bool_t sem_validate_attrs_prev_cur(version_attrs_info *prev, version_attrs_info *cur, ast_node *name_ast) {
  Contract(name_ast);
  EXTRACT_STRING(name, name_ast);

  bool_t valid = sem_validate_version_attrs(cur);
  Invariant(valid);  // already verified

  valid = sem_validate_version_attrs(prev);
  Invariant(valid);  // already verified

  // Note that it is ok to go from "no plan" to "recreate" so -1 for both is ok
  if (prev->create_version > 0 || prev->delete_version > 0) {
    if (cur->recreate && !prev->recreate) {
      report_error(name_ast, "CQL0114: current schema can't go back to @recreate semantics for", name);
      return false;
    }
  }

  if (prev->recreate) {
    // If we used to be on the @recreate plan then we don't have to check the current create version
    // but we do have to make sure the recreate transition special action is being used.
    // Note: if recreate is dropped and delete is added we give a better error later so that case
    // is excluded here.
    if (!cur->recreate && cur->delete_version < 0 && cur->create_code == SCHEMA_ANNOTATION_CREATE_TABLE) {
       if (!cur->create_proc || StrCaseCmp(CQL_FROM_RECREATE, cur->create_proc)) {
         report_error(name_ast, "CQL0377: table transitioning from @recreate to @create must use @create(nn,cql:from_recreate)", name);
         return false;
       }
    }
  }
  else {
    // otherwise this is not a recreate to create transition so normal version checks
    if (!sem_validate_create_prev_cur(prev->create_version, cur->create_version)) {
      report_error(name_ast, "CQL0115: current create version not equal to previous create version for", name);
      return false;
    }

    // not previously on the recreate plan the proc name must match
    if (!sem_match_optional_string(prev->create_proc, cur->create_proc)) {
      report_error(name_ast, "CQL0118: @create procedure changed in object", name);
      return false;
    }
  }

  if (!sem_validate_delete_prev_cur(prev->delete_version, cur->delete_version)) {
    report_error(name_ast, "CQL0116: current delete version not equal to previous delete version for", name);
    return false;
  }

  // adding a migrate proc when moving to the delete plan is ok
  // if we were already on the delete plan then the migrate proc must match
  if (prev->delete_version > 0) {
    if (!sem_match_optional_string(prev->delete_proc, cur->delete_proc)) {
      report_error(name_ast, "CQL0117: @delete procedure changed in object", name);
      return false;
    }
  }

  return true;
}

// Return the default value from the attribute list
// This must be called when there is a default value by contract.
// This has the side-effect of validating the HAS_DEFAULT flag
cql_noexport ast_node *sem_get_col_default_value(ast_node *attrs) {
  Contract(attrs);

  ast_node *ast = attrs;

  while (!is_ast_col_attrs_default(ast)) {
     ast = ast->right;
  }

  Contract(ast);
  return ast->left;
}

// Validate the the previous and current verision of the schema for a given
// column are compatible.  Note columns can't be re-ordered.  If they are the
// names will appear to not match, that's ok.
// For any given column and its previous version:
//  * the name must match
//  * the type must match (including combined_flags and autoincrement)
//  * @create cannot ever change
//  * @delete can "arrive" but never change
//  * if the column has a default value it has to change
// Any failures produces an error on the column
static void sem_validate_col_def_prev_cur(ast_node *def, ast_node *prev_def, version_attrs_info *cur_info, version_attrs_info *prev_info) {
  // pull out the current column info
  Contract(is_ast_col_def(def));
  EXTRACT_NOTNULL(col_def_type_attrs, def->left);
  EXTRACT_ANY(attrs, col_def_type_attrs->right);
  EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
  EXTRACT_NAME_AST(name_ast, col_def_name_type->left);
  EXTRACT_STRING(name, name_ast);

  // pull out the previous column info
  Contract(is_ast_col_def(prev_def));
  EXTRACT_NAMED_NOTNULL(prev_col_def_type_attrs, col_def_type_attrs, prev_def->left);
  EXTRACT_ANY(prev_attrs, prev_col_def_type_attrs->right);
  EXTRACT_NAMED_NOTNULL(prev_col_def_name_type, col_def_name_type, prev_col_def_type_attrs->left);
  EXTRACT_NAME_AST(prev_name_ast, prev_col_def_name_type->left);
  EXTRACT_STRING(prev_name, prev_name_ast);

  if (strcmp(name, prev_name)) {
    report_error(name_ast, "CQL0119: column name is different between previous and current schema", name);
    record_error(prev_def);
    return;
  }

  // Partial pk is caught later by checking the PK constraint, which is more diagnostic so we don't
  // detect that here.  Likewise weith SEM_TYPE_FK, this is caught later by the FK contraint or the
  // FK attribute.

  sem_t ok_diffs = SEM_TYPE_SENSITIVE | SEM_TYPE_DELETED | SEM_TYPE_FK | SEM_TYPE_PARTIAL_PK;

  sem_t cur_type = def->sem->sem_type & sem_not(ok_diffs);
  sem_t prev_type = prev_def->sem->sem_type & sem_not(ok_diffs);

  if (cur_type != prev_type) {
    report_error(name_ast, "CQL0120: column type is different between previous and current schema", name);
    record_error(prev_def);
    return;
  }

  col_def_info cur_cd_info;
  init_col_def_info(&cur_cd_info, cur_info);
  sem_col_def(def, &cur_cd_info);

  col_def_info prev_cd_info;
  init_col_def_info(&prev_cd_info, prev_info);
  sem_col_def(prev_def, &prev_cd_info);

  if (!sem_validate_create_prev_cur(prev_cd_info.create_version, cur_cd_info.create_version)) {
    report_error(name_ast, "CQL0121: column current create version not equal to previous create version", name);
    record_error(prev_def);
    return;
  }

  if (!sem_validate_delete_prev_cur(prev_cd_info.delete_version, cur_cd_info.delete_version)) {
    report_error(name_ast, "CQL0122: column current delete version not equal to previous delete version", name);
    record_error(prev_def);
    return;
  }

  // if the column was already deleted then the procedure name must match
  if (prev_cd_info.delete_version != -1) {
    if (!sem_match_optional_string(prev_cd_info.delete_proc, cur_cd_info.delete_proc)) {
      report_error(name_ast, "CQL0123: column @delete procedure changed", name);
      record_error(prev_def);
      return;
    }
  }

  // The create case is a little easier (no -1 check) because if the column was just created then
  // it isn't in the prevous schema at all and hence we wouldn't even be here.  This loop only
  // covers columns that exist in previous by definition.
  if (!sem_match_optional_string(prev_cd_info.create_proc, cur_cd_info.create_proc)) {
    report_error(name_ast, "CQL0124: column @create procedure changed", name);
    record_error(prev_def);
    return;
  }

  // if default value changed that's an error
  if (has_default(def->sem->sem_type)) {
    // previously verified that these match
    Invariant(has_default(prev_def->sem->sem_type));
    ast_node *cur_default = sem_get_col_default_value(attrs);
    ast_node *prev_default = sem_get_col_default_value(prev_attrs);

    bool_t identical = sem_validate_identical_text(prev_default, cur_default, gen_root_expr, NULL);
    if (!identical) {
      report_error(name_ast, "CQL0125: column current default value not equal to previous default value", name);
      record_error(prev_def);
      return;
    }
  }
}

// In addition to the normal checking, we look at the canonical string
// for the facet, if it's changed at all then there is an error.
// Note that @create/@delete are not validated here.  Those are just
// for columns and they are tested above.  Unstructured attributes like
// @attribute are disregarded entirely because they are assumed to not
// affect the schema and could be essential for codegen correctness.
// NOTE: when validating table definition pieces we are generous with @sensitive
// we already independently check if @sensitive was added and that does not cause
// a schema failure (removing it does). Here we do not generate the text of @senstive
// by providing callbacks so it looks like we're generating for SQLite.  This is
// deliberate and the tests verify this.
static bool_t sem_validate_identical_coldef(ast_node *def, ast_node *prev_def) {
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  return sem_validate_identical_text(def, prev_def, gen_col_or_key, &callbacks);
}

// This is the callback method handed to the gen_ method to force a
// no IF NOT EXISTS qualifier on create table or view statements.
static bool_t force_no_if_not_exists(ast_node *ast, void *context, charbuf *output) {
  // no output
  return true; // handled
}

// Full text comparison (including all options) but excluding "IF NOT EXISTS"
static bool_t sem_validate_identical_ddl(ast_node *cur, ast_node *prev) {
  gen_sql_callbacks callbacks;
  init_gen_sql_callbacks(&callbacks);
  callbacks.mode = gen_mode_echo; // we want all the options to count, so NOT for Sqilte output
  callbacks.if_not_exists_callback = force_no_if_not_exists; // we'll strip IF NOT EXISTS if it's there
  return sem_validate_identical_text(cur, prev, gen_one_stmt, &callbacks);
}

// When comparing two declarations, it will sometimes be the case that one of
// the declarations will have not yet been analyzed. This callback allows for
// named types to be resolved in such unanalyzed declarations so that the
// comparison can be made properly.
static bool_t sem_named_type_gen_sql_callback(ast_node *ast, void *context, charbuf *buf) {
  Contract(is_ast_str(ast));
  EXTRACT_STRING(name, ast);

  ast_node *named_type = find_named_type(name);

  if (named_type) {
    AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
    gen_data_type(rewrite_gen_data_type(named_type->sem->sem_type, named_type->sem->kind));
    AST_REWRITE_INFO_RESET();
    return true;
  }

  return false;
}

// Several places require identical definitions if names are duplicated
// This method does the job for a variety of objects, it generates the canoncial text
// for the AST and verifies that it is identical.  This works for all kinds of objects.
static bool_t sem_validate_identical_text(ast_node *prev, ast_node *cur, gen_func fn, gen_sql_callbacks *callbacks) {
  CHARBUF_OPEN(prev_sql);
  CHARBUF_OPEN(cur_sql);

  // We set `named_type_callback` so named types are always resolved before
  // being compared -- even when `prev` or `cur` have not been analyzed.
  gen_sql_callbacks callbacks_with_named_type_callback;
  if (callbacks) {
     // The input `callbacks` is copied to avoid mutating anything in the
     // caller.
     callbacks_with_named_type_callback = *callbacks;
  }
  else {
    init_gen_sql_callbacks(&callbacks_with_named_type_callback);
    // We set `gen_mode_echo` as it's equivalent to passing NULL to
    // `gen_with_callbacks`.
    callbacks_with_named_type_callback.mode = gen_mode_echo;
  }
  callbacks_with_named_type_callback.named_type_callback = sem_named_type_gen_sql_callback;

  gen_set_output_buffer(&prev_sql);
  gen_with_callbacks(prev, fn, &callbacks_with_named_type_callback);

  gen_set_output_buffer(&cur_sql);
  gen_with_callbacks(cur, fn, &callbacks_with_named_type_callback);

  bool_t identical = !strcmp(prev_sql.ptr, cur_sql.ptr);

  if (!identical) {
    cql_error("Incompatible declarations found\n");
    report_error(prev, prev_sql.ptr, NULL);
    report_error(cur, cur_sql.ptr, NULL);
    cql_error("The above must be identical.\n");
  }

  CHARBUF_CLOSE(cur_sql);
  CHARBUF_CLOSE(prev_sql);

  return identical;
}

// Here we're going to validate that two function declarations are identical.
// We're going to do this by comparing the canonical sql for both.
// We could compare the AST directly but to do so we would have to basically
// recapitulate all of the same walking that the text generator does.
// That is a maintenance problem but also doing it this way is economical
// and it ensures that the string decoding is bug-free.
static bool_t sem_validate_identical_funcs(ast_node *prev_func, ast_node *cur_func) {
  return sem_validate_identical_text(cur_func, prev_func, gen_one_stmt, NULL);
}

// Here we're going to validate that two proc declarations are identical.
// We're going to do this by comparing the canonical sql for both.
// We could compare the AST directly but to do so we would have to basically
// recapitulate all of the same walking that the text generator does.
// That is a maintenance problem but also doing it this way is economical
// and it ensures that the string decoding is bug-free.
static bool_t sem_validate_identical_procs(ast_node *prev_proc, ast_node *cur_proc) {
  return sem_validate_identical_text(prev_proc, cur_proc, gen_declare_proc_from_create_or_decl, NULL);
}

// Here we check the table found in the "previous" schema against the current schema.
// There are several validations we have to do here:
//  * the table should be present (but maybe marked with @delete)
//  * the table must not be a view now
//  * the table has to have a compatible create version
//  * the table has to have a compatible delete version
//  * any matching column validations (see related method) must be ok
//  * the new version of the table can't have fewer columns (you @delete instead)
//  * if the new verision has more columns they have to be all at the end and be marked create
//  * new columns can't be marked with @create and @delete
//  * the table create flags (like TEMP, or IF NOT EXISTS) must be the same
static void sem_validate_previous_table(ast_node *prev_table) {
  Contract(!current_joinscope);
  Contract(is_ast_create_table_stmt(prev_table));
  EXTRACT_NAMED_NOTNULL(prev_create_table_name_flags, create_table_name_flags, prev_table->left);
  EXTRACT_NAMED_NOTNULL(prev_table_flags_attrs, table_flags_attrs, prev_create_table_name_flags->left);
  EXTRACT_OPTION(prev_flags, prev_table_flags_attrs->left);
  EXTRACT_ANY(prev_table_attrs, prev_table_flags_attrs->right);
  EXTRACT_NAME_AST(prev_name_ast, prev_create_table_name_flags->right);
  EXTRACT_STRING(name, prev_name_ast);
  EXTRACT_ANY_NOTNULL(prev_col_key_list, prev_table->right);

  bool_t is_temp = !!(prev_flags & TABLE_IS_TEMP);

  bool_t is_table_backed = is_backed(prev_table->sem->sem_type);

  // validation of @deleted tables is a thing, so we need deleted tables, too
  ast_node *ast = find_table_or_view_even_deleted(name);

  if (!ast && (is_temp || is_table_backed)) {
    // temp table or backed table totally gone, that's ok
    return;
  }

  if (!ast) {
    report_error(prev_table, "CQL0126: table was present but now it does not exist (use @delete instead)", name);
    record_error(prev_table);
    return;
  }

  if (!is_ast_create_table_stmt(ast)) {
    report_error(ast, "CQL0127: object was a table but is now a view", name);
    record_error(prev_table);
    record_error(ast);
    return;
  }

  EXTRACT_NOTNULL(create_table_name_flags, ast->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_ANY(table_attrs, table_flags_attrs->right);
  EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
  EXTRACT_ANY_NOTNULL(col_key_list, ast->right);

  // Tables that are missing from the previous schema have to be validated as well
  // but using their own rules.  That happens in sem_validate_all_tables_not_in_previous.
  // Once this flag is set sem_validate_all_tables_not_in_previous won't consider this table.
  sem_add_flags(ast, SEM_TYPE_VALIDATED);

  if (is_table_backed) {
    // backed tables can be changed pretty much at whim, if the mandatory fields
    // are consistent they keep their data
    return;
  }

  version_attrs_info prev_info;
  init_version_attrs_info(&prev_info, name, prev_table, prev_table_attrs);
  version_attrs_info cur_info;
  init_version_attrs_info(&cur_info, name, ast, table_attrs);

  if (!sem_validate_attrs_prev_cur(&prev_info, &cur_info, name_ast)) {
    record_error(prev_table);
    record_error(ast);
    return;
  }

  // the max schema number, we can't do that until later so save it.
  if (prev_info.recreate && !cur_info.recreate) {
    // the table was deleted and didn't stay on the recreate plan, that's an error
    if (cur_info.delete_version > 0 && !cur_info.is_virtual_table) {
      report_error(ast, "CQL0448: table was marked @delete but it needs to be marked @recreate @delete", name);
      record_error(prev_table);
      record_error(ast);
      return;
    }

    // check create verisions
    if (ast->sem->create_version > 0) {
      add_item_to_list(&all_prev_recreate_tables, ast);
    }
  }

  // If we're on the @recreate plan then we can make any changes we like to the table
  // We don't need to check the rest... drop/create works on everything.
  if (cur_info.recreate || prev_info.recreate) {
    return;
  }

  // Begin table facet validations

  ast_node *prev_item = prev_col_key_list;
  ast_node *item = col_key_list;
  ast_node *def = NULL;
  ast_node *prev_def = NULL;

  // First validate columns
  for (;;) {
    while (item && !is_ast_col_def(def = item->left)) {
      Contract(is_ast_col_key_list(item));
      item = item->right;
    }

    while (prev_item && !is_ast_col_def(prev_def = prev_item->left)) {
      Contract(is_ast_col_key_list(prev_item));
      prev_item = prev_item->right;
    }

    if (!item || !prev_item) {
      break;
    }

    // this gives superior diagnostics for most typical differences
    sem_validate_col_def_prev_cur(def, prev_def, &cur_info, &prev_info);
    if (is_error(prev_def)) {
      record_error(prev_table);
      record_error(ast);
      return;
    }

    // any other differences are found by comparing the canonical def text
    if (!sem_validate_identical_coldef(def, prev_def)) {
      report_error(def, "CQL0128: table has a column that is different in the previous and current schema", def->sem->name);
      record_error(prev_table);
      record_error(ast);
      return;
    }

    item = item->right;
    prev_item = prev_item->right;
  }

  // the loop doesn't end until we hit the end of one of the lists
  Invariant(!item || !prev_item);

  // If def is null and prev_def is not null then that means stuff was removed
  // in the current schema, it should have been marked delete, not removed.

  if (prev_item) {
    report_error(prev_item, "CQL0129: a column was removed from the table rather than marked with @delete", prev_item->left->sem->name);
    record_error(prev_table);
    record_error(ast);
    return;
  }

  // If there are any columns left then they should be only created columns
  // These are new created columns (that's fine and their created version must
  // be >= the biggest schema version in the previous schema.
  // It's ok to add more created columns to the current schema.

  for ( ;item; item = item->right) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(cdef, item->left);

    // looking only at columns
    if (!is_ast_col_def(cdef)) {
      continue;
    }

    if (cdef->sem->create_version < 0) {
      report_error(cdef, "CQL0130: table has columns added without marking them @create", name);
      record_error(prev_table);
      record_error(ast);
      return;
    }

    if (cdef->sem->delete_version > 0) {
      report_error(cdef, "CQL0131: table has newly added columns that are marked both @create and @delete", name);
      record_error(prev_table);
      record_error(ast);
      return;
    }

    // The create version will have to be validated against the max version in the previous schema.
    // We can't do that until the end when we know the max version.
    add_item_to_list(&created_columns, cdef);
  }

  // Reset and validate non-columns

  prev_item = prev_col_key_list;
  item = col_key_list;

  for (;;) {
    while (item && is_ast_col_def(def = item->left)) {
      Contract(is_ast_col_key_list(item));
      item = item->right;
    }

    while (prev_item && is_ast_col_def(prev_def = prev_item->left)) {
      Contract(is_ast_col_key_list(prev_item));
      prev_item = prev_item->right;
    }

    if (!item || !prev_item) {
      break;
    }

    // any other differences are found by comparing the canonical def text
    if (!sem_validate_identical_coldef(def, prev_def)) {
      report_error(def, "CQL0132: table has a facet that is different in the previous and current schema", name);
      record_error(prev_table);
      record_error(ast);
      return;
    }

    item = item->right;
    prev_item = prev_item->right;
  }

  // the loop doesn't end until we hit the end of one of the lists
  Invariant(!item || !prev_item);

  // If def is null and prev_def is not null then that means stuff was removed
  // in the current schema, it should have been marked delete, not removed.

  if (prev_item) {
    report_error(prev_item, "CQL0133: non-column facets have been removed from the table", name);
    record_error(prev_table);
    return;
  }

  // some new non-column was added...
  if (item) {
    report_error(item, "CQL0134: table has a new non-column facet in the current schema", name);
    record_error(prev_table);
    record_error(ast);
    return;
  }

  // If both def and prev_def are null then perfect match no further checking.

  // the table flags have to match
  if (flags != prev_flags) {
    report_error(ast, "CQL0135: table create statement attributes different than previous version", name);
    record_error(prev_table);
    record_error(ast);
    return;
  }

  enqueue_pending_region_validation(prev_table, ast, name);
}

// Verison info can be gathered from tables, views, or indices (columns are done seperately)
// Here we emit a record the annotation with the correct code into the pending annotations buffer
// this will be later sorted and used to drive schema migration if schema codegen happens.
static void sem_record_annotation_from_vers_info(version_attrs_info *vers_info) {
  ast_node *target_ast = vers_info->target_ast;

  if (is_ast_create_table_stmt(target_ast) && is_table_not_physical(target_ast)) {
    return;
  }

  if (vers_info->recreate) {
    ast_node *recreate_ast = vers_info->recreate_version_ast;
    CSTR group_name = vers_info->recreate_group_name ? vers_info->recreate_group_name : "";
    record_recreate_annotation(target_ast, vers_info->name, group_name, recreate_ast);
    // no need for @create or @delete annotation if recreate, the recreate will also handle delete if reqd
    return;
  }

  if (vers_info->create_version > 0) {
    EXTRACT(version_annotation, vers_info->create_version_ast);
    uint32_t code = vers_info->create_code;
    record_schema_annotation(vers_info->create_version, target_ast, vers_info->name, code, NULL, version_annotation, 0);
  }

  if (vers_info->delete_version > 0) {
    EXTRACT(version_annotation, vers_info->delete_version_ast);
    uint32_t code = vers_info->delete_code;
    record_schema_annotation(vers_info->delete_version, target_ast, vers_info->name, code, NULL, version_annotation, 0);
  }

}

typedef struct trigger_dep_context {
   ast_node *trigger_ast;
   CSTR trigger_on_table_name;
} trigger_dep_context;

// When we locate a table used by a view we simply add that info to the dependency map in both directions
static void sem_found_dep_in_trigger(CSTR _Nonnull target_name, ast_node *_Nonnull target_ast, void *_Nullable context) {
  Contract(is_ast_create_table_stmt(target_ast) || is_ast_create_view_stmt(target_ast));

  trigger_dep_context *info  = context;

  if (StrCaseCmp(info->trigger_on_table_name, target_name)) {
    // we don't have to record that the trigger depends on the table that it is on
    // if that table goes away the trigger is implicitly deleted anyway, it would
    // just give us a bunch of false positives.  It's the other tables that need searching
    record_table_dependencies(info->trigger_ast, target_ast);
  }
}

// Here we peek into the trigger body and find the tables that it uses.
// We're going to record those so that if a table is unsubscribed we can make sure
// there are no lingering triggers still using it.  We don't have to worry about views inside
// the body because if the trigger uses a view and the view uses a table then that view itself
// will cause an error to be reported if you attempt to unsubscribe the table.
static void sem_record_trigger_dependencies(ast_node *ast) {
  Contract(is_ast_create_trigger_stmt(ast));

  EXTRACT_NOTNULL(trigger_body_vers, ast->right);
  EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
  EXTRACT_NOTNULL(trigger_condition, trigger_def->right);
  EXTRACT_NOTNULL(trigger_op_target, trigger_condition->right);
  EXTRACT_NOTNULL(trigger_target_action, trigger_op_target->right);
  EXTRACT_NAME_AST(table_name_ast, trigger_target_action->left);
  EXTRACT_STRING(table_name, table_name_ast);

  trigger_dep_context context = {
    .trigger_ast = ast,
    .trigger_on_table_name = table_name
  };

  table_callbacks callbacks = {
    .callback_any_table = sem_found_dep_in_trigger,
    .callback_any_view = sem_found_dep_in_trigger,
    .callback_context = &context,
    .do_not_recurse_views = true,
  };

  find_table_refs(&callbacks, ast);
}

// The create trigger statement is quite a beast, validations include:
//  * the trigger name must be unique
//  * For insert the "new.*" table is available in expressions/statement
//  * For delete the "old.*" table is avallable in expressions/statements
//  * For update both are available
//    * If optional columns present in update, they must be unique/valid
//  * The When expression must evaluate to a numeric
//  * The statement list must be error free with the usual rules plus new/old
//  * The RAISE function may be used inside a trigger (NYI)
//  * The table_name must be a table (not a view) UNLESS the trigger type is TRIGGER_INSTEAD_OF
//  * select statements inside the statement block do not count as returns for the proc
static void sem_create_trigger_stmt(ast_node *ast) {
  Contract(is_ast_create_trigger_stmt(ast));

  EXTRACT_OPTION(flags, ast->left);
  EXTRACT_NOTNULL(trigger_body_vers, ast->right);
  EXTRACT_ANY(trigger_attrs, trigger_body_vers->right);
  EXTRACT_NOTNULL(trigger_def, trigger_body_vers->left);
  EXTRACT_NAME_AST(trigger_name_ast, trigger_def->left);
  EXTRACT_STRING(trigger_name, trigger_name_ast);
  EXTRACT_NOTNULL(trigger_condition, trigger_def->right);
  EXTRACT_OPTION(cond_flags, trigger_condition->left);
  flags |= cond_flags;
  EXTRACT_NOTNULL(trigger_op_target, trigger_condition->right);
  EXTRACT_NOTNULL(trigger_operation, trigger_op_target->left);
  EXTRACT_OPTION(op_flags, trigger_operation->left);
  EXTRACT(name_list, trigger_operation->right);
  flags |= op_flags;
  EXTRACT_NOTNULL(trigger_target_action, trigger_op_target->right);
  EXTRACT_NAME_AST(table_name_ast, trigger_target_action->left);
  EXTRACT_STRING(table_name, table_name_ast);
  EXTRACT_NOTNULL(trigger_action, trigger_target_action->right);
  EXTRACT_OPTION(action_flags, trigger_action->left);
  flags |= action_flags;
  EXTRACT_NOTNULL(trigger_when_stmts, trigger_action->right);
  EXTRACT_ANY(when_expr, trigger_when_stmts->left);
  EXTRACT_NOTNULL(stmt_list, trigger_when_stmts->right);

  // as with many other constructs, if we're validating previous schema it isn't safe to look inside the trigger
  // body because it likely refers to things that don't exist in the current schema.  This being the case
  // we just do the previous validation and move on;  Views do the same.
  if (validating_previous_schema) {
    record_ok(ast);
    sem_validate_previous_trigger(ast);
    return;
  }

  bool_t adding_current_entity = will_add_current_entity();

  // if there is an existing trigger, save it here so we can check for duplicates later.
  ast_node *existing_defn = adding_current_entity ? find_trigger(trigger_name) : NULL;

  // Trigger declarations (i.e. outside of any proc) are totally ignored
  // in the context of a schema migration script.  This prevents us from
  // getting errors because the trigger refers to tables or columns that are not yet
  // in existence in the version we are migrating.
  if (schema_upgrade_version > 0) {
    record_ok(ast);
    return;
  }

  version_attrs_info vers_info;
  init_version_attrs_info(&vers_info, trigger_name, ast, trigger_attrs);

  bool_t valid_version_info = sem_validate_version_attrs(&vers_info);
  Invariant(valid_version_info);   // nothing can go wrong with trigger versions

  if (!sem_validate_vers_ok_in_context(&vers_info)) {
    record_error(ast);
    return;
  }

  if (!sem_validate_no_delete_migration(&vers_info, ast, trigger_name)) {
    return;
  }

  ast_node *target = NULL;
  bool_t deleting = vers_info.delete_version > 0;

  if (deleting) {
    target = find_usable_table_or_view_even_deleted(
      table_name,
      table_name_ast,
      "CQL0137: table/view not found");

    if (is_deleted(target)) {
      report_error(ast, "CQL0397: object is an orphan because its table is deleted. Remove rather than @delete", trigger_name);
      record_error(ast);
      return;
    }
  }
  else {
    target = find_usable_and_not_deleted_table_or_view(
      table_name,
      table_name_ast,
      "CQL0137: table/view not found");
  }

  if (!target) {
    record_error(ast);
    return;
  }

  sem_non_backed_table(ast, target);
  if (is_error(ast)) {
    return;
  }

  sem_non_blob_storage_table(ast, target);
  if (is_error(ast)) {
    return;
  }

  if (is_virtual_ast(target)) {
    report_error(table_name_ast, "CQL0162: cannot add a trigger to a virtual table", table_name);
    record_error(ast);
    return;
  }

  table_name_ast->sem = target->sem;

  if (!is_ast_create_table_stmt(target) && !(flags & TRIGGER_INSTEAD_OF)) {
    report_error(table_name_ast, "CQL0138: a trigger on a view must be the INSTEAD OF form", table_name);
    record_error(ast);
    return;
  }

  sem_join *jptr;
  sem_struct *sptr = target->sem->sptr;

  if (flags & TRIGGER_INSERT) {
    jptr = new_sem_join(1);
    jptr->names[0] = "new";
    jptr->tables[0] = sptr;
  }
  else if (flags & TRIGGER_DELETE) {
    jptr = new_sem_join(1);
    jptr->names[0] = "old";
    jptr->tables[0] = sptr;
  }
  else {
    Contract(flags & TRIGGER_UPDATE);
    jptr = new_sem_join(2);
    jptr->names[0] = "old";
    jptr->tables[0] = sptr;
    jptr->names[1] = "new";
    jptr->tables[1] = sptr;

    // temporarily change the count 1 to avoid name ambiguity resolving the columns
    jptr->count = 1;

    // validate columns names if present
    if (name_list && !sem_validate_name_list(name_list, jptr)) {
      record_error(ast);
      return;
    }

    // and put it back if we're gonna proceed
    jptr->count = 2;
  }

  if (when_expr) {
    Invariant(!in_trigger_when_expr);
    in_trigger_when_expr = 1;

    PUSH_JOIN(when_scope, jptr);
    sem_numeric_expr(when_expr, NULL, "WHEN", SEM_EXPR_CONTEXT_WHERE);
    POP_JOIN();

    Invariant(in_trigger_when_expr);
    in_trigger_when_expr = 0;

    if (is_error(when_expr)) {
      record_error(ast);
      return;
    }
  }

  PUSH_JOIN(trigger_scope, jptr);
  Invariant(!in_trigger);
  in_trigger = 1;

  sem_stmt_list(stmt_list);

  Invariant(in_trigger);
  in_trigger = 0;
  POP_JOIN();

  if (is_error(stmt_list)) {
    record_error(ast);
    return;
  }

  ast->sem = new_sem(SEM_TYPE_OK);
  ast->sem->delete_version = vers_info.delete_version;
  ast->sem->region = current_region;

  if (ast->sem->delete_version > 0) {
    ast->sem->sem_type |= SEM_TYPE_DELETED;
  }

  if (existing_defn) {
    if (!sem_validate_identical_ddl(existing_defn, ast)) {
      report_error(trigger_name_ast, "CQL0136: trigger already exists", trigger_name);
      record_error(trigger_name_ast);
      record_error(ast);
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      sem_add_flags(ast, SEM_TYPE_ALIAS);
    }
    return;
  }

  if (adding_current_entity) {
    add_trigger(ast, trigger_name);
    add_item_to_list(&all_triggers_list, ast);

    // and record the annotation
    sem_record_annotation_from_vers_info(&vers_info);

    // record the tables used by this trigger (and cross link)
    sem_record_trigger_dependencies(ast);
  }
}

static bool_t sem_validate_virtual_table_vers(version_attrs_info *table_vers_info) {
  Contract(table_vers_info);
  EXTRACT_NOTNULL(create_table_stmt, table_vers_info->target_ast);

  // if deleting virtual table... you must add the reminder
  if (table_vers_info->is_virtual_table && table_vers_info->delete_version_ast) {
     if (!table_vers_info->delete_proc || StrCaseCmp(CQL_MODULE_WARN, table_vers_info->delete_proc )) {
        report_error(table_vers_info->delete_version_ast, "CQL0392: when deleting a virtual table you must specify @delete(nn, "
            CQL_MODULE_WARN ") as a reminder not to delete the module for this virtual table", table_vers_info->name);
        record_error(create_table_stmt);
        return false;
     }
  }
  return true;
}

// If you are putting DDL inside of a procedure then it is going to run regardless; these
// entires do not get versioning attributes, those are reserved for schema declarations outside
// of any procedure.
static bool_t sem_validate_vers_ok_in_context(version_attrs_info *vers) {
  bool_t is_versioned = vers->create_version > 0 || vers->delete_version > 0;

  // virtual tables are always recreate, this is hard coded, so disregard that as a versioning error
  is_versioned |= !vers->is_virtual_table && vers->recreate;

  if (current_proc && is_versioned) {
     report_error(vers->target_ast, "CQL0396: versioning attributes may not be used on DDL inside a procedure", vers->name);
     return false;
  }

  if (vers->is_temp && is_versioned) {
    report_error(vers->target_ast, "CQL0139: temp objects may not have versioning annotations", vers->name);
    return false;
  }

  return true;
}

static void report_invalid_blob_storage_column(ast_node *ast, CSTR reason, CSTR column, CSTR table) {
  Contract(ast);
  Contract(reason);
  Contract(table);

  CSTR err_msg = dup_printf("CQL0459: table is not suitable for use as blob storage: column '%s' %s in", column, reason);
  report_error(ast, err_msg, table);
  record_error(ast);
}

// validate that the indicated col_def is ok for blob storage
// this basically means it has to be ultra simple
// no autoinc, no fk, no pk, no default value
static void sem_blob_storage_col_def(ast_node *table_ast, ast_node *def, CSTR table_name) {
  Contract(is_ast_col_def(def));
  EXTRACT_NOTNULL(col_def_type_attrs, def->left);

  EXTRACT_ANY(attrs, col_def_type_attrs->right);
  EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
  EXTRACT_NAME_AST(name_ast, col_def_name_type->left);
  EXTRACT_STRING(col_name, name_ast);

  // if we find anything weird, it's an error
  for (ast_node *ast = attrs; ast; ast = ast->right) {
    if (is_ast_create_attr(ast) || is_ast_col_attrs_not_null(ast) || is_ast_sensitive_attr(ast)) {
    }
    else if (is_ast_delete_attr(ast)) {
      // In principle we could support this, but we don't for now.
      // To do this you'd have to ensure that the blob storage included the field but didn't decode it
      // if it was present...  the problem is that old versions of the blob might exist with the field
      // there, so you can't just get rid of it.  Really this is likely to be super confusing
      // and we may never do this for that reason.
      report_invalid_blob_storage_column(table_ast, "has been deleted", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_default(ast)) {
      // In principle we could support this, but we don't for now.
      report_invalid_blob_storage_column(table_ast, "has a default value", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_check(ast)) {
      report_invalid_blob_storage_column(table_ast, "has a check expression", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_collate(ast)) {
      report_invalid_blob_storage_column(table_ast, "specifies collation order", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_pk(ast)) {
      // note that autoinc must be on a pk and is in its node so this also detects autoinc
      report_invalid_blob_storage_column(table_ast, "has a primary key", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_fk(ast)) {
      report_invalid_blob_storage_column(table_ast, "has a foreign key", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_hidden(ast)) {
      report_invalid_blob_storage_column(table_ast, "is a hidden column", col_name, table_name);
      return;
    }
    else {
      // this is all that's left
      Contract(is_ast_col_attrs_unique(ast));
      report_invalid_blob_storage_column(table_ast, "has a unique key", col_name, table_name);
      return;
    }
  }
}

static void report_invalid_blob_storage(ast_node *ast, CSTR reason, CSTR table) {
  Contract(ast);
  Contract(reason);
  Contract(table);

  CSTR err_msg = dup_printf("CQL0459: table is not suitable for use as blob storage: %s", reason);
  report_error(ast, err_msg, table);
  record_error(ast);
}

static void sem_validate_table_for_blob_storage(ast_node *ast) {
  Contract(is_ast_create_table_stmt(ast));
  EXTRACT_NOTNULL(create_table_name_flags, ast->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_ANY(table_attrs, table_flags_attrs->right);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(col_key_list, ast->right);

  Contract(!is_error(ast));

  int32_t temp = flags & TABLE_IS_TEMP;
  int32_t no_rowid = flags & TABLE_IS_NO_ROWID;

  if (temp) {
    report_invalid_blob_storage(ast, "it is redundantly marked TEMP", name);
    return;
  }

  if (no_rowid) {
    report_invalid_blob_storage(ast, "it is redundantly marked WITHOUT ROWID", name);
    return;
  }

  // check the column defs, error out if we find any constraints
  for (ast_node *item = col_key_list; item; item = item->right) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(def, item->left);

    if (!is_ast_col_def(def)) {
      report_invalid_blob_storage(ast, "it has at least one constraint", name);
      return;
    }

    sem_blob_storage_col_def(ast, def, name);
    if (is_error(ast)) {
      return;
    }
  }

  while (table_attrs) {
    if (is_ast_recreate_attr(table_attrs)) {
      report_invalid_blob_storage(ast, "it is declared using @recreate", name);
      return;
    }
    table_attrs = table_attrs->right;
  }
}

static void report_invalid_backing_column(ast_node *ast, CSTR reason, CSTR column, CSTR table) {
  Contract(ast);
  Contract(reason);
  Contract(table);

  CSTR err_msg = dup_printf("CQL0483: table is not suitable for use as backing storage: column '%s' %s in", column, reason);
  report_error(ast, err_msg, table);
  record_error(ast);
}

// validate that the indicated col_def is ok for blob storage
// this basically means it has to be ultra simple
// no autoinc, no fk, no pk, no default value
static void sem_backing_col_def(ast_node *table_ast, ast_node *def, CSTR table_name) {
  Contract(is_ast_col_def(def));
  EXTRACT_NOTNULL(col_def_type_attrs, def->left);

  EXTRACT_ANY(attrs, col_def_type_attrs->right);
  EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
  EXTRACT_NAME_AST(name_ast, col_def_name_type->left);
  EXTRACT_ANY_NOTNULL(col_type, col_def_name_type->right);
  EXTRACT_STRING(col_name, name_ast);

  // if we find anything weird, it's an error
  for (ast_node *ast = attrs; ast; ast = ast->right) {
    if (is_ast_col_attrs_not_null(ast) || is_ast_sensitive_attr(ast)) {
        // these basic column attributes are allowed
    }
    else if (is_ast_col_attrs_pk(ast)) {
      EXTRACT_NOTNULL(autoinc_and_conflict_clause, ast->left);
      EXTRACT(col_attrs_autoinc, autoinc_and_conflict_clause->left);

      // conflict clause is ok, we can ignore it, autoinc is not supported until we do "stage 2"
      // of this feature, initially the pk is just a blob and all the playload is in another blob

      if (col_attrs_autoinc) {
        report_invalid_backing_column(table_ast, "specifies auto increment", col_name, table_name);
        return;
      }
    }
    else if (is_ast_create_attr(ast)) {
      // backing tables do not support schema changes at this time
      report_invalid_backing_column(table_ast, "has create attribute", col_name, table_name);
      return;
    }
    else if (is_ast_delete_attr(ast)) {
      // backing tables do not support schema changes at this time
      report_invalid_backing_column(table_ast, "has delete attribute", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_default(ast)) {
      // In principle we could support this, but we don't for now.
      report_invalid_backing_column(table_ast, "has a default value", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_check(ast)) {
      // In principle we could support this, but we don't for now.
      report_invalid_backing_column(table_ast, "has a check expression", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_collate(ast)) {
      // In principle we could support this, but we don't for now.  Assuming it makes sense for blobs?
      report_invalid_backing_column(table_ast, "specifies collation order", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_fk(ast)) {
      // In principle we could support this, but we don't for now.  Planned for "Stage 3"
      report_invalid_backing_column(table_ast, "has a foreign key", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_hidden(ast)) {
      // Doesn't make a lot of sense for a backing store, invalid.
      report_invalid_backing_column(table_ast, "is a hidden column", col_name, table_name);
      return;
    }
    else {
      // In principle we could support this, but we don't for now.  Planned for "Stage 3"
      // There are no other attribute types hence the "invariant"
      Invariant(is_ast_col_attrs_unique(ast));
      report_invalid_backing_column(table_ast, "has a unique key", col_name, table_name);
      return;
    }
  }

  // Stage 1 limitation, the backing store is always a key blob and a value blob, hence non blobs are illegal
  if (!is_ast_type_blob(col_type)) {
   report_invalid_backing_column(table_ast, "has a column that is not a blob", col_name, table_name);
   return;
  }
}

static void report_invalid_backing(ast_node *ast, CSTR reason, CSTR table) {
  Contract(ast);
  Contract(reason);
  Contract(table);

  CSTR err_msg = dup_printf("CQL0483: table is not suitable for use as backing storage: %s", reason);
  report_error(ast, err_msg, table);
  record_error(ast);
}

static void sem_validate_table_for_backing(ast_node *ast) {
  Contract(is_ast_create_table_stmt(ast));
  EXTRACT_NOTNULL(create_table_name_flags, ast->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(col_key_list, ast->right);

  Contract(!is_error(ast));
  Contract(ast->sem);  // semantic type already computed

  int32_t temp = flags & TABLE_IS_TEMP;
  int32_t no_rowid = flags & TABLE_IS_NO_ROWID;
  int32_t col_count = 0;
  bool_t has_key = false;
  bool_t has_value = false;

  if (temp) {
    report_invalid_backing(ast, "it is redundantly marked TEMP", name);
    return;
  }

  if (no_rowid) {
    report_invalid_backing(ast, "it is redundantly marked WITHOUT ROWID", name);
    return;
  }

  // check the column defs, error out if we find any constraints
  for (ast_node *item = col_key_list; item; item = item->right) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(def, item->left);

    // PK is allowed
    if (is_ast_pk_def(def)) {
      EXTRACT_NOTNULL(indexed_columns_conflict_clause, def->right);
      EXTRACT(indexed_columns, indexed_columns_conflict_clause->left);

      for (ast_node *pk_item = indexed_columns; pk_item; pk_item = pk_item->right) {
        if (!is_ast_str(pk_item->left->left)) {
          report_invalid_backing(ast, "it has an expression in its primary key", string_from_name_list_item(pk_item));
          return;
        }
      }

      continue;
    }

    if (!is_ast_col_def(def)) {
      report_invalid_backing(ast, "it has at least one invalid constraint", name);
      return;
    }

    col_count++;
    sem_t sem_type = def->sem->sem_type;
    bool_t is_pk = is_primary_key(sem_type) || is_partial_pk(sem_type);
    has_key |= is_pk;
    has_value |= !is_pk;

    sem_backing_col_def(ast, def, name);
    if (is_error(ast)) {
      return;
    }
  }

  if (col_count != 2) {
    report_invalid_backing(ast, "it does not have exactly two blob columns", name);
    return;
  }

  if (!has_key) {
    report_invalid_backing(ast, "it does not have a primary key", name);
    return;
  }

  if (!has_value) {
    report_invalid_backing(ast, "it has only primary key columns", name);
    return;
  }
}

static void report_invalid_backed_column(ast_node *ast, CSTR reason, CSTR column, CSTR table) {
  Contract(ast);
  Contract(reason);
  Contract(table);

  CSTR err_msg = dup_printf("CQL0487: table is not suitable for use as backed storage: column '%s' %s in", column, reason);
  report_error(ast, err_msg, table);
  record_error(ast);
}

// validate that the indicated col_def is ok for blob storage
// this basically means it has to be ultra simple
// no autoinc, no fk, no default value, no unique constraints etc.
static void sem_backed_col_def(ast_node *table_ast, ast_node *def, CSTR table_name) {
  Contract(is_ast_col_def(def));
  EXTRACT_NOTNULL(col_def_type_attrs, def->left);

  EXTRACT_ANY(attrs, col_def_type_attrs->right);
  EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
  EXTRACT_NAME_AST(name_ast, col_def_name_type->left);
  EXTRACT_STRING(col_name, name_ast);

  // if we find anything weird, it's an error
  for (ast_node *ast = attrs; ast; ast = ast->right) {
    if (is_ast_col_attrs_not_null(ast) || is_ast_sensitive_attr(ast)) {
        // these basic column attributes are allowed
    }
    else if (is_ast_col_attrs_pk(ast)) {
      EXTRACT_NOTNULL(autoinc_and_conflict_clause, ast->left);
      EXTRACT(col_attrs_autoinc, autoinc_and_conflict_clause->left);

      // conflict clause is ok, we can ignore it, autoinc is not supported until we do "stage 2"
      // of this feature, initially the pk is just a blob and all the playload is in another blob

      if (col_attrs_autoinc) {
        report_invalid_backed_column(table_ast, "specifies auto increment", col_name, table_name);
        return;
      }
    }
    else if (is_ast_create_attr(ast)) {
      // backed tables do not use schema annotations, they can change at whim
      report_invalid_backed_column(table_ast, "has create attribute", col_name, table_name);
      return;
    }
    else if (is_ast_delete_attr(ast)) {
      // backed tables do not use schema annotations, they can change at whim
      report_invalid_backed_column(table_ast, "has delete attribute", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_default(ast)) {
      // this is valid, we can fill it in when we do an insert
    }
    else if (is_ast_col_attrs_check(ast)) {
      report_invalid_backed_column(table_ast, "has a check expression", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_collate(ast)) {
      report_invalid_backed_column(table_ast, "specifies collation order", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_fk(ast)) {
      // these could be supported when the backing table is allowed to have an explicit FK column or columns to match
      report_invalid_backed_column(table_ast, "has a foreign key", col_name, table_name);
      return;
    }
    else if (is_ast_col_attrs_hidden(ast)) {
      report_invalid_backed_column(table_ast, "is a hidden column", col_name, table_name);
      return;
    }
    else {
      // this is all that's left
      Contract(is_ast_col_attrs_unique(ast));
      report_invalid_backed_column(table_ast, "has a unique key", col_name, table_name);
      return;
    }
  }
}

static void report_invalid_backed(ast_node *ast, CSTR reason, CSTR table) {
  Contract(ast);
  Contract(reason);
  Contract(table);

  CSTR err_msg = dup_printf("CQL0487: table is not suitable for use as backed storage: %s", reason);
  report_error(ast, err_msg, table);
  record_error(ast);
}

static void sem_validate_table_for_backed(ast_node *ast) {
  Contract(is_ast_create_table_stmt(ast));
  EXTRACT_NOTNULL(create_table_name_flags, ast->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(col_key_list, ast->right);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  Contract(!is_error(ast));

  if (current_proc) {
    report_invalid_backed(ast, "backed table must appear outside of any procedure", name);
    return;
  }

  // the table has the attribute or we would not be here
  CSTR backing_table_name = get_named_string_attribute_value(misc_attrs, "backed_by");
  Contract(backing_table_name);

  ast_node *backing_table = find_table_or_view_even_deleted(backing_table_name);

  if (!backing_table) {
    report_invalid_backed(ast, "backing table does not exist", backing_table_name);
    return;
  }

  if (!is_backing(backing_table->sem->sem_type)) {
    report_invalid_backed(ast, "table exists but is not a valid backing table", backing_table_name);
    return;
  }

  cg_blob_mappings_t *map = find_backing_info(backing_table_name);
  Invariant(map);  // already added for sure!

  // JSON backing tables can't hold blobs, so backed tables must not have any
  bool_t is_json = map->use_json || map->use_jsonb;

  int32_t temp = flags & TABLE_IS_TEMP;
  int32_t no_rowid = flags & TABLE_IS_NO_ROWID;
  bool_t has_key = false;
  bool_t has_value = false;
  ast_node *pk_def = NULL;
  int16_t icol_pk = -1;
  int16_t icol = 0;

  if (temp) {
    report_invalid_backed(ast, "it is redundantly marked TEMP", name);
    return;
  }

  if (no_rowid) {
    report_invalid_backed(ast, "it is redundantly marked WITHOUT ROWID", name);
    return;
  }

  // check the column defs, error out if we find any constraints
  for (ast_node *item = col_key_list; item; item = item->right, icol++) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(def, item->left);

    // PK is allowed
    if (is_ast_pk_def(def)) {
      pk_def = def;

      EXTRACT_NOTNULL(indexed_columns_conflict_clause, pk_def->right);
      EXTRACT(indexed_columns, indexed_columns_conflict_clause->left);

      for (ast_node *pk_item = indexed_columns; pk_item; pk_item = pk_item->right) {
        if (!is_ast_str(pk_item->left->left)) {
          report_invalid_backed(ast, "it has an expression in its primary key", string_from_name_list_item(pk_item));
          return;
        }
      }

      continue;
    }

    if (!is_ast_col_def(def)) {
      report_invalid_backed(ast, "it has at least one invalid constraint", name);
      return;
    }

    sem_t sem_type = def->sem->sem_type;
    bool_t is_pk = is_primary_key(sem_type) || is_partial_pk(sem_type);
    has_key |= is_pk;
    has_value |= !is_pk;

    if (is_primary_key(sem_type)) {
      icol_pk = icol;
    }

    if (is_blob(sem_type) && is_json) {
      Invariant(def->sem->name);
      report_invalid_backed_column (
        def,
        "is a blob column, but blobs cannot appear in tables backed by JSON",
        def->sem->name,
        name);
      record_error(ast);
      return;
    }

    sem_backed_col_def(ast, def, name);
    if (is_error(ast)) {
      return;
    }
  }

  if (!has_key) {
    report_invalid_backed(ast, "it does not have a primary key", name);
    return;
  }

  if (!has_value) {
    report_invalid_backed(ast, "it has only primary key columns", name);
    return;
  }

  Invariant(!is_error(backing_table));
  Invariant(!is_error(ast));

  sem_node *backing_sem = backing_table->sem;
  sem_node *backed_sem = ast->sem;

  if (backed_sem->create_version > 0 || backed_sem->delete_version > 0) {
    report_invalid_backed(ast, "it is declared using schema directives (@create or @delete", name);
    return;
  }

  if (backing_sem->recreate != backed_sem->recreate) {
    // the recreate attribute is moot in reality but having them match
    // means the user is saying they know that their backed storage could go away
    // if the backing table were to change
    report_invalid_backed(ast, "@recreate attribute doesn't match the backing table", name);
    return;
  }

  CSTR backing_group = backing_sem->recreate_group_name ? backing_sem->recreate_group_name : "";
  CSTR backed_group = backed_sem->recreate_group_name ? backed_sem->recreate_group_name : "";

  if (StrCaseCmp(backing_group, backed_group)) {
    // if a group was specified they should match
    report_invalid_backed(ast, "@recreate group doesn't match the backing table", name);
    return;
  }

  sem_struct *sptr = ast->sem->sptr;
  Invariant(sptr);
  table_node *table_info = ast->sem->table_info;
  Invariant(table_info);

  // Can't have both PK constraint and PK column (enforced below)

  if (icol_pk >= 0) {
    Invariant(pk_def == NULL);
    table_info->key_count = 1;
    table_info->key_cols = _ast_pool_new_array(int16_t, 1);
    table_info->key_cols[0] =  icol_pk;
  }
  else {
    Invariant(icol_pk == -1);
    is_ast_pk_def(pk_def);
    table_info->key_count = 1;

    EXTRACT_NOTNULL(indexed_columns_conflict_clause, pk_def->right);
    EXTRACT(indexed_columns, indexed_columns_conflict_clause->left);

    int16_t key_count = 0;
    for (ast_node *item = indexed_columns; item; item = item->right) {
      key_count++;
    }

    Invariant(key_count > 0);

    table_info->key_count = key_count;
    table_info->key_cols = _ast_pool_new_array(int16_t, (uint32_t)key_count);

    // clobber the array with known junk so that assertions will fail
    // for sure if we do not fill it out correctly
    memset(table_info->key_cols, 0xff, (uint32_t)key_count * sizeof(int16_t));

    key_count = 0;
    for (ast_node *item = indexed_columns; item; item = item->right) {
      CSTR c_name = string_from_name_list_item(item);

      // always a valid column name, it MUST match
      icol = (int16_t)find_col_in_sptr(sptr, c_name);
      Invariant(icol >= 0);

      table_info->key_cols[key_count++] = icol;
    }

    Invariant(key_count == table_info->key_count);
  }

  int16_t notnull_count = 0;
  for (uint32_t i = 0; i < sptr->count; i++) {
    if (is_nullable(sptr->semtypes[i])) {
      continue;
    }
    notnull_count++;
  }

  // not null columns (i.e. the mandatory ones)
  Invariant(notnull_count > 0);
  table_info->notnull_count = notnull_count;
  table_info->notnull_cols = _ast_pool_new_array(int16_t, (uint32_t)notnull_count);

  // value columns are everything but the key columns
  int16_t value_count = ((int16_t)(sptr->count)) - table_info->key_count;
  Invariant(value_count > 0);
  table_info->value_count = value_count;
  table_info->value_cols = _ast_pool_new_array(int16_t, (uint32_t)value_count);

  notnull_count = 0;
  value_count = 0;
  for (uint32_t i = 0; i < sptr->count; i++) {
    sem_t sem_type = sptr->semtypes[i];
    if (!is_nullable(sem_type)) {
      table_info->notnull_cols[notnull_count++] = (int16_t)i;
    }

    if (!is_primary_key(sem_type) && !is_partial_pk(sem_type)) {
      table_info->value_cols[value_count++] = (int16_t)i;
    }
  }

  Invariant(notnull_count == table_info->notnull_count);
  Invariant(value_count == table_info->value_count);
}

static CSTR get_backing_attr(ast_node *table, CSTR attr, CSTR default_value) {
  Contract(table);
  Contract(table->sem);
  Contract(is_backing(table->sem->sem_type));
  EXTRACT_MISC_ATTRS(table, misc_attrs);
  Contract(misc_attrs);

  CSTR result = get_named_string_attribute_value(misc_attrs, attr);
  return result ? result : default_value;
}

static bool_t has_backing_attr(ast_node *table, CSTR attr) {
  Contract(table);
  Contract(table->sem);
  Contract(is_backing(table->sem->sem_type));
  EXTRACT_MISC_ATTRS(table, misc_attrs);
  Contract(misc_attrs);

  return !!find_named_attr(misc_attrs, attr);
}

static void create_backing_table_functions(ast_node *table, CSTR name) {
  cg_blob_mappings_t *map = _ast_pool_new(cg_blob_mappings_t);

  map->get_key_type = get_backing_attr(table, "get_type", "bgetkey_type");
  map->get_val_type = map->get_key_type;  // this is never used
  map->get_key = get_backing_attr(table, "get_key", "bgetkey");
  map->get_val = get_backing_attr(table, "get_val", "bgetval");
  map->create_key = get_backing_attr(table, "create_key", "bcreatekey");
  map->create_val = get_backing_attr(table, "create_val", "bcreateval");
  map->update_key = get_backing_attr(table, "update_key", "bupdatekey");
  map->update_val = get_backing_attr(table, "update_val", "bupdateval");

  map->key_use_offsets = !has_backing_attr(table, "use_key_codes");  // offsets are the default
  map->val_use_offsets = has_backing_attr(table, "use_val_offsets");  // codes are the default
  map->use_json = has_backing_attr(table, "json");
  map->use_jsonb = has_backing_attr(table, "jsonb");

  add_backing_info(map, name);
}

static void clone_backing_table_functions(ast_node *table, CSTR name) {
  Contract(is_backed(table->sem->sem_type));
  EXTRACT_MISC_ATTRS(table, misc_attrs_backed);
  CSTR table_name = get_named_string_attribute_value(misc_attrs_backed, "backed_by");
  Contract(table_name); // already checked

  cg_blob_mappings_t *map = find_backing_info(table_name);
  Invariant(map);  // already added for sure!
  add_backing_info(map, name);
}

// Unlike the other parts of DDL we actually deeply care about the tables.
// We have to grab all the columns and column types out of it and create
// the appropriate sem_struct, as well as the sem_join with just one table.
// Along the way we validate a bunch of stuff like:
// * unique table name
// * no duplicate column names
// * recursive correctness of constraints (see above)
// The table will be added to the table/view list.
static void sem_create_table_stmt(ast_node *ast) {
  Contract(!current_joinscope);
  Contract(is_ast_create_table_stmt(ast));
  EXTRACT_NOTNULL(create_table_name_flags, ast->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_ANY(table_attrs, table_flags_attrs->right);
  EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(col_key_list, ast->right);

  // These never nest
  Invariant(!current_table_name);
  Invariant(!current_table_ast);

  // Save these so that we can quickly detect if we are trying to refer to the table that we are building
  // and get its ast.  This is needed because that name won't be in the symbol table until it succeeds. So
  // the self-referencing table case needs to use these to detect the self-reference.
  current_table_name = name;
  current_table_ast = ast;

  // stashed default values for the tables
  symtab *def_values = symtab_new();

  int32_t temp = flags & TABLE_IS_TEMP;
  int32_t no_rowid = flags & TABLE_IS_NO_ROWID;

  // CREATE [TEMP] TABLE [name] [if_not_exist] [col_key_list] [without rowid] [table_attrs]

  version_attrs_info table_vers_info;
  init_version_attrs_info(&table_vers_info, name, ast, table_attrs);

  if (!sem_validate_version_attrs(&table_vers_info)) {
    record_error(ast);
    goto cleanup;
  }

  if (!sem_validate_virtual_table_vers(&table_vers_info)) {
    record_error(ast);
    goto cleanup;
  }

  if (!sem_validate_vers_ok_in_context(&table_vers_info)) {
    record_error(ast);
    goto cleanup;
  }

  bool_t adding_current_entity = will_add_current_entity();

  // if there is an existing table, save it here so we can check for duplicates later.
  ast_node *existing_defn = adding_current_entity ? find_table_or_view_even_deleted(name) : NULL;

  col_def_info col_info;
  init_col_def_info(&col_info, &table_vers_info);

  bool_t rewrite_col = rewrite_col_key_list(col_key_list);

  if (!rewrite_col) {
    record_error(ast);
    goto cleanup;
  }

  // first count up the columns (and only the columns)
  uint32_t cols = 0;
  bool_t found_constraint = false;
  for (ast_node *item = col_key_list; item; item = item->right) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(def, item->left);

    if (is_ast_col_def(def)) {
      if (found_constraint) {
        report_error(def, "CQL0349: column definitions may not come after constraints", col_info.col_name);
        record_error(ast);
        goto cleanup;;
      }

      sem_col_def(def, &col_info);
      if (is_error(def)) {
        record_error(ast);
        goto cleanup;
      }

      if (col_info.default_value) {
        symtab_add(def_values, col_info.col_name, col_info.default_value);
      }

      if (temp && (col_info.create_version > 0 || col_info.delete_version > 0)) {
        report_error(def, "CQL0140: columns in a temp table may not have versioning attributes", col_info.col_name);
        record_error(ast);
        goto cleanup;;
      }

      if (is_deleted(def)) {
        continue;
      }

      cols++;
    }
    else {
      found_constraint = true;
    }
  }

  Invariant(col_info.autoinc_columns <= 1);

  if (col_info.autoinc_columns && no_rowid) {
    report_error(ast, "CQL0141: table has an AUTOINCREMENT column; it cannot also be WITHOUT ROWID", name);
    record_error(ast);
    goto cleanup;
  }

  if (enforcement.strict_without_rowid && no_rowid) {
    report_error(ast, "CQL0339: WITHOUT ROWID tables are forbidden if strict without rowid mode is enabled", name);
    record_error(ast);
    goto cleanup;
  }

  // now create a struct type with the correct number of columns
  // the types have already been computed so all we have to do is
  // check for duplicates
  sem_struct *sptr = new_sem_struct(name, cols);

  symtab *columns = symtab_new();

  uint32_t col = 0;
  for (ast_node *item = col_key_list; item; item = item->right) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(def, item->left);

    if (is_ast_col_def(def)) {
      Invariant(def->sem->name);
      Invariant(col <= cols);  // it's possible that the rest are deleted and we're at the end.

      // columns must be unique, including deleted columns
      if (!symtab_add(columns, def->sem->name, NULL)) {
        EXTRACT_NOTNULL(col_def_type_attrs, def->left);
        EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
        EXTRACT_NAME_AST(col_name_ast, col_def_name_type->left);

        report_error(col_name_ast, "CQL0142: duplicate column name", def->sem->name);
        record_error(ast);
        symtab_delete(columns);
        goto cleanup;;
      }

      if (is_deleted(def)) {
        continue;
      }

      Invariant(col < cols);

      sptr->names[col] = def->sem->name;
      sptr->semtypes[col] = def->sem->sem_type;
      sptr->kinds[col] = def->sem->kind;
      col++;
    }
  }

  symtab_delete(columns);

  Invariant(col == cols);

  ast->sem = new_sem(SEM_TYPE_STRUCT);
  ast->sem->sptr = sptr;
  ast->sem->jptr = sem_join_from_sem_struct(sptr);
  ast->sem->region = current_region;
  ast->sem->table_info = _ast_pool_new(table_node);
  memset(ast->sem->table_info, 0, sizeof(table_node));

  sem_constraints(ast, col_key_list, &col_info);

  if (is_error(ast)) {
    // important to early out here so that sem_type is not altered with table flags
    // that will break invariants (SEM_TYPE_ERROR should stay "pure")
    goto cleanup;;
  }

  if (col_info.primary_keys > 1) {
    report_error(name_ast, "CQL0143: more than one primary key in table", name);
    record_error(ast);
    goto cleanup;;
  }

  // Constraints may have computed type changes
  // if there are any such changes we need to apply them to the def
  // node so that the types are consistent.

  col = 0;
  for (ast_node *item = col_key_list; item; item = item->right) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(def, item->left);

    if (is_ast_col_def(def)) {
      if (is_deleted(def)) {
        continue;
      }

      Invariant(col < cols);

      if (not_nullable_flag(sptr->semtypes[col]) && !not_nullable_flag(def->sem->sem_type)) {
        sem_add_flags(def, SEM_TYPE_NOTNULL);
      }

      if (is_partial_pk(sptr->semtypes[col]) && !is_partial_pk(def->sem->sem_type)) {
        sem_add_flags(def, SEM_TYPE_PARTIAL_PK);
      }
      col++;
    }
  }

  Invariant(col == cols);

  ast->sem->sem_type           |= table_vers_info.flags;
  ast->sem->create_version      = table_vers_info.create_version;
  ast->sem->delete_version      = table_vers_info.delete_version;
  ast->sem->recreate            = table_vers_info.recreate;
  ast->sem->recreate_group_name = table_vers_info.recreate_group_name;

  if (is_qid(name_ast)) {
    ast->sem->sem_type |= SEM_TYPE_QID;
  }

  run_pending_table_validations();

  if (!is_error(ast)) {
    if (existing_defn) {
      // Use the virtual table definition for comparison if there is one -- it's the parent node.
      // If only one of the tables is virtual then the text can't possibly match so we don't
      // need any special case logic for mix and match of virtual/non-virtual. And the error
      // message will include the text of both so it should be obvious what has happened.
      ast_node *existing_cmp = is_virtual_ast(existing_defn) ? existing_defn->parent : existing_defn;
      ast_node *current_cmp = is_virtual_ast(ast) ? ast->parent : ast;

      if (!sem_validate_identical_ddl(existing_cmp, current_cmp)) {
        report_error(name_ast, "CQL0103: duplicate table/view name", name);
        record_error(name_ast);
        record_error(ast);
      }
      else {
        // this will let us find the duplicate later, it marks this as not authoritative
        sem_add_flags(ast, SEM_TYPE_ALIAS);
      }
      goto cleanup;;
    }

    if (is_table_blob_storage(ast)) {
      sem_validate_table_for_blob_storage(ast);
      if (is_error(ast)) {
        goto cleanup;
      }
    }

    if (is_table_backing(ast)) {
      sem_validate_table_for_backing(ast);
      if (is_error(ast)) {
        goto cleanup;
      }
      ast->sem->sem_type |= SEM_TYPE_BACKING;
    }

    if (is_table_backed(ast)) {
      sem_validate_table_for_backed(ast);
      if (is_error(ast)) {
        goto cleanup;
      }
      ast->sem->sem_type |= SEM_TYPE_BACKED;
    }

    if (validating_previous_schema) {
      sem_validate_previous_table(ast);
    }
    else if (adding_current_entity) {
      // deleted or no it goes in the main list
      add_item_to_list(&all_tables_list, ast);

      // The name is consumed, some clients will use find_usable_and_not_deleted_table_or_view
      // to not see deleted views (e.g. select) others don't (e.g. drop)
      add_table_or_view(ast);

      add_default_values(def_values, name);
      def_values = NULL;

      sem_record_annotation_from_vers_info(&table_vers_info);

      if (is_backing(ast->sem->sem_type)) {
        create_backing_table_functions(ast, name);
      }

      if (is_backed(ast->sem->sem_type)) {
        clone_backing_table_functions(ast, name);
        rewrite_shared_fragment_from_backed_table(ast);
        ast->sem->jptr->tables[0]->is_backed = true;
      }
    }
  }

cleanup:
  current_table_name = NULL;
  current_table_ast = NULL;
  if (def_values) {
    // if it's been stored in tables_default_values the local will be null
    symtab_delete(def_values);
  }
}

// Semantic analysis for virtual tables is odd. The "virtual" part of the
// create virtual table is competely uninteresting to CQL. It is a module
// invocation to a module that CQL has no visibility into.  The arguments
// can be anything; in the SQLite language they can be literally a letter
// to gramma -- the only requirement is that the parens match.  CQL limits
// the args to the forms allowed in a misc attribute list. This is general
// enough to represent an arbitrary LISP program but not totally arbitrary,
// but it requires no validation beyond syntax!  So we're left with the
// part that tells us the table shape.
void sem_create_virtual_table_stmt(ast_node *ast) {
  Contract(is_ast_create_virtual_table_stmt(ast));

  EXTRACT_NOTNULL(module_info, ast->left);
  EXTRACT_NOTNULL(create_table_stmt, ast->right);
  EXTRACT_NOTNULL(create_table_name_flags, create_table_stmt->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);
  EXTRACT_STRING(name, create_table_name_flags->right);
  EXTRACT_STRING(module_name, module_info->left);

  if (is_table_blob_storage(ast)) {
    report_invalid_blob_storage(ast, "it is a virtual table", name);
    return;
  }

  if (is_table_backing(ast)) {
    report_invalid_backing(ast, "it is a virtual table", name);
    return;
  }

  if (is_table_backed(ast)) {
    report_invalid_backed(ast, "it is a virtual table", name);
    return;
  }

  bool_t is_eponymous = !!(flags & VTAB_IS_EPONYMOUS);

  if (is_eponymous && StrCaseCmp(name, module_name)) {
    CSTR err_msg = dup_printf(
         "CQL0447: virtual table '%s' claims to be eponymous but its module name '%s' differs from its table name",
         name, module_name);
    report_error(ast, err_msg, NULL);
    record_error(ast);
    return;
  }

  sem_create_table_stmt(create_table_stmt);
  if (is_error(create_table_stmt)) {
    record_error(ast);
    return;
  }

  // nothing else can go wrong, any module name is legal and any args are legal
  // the args are not checked against anything as they are only meaningful to
  // the module code that interprets them. In a very real sense CQL only
  // cares about the 'AS' part of the create table statement

  create_table_stmt->sem->sem_type |= SEM_TYPE_VIRTUAL;
  ast->sem = create_table_stmt->sem;
}

// Validate alter table add column
// * table must exist and not be a view (in any version)
// * column definition must be self-consistent
// * no auto increment columns may be added
// * no not nullable columns may be added
//
// Note: Alter statements are typically used in the context of migration so it's
// possible the table is gone in the latest version.  We still have to run
// the intervening upgrade steps so basically DDL gets to ignore the current
// state.
static void sem_alter_table_add_column_stmt(ast_node *ast) {
  Contract(is_ast_alter_table_add_column_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT(col_def, ast->right);

  // ALTER statements can be operating in the past, so we might be working on a table that is now deleted
  ast_node *table_ast = find_usable_table_or_view_even_deleted(name, name_ast, "CQL0144: table in alter statement does not exist");
  if (!table_ast) {
    record_error(ast);
    return;
  }

  name_ast->sem = table_ast->sem;

  if (!is_ast_create_table_stmt(table_ast)) {
    report_error(name_ast, "CQL0144: cannot alter a view", name);
    record_error(ast);
    return;
  }

  if (is_virtual_ast(table_ast)) {
    report_error(name_ast, "CQL0164: cannot use ALTER TABLE on a virtual table", name);
    record_error(ast);
    return;
  }

  version_attrs_info table_vers_info;
  init_version_attrs_info(&table_vers_info, name, table_ast, NULL);
  table_vers_info.create_version      = table_ast->sem->create_version;
  table_vers_info.delete_version      = table_ast->sem->delete_version;
  table_vers_info.recreate            = table_ast->sem->recreate;
  table_vers_info.recreate_group_name = table_ast->sem->recreate_group_name;

  col_def_info col_info;
  init_col_def_info(&col_info, &table_vers_info);

  sem_col_def(col_def, &col_info);
  if (is_error(col_def)) {
    record_error(ast);
    return;
  }

  if (col_info.create_version > 0 || col_info.delete_version > 0) {
    report_error(col_def, "CQL0145: version annotations not valid in alter statement", col_def->sem->name);
    record_error(ast);
    return;
  }

  if (col_info.autoinc_columns) {
    report_error(col_def, "CQL0146: adding an auto increment column is not allowed", col_def->sem->name);
    record_error(ast);
    return;
  }

  if (is_not_nullable(col_def->sem->sem_type) && !has_default(col_def->sem->sem_type)) {
    report_error(col_def, "CQL0147: adding a not nullable column with no default value is not allowed", col_def->sem->name);
    record_error(ast);
    return;
  }

  // CQL's world view is that the schema as declared is authoritative, so the alter should
  // already be reflected.  The only purpose of executing this statement is to bring the physical schema
  // up to date.

  EXTRACT_ANY_NOTNULL(col_key_list, table_ast->right);

  ast_node *def_found = NULL;

  for (ast_node *item = col_key_list; item; item = item->right) {
    Contract(is_ast_col_key_list(item));
    EXTRACT_ANY_NOTNULL(def, item->left);

    // only columns
    if (!is_ast_col_def(def)) {
      continue;
    }

    // if the column is not marked for @create it doesn't count!
    if (def->sem->create_version < 0) {
      continue;
    }

    // if the column is logically deleted, it doesn't count
    if (is_deleted(def)) {
      continue;
    }

    // if the name matches, we found it!
    if (!strcmp(def->sem->name, col_def->sem->name)) {
      def_found = def;
      break;
    }
  }

  if (!def_found) {
    report_error(col_def, "CQL0148: added column must already be reflected in declared schema, with @create, exact name match required", col_def->sem->name);
    record_error(ast);
    return;
  }

  sem_t sem_type_added = col_def->sem->sem_type;
  sem_t sem_type_required = def_found->sem->sem_type;

  if (sem_type_added != sem_type_required) {
    report_error(col_def, "CQL0149: added column must be an exact match for the column type declared in the table", col_def->sem->name);
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// Enables a nonnull improvement, if possible.
static void sem_set_notnull_improved(CSTR name, CSTR scope) {
  Contract(name);

  bool_t is_global = false;

  sem_t *type = find_mutable_type_and_global_status(name, scope, &is_global);
  Contract(type);

  // There's no need to proceed if this is a NOT NULL type or if it is a
  // nullable type that has already been improved.
  if (*type & (SEM_TYPE_NOTNULL | SEM_TYPE_INFERRED_NOTNULL)) {
    return;
  }

  // We keep track of globals as we need to un-improve all of them after every
  // procedure call. We need to do this due to the assumption that the procedure
  // could have set any number of globals to null.
  if (is_global) {
    // Since this is a global, record it as such.
    global_notnull_improvement_item *global_item = _ast_pool_new(global_notnull_improvement_item);
    global_item->type = type;
    global_item->next = global_notnull_improvements;
    global_notnull_improvements = global_item;
  }

  flow_set_flag_for_type(SEM_TYPE_INFERRED_NOTNULL, type);
}

// This needs to be called for everything that is no longer safe to consider NOT
// NULL due to a mutation. It is fine to call this for something not currently
// subject to improvement, but it must only be called with a name/scope pair
// referring to something has a mutable type (e.g., it must not be an unbound
// variable, a cursor used an expression, an enum case, et cetera).
static void sem_unset_notnull_improved(CSTR name, CSTR scope) {
  Contract(name);

  sem_t *type = find_mutable_type(name, scope);
  // There is no case in which we should ever attempt to unset something that
  // doesn't have a mutable type: Such a name/scope pair would've never been
  // improved to begin with (e.g., because our input program had an error in
  // which the name/scope pair was used without being defined), and no hazard
  // (e.g., SET or OUT args) allows something for which `find_mutable_type` will
  // return NULL (e.g., an enum case, 'rowid', or a cursor in an expression
  // position).
  Contract(type);

  // As in `sem_unset_notnull_improvements_in_context`, it is critical that we
  // do not unset an improvement if it is not currently set; see the comments
  // within `sem_unset_notnull_improvements_in_context` for details.
  if (*type & SEM_TYPE_INFERRED_NOTNULL) {
    flow_unset_flag_for_type(SEM_TYPE_INFERRED_NOTNULL, type);
  }
}

// Unsets notnull improvements for all currently improved globals.
static void sem_unset_global_notnull_improvements() {
  for (global_notnull_improvement_item *head = global_notnull_improvements; head; head = head->next) {
    if (*head->type & SEM_TYPE_INFERRED_NOTNULL) {
      flow_unset_flag_for_type(SEM_TYPE_INFERRED_NOTNULL, head->type);
    }
  }
}

// Given a conditional expression `ast` possibly containing AND-linked
// subexpressions, set all of the applicable nullability and has-row
// improvements within the current flow context. Generally speaking, calls to
// this function should be bounded by a new flow context corresponding to the
// portion of the program for which the condition `ast` must be be true.
static void sem_set_improvements_for_true_condition(ast_node* ast)
{
  Contract(ast);

  if (is_ast_and(ast)) {
    // We include all improvements along the outermost spine of AND expressions.
    Invariant(ast->left);
    Invariant(ast->right);
    sem_set_improvements_for_true_condition(ast->left);
    sem_set_improvements_for_true_condition(ast->right);
    return;
  }

  if (is_id(ast)) {
    // This is the "id" case. We can possibly make a has-row improvement.
    EXTRACT_STRING(name, ast);
    sem_t *type = find_mutable_type(name, NULL);
    if (type && is_auto_cursor(*type)) {
      // `ast` refers to a cursor an auto cursor. We can set a has-row
      // improvement accordingly.
      sem_set_has_row_improved(name);
      return;
    }
  }

  if (is_ast_is_not(ast) && is_ast_null(ast->right) && is_id_or_dot(ast->left)) {
    // This is the "id_or_dot IS NOT NULL" case. We can improve nullability
    // here.
    //
    // NOTE: Since calling a procedure as a function is only allowed if it
    // has exactly one trailing OUT parameter (which becomes the return value),
    // it cannot be the case that any call within `ast` could unset any
    // improvements we just made (because no variables might be passed as OUT
    // arguments therein). Were the aforementioned proc-as-func restriction not
    // in place, we'd need to deep-traverse `ast` looking for any calls with OUT
    // arguments as any improvements we just made could possibly be invalidated
    // by such calls. This was, indeed, the case in earlier versions of CQL.
    EXTRACT_NAME_AND_SCOPE(ast->left);
    sem_set_notnull_improved(name, scope);
    return;
  }
}

// Improvements for known-false conditions are dual to improvements for
// known-true conditions.
//
// For nullability, known-false conditions improve ids and dots verified to be
// NULL via `IS NULL` along the outermost spine of `OR` expressions, whereas
// known-true conditions improve ids and dots verified to be nonnull via `IS NOT
// NULL` along the outermost spine of `AND` expressions. For example, the
// following two statements introduce the same improvements:
//
//   IF a IS NOT NULL AND b IS NOT NULL THEN
//     -- `a` and `b` are improved here because we know the condition is true
//   END IF;
//
//   IF a IS NULL OR b IS NULL RETURN;
//   -- `a` and `b` are improved here because we know the condition is false
//   -- since we must not have returned if we got this far
//
// Likewise, for cursors, known-false conditions improve ids verified to not
// have a row along the outermost spine of `OR` expresions, whereas known-true
// conditions improve cursors verified to have a row along the outermost spine
// of `AND` expressions. Again, the following two statements introduce the same
// improvements:
//
//   IF c THEN
//     -- `c` is known to have a row here
//   END IF;
//
//   IF not c THEN RETURN;
//   -- `c` is known to have a row here
static void sem_set_improvements_for_false_condition(ast_node *ast) {
  Contract(ast);

  if (is_ast_or(ast)) {
    // As in `sem_set_improvements_for_true_condition`, we make sure to
    // recurse through the left side first in keeping with the order of
    // evaluation at runtime.
    sem_set_improvements_for_false_condition(ast->left);
    sem_set_improvements_for_false_condition(ast->right);
    return;
  }

  if (is_ast_not(ast) && is_id(ast->left)) {
    // This is the "NOT id" case. We can possibly make a has-row improvement.
    EXTRACT_STRING(name, ast->left);
    sem_t *type = find_mutable_type(name, NULL);
    if (type && is_auto_cursor(*type)) {
      // `ast->left` refers to an auto cursor. We can set a has-row improvement
      // accordingly.
      sem_set_has_row_improved(name);
      return;
    }
  }

  if (is_ast_is(ast) && is_ast_null(ast->right) && is_id_or_dot(ast->left)) {
    // This is the "id_or_dot IS NULL" case. We can improve nullability here.
    EXTRACT_ANY_NOTNULL(id_or_dot, ast->left);
    EXTRACT_NAME_AND_SCOPE(id_or_dot);
    sem_set_notnull_improved(name, scope);
    return;
  }
}

// This is the [expression] then [statements] part of an IF or ELSE IF
// Which is what we mean by a conditional action.  We have to validate
// that the condition is numeric and the statements have no errors.
// There's helper for all that.
static void sem_cond_action(ast_node *ast) {
  Contract(is_ast_cond_action(ast));
  EXTRACT(stmt_list, ast->right);
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  // [expr] THEN stmt_list
  sem_expr(expr);
  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  if (!is_numeric_expr(expr)) {
    report_error(expr, "CQL0150: expected numeric expression in IF predicate", NULL);
    record_error(ast);
    return;
  }

  if (stmt_list) {
    FLOW_PUSH_CONTEXT_BRANCH();
    // Add improvements for `stmt_list` where `expr` must be true.
    sem_set_improvements_for_true_condition(expr);
    sem_stmt_list_in_current_flow_context(stmt_list);
    FLOW_POP_CONTEXT_BRANCH();
    if (is_error(stmt_list)) {
      record_error(ast);
      return;
    }
  }
  else {
    flow_context_branch_group_add_empty_branch();
  }

  // If a later branch will be taken, `expr` must be false. Add its negative
  // improvements to the context created in `sem_if_stmt` so that all later
  // branches will be improved by the OR-linked spine of IS NULL checks in
  // `expr`.
  sem_set_improvements_for_false_condition(expr);

  ast->sem = expr->sem;
}

// Enables an initialization improvement for a variable if the improvement does
// not already exist.
static void sem_set_initialization_improved(CSTR name, CSTR scope) {
  Contract(name);

  sem_t *type = find_mutable_type(name, scope);
  Contract(type);
  Contract(is_variable(SEM_TYPE_VARIABLE));

  if (!(*type & SEM_TYPE_INIT_REQUIRED) || *type & SEM_TYPE_INIT_COMPLETE) {
    return;
  }

  flow_set_flag_for_type(SEM_TYPE_INIT_COMPLETE, type);
}

// Enables a has-row improvement for an auto cursor if the improvement does not
// already exist.
static void sem_set_has_row_improved(CSTR cursor_name) {
  Contract(cursor_name);

  sem_t *type = find_mutable_type(cursor_name, NULL);
  Contract(type);
  Contract(is_auto_cursor(*type));

  if (*type & SEM_TYPE_HAS_ROW) {
    return;
  }

  flow_set_flag_for_type(SEM_TYPE_HAS_ROW, type);
}

// Disables a has-row improvement for an auto cursor if the improvement exists.
// This must be called after every FETCH that is not guaranteed to result in a
// row.
static void sem_unset_has_row_improved(CSTR cursor_name) {
  Contract(cursor_name);

  sem_t *type = find_mutable_type(cursor_name, NULL);
  Contract(type);
  Contract(is_auto_cursor(*type));

  if (!(*type & SEM_TYPE_HAS_ROW)) {
    return;
  }

  flow_unset_flag_for_type(SEM_TYPE_HAS_ROW, type);
}

// This is the list of else-ifs, which is to say a linked list of
// conditional actions (see above).  We just walk the list and
// decorate each piece accordingly, if anything goes wrong mark the
// head with an error.
static void sem_elseif_list(ast_node *head) {
  Contract(is_ast_elseif(head));

  for (ast_node *ast = head; ast; ast = ast->right) {
    Contract(is_ast_elseif(ast));
    EXTRACT_NOTNULL(cond_action, ast->left);

    // ELSE IF [cond_action]
    sem_cond_action(cond_action);
    if (is_error(cond_action)) {
      record_error(ast);
      record_error(head);
      return;
    }
    ast->sem = cond_action->sem;
  }
}

// Returns the first statement in a list of statements while taking attributes
// into account.
static ast_node *first_stmt_in_stmt_list(ast_node *ast) {
  Contract(is_ast_stmt_list(ast));

  EXTRACT_ANY_NOTNULL(stmt_or_stmt_and_attr, ast->left);

  if (is_ast_stmt_and_attr(stmt_or_stmt_and_attr)) {
    EXTRACT_ANY_NOTNULL(stmt, stmt_or_stmt_and_attr->right);
    return stmt;
  }

  return stmt_or_stmt_and_attr;
}

// Returns true if `ast` is a type of control statement, else false.
static bool_t is_control_stmt(ast_node *ast) {
  return is_ast_commit_return_stmt(ast)
    || is_ast_continue_stmt(ast)
    || is_ast_leave_stmt(ast)
    || is_ast_return_stmt(ast)
    || is_ast_rollback_return_stmt(ast)
    || is_ast_throw_stmt(ast);
}

// Given a `stmt_list`, perform a shallow search and return true if the
// statement list directly contains a control statement, else return false.
static bool_t stmt_list_contains_control_stmt(ast_node *ast) {
  Contract(is_ast_stmt_list(ast));

  for (ast_node *head = ast; head; head = head->right) {
    ast_node *stmt = first_stmt_in_stmt_list(head);
    if (is_control_stmt(stmt)) {
      return true;
    }
  }

  return false;
}

// This analyzes and expression statement, discarding the result.
// We also look for top level "function" calls that are actually calling
// a procedure and convert the tree into a procedure call. This means
// that at the top level if it could be a proc call or a func call (both can exist, e.g. printf)
// the proc call gets priority!  This is not an accident!  Because printf.
static void sem_expr_stmt(ast_node *ast) {
  Contract(is_ast_expr_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);

  if (is_ast_eq(expr)) {
    report_error(expr, "CQL0471: a top level equality is almost certainly an error. ':=' is assignment, not '='\n", NULL);
    record_error(expr);
    record_error(ast);
    return;
  }

  // find the operator tag for the expression here
  symtab_entry *entry = symtab_find(exprs, expr->type);
  Invariant(entry);
  sem_expr_dispatch *disp = (sem_expr_dispatch*)entry->val;

  // rewrite top level +=, -=, /=, *=, and %= before we go any further
  // if it's not one of these (e.g. ==) then this is a no-op
  rewrite_op_equals_assignment_if_needed(expr, disp->str);

  // we have to write array access before everything else, it will need the other rewrites to follow
  if (is_ast_expr_assign(expr)) {
     EXTRACT_ANY_NOTNULL(left, expr->left);
     EXTRACT_ANY_NOTNULL(value, expr->right);

     bool_t rewritten_assignment = false;

     if (is_ast_array(left)) {
       sem_validate_array_transform(left, "set");
       rewritten_assignment = true;
     }
     else if (is_ast_dot(left)) {
       sem_validate_dot_transform(left, "set");
       rewritten_assignment = true;
     }

     if (rewritten_assignment) {
       if (is_error(left)) {
         record_error(ast);
         return;
       }

       // move the assigned value into the last arg of the call
       expr->type = left->type;
       ast_set_left(expr, left->left);
       ast_set_right(expr, left->right);
       rewrite_append_arg(left, value);

       // the call is left unanalyzed, call is processed further below
       // so it won't escape the semantic pass
     }
  }

  // if there is a x:y x::y or x:::y operation then transform the AST now
  // so that everything looks like normal calls. Just the transform though.
  // We may have to analyze the transformed call as a procedure so we defer that.
  bool_t hard_error = sem_reverse_apply_if_needed(expr, SEM_REVERSE_APPLY_REWRITE_ONLY);
  if (hard_error) {
    record_error(ast);
    return;
  }


  // Here is the magic.  If the top level expression is a function call
  // then we want to look to see if that function is actually a procedure.
  // If it is, we will rewrite that into a call statement so that you can
  // call top level procedures with no call keyword.  We did the reverse
  // apply above so that any x:foo(..) has already been unwound into a normal
  // call.  We don't want to have to look for all the : :: and ::: forms.
  if (is_ast_call(expr)) {
    EXTRACT_NAME_AST(name_ast, expr->left);
    EXTRACT_STRING(name, name_ast);

    EXTRACT_NOTNULL(call_arg_list, expr->right);
    EXTRACT_NOTNULL(call_filter_clause, call_arg_list->left);
    EXTRACT_ANY(filters, call_filter_clause->left);

    // if there is a filter clause it can't be a proc call
    if (!filters) {
      bool_t perform_proc_rewrite = false;
      ast_node *proc_stmt = find_proc(name);

      if (proc_stmt) {
        EXTRACT(arg_list, call_arg_list->right);

        // expand '*' into FROM LOCALS LIKE [target_of_call] ARGUMENTS
        if (!rewrite_ast_star_if_needed(arg_list, name_ast)) {
          record_error(ast);
          return;
        }

        // expand any FROM forms in the arg list
        // it's still a function call after this.  This would
        // have happened anyway in sem_expr we're doing it sooner.
        if (!rewrite_shape_forms_in_list_if_needed(arg_list)) {
          record_error(ast);
          return;
        }

        // compute the count of provided args after expansion
        uint32_t arg_count = 0;
        for (ast_node *item = arg_list; item; item = item->right) arg_count++;

        Contract(is_proc(proc_stmt));
        EXTRACT_NOTNULL(proc_params_stmts, proc_stmt->right);
        EXTRACT(params, proc_params_stmts->left);

        // now compute the count of formal parameters
        uint32_t param_count = 0;
        for (ast_node *item = params; item; item = item->right) param_count++;

        // if exactly one argument missing, don't do the rewrite
        // if more are missing do the rewrite even though we know it will fail
        // semantic validation.  The error message will be better.
        perform_proc_rewrite = (arg_count != param_count - 1);
      }
      else if (find_unchecked_proc(name)) {
        perform_proc_rewrite = true;
      }

      // All of this is so that you can write a top level proc call
      // where the call will turn into proc as func because there is
      // an out arg missing.  That call has to be not rewritten as
      // a standard call.  So imagine there is a 'dump' function that
      // prints its argument and returns it.  `x:dump()` needs to work
      // at the top level even though dump has an out arg.
      if  (perform_proc_rewrite) {
        // Safe to rewrite the function as a proc call now
        // Either it's unchecked, or else normal and matching arg count
        rewrite_func_call_as_proc_call(ast);
        sem_call_stmt_opt_cursor(ast, NULL);
        return;
      }
    }
  }
  else if (is_ast_expr_assign(expr)) {
    if (!is_id(expr->left)) {
      report_error(expr, "CQL0465: left operand of assignment operator must be a name", ":=");
      record_error(expr);
      record_error(ast);
      return;
    }

    // convert the operator into a SET statement
    // this is a top level expression so it's ok to do that
    ast->type = k_ast_assign;
    ast_set_left(ast, expr->left);
    ast_set_right(ast, expr->right);
    sem_assign(ast);
    return;
  }

  // If we're on this path then it's not a proc
  // or else it is a proc but it's the proc as func pattern
  // so it has to be evaluated as an expression.
  sem_expr(expr);
  ast->sem = expr->sem;
}

static void sem_ifdef_stmt(ast_node *ast) {
  Contract(is_ast_ifdef_stmt(ast) || is_ast_ifndef_stmt(ast));
  EXTRACT_ANY_NOTNULL(evaluation, ast->left);
  EXTRACT_NOTNULL(pre, ast->right);
  record_ok(ast);

  ast_node *target;
  if (is_ast_is_true(evaluation)) {
    EXTRACT(stmt_list, pre->left);
    target = stmt_list;
  }
  else {
    EXTRACT(stmt_list, pre->right);
    target = stmt_list;
  }

  if (target) {
    sem_stmt_list(target);
    if (is_error(target)) {
      record_error(ast);
    }
  }
}

static void sem_ifndef_stmt(ast_node *ast) {
  // the true/false evaluation has already been done and we are is_true if
  // we take the true branch
  sem_ifdef_stmt(ast);
}

// The top level if node links the initial cond_action with a possible
// series of else_if nodes and then the else node.  All that happens
// at this point is decoding of the if pieces and calling out to the helpers.
// The else clause is the only thing that isn't a cond_action.  This is
// basically just calling out and marking errors up the stack as needed.
static void sem_if_stmt(ast_node *ast) {
  Contract(is_ast_if_stmt(ast));
  EXTRACT_NOTNULL(cond_action, ast->left);
  EXTRACT_NOTNULL(if_alt, ast->right);

  // Each branch gets its own flow context in `sem_cond_action` where its
  // condition is known to be true. We also create one more context for the
  // entire set of branches. In addition to grouping the branches together, this
  // outer context holds all of the negative improvements that result from the
  // knowledge that, if a given branch's statements are being evaluated, all
  // previous branches' conditions must have been false.
  FLOW_PUSH_CONTEXT_BRANCH_GROUP();

  // IF [cond_action]
  EXTRACT(elseif, if_alt->left);
  EXTRACT_NAMED(elsenode, else, if_alt->right);

  sem_cond_action(cond_action);
  if (is_error(cond_action)) {
    goto error;
  }

  if (elseif) {
    sem_elseif_list(elseif);
    if (is_error(elseif)) {
      record_error(if_alt);
      goto error;
    }
  }

  if (elsenode) {
    // ELSE [stmt_list]
    flow_set_context_branch_group_covers_all_cases(true);
    EXTRACT(stmt_list, elsenode->left);
    if (stmt_list) {
      FLOW_PUSH_CONTEXT_BRANCH();
      sem_stmt_list_in_current_flow_context(stmt_list);
      FLOW_POP_CONTEXT_BRANCH();
      if (is_error(stmt_list)) {
        record_error(elsenode);
        record_error(if_alt);
        goto error;
      }
    }
    else {
      flow_context_branch_group_add_empty_branch();
    }
    record_ok(elsenode);
  }

  record_ok(if_alt);

  ast->sem = cond_action->sem;
  // END IF

cleanup:
  FLOW_POP_CONTEXT_BRANCH_GROUP();

  if (is_error(ast)) {
    return;
  }

  // Check for use of the guard pattern, i.e., an IF with only a THEN block that
  // concludes with a control statement. If this IF follows the guard pattern,
  // then we can add improvements for the statements that follow due to the fact
  // that the condition must have been false.
  //
  // NOTE: The reason that no `elseif` or `elsenode` can be present for this to
  // be safe is that, if the THEN condition were false, those branches would
  // run, and they could do something that would invalidate the improvements
  // we're about to make (e.g., by setting something to NULL).
  if (!elseif && !elsenode) {
    EXTRACT(stmt_list, cond_action->right);
    if (stmt_list && stmt_list_contains_control_stmt(stmt_list)) {
      EXTRACT_ANY_NOTNULL(cond_expr, cond_action->left);
      sem_set_improvements_for_false_condition(cond_expr);
    }
  }

  return;

error:
  record_error(ast);
  goto cleanup;
}

// Guard statements are a restricted form of IF statement where the current
// block or procedure is exited when the guard condition is true. The valid
// forms are as follows:
//
//   IF expr COMMIT RETURN;
//   IF expr CONTINUE;
//   IF expr LEAVE;
//   IF expr RETURN;
//   IF expr ROLLBACK RETURN;
//   IF expr THROW;
//
//  As with IF statements, nullability improvements are possible.
static void sem_guard_stmt(ast_node *ast) {
  Contract(is_ast_guard_stmt(ast));
  EXTRACT_ANY_NOTNULL(control_stmt, ast->right);
  Invariant(is_control_stmt(control_stmt));

  rewrite_guard_stmt_to_if_stmt(ast);
}

// if the statement has a with clause, get the with version
cql_noexport ast_node *sem_recover_with_stmt(ast_node *ast) {
  if (ast->parent && ast->parent->left && is_ast_with(ast->parent->left)) {
    return ast->parent;
  }
  return ast;
}

// If this is the "with" form of a statement get ito the inner statement,
// skipping the with prefix.  The inverse of the above
cql_noexport ast_node *sem_skip_with(ast_node *ast) {
  if (ast->left && is_ast_with(ast->left)) {
    return ast->right;
  }
  return ast;
}

// This is the delete analyzer, it sets up a joinscope for the table being
// deleted and the validates the WHERE if present against that joinscope.
// Additionally we verify that the table actually was defined and is not a view.
static void sem_delete_stmt(ast_node *ast) {
  Contract(is_ast_delete_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT(opt_where, ast->right);

  BEGIN_BACKING_REWRITE();

  // DELETE FROM [name]

  ast_node *table_ast = find_usable_and_not_deleted_table_or_view(
    name,
    name_ast,
    "CQL0151: table in delete statement does not exist");
  if (!table_ast) {
    record_error(ast);
    goto cleanup;
  }

  sem_non_blob_storage_table(ast, table_ast);
  if (is_error(ast)) {
    goto cleanup;
  }

  name_ast->sem = table_ast->sem;

  if (!is_ast_create_table_stmt(table_ast)) {
    report_error(name_ast, "CQL0152: cannot delete from a view", name);
    record_error(ast);
    goto cleanup;
  }

  PUSH_JOIN(where_scope, table_ast->sem->jptr);

  if (opt_where) {
    // WHERE
    sem_opt_where(opt_where);
    if (is_error(opt_where)) {
      record_error(ast);
      POP_JOIN();
      goto cleanup;
    }
  }

  POP_JOIN();

  record_ok(ast);

  // rewrite top level delete statements if needed
  if (BACKING_REWRITE_NEEDED(ast, table_ast)) {
    rewrite_delete_statement_for_backed_table(sem_recover_with_stmt(ast), backed_tables_list);
  }

cleanup:

  END_BACKING_REWRITE();
}

// Top level WITH-DELETE form -- create the CTE context and then process
// the delete statement.
static void sem_with_delete_stmt(ast_node *stmt) {
  Contract(is_ast_with_delete_stmt(stmt));
  EXTRACT_ANY_NOTNULL(with_prefix, stmt->left)
  EXTRACT(cte_tables, with_prefix->left);
  EXTRACT_NOTNULL(delete_stmt, stmt->right);

  Invariant(cte_cur == NULL);

  sem_push_cte_state();

  sem_cte_tables(cte_tables);
  if (is_error(cte_tables)) {
    record_error(stmt);
    goto cleanup;
  }

  sem_delete_stmt(delete_stmt);

  if (is_error(delete_stmt)) {
    record_error(stmt);
    goto cleanup;
  }

  stmt->sem = delete_stmt->sem;

cleanup:
  sem_pop_cte_state();
}

static void sem_returning_clause(
  ast_node *select_expr_list,
  CSTR table_name)
 {
  Contract(select_expr_list);

  // note that the original statment might have been rewritten due to backing tables
  // and now it has a with prefix.  We don't want to get the table name out of
  // that, instead we want the original table name.  That's the backed name if there
  // is one.

  ast_node *table_ast = find_table_or_view_even_deleted(table_name);
  Invariant(table_ast);  // already verified by the above

  sem_join join = *table_ast->sem->jptr;

  // change * and T.* to @COLUMNS(T)
  rewrite_star_and_table_star_as_columns_calc(select_expr_list, &join);

  // expand those (there may be some there in the source too)
  rewrite_select_expr_list(select_expr_list, &join);

  PUSH_JOIN(delete_scope, &join);
  sem_select_expr_list(select_expr_list);
  POP_JOIN();

  if (is_error(select_expr_list)) {
    return;
  }

  if (is_backed(table_ast->sem->sem_type)) {
    // we need to change any references to the tables to be the blob extractions
    // from the key and value blobs
    rewrite_backed_column_references_in_ast(select_expr_list, table_ast);
  }
}

static void sem_delete_returning(ast_node *ast) {
  Contract(is_ast_delete_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(delete_stmt, ast->left);
  EXTRACT_NOTNULL(select_expr_list, ast->right);

  ast_node *delete_stmt_plain = delete_stmt;

  if (is_ast_with_delete_stmt(delete_stmt)) {
    delete_stmt_plain = delete_stmt->right;
  }

  Invariant(is_ast_delete_stmt(delete_stmt_plain));
  EXTRACT_STRING(table_name, delete_stmt_plain->left);

  if (is_ast_with_delete_stmt(delete_stmt)) {
    sem_with_delete_stmt(delete_stmt);
  }
  else {
    sem_delete_stmt(delete_stmt);
  }

  if (is_error(delete_stmt)) {
    record_error(ast);
    return;
  }

  sem_returning_clause(select_expr_list, table_name);
  if (is_error(select_expr_list)) {
     record_error(ast);
     return;
  }

  ast->sem = select_expr_list->sem;
}

static void sem_delete_returning_stmt(ast_node *ast) {
  sem_delete_returning(ast);
  sem_update_proc_type_for_select(ast);
}

// This is is the helper that computes the types in an update where
// you might go update foo set x = y.  This is the "set x = y" portion.
// This will be one update in a list of such updates.  The only trick here
// is that when setting, the left side must not be a variable, it has to be a column.
// To do this we temporarily hide the variables head.  We verify that the types
// are compatible and we also handle the special case of trying to set a
// not-nullable type to null.
static void sem_update_entry(
  ast_node *ast,
  symtab *update_columns,
  sem_join *from_jptr,
  ast_node *table_name_ast)
{
  Contract(is_ast_update_entry(ast));
  Contract(current_joinscope);

  // name = expr  or name1.name2 = expr

  EXTRACT_ANY_NOTNULL(left, ast->left);
  EXTRACT_ANY_NOTNULL(right, ast->right);

  {
    symtab *saved_locals = locals;
    symtab *saved_globals = globals;

    // hide variables for this expression, no variables on left of :=
    locals = globals = NULL;

    // the FROM clause (if any) is not in scope at this point, this is deliberate
    // in SET x = y  the 'x' cannot come from the FROM clause but 'y' can
    sem_expr(left);

    locals = saved_locals;
    globals = saved_globals;
  }

  if (is_error(left)) {
    record_error(ast);
    return;
  }

  if (!symtab_add(update_columns, left->sem->name, NULL)) {
    report_error(left, "CQL0153: duplicate target column name in update statement", left->sem->name);
    record_error(ast);
    record_error(left);
    return;
  }

  // the from clause contributes to scopes on the right of the assignment
  // but not on the left
  if (from_jptr) {
    PUSH_JOIN(from_scope, from_jptr);
    sem_root_expr(right, SEM_EXPR_CONTEXT_SELECT_LIST);
    POP_JOIN();
  }
  else {
    sem_root_expr(right, SEM_EXPR_CONTEXT_SELECT_LIST);
  }

  if (is_error(right)) {
    record_error(ast);
    return;
  }

  sem_t sem_type_left = left->sem->sem_type;
  sem_t sem_type_right = right->sem->sem_type;

  Invariant(is_unitary(sem_type_left));
  Invariant(is_unitary(sem_type_right));
  Invariant(!is_object(sem_type_left));
  Invariant(!is_object(sem_type_right));

  if (!sem_verify_assignment(right, sem_type_left, sem_type_right, left->sem->name)) {
    CHARBUF_OPEN(tmp);
    bprintf(&tmp, "additional info: in update table '");
    gen_name_for_msg(table_name_ast, &tmp);
    bprintf(&tmp, "' the column with the problem is");
    report_error(right, Strdup(tmp.ptr), left->sem->name);
    CHARBUF_CLOSE(tmp);
    record_error(ast);
    return;
  }

  sem_combine_kinds(right, left->sem->kind);
  if (is_error(right)) {
    record_error(ast);
    return;
  }

  ast->sem = left->sem;
}

// This is the list of updates we need to perform, we walk the list here and handle
// each one, reporting errors as we go.
static void sem_update_list(ast_node *head, sem_join *from_jptr, ast_node *table_name_ast) {
  Contract(is_ast_update_list(head));

  symtab *update_columns = symtab_new();

  for (ast_node *ast = head; ast; ast = ast->right) {
    Contract(is_ast_update_list(ast));
    EXTRACT_NOTNULL(update_entry, ast->left);

    sem_update_entry(update_entry, update_columns, from_jptr, table_name_ast);
    if (is_error(update_entry)) {
      record_error(head);
      symtab_delete(update_columns);
      return;
    }
  }

  symtab_delete(update_columns);

  record_ok(head);
}

// This is the top level update statement, it calls the update list helpers
// and sets up the joinscope for the table(s) being updated.  If there are
// optional clauses they are evaluated just like in a select statement
// with those same helper methods.
static void sem_update_stmt(ast_node *ast) {
  Contract(is_ast_update_stmt(ast));
  EXTRACT_ANY(table_name_ast, ast->left);
  EXTRACT_NOTNULL(update_set, ast->right);
  EXTRACT_ANY_NOTNULL(update_list, update_set->left);
  EXTRACT_NOTNULL(update_from, update_set->right);
  EXTRACT_NOTNULL(update_where, update_from->right);
  EXTRACT_NOTNULL(update_orderby, update_where->right);
  EXTRACT_ANY(query_parts, update_from->left);
  EXTRACT(opt_where, update_where->left);
  EXTRACT(opt_orderby, update_orderby->left);
  EXTRACT(opt_limit, update_orderby->right);
  ast_node *table_ast = NULL;

  // Any early out is an error, cleanup is needed to get the POP_JOIN
  bool_t error = true;
  int32_t join_pushed = 0;

  BEGIN_BACKING_REWRITE();

  if (enforcement.strict_update_from && query_parts) {
    report_error(ast,
       "CQL0498: strict UPDATE ... FROM validation requires that the UPDATE statement not include a FROM clause", NULL);
    goto cleanup;
  }

  // update [table] SET [update_list]

  if (table_name_ast) {
    EXTRACT_STRING(name, table_name_ast);

    table_ast = find_usable_and_not_deleted_table_or_view(
      name,
      table_name_ast,
      "CQL0154: table in update statement does not exist");
    if (!table_ast) {
      goto cleanup;
    }

    table_name_ast->sem = table_ast->sem;

    if (!is_ast_create_table_stmt(table_ast)) {
      report_error(table_name_ast, "CQL0155: cannot update a view", name);
      goto cleanup;
    }

    // This means we're in upsert statement subtree therefore the table name
    // should not be included in the update statement
    if (in_upsert) {
      report_error(table_name_ast, "CQL0281: upsert statement does not include table name in the update statement", name);
      goto cleanup;
    }
  }
  else {
    // This means we're in an upsert statement therefore the table name should not
    // be provided in the update statement of upsert otherwise it's a symantical error
    if (!in_upsert) {
      report_error(ast, "CQL0282: update statement requires a table name", NULL);
      goto cleanup;
    }
    table_ast = current_upsert_table_ast;
    Invariant(table_ast);
  }

  ast->sem = table_ast->sem;

  EXTRACT_NOTNULL(create_table_name_flags, table_ast->left);
  table_name_ast = create_table_name_flags->right;
  EXTRACT_STRING(table_name, table_name_ast);

  sem_join join = *table_ast->sem->jptr;

  PUSH_JOIN(update_scope, &join);
  join_pushed = 1;

  sem_join *from_jptr = NULL;

  if (query_parts) {
    sem_query_parts(query_parts);
    if (is_error(query_parts)) {
      goto cleanup;
    }

    from_jptr = query_parts->sem->jptr;
  }

  if (is_ast_columns_values(update_list)) {
    // UPDATE table_name SET ([column_spec]) := [from_shape]
    EXTRACT_NOTNULL(columns_values, update_list);
    EXTRACT_NOTNULL(column_spec, columns_values->left);

    rewrite_column_values_for_update_stmts(ast, columns_values, table_ast->sem->sptr);

    if (is_error(ast)) {
      goto cleanup;
    }

    update_list = rewrite_column_values_as_update_list(columns_values);

    ast_set_left(update_set, update_list);
  }

  // we can't push the from jptr yet because
  // in 'SET x = name' the 'x' is only in the scope of original table
  // and not in the joins.  So set name = 'x'  is never ambiguous even
  // if the from clause has joins with tables with a name column.  But
  // set name = name || 'x' *can* be ambiguous
  sem_update_list(update_list, from_jptr, table_name_ast);
  if (is_error(update_list)) {
    goto cleanup;
  }

  // the from_scope is lexical, so we push it so that the variable stays in scope
  PUSH_JOIN(from_scope, from_jptr);

  if (from_jptr) {
    join_pushed = 2;
  }
  else {
    // if it's not valid we pop it right off... join_pushed stays at 1
    POP_JOIN();
  }

  if (opt_where) {
    // WHERE
    sem_opt_where(opt_where);
    if (is_error(opt_where)) {
      goto cleanup;
    }
  }

  if (opt_orderby) {
    // ORDER BY
    sem_opt_orderby(opt_orderby);
    if (is_error(opt_orderby)) {
      goto cleanup;
    }
  }

  if (opt_limit) {
    // LIMIT
    sem_opt_limit(opt_limit);
    if (is_error(opt_limit)) {
      goto cleanup;
    }
  }

  // no support for backed tables in the update statement with a from clause yet
  // this will require different codegen than the normal "no from" case
  if (query_parts && table_ast && is_backed(table_ast->sem->sem_type)) {
    report_error(ast, "CQL0497: FROM clause not supported when updating backed table", table_name);
    goto cleanup;
  }

  error = false;

cleanup:

  if (error) {
    record_error(ast);
  }

  if (join_pushed == 2) {
    POP_JOIN();
  }

  if (join_pushed) {
    POP_JOIN();
  }

  if (BACKING_REWRITE_NEEDED(ast, table_ast)) {
    rewrite_update_statement_for_backed_table(sem_recover_with_stmt(ast), backed_tables_list);
  }

  END_BACKING_REWRITE();
}

// Top level WITH-UPDATE form -- create the CTE context and then process
// the update statement.
static void sem_with_update_stmt(ast_node *stmt) {
  Contract(is_ast_with_update_stmt(stmt));
  EXTRACT_ANY_NOTNULL(with_prefix, stmt->left)
  EXTRACT(cte_tables, with_prefix->left);
  EXTRACT_NOTNULL(update_stmt, stmt->right);

  Invariant(cte_cur == NULL);

  sem_push_cte_state();

  sem_cte_tables(cte_tables);
  if (is_error(cte_tables)) {
    record_error(stmt);
    goto cleanup;
  }

  sem_update_stmt(update_stmt);

  if (is_error(update_stmt)) {
    record_error(stmt);
    goto cleanup;
  }

  stmt->sem = update_stmt->sem;

cleanup:
  sem_pop_cte_state();
}

static void sem_update_returning(ast_node *ast) {
  Contract(is_ast_update_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(update_stmt, ast->left);
  EXTRACT_NOTNULL(select_expr_list, ast->right);

  ast_node *update_stmt_plain = update_stmt;

  if (is_ast_with_update_stmt(update_stmt)) {
    update_stmt_plain = update_stmt->right;
  }

  Invariant(is_ast_update_stmt(update_stmt_plain));
  EXTRACT_STRING(table_name, update_stmt_plain->left);

  if (is_ast_with_update_stmt(update_stmt)) {
    sem_with_update_stmt(update_stmt);
  }
  else {
    sem_update_stmt(update_stmt);
  }

  if (is_error(update_stmt)) {
    record_error(ast);
    return;
  }

  sem_returning_clause(select_expr_list, table_name);
  if (is_error(select_expr_list)) {
     record_error(ast);
     return;
  }

  ast->sem = select_expr_list->sem;
}

static void sem_update_returning_stmt(ast_node *ast) {
  sem_update_returning(ast);
  sem_update_proc_type_for_select(ast);
}

// The column list specifies the columns we will provide, they must exist and be unique.
// The insert list specifies the values that are to be updated.
// The type of each value must match the type of the column.
// If there are too many or too few columns, that is also an error.
static void sem_update_cursor_stmt(ast_node *ast) {
  Contract(is_ast_update_cursor_stmt(ast));
  EXTRACT_ANY(cursor, ast->left);
  EXTRACT_STRING(name, cursor);
  EXTRACT_ANY_NOTNULL(columns_values, ast->right);

  sem_cursor(cursor);
  if (is_error(cursor)) {
    record_error(ast);
    return;
  }

  // expr_names node is a sugar syntax we need to rewrite [USING ...] part to [FROM VALUES(...)]
  if (is_ast_expr_names(columns_values)) {
    rewrite_expr_names_to_columns_values(columns_values);
    Contract(is_ast_columns_values(columns_values));
  }

  rewrite_empty_column_list(columns_values, cursor->sem->sptr);

  rewrite_like_column_spec_if_needed(columns_values);
  if (is_error(columns_values)) {
    record_error(ast);
    return;
  }

  rewrite_from_shape_if_needed(ast, columns_values);
  if (is_error(ast)) {
    return;
  }

  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT_ANY_NOTNULL(name_list, column_spec->left);
  EXTRACT_ANY_NOTNULL(insert_list, columns_values->right);

  // if there are any FROM C(like shape) thing in the values list, expand them
  if (!rewrite_shape_forms_in_list_if_needed(insert_list)) {
    record_error(ast);
    return;
  }

  sem_t sem_type = cursor->sem->sem_type;

  // We can't do this if the cursor was not used with the auto syntax
  if (!is_auto_cursor(sem_type)) {
    report_error(cursor, "CQL0067: cursor was not used with 'fetch [cursor]'", name);
    record_error(cursor);
    record_error(ast);
    return;
  }

  // count values
  uint32_t cols = 0;

  for (ast_node *item = insert_list; item; item = item->right) {
    cols++;
  }

  sem_join *jptr = sem_join_from_sem_struct(cursor->sem->sptr);

  // check the column names for uniqueness, build a symbol table of them
  name_check check;
  init_name_check(&check, name_list, jptr);
  bool_t valid = sem_name_check(&check);

  // Ensure that the number of values matches the number of columns.
  if (valid && check.count != cols) {
    report_error(ast, "CQL0157: count of columns differs from count of values", NULL);
    valid = 0;
  }

  if (valid) {
    valid = sem_validate_compatible_cols_vals(name_list, insert_list);
  }

  destroy_name_check(&check);

  if (valid) {
    record_ok(ast);
  }
  else {
    record_error(ast);
  }
}

static int32_t sem_insert_dummy_spec(ast_node *ast) {
  EXTRACT_ANY_NOTNULL(seed_expr, ast->left);
  EXTRACT_OPTION(flags, ast->right);

  sem_root_expr(seed_expr, SEM_EXPR_CONTEXT_NONE);
  if (is_error(seed_expr)) {
    record_error(ast);
    return false;
  }

  ast->sem = seed_expr->sem;
  sem_t sem_type = seed_expr->sem->sem_type;

  if (is_nullable(sem_type) || core_type_of(sem_type) != SEM_TYPE_INTEGER) {
    report_error(seed_expr, "CQL0156: seed expression must be a non-nullable integer", NULL);
    record_error(ast);
    return false;
  }

  return flags;
}

// If we're here then we need to verify that the insert we're dealing with is
// the values form with exactly one value row.  If it is then we hoist out that
// row.  We do this so that we can still do dummy defaults on the simple
// insert form even though it looks like a select statement.  It can be just
// a value list.
static bool_t sem_validate_one_values_row(ast_node *stmt, ast_node **insert_list) {
  Contract(insert_list);
  *insert_list = NULL;

  // not a simple select (could be WITH...SELECT, or EXPLAIN or some such)
  if (!is_ast_select_stmt(stmt)) {
    goto error;
  }

  EXTRACT_NAMED_NOTNULL(any_select_stmt, select_stmt, stmt);
  EXTRACT_NOTNULL(select_core_list, any_select_stmt->left);
  EXTRACT_NOTNULL(select_core, select_core_list->left);
  EXTRACT(select_core_compound, select_core_list->right);
  EXTRACT_ANY(select_values, select_core->left);

  // not VALUES at all, can't rewrite this.
  if (!is_ast_select_values(select_values)) {
    goto error;
  }

  // INSERT [conflict resolution] INTO name [( name_list )] VALUES [(...) ...] [insert_dummy_spec]
  // dummy_insert_spec feature support VALUES with a single row of values
  // this is because there is only one seed expression and you likely want
  // each row to have some unique seed value. This this is only intended for
  // test code creating dummy data this restriction simplifies things for
  // everyone.  Make your dummy rows in a loop rather than with a value set.
  // One row at a time is all we need.
  if (select_core_compound != NULL) {
    goto error;
  }

  EXTRACT_NOTNULL(values, select_core->right);

  // INSERT [conflict resolution] INTO name [( name_list )] [VALUES (...), (...), ...]
  // We have multiple values in select_values ast to be handled. This is not allowed
  if (values->right != NULL) {
    goto error;
  }

  // At this point we know we have validated: INSERT [conflict resolution] INTO name [( name_list )] VALUES(...) [insert_dummy_spec]
  // We need to rewrite the columns_values->right node by replacing select_stmt node value with insert_list node.
  EXTRACT_NAMED(values_insert_list, insert_list, values->left);
  *insert_list = values_insert_list;
  return true;

error:
  report_error(stmt, "CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row", NULL);
  record_error(stmt);
  return false;
}

// The column list specifies the columns we will provide, they must exist and be unique.
// The columns specified must suffice to insert a row (all not nulls and not default present)
// The insert list specifies the values that are to be inserted.
// The type of each value must match the type of the column.
// Autoinc columns may be specified as NULL.
// If there are too many or too few columns, that is also an error.
// By the time we get here, column_spec is populated with a synthetic (possibly empty)
// list and we have normalized on the insert columns form.
static void sem_column_spec_and_values(ast_node *ast, ast_node *table_ast) {
  Contract(is_ast_insert_stmt(ast));
  EXTRACT_ANY_NOTNULL(insert_type, ast->left);
  EXTRACT_NOTNULL(name_columns_values, ast->right);
  EXTRACT_NOTNULL(columns_values, name_columns_values->right);
  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT(name_list, column_spec->left);
  EXTRACT_ANY(insert_dummy_spec, insert_type->left);

  // seed replacement has already happened, don't do it again when we re-analyze after a rewrite
  if (is_ast_seed_stub(insert_dummy_spec)) {
    insert_dummy_spec = NULL;
  }

  ast_node *select_stmt = NULL;
  ast_node *insert_list = NULL;

  EXTRACT_ANY_NOTNULL(value_source, columns_values->right);

  // We need an insert list for dummy specs... if we don't have one then
  // we check to see if we need to do the easy rewrite.
  if (is_ast_insert_list(value_source)) {
    // We might already columns/values due to rewriting say "FROM ARGUMENTS"
    // this is always good to go.
    insert_list = value_source;
  }
  else if (insert_dummy_spec) {
    // We need the values form if there is a dummy spec... so let's see if we can convert it.
    if (!sem_validate_one_values_row(value_source, &insert_list)) {
      // it doesn't have a simple insert list, it's an error then.
      record_error(ast);
      record_error(columns_values);
      return;
    }
    // we're back on track with the simple form known to be good
    // note, it still might be an empty insert_list, that's allowed.
    ast_set_right(columns_values, insert_list);
  }
  else {
    // Since the insert statement does not have insert_dummy_spec, then we
    // don't need to do any rewrite.  Any select form is allowed then.
    Contract(is_select_variant(value_source));
    select_stmt = value_source;
  }

  Contract(table_ast->sem);
  Contract(table_ast->sem->sptr);
  Contract(table_ast->sem->jptr);

  int32_t dummy_flags = 0;

  if (insert_dummy_spec) {
    dummy_flags = sem_insert_dummy_spec(insert_dummy_spec);
    if (is_error(insert_dummy_spec)) {
      record_error(ast);
      return;
    }
  }

  if (select_stmt) {
    // this handles more than select but that's ok
    sem_any_select(select_stmt);
    if (is_error(select_stmt)) {
      record_error(ast);
      return;
    }

    if (enforcement.strict_insert_select && sem_select_stmt_is_mixed_results(select_stmt)) {
      report_error(select_stmt,
        "CQL0370: due to a memory leak bug in old SQLite versions, "
        "the select part of an insert must not have a top level join or compound operator. "
        "Use WITH and a CTE, or a nested select to work around this.", NULL);
      record_error(select_stmt);
      record_error(ast);
      return;
    }
  }

  bool_t valid = 1;

  // count values, find end of the value list
  ast_node *insert_list_tail = NULL;
  uint32_t cols = 0;

  if (select_stmt) {
    cols = select_stmt->sem->sptr->count;
  }
  else {
    for (ast_node *item = insert_list; item; item = item->right) {
      insert_list_tail = item;
      cols++;
    }
  }

  // check the column names for uniqueness, build a symbol table of them
  name_check check;
  init_name_check(&check, name_list, table_ast->sem->jptr);
  valid = sem_name_check(&check);

  symtab *column_names = check.names;
  ast_node *name_list_tail = check.name_list_tail;

  // Ensure that the number of values matches the number of columns.
  if (valid && check.count != cols) {
    report_error(ast, "CQL0157: count of columns differs from count of values", NULL);
    valid = 0;
  }

  if (valid) {
    // ensure that all the necessary columns are present in some order

    sem_struct *sptr = table_ast->sem->sptr;
    for (uint32_t icol = 0; icol < sptr->count; icol++) {
      sem_t sem_type_col = sptr->semtypes[icol];
      CSTR name = sptr->names[icol];

      if (symtab_find(column_names, name)) {
        continue;
      }

      if (has_default(sem_type_col) && !(dummy_flags & INSERT_DUMMY_DEFAULTS)) {
        continue;
      }

      if (is_nullable(sem_type_col) && !(dummy_flags & INSERT_DUMMY_NULLABLES)) {
        continue;
      }

      if (sem_type_col & SEM_TYPE_HIDDEN_COL) {
        continue;
      }

      if (!insert_dummy_spec) {
        report_error(ast, "CQL0158: required column missing in INSERT statement", sptr->names[icol]);
        valid = 0;
        break;
      }

      // if we get this far then we're going to re-write the AST for the missing columns

      // the select statement alternative has no dummy values
      Invariant(!select_stmt);

      // insert the dummy value into the two lists, there's a lot of state here.

      Invariant(column_spec);  // still set up

      dummy_info info;
      info.name = name;
      info.sem_type_col = sem_type_col;
      info.jptr = table_ast->sem->jptr;
      info.name_list_tail = name_list_tail;
      info.name_list_head = column_spec->left;
      info.insert_list_tail = insert_list_tail;
      info.insert_list_head = columns_values->right;
      info.use_null = false;
      info.sql_context = true;

      AST_REWRITE_INFO_SET(column_spec->lineno, column_spec->filename);

      sem_synthesize_dummy_value(&info);

      AST_REWRITE_INFO_RESET();

      name_list = info.name_list_head;
      name_list_tail = info.name_list_tail;
      insert_list = info.insert_list_head;
      insert_list_tail = info.insert_list_tail;

      ast_set_left(column_spec, name_list);
      ast_set_right(columns_values, insert_list);
    }
  }

  // clobber the dummy seed once it has been used, if we do semantic analysis again
  // we don't want to reconsider it, and later rewrites should not see it
  if (insert_dummy_spec) {
    AST_REWRITE_INFO_SET(insert_dummy_spec->lineno, insert_dummy_spec->filename);
    ast_set_left(insert_type, new_ast_seed_stub(insert_dummy_spec->left, insert_dummy_spec->right));
    AST_REWRITE_INFO_RESET();
  }

  if (valid) {
    if (select_stmt) {
      valid = sem_validate_compatible_table_cols_select(table_ast, name_list, select_stmt);
    }
    else {
      valid = sem_validate_compatible_table_cols_vals(table_ast, name_list, insert_list);
    }
  }

  destroy_name_check(&check);

  if (valid) {
    record_ok(ast);
  }
  else {
    record_error(ast);
  }
}

// This is the top level insert statement
// We check that the table exists and then we walk the columns and the value list
// using the  helper above to make sure they are valid for the table.
// Also we cannot insert into a view.
static void sem_insert_stmt(ast_node *ast) {
  Contract(is_ast_insert_stmt(ast));
  EXTRACT_ANY_NOTNULL(insert_type, ast->left);
  EXTRACT_NOTNULL(name_columns_values, ast->right);
  EXTRACT_NAME_AST(name_ast, name_columns_values->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY_NOTNULL(columns_values, name_columns_values->right);
  EXTRACT_ANY(insert_dummy_spec, insert_type->left);

  // seed replacement has already happened, don't do it again when we re-analyze after a rewrite
  if (is_ast_seed_stub(insert_dummy_spec)) {
    insert_dummy_spec = NULL;
  }

  BEGIN_BACKING_REWRITE();

  // INSERT [conflict resolution] INTO name [( name_list )] VALUES (insert_list)
  // INSERT [conflict resolution] INTO name [( name_list )] SELECT ...
  // INSERT [conflict resolution] INTO name [( name_list )] FROM ARGUMENTS

  ast_node *table_ast = find_usable_and_not_deleted_table_or_view(
    name,
    name_ast,
    "CQL0160: table in insert statement does not exist");
  if (!table_ast) {
    record_error(ast);
    goto cleanup;
  }

  name_ast->sem = table_ast->sem;

  if (!is_ast_create_table_stmt(table_ast)) {
    report_error(name_ast, "CQL0161: cannot insert into a view", name);
    record_error(ast);
    goto cleanup;
  }

  // expr_names node is a sugar syntax we need to rewrite it to a SQL syntax
  if (is_ast_expr_names(columns_values)) {
    rewrite_expr_names_to_columns_values(columns_values);
    Contract(is_ast_columns_values(columns_values));
  }

  // here we look for the sugar form INSERT foo USING select ... and rewrite it
  // we just need to make sure the select is semantically ok and has names we can use
  // the rewrite itself will just create a name list, easy sugar.
  if (is_select_variant(columns_values)) {
    sem_select_stmt(columns_values);
    if (is_error(columns_values)) {
      record_error(ast);
      goto cleanup;
    }

    sem_verify_no_anon_columns(columns_values);
    if (is_error(columns_values)) {
      record_error(ast);
      goto cleanup;
    }

    rewrite_select_stmt_to_columns_values(columns_values);
    Contract(is_ast_columns_values(columns_values));
  }

  // This means we're in upsert tree. We want to record table_ast to be used
  // later for semantic analysis in other part of the upsert tree. But also do
  // semantic analysis on this insert_stmt node.
  if (in_upsert) {
    if (!is_ast_insert_normal(insert_type)) {
      report_error(insert_type, "CQL0283: upsert syntax only supports INSERT INTO", name);
      record_error(ast);
      goto cleanup;
    }
    else if (is_ast_default_columns_values(columns_values)) {
      // INSERT [conflict resolution] INTO name DEFAULT VALUES
      // insert statement with default values can not be used in an upsert statement
      report_error(insert_type, "CQL0316: upsert-clause is not compatible with DEFAULT VALUES", name);
      record_error(ast);
      goto cleanup;
    }
  }

  if (is_ast_columns_values(columns_values)) {
    rewrite_empty_column_list(columns_values, table_ast->sem->sptr);

    rewrite_like_column_spec_if_needed(columns_values);
    if (is_error(columns_values)) {
      record_error(ast);
      goto cleanup;
    }

    rewrite_from_shape_if_needed(ast, columns_values);
    if (is_error(ast)) {
      goto cleanup;
    }

    sem_column_spec_and_values(ast, table_ast);
  }
  else {
    // INSERT [conflict resolution] INTO name DEFAULT VALUES
    Contract(is_ast_default_columns_values(columns_values));

    // We need to do semantic analysis to validate all columns type in the table
    // are compatible. A columns is compatible if:
    // - has default value, including autoincrement column
    // - or is nullable. The default value for a nullable column is NULL.
    sem_struct *sptr = table_ast->sem->sptr;
    for (uint32_t i = 0; i < sptr->count; i++) {
      sem_t type = sptr->semtypes[i];
      if (!is_nullable(type) && !has_default(type) && !has_autoincrement(type)) {
        report_error(
          name_ast,
          "CQL0315: mandatory column with no default value in INSERT INTO name DEFAULT VALUES statement",
          sptr->names[i]);
        record_error(ast);
        goto cleanup;
      }
    }
    record_ok(ast);
  }

  // rewrite top level insert statements if needed
  if (BACKING_REWRITE_NEEDED(ast, table_ast)) {
    rewrite_insert_statement_for_backed_table(sem_recover_with_stmt(ast), backed_tables_list);
  }

cleanup:

  END_BACKING_REWRITE();
}

// Recursively goes through all the node to find the root select_stmt with SELECT token and
// checks whether or not it has WHERE clause.  We're doing this to force the upsert statement
// we are scanning to have a WHERE clause in the SELECT statement. The upsert statement is
// otherwise ambgiuously parseable.  So we force the issue in CQL ensuring SQLite will only
// ever see the unambiguous form.  You might have to add WHERE TRUE like the SQLite docs say.
static bool_t root_select_stmt_has_opt_where_node (ast_node *ast, int32_t *select_count) {
  if (!ast || is_primitive(ast)) {
    return false;
  }

  // we're only checking the root select stmt. The nested select stmt are skipped
  if (is_select_variant(ast)) {
    EXTRACT_NOTNULL(select_core_list, ast->left);
    EXTRACT_NOTNULL(select_core, select_core_list->left);
    if (is_ast_select_values(select_core->left)) {
      // The select_stmt with SELECT clause is the one we're tracking as part of the upsert pattern
      // in this function. However, the [VALUES (...), (...)] is also a select_stmt. In the upsert
      // form we require that the select statement has a WHERE clause. The [VALUES(...), (...)] form
      // can't have a WHERE clause, so we skip this subtree.
      return false;
    }
    if (*select_count == 0) {
      return false;
    }
    else {
      (*select_count) -= 1;
    }
  }

  if (is_ast_opt_where(ast)) {
    return true;
  }

  return root_select_stmt_has_opt_where_node(ast->left, select_count) ||
         root_select_stmt_has_opt_where_node(ast->right, select_count);
}

// Top level WITH-UPSERT form -- create the CTE context and then process
// the upsert statement.
static void sem_with_upsert_stmt(ast_node *stmt) {
  Contract(is_ast_with_upsert_stmt(stmt));
  EXTRACT_ANY_NOTNULL(with_prefix, stmt->left)
  EXTRACT(cte_tables, with_prefix->left);
  EXTRACT_NOTNULL(upsert_stmt, stmt->right);

  Invariant(cte_cur == NULL);

  sem_push_cte_state();

  sem_cte_tables(cte_tables);
  if (is_error(cte_tables)) {
    record_error(stmt);
    goto cleanup;
  }

  sem_upsert_stmt(upsert_stmt);

  if (is_error(upsert_stmt)) {
    record_error(stmt);
    goto cleanup;
  }

  stmt->sem = upsert_stmt->sem;

cleanup:
  sem_pop_cte_state();
}

// The semantic analysis of upsert_stmt consist in runing insert_stmt, update_stmt
// analysis and validate node (conflict_target) which belong only to upsert tree
static void sem_upsert_stmt(ast_node *stmt) {
  Contract(is_ast_upsert_stmt(stmt) && !in_upsert && !current_upsert_table_ast);
  if (enforcement.strict_upsert_stmt) {
    report_error(stmt, "CQL0289: upsert statement are forbidden if strict upsert statement mode is enabled", NULL);
    record_error(stmt);
    return;
  }

  BEGIN_BACKING_REWRITE();

  EXTRACT_NOTNULL(insert_stmt, stmt->left);
  EXTRACT_NOTNULL(upsert_update, stmt->right);
  EXTRACT(conflict_target, upsert_update->left);
  EXTRACT(update_stmt, upsert_update->right);
  EXTRACT(indexed_columns, conflict_target->left);
  EXTRACT(opt_where, conflict_target->right);
  in_upsert = true;

  // insert_stmt ON CONFLICT ([indexed_columns]) [WHERE ...] DO [UPDATE ...]
  EXTRACT_NOTNULL(name_columns_values, insert_stmt->right);
  EXTRACT_NAME_AST(name_ast, name_columns_values->left)
  EXTRACT_STRING(name, name_ast);

  ast_node *table_ast = find_usable_and_not_deleted_table_or_view(
    name,
    name_ast,
    "CQL0160: table in insert statement does not exist");
  if (!table_ast) {
    goto error;
  }

  current_upsert_table_ast = table_ast;

  sem_insert_stmt(insert_stmt);
  if (is_error(insert_stmt)) {
    goto error;
  }

  // deep copy from the table for the excluded columns, strip nothing extra
  sem_struct *sptr = new_sem_struct_strip_table_flags(table_ast->sem->sptr); 
  
  // we get the backed status from the tables jptr directly
  sptr->is_backed = table_ast->sem->jptr->tables[0]->is_backed;

  // We'll store the resultant type in the AST as well on the conflict target
  // which gives us the ability to see it in the test output.
  conflict_target->sem = new_sem(SEM_TYPE_STRUCT);
  conflict_target->sem->sptr = sptr;

  // and here is our join target. Now we've made the excluded table an alias for
  // the backed table (subsetted) as thought it had an AS clause on it, this
  // gives us both names and we will need both later to make the correct
  // cql_blob_get call.
  sem_join *jptr_excluded = sem_join_from_sem_struct(sptr);
  jptr_excluded->names[0] = "excluded";

  int32_t select_count = 1;
  bool_t found_where_stmt = root_select_stmt_has_opt_where_node(insert_stmt, &select_count);
  if (select_count == 0 && !found_where_stmt && !in_upsert_rewrite) {
    report_error(insert_stmt, "CQL0280: upsert statement requires a where clause if the insert clause uses select", NULL);
    record_error(insert_stmt);
    goto error;
  }

  if (indexed_columns) {
    if (!sem_validate_name_list(indexed_columns, current_upsert_table_ast->sem->jptr)) {
      record_error(upsert_update);
      record_error(conflict_target);
      goto error;
    }

    bool_t is_single_unique_key = 0;
    // if we only have one column listed in the indexed_columns node then we
    // check if that column is a single primary or unique key in the table
    if (!indexed_columns->right) {
      EXTRACT_NOTNULL(indexed_column, indexed_columns->left);
      EXTRACT_STRING(column_name, indexed_column->left);
      is_single_unique_key = is_column_unique_key(current_upsert_table_ast, column_name);
    }

    // we are going to check if all the columns in indexed_columns node are
    // - a unique key (UNIQUE (...) OR UNIQUE CONSTRAINT (...))
    // - unique index (CREATE UNIQUE INDEX ...)
    // - a group of primary key (PRIMARY KEY (a,b,...)).
    if (!is_single_unique_key) {
      bool_t valid = find_referenceable_columns(
        current_upsert_table_ast,
        validate_referenceable_fk_def_callback,
        indexed_columns);
      if (!valid) {
        report_error(indexed_columns,
          "CQL0279: columns referenced in an UPSERT conflict target must exactly match a unique key the target table",
          NULL);
        record_error(upsert_update);
        record_error(conflict_target);
        goto error;
      }
    }
  }

  if (opt_where) {
    sem_join join = *current_upsert_table_ast->sem->jptr;

    // The opt_where node is in the upsert context therefore we need to make sure
    // we register a join context for search.  Note that it is not legal to use
    // 'excluded' in the conflict target where clause, so we do not push it.
    PUSH_JOIN(upsert_scope, &join);
    sem_opt_where(opt_where);
    POP_JOIN()
    if (is_error(opt_where)) {
      record_error(upsert_update);
      record_error(conflict_target);
      goto error;
    }

    if (is_backed(current_upsert_table_ast->sem->sem_type)) {
      // we need to change any references to the tables to be the blob extractions
      // from the key and value blobs
      rewrite_backed_column_references_in_ast(opt_where, current_upsert_table_ast);
    }
  }

  if (update_stmt) {
    PUSH_JOIN(update_scope, jptr_excluded);
    sem_update_stmt(update_stmt);
    POP_JOIN();
    if (is_error(update_stmt)) {
      record_error(upsert_update);
      goto error;
    }
  }

  stmt->sem = insert_stmt->sem;
  record_ok(upsert_update);

  if (BACKING_REWRITE_NEEDED(stmt, current_upsert_table_ast)) {
    rewrite_upsert_statement_for_backed_table(sem_recover_with_stmt(stmt), backed_tables_list);
  }

cleanup:
  in_upsert = false;
  current_upsert_table_ast = NULL;

  END_BACKING_REWRITE();

  return;

error:
  record_error(stmt);
  goto cleanup;
}

static void sem_upsert_returning(ast_node *ast) {
  Contract(is_ast_upsert_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(upsert_stmt, ast->left);
  EXTRACT_NOTNULL(select_expr_list, ast->right);

  ast_node *upsert_stmt_plain = upsert_stmt;

  if (is_ast_with_upsert_stmt(upsert_stmt)) {
    upsert_stmt_plain = upsert_stmt->right;
  }

  Invariant(is_ast_upsert_stmt(upsert_stmt_plain));
  EXTRACT_NOTNULL(insert_stmt, upsert_stmt_plain->left);
  EXTRACT_NOTNULL(name_columns_values, insert_stmt->right);
  EXTRACT_STRING(table_name, name_columns_values->left)

  if (is_ast_with_upsert_stmt(upsert_stmt)) {
    sem_with_upsert_stmt(upsert_stmt);
  }
  else {
    sem_upsert_stmt(upsert_stmt);
  }

  if (is_error(upsert_stmt)) {
    record_error(ast);
    return;
  }

  sem_returning_clause(select_expr_list, table_name);
  if (is_error(select_expr_list)) {
     record_error(ast);
     return;
  }

  ast->sem = select_expr_list->sem;
}

static void sem_upsert_returning_stmt(ast_node *ast) {
  sem_upsert_returning(ast);
  sem_update_proc_type_for_select(ast);
}

// Top level WITH-INSERT form -- create the CTE context and then process
// the insert statement.
static void sem_with_insert_stmt(ast_node *stmt) {
  Contract(is_ast_with_insert_stmt(stmt));
  EXTRACT_ANY_NOTNULL(with_prefix, stmt->left)
  EXTRACT(cte_tables, with_prefix->left);
  EXTRACT_NOTNULL(insert_stmt, stmt->right);

  Invariant(cte_cur == NULL);

  sem_push_cte_state();

  sem_cte_tables(cte_tables);
  if (is_error(cte_tables)) {
    record_error(stmt);
    goto cleanup;
  }

  sem_insert_stmt(insert_stmt);

  if (is_error(insert_stmt)) {
    record_error(stmt);
    goto cleanup;
  }

  stmt->sem = insert_stmt->sem;

cleanup:
  sem_pop_cte_state();
}

static void sem_insert_returning(ast_node *ast) {
  Contract(is_ast_insert_returning_stmt(ast));
  EXTRACT_ANY_NOTNULL(insert_stmt, ast->left);
  EXTRACT_NOTNULL(select_expr_list, ast->right);

  ast_node *insert_stmt_plain = insert_stmt;

  if (is_ast_with_insert_stmt(insert_stmt)) {
    insert_stmt_plain = insert_stmt->right;
  }

  Invariant(is_ast_insert_stmt(insert_stmt_plain));
  EXTRACT_NOTNULL(name_columns_values, insert_stmt_plain->right);
  EXTRACT_STRING(table_name, name_columns_values->left)

  if (is_ast_with_insert_stmt(insert_stmt)) {
    sem_with_insert_stmt(insert_stmt);
  }
  else {
    sem_insert_stmt(insert_stmt);
  }

  if (is_error(insert_stmt)) {
    record_error(ast);
    return;
  }

  sem_returning_clause(select_expr_list, table_name);
  if (is_error(select_expr_list)) {
     record_error(ast);
     return;
  }

  ast->sem = select_expr_list->sem;
}

static void sem_insert_returning_stmt(ast_node *ast) {
  sem_insert_returning(ast);
  sem_update_proc_type_for_select(ast);
}

// This code works for any of the cursor to/from blob forms as the checks are the same
// the blob might be the source or the destination, the last two args tell us which way it is
// which mostly doesn't matter.  We ensure that the blob is a blob and the cursor is a cursor
// and the blob kind tells us a struct that has the same columns as the cursor.  We
// only need to know the destination so that when we check if the columns are the same
// we can complaint accurately that the source doesn't match the target rather than
// the reverse.
cql_noexport void sem_validate_cursor_blob_compat(
  ast_node *ast_error,
  ast_node *cursor,
  ast_node *blob,
  ast_node *dest,
  ast_node *src)
{
  Contract(blob);
  Contract(cursor);
  Contract(dest);
  Contract(src);

  Contract(blob != cursor);
  Contract(src != dest);
  Contract(src == blob || src == cursor);
  Contract(dest == blob || dest == cursor);

  // function validation already checked this
  Contract(!is_error(blob));
  Contract(is_blob(blob->sem->sem_type));
  Contract(!is_error(cursor));
  Contract(is_cursor(cursor->sem->sem_type));
  Contract(is_auto_cursor(cursor->sem->sem_type));

  // Note that the blob might have been rewritten due to notnull improvement
  // but that's ok, we only need the name and it's in the sem node for us now.
  // If the expression is such that it doesn't have a name that's ok too.
  CSTR kind = blob->sem->kind;
  CSTR blob_name = blob->sem->name;

  if (!kind) {
    report_error(blob, "CQL0455: blob variable must have a type-kind for type safety", blob_name);
    record_error(ast_error);
    return;
  }

  ast_node *table_ast = find_usable_and_not_deleted_table_or_view(
      kind,
      blob,
      "CQL0453: blob type is not a valid table");
  if (!table_ast) {
    record_error(ast_error);
    return;
  }

  if (!is_ast_create_table_stmt(table_ast)) {
    report_error(blob, "CQL0456: blob type is a view, not a table", kind);
    record_error(ast_error);
    return;
  }

  if (!is_table_blob_storage(table_ast)) {
    report_error(blob, "CQL0457: the indicated table is not marked with [[blob_storage]]", kind);
    record_error(ast_error);
    return;
  }

  blob->sem->sptr = table_ast->sem->sptr;

  sem_verify_identical_columns(dest, src, "in the cursor and the blob type");
  if (is_error(src)) {
    record_error(ast_error);
    return;
  }

  // Now we need to mark the cursor as requiring the serializer helpers
  // so that we know to code-gen them later.  Since we want to do this
  // during the cursor declare we need to put this on the declaration.
  // Therefore, we're mutating the flags in place so as to change the
  // various linked places this type is used in particular we want to mutate
  // the semantic info in the declare cursor node.  This is why we
  // don't make a new semantic node.

  ast_node *var = find_local_or_global_variable(cursor->sem->name);
  Invariant(var); // we know the cursor exists and is unique already
  var->sem->sem_type |= SEM_TYPE_SERIALIZE;

  record_ok(ast_error);
  return;
}

// This is the statement used for loading a value cursor from ... values
// There are a number of forms, but importantly all of these apply to value
// cursors, not statement cursors.  So we're never dealing with a Sqilte statement
// here, just columns.  They could be being loaded from anywhere.
// The general forms:
//   fetch C(cols) from values (values) [insert_dummy_spec]
//   fetch C from shape
// The "from shape" case is sugar; it is immediately rewritten into
// the normal fetch from values form where the values are the proc arguments.
// So this leaves us with the first form.
//   * if the name list is empty that's the same as listing every columnm,
//     so that is rewritten as well (more sugar)
//   * we have to check all the names against all the values for type compatibility
//   * we have to ensure that all the non-null values of the cursor were specified
//   * we use all the columns that are present, if there are any non-null columns missing
//     then we give an error unless dummy data is specified.  If dummy data is specified
//     then we rewrite the value list and the column list to add the needed columns and
//     use a dummy value.
static void sem_fetch_values_stmt(ast_node *ast) {
  Contract(is_ast_fetch_values_stmt(ast));
  Contract(!current_joinscope);  // I don't belong inside a select(!)

  EXTRACT(insert_dummy_spec, ast->left);
  EXTRACT_NOTNULL(name_columns_values, ast->right);
  EXTRACT_ANY_NOTNULL(cursor, name_columns_values->left)
  EXTRACT_ANY_NOTNULL(columns_values, name_columns_values->right);

  // FETCH name [( name_list )] FROM VALUES (insert_list) [insert_dummy_spec]
  // FETCH name FROM ARGUMENTS;  (rewritten into the first form)
  // FETCH name [(name_list )] FROM ARGUMENTS; (rewritten into the first form)
  // FETCH name USING expr_names;

  sem_cursor(cursor);
  if (is_error(cursor)) {
    record_error(ast);
    return;
  }

  if (!(cursor->sem->sem_type & SEM_TYPE_VALUE_CURSOR)) {
    report_error(cursor, "CQL0165: fetch values is only for value cursors, not for sqlite cursors", cursor->sem->name);
    record_error(ast);
    return;
  }

  if (is_ast_expr_names(columns_values)) {
    rewrite_expr_names_to_columns_values(columns_values);
  }
  Invariant(is_ast_columns_values(columns_values));

  rewrite_empty_column_list(columns_values, cursor->sem->sptr);

  rewrite_like_column_spec_if_needed(columns_values);
  if (is_error(columns_values)) {
    record_error(ast);
    return;
  }

  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT(name_list, column_spec->left);

  rewrite_from_shape_if_needed(ast, columns_values);
  if (is_error(ast)) {
    return;
  }

  // this may have be rewritten by the above
  EXTRACT(insert_list, columns_values->right);

  // if there are any FROM C(like shape) thing in the values list, expand them
  if (!rewrite_shape_forms_in_list_if_needed(insert_list)) {
    record_error(ast);
    return;
  }

  int32_t dummy_flags = 0;

  if (insert_dummy_spec) {
    dummy_flags = sem_insert_dummy_spec(insert_dummy_spec);
    if (is_error(insert_dummy_spec)) {
      record_error(ast);
      return;
    }
  }

  bool_t valid = 1;

  // count values, find end of the value list
  ast_node *insert_list_tail = NULL;
  int32_t cols = 0;
  for (ast_node *item = insert_list; item; item = item->right) {
    insert_list_tail = item;
    cols++;
  }

  cursor->sem->jptr = sem_join_from_sem_struct(cursor->sem->sptr);

  // check the column names for uniqueness, build a symbol table of them
  name_check check;
  init_name_check(&check, name_list, cursor->sem->jptr);
  valid = sem_name_check(&check);

  symtab *insert_column_names = check.names;
  ast_node *name_list_tail = check.name_list_tail;

  // Ensure that the number of values matches the number of columns.
  if (valid && check.count != cols) {
    report_error(ast, "CQL0166: count of columns differs from count of values", NULL);
    valid = 0;
  }

  if (valid) {
    // Ensure that all the necessary columns are present in some order.

    sem_struct *sptr = cursor->sem->sptr;
    for (uint32_t icol = 0; icol < sptr->count; icol++) {
      sem_t sem_type_col = sptr->semtypes[icol];
      CSTR name = sptr->names[icol];

      if (symtab_find(insert_column_names, name)) {
        continue;
      }

      bool_t will_use_null = is_nullable(sem_type_col) && !(dummy_flags & INSERT_DUMMY_NULLABLES);

      // Note if the column is nullable we will automatically insert a null even if no dummy data.
      // Previously we would generate an error if any columns were missing with no dummy data but
      // all null, or mostly null rows are super useful.

      if (!will_use_null && !insert_dummy_spec) {
        report_error(ast, "CQL0167: required column missing in FETCH statement", sptr->names[icol]);
        valid = 0;
        break;
      }

      // if we get this far then we're going to re-write the AST for the missing columns

      // insert the dummy value into the two lists, there's a lot of state here.

      dummy_info info;
      info.name = name;
      info.sem_type_col = sem_type_col;
      info.jptr = cursor->sem->jptr;
      info.name_list_tail = name_list_tail;
      info.name_list_head = column_spec->left;
      info.insert_list_tail = insert_list_tail;
      info.insert_list_head = columns_values->right;
      info.use_null = will_use_null;
      info.sql_context = false;

      AST_REWRITE_INFO_SET(columns_values->lineno, columns_values->filename);

      sem_synthesize_dummy_value(&info);

      AST_REWRITE_INFO_RESET();

      name_list = info.name_list_head;
      name_list_tail = info.name_list_tail;
      insert_list = info.insert_list_head;
      insert_list_tail = info.insert_list_tail;

      ast_set_right(columns_values, insert_list);
      ast_set_left(column_spec, name_list);
    }
  }

  if (valid) {
    valid = sem_validate_compatible_cols_vals(name_list, insert_list);
  }

  destroy_name_check(&check);

  if (valid) {
    // TODO: It's possible to do better here by un-improving those being set to
    // a value of a nullable type and actually improving those being set to a
    // notnull type. For now though, we just unimprove all of them.
    sem_struct *sptr = cursor->sem->sptr;
    for (uint32_t i = 0; i < sptr->count; i++) {
      sem_unset_notnull_improved(sptr->names[i], cursor->sem->name);
    }

    // This type of fetch cannot fail so no fetch check should be required.
    sem_set_has_row_improved(cursor->sem->name);

    record_ok(ast);
  }
  else {
    record_error(ast);
  }
}

// Here we just make sure that we can look up every name in this name list
// in the indicated joinscope.  This is helpful if you want to ensure that
// there are names present in a certain level of the tree.
// This helper is intended to (e.g.) look up column names in the context
// of the table they belong to.  Or look up column names in both sides
// of an FK relationship.  This is only used to evaluate at the top level
// if it's happening in the context of a join that's wrong.
static bool_t sem_name_check(name_check *check) {
  bool_t valid = true;
  PUSH_JOIN_BLOCK()
  PUSH_JOIN(name_check, check->jptr);

  // Check for invalid column names and duplicate column names.

  check->name_list_tail = NULL;

  for (ast_node *item = check->name_list; item; item = item->right) {
    Contract(is_ast_name_list(item) || is_ast_indexed_columns(item));
    check->name_list_tail = item;

    CSTR item_name = NULL;
    ast_node *target = NULL;

    if (is_ast_name_list(item)) {
      ast_node *name_ast = target = item->left;

      // Resolve name with no qualifier in the current scope.
      EXTRACT_STRING(name, name_ast);

      if (!sem_find_column_for_name(name_ast, name) || is_error(name_ast)) {
        report_error(name_ast, "CQL0171: name not found", name);
        record_error(name_ast);
        record_error(check->name_list);
        valid = false;
        break;
      }

      item_name = name_ast->sem->name;
    }
    else {
      EXTRACT_NOTNULL(indexed_column, item->left);
      EXTRACT_ANY_NOTNULL(expr, indexed_column->left);

      sem_validate_index_expr_for_jptr(check->jptr, expr);
      if (is_error(expr)) {
        record_error(check->name_list);
        valid = false;
        break;
      }

      item_name = expr_as_text(expr);

      target = expr;
    }

    Invariant(item_name);

    if (!symtab_add(check->names, item_name, NULL)) {
      report_error(target, "CQL0172: name list has duplicate name", item_name);
      record_error(target);
      record_error(check->name_list);
      valid = 0;
      break;
    }

    check->count++;
  }

  POP_JOIN();
  POP_JOIN();
  return valid;
}

// This helper produces a "printf" call suitable for constructing the text "col_%d"
// which is the format of string and blob columns given a dummy seed value for the %d.
// The local variable "seed" is used for the column.  These AST nodes will be used
// in the rewrite of the dummy columns for string and blobs.
static ast_node *printf_col_for_dummy(CSTR col, CSTR seed_name) {
  ast_node *ast_printf = new_ast_str("printf");
  CSTR fmt = dup_printf("'%s_%%d'", col);  // this turns into 'col_%d'
  ast_node *ast_string = new_ast_str(fmt);
  ast_node *ast_seed = new_ast_str(seed_name);

  ast_node *args = new_ast_arg_list(ast_string, new_ast_arg_list(ast_seed, NULL));
  ast_node *call_filter_clause = new_ast_call_filter_clause(NULL, NULL);
  ast_node *call_arg_list = new_ast_call_arg_list(call_filter_clause, args);
  return new_ast_call(ast_printf, call_arg_list);
}

// This helper produces a "cql_blob_from_int" text "col_%d" with null terminator
// which is the format of string and blob columns given a dummy seed value for the %d.
// The local variable "seed" is used for the column.  These AST nodes will be used
// in the rewrite of the dummy columns for blobs when printf cannot be used, i.e.
// in a non SQLite context.
static ast_node *blob_from_int_for_dummy(CSTR col, CSTR seed_name) {
  ast_node *ast_blob_from_int = new_ast_str("cql_blob_from_int");
  ast_node *ast_seed = new_ast_str(seed_name);

  CSTR prefix = dup_printf("'%s_'", col);  // this turns into 'col_'
  ast_node *ast_string = new_ast_str(prefix);

  ast_node *args = new_ast_arg_list(ast_string, new_ast_arg_list(ast_seed, NULL));
  ast_node *call_filter_clause = new_ast_call_filter_clause(NULL, NULL);
  ast_node *call_arg_list = new_ast_call_arg_list(call_filter_clause, args);
  return new_ast_call(ast_blob_from_int, call_arg_list);
}

// If we're doing either a FETCH from values or an INSERT from values
// we might need a dummy value.  To accomplish this we add the missing
// value to the column list and to the values list, changing the AST.
// The later code will then process it as though it was present in the first place.
// The code gen for dummy values will use the hidden variable _seed_ which
// is initialized from the dummy value expression.  That will be part of
// codegen later.  For now we only need insert the columns.  They will be
// validated later.  This validation can't actually fail.
static void sem_synthesize_dummy_value(dummy_info *info) {
  CSTR seed_name = "_seed_";
  symtab *scope = locals ? locals : globals;
  Invariant(scope);

  // implictly declare _seed_ as a local/global variable if needed
  if (!symtab_find(scope, seed_name)) {
    ast_node *asts = new_ast_str(seed_name);
    asts->sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL | SEM_TYPE_VARIABLE);
    asts->sem->name = seed_name;
    symtab_add(scope, seed_name, asts);
  }

  // Look up the name in the current scope, and only that scope.  No locals
  // No nothing.  Just the columns in the indicated type.
  ast_node *ast_col = new_str_or_qstr(info->name, info->sem_type_col);

  PUSH_JOIN_BLOCK()
  PUSH_JOIN(info_scope, info->jptr);
  bool_t found = sem_find_column_for_name(ast_col, info->name);
  Invariant(found);
  Invariant(!is_error(ast_col));  // name is known to be good!
  POP_JOIN();
  POP_JOIN();

  // add name to the name list
  ast_node *new_tail = new_ast_name_list(ast_col, NULL);
  if (info->name_list_tail) {
    ast_set_right(info->name_list_tail, new_tail);
  }
  else {
    info->name_list_head = new_tail;
  }
  info->name_list_tail = new_tail;

  ast_node *expr = NULL;

  // make a dummy insert node for the column based on its type
  if (info->use_null) {
    Contract(is_nullable(info->sem_type_col));
    expr = new_ast_null();
  }
  else if (is_numeric(info->sem_type_col)) {
    // numbers dummy value is seed
    expr = new_ast_str(seed_name);
  }
  else if (is_blob(info->sem_type_col)) {
    if (info->sql_context) {
      ast_node *inner = printf_col_for_dummy(info->name, seed_name);
      expr = new_ast_cast_expr(inner, new_ast_type_blob(NULL));
    }
    else {
      expr = blob_from_int_for_dummy(info->name, seed_name);
    }
  }
  else {
    // strings are column_name_{seed} -- using printf
    expr = printf_col_for_dummy(info->name, seed_name);
  }

  new_tail = new_ast_insert_list(expr, NULL);
  if (info->insert_list_tail) {
    ast_set_right(info->insert_list_tail, new_tail);
  }
  else {
    info->insert_list_head = new_tail;

  }
  info->insert_list_tail = new_tail;
}

// Ensure that the values are valid and the types of the values are compatible
// with the types of the columns.
static bool_t sem_validate_compatible_table_cols_vals(ast_node *table_ast, ast_node *name_list, ast_node *insert_list) {
  Contract(is_ast_create_table_stmt(table_ast));

  ast_node *value = insert_list;
  sem_struct *sptr = table_ast->sem->sptr;

  for (ast_node *item = name_list ; item; item = item->right, value = value->right) {
    EXTRACT_ANY_NOTNULL(expr, value->left);
    EXTRACT_ANY_NOTNULL(col, item->left);
    sem_root_expr(expr, SEM_EXPR_CONTEXT_WHERE); // non-aggregate context
    if (is_error(expr)) {
      return false;
    }

    // we have to find the specific column now so that we can look at table flags
    int32_t icol = 0;
    while (strcmp(sptr->names[icol], col->sem->name)) icol++;

    // autoinc column may be specified as null even though it's not-nullable
    if (is_ast_null(expr) && (sptr->semtypes[icol] & SEM_TYPE_AUTOINCREMENT)) {
      continue;
    }

    // if the column and expression kinds are not compatible we have to bail (e.g. <dollars> used where <euros> expected)
    sem_combine_kinds(expr, col->sem->kind);
    if (is_error(expr)) {
      return false;
    }

    // otherwise the columns have to be assignment compatible
    if (!sem_verify_assignment(expr, col->sem->sem_type, expr->sem->sem_type, col->sem->name)) {
      return false;
    }
  }

  return true;
}

// Ensure that the columns of the select are compatible with the columns of the table in the order specified
static bool_t sem_validate_compatible_table_cols_select(ast_node *table_ast, ast_node *name_list, ast_node *select_stmt) {
  Contract(is_ast_create_table_stmt(table_ast));

  sem_struct *sptr_select = select_stmt->sem->sptr;
  sem_struct *sptr = table_ast->sem->sptr;

  if (is_ast_with_select_stmt(select_stmt)) {
    select_stmt = select_stmt->right;
  }

  // no additional checks are possible if it isn't a standard select statement presumably containing values
  // we just move on and report the best error we can (we still need the types to match)
  if (is_ast_select_stmt(select_stmt)) {
    // The select statement might contain a VALUES clause.
    // We need to walk through all the select_core nodes and do type checking of
    // expressions in VALUES clauses against the name_list. In case of errors found,
    // we tag the error into the expression node in the values clause instead of
    // the name_list. This provides a better error location for the user.
    // e.g: insert into foo select 1 union all values ('x') union all values (3) ...
    // The 'x' is incorrect and the error should refer to that rather than some
    // generic error about the select statement being badly formed.
    EXTRACT_NOTNULL(select_core_list, select_stmt->left);
    for (ast_node *item = select_core_list; item; item = item->right) {
      Contract(is_ast_select_core_list(item));
      EXTRACT_NOTNULL(select_core, item->left);
      EXTRACT_ANY_NOTNULL(select_core_right, select_core->right);

      if (is_ast_values(select_core_right)) {
        EXTRACT_NOTNULL(values, select_core_right);

        for (ast_node *node = values; node; node = node->right) {
          EXTRACT_NOTNULL(insert_list, node->left);

          ast_node *value = insert_list;
          for (ast_node *list = name_list ; list && value; list = list->right, value = value->right) {
            EXTRACT_ANY_NOTNULL(expr, value->left);
            EXTRACT_ANY_NOTNULL(col, list->left);

            // we have to find the specific column now so that we can look at table flags
            int32_t icol = 0;
            while (strcmp(sptr->names[icol], col->sem->name)) icol++;

            // autoinc column may be specified as null even though it's not-nullable
            if (is_null_type(expr->sem->sem_type) && (sptr->semtypes[icol] & SEM_TYPE_AUTOINCREMENT)) {
              continue;
            }

            // NOTE: kind mismatch can be an issue here but only if the values clause has some expressions in it,
            // which is atypical but it can happen.  The normal thing is that values are all constants.
            sem_combine_kinds(expr, col->sem->kind);
            if (is_error(expr)) {
              return false;
            }

            // in case of semantic error the expr is tagged to the expr node in values clause.
            if (!sem_verify_assignment(expr, col->sem->sem_type, expr->sem->sem_type, col->sem->name)) {
              return false;
            }
          }
        }
      }

      // We need to make item->right is always a select_core_list ast.
      if (item->right) {
        Contract(is_ast_select_core_compound(item->right));
        Contract(is_ast_select_core_list(item->right->right));
        item = item->right;
      }
    }
  }

  // Here we just validate that the column types in struct type of the select
  // statement are compatible with the column names types that receive the values
  // in the insert statement.
  uint32_t icol_select = 0;
  for (ast_node *item = name_list ; item; item = item->right, icol_select++) {
    Invariant(icol_select < sptr_select->count);

    EXTRACT_ANY_NOTNULL(col, item->left);

    // we have to find the specific column now so that we can look at table flags
    int32_t icol = 0;
    while (strcmp(sptr->names[icol], col->sem->name)) icol++;

    // autoinc column may be specified as null even though it's not-nullable
    if (is_null_type(sptr_select->semtypes[icol_select]) && (sptr->semtypes[icol] & SEM_TYPE_AUTOINCREMENT)) {
      continue;
    }

    sem_combine_kinds(col, sptr_select->kinds[icol_select]);
    if (is_error(col)) {
      return false;
    }

    // otherwise the columns have to be assignment compatible
    if (!sem_verify_assignment(col, col->sem->sem_type, sptr_select->semtypes[icol_select], col->sem->name)) {
      return false;
    }
  }

  return true;
}

// Check that the indicated columns are compatible with the corresponding expressions
// Note the count has already been verified.
static bool_t sem_validate_compatible_cols_vals(ast_node *name_list, ast_node *values) {
  ast_node *value = values;

  for (ast_node *item = name_list ; item; item = item->right, value = value->right) {
    EXTRACT_ANY_NOTNULL(expr, value->left);
    EXTRACT_ANY_NOTNULL(col, item->left);
    sem_expr(expr);
    if (is_error(expr)) {
      return false;
    }

    sem_combine_kinds(col, expr->sem->kind);
    if (is_error(col)) {
      return false;
    }

    if (!sem_verify_assignment(expr, col->sem->sem_type, expr->sem->sem_type, col->sem->name)) {
      return false;
    }
  }

  // count matches
  Invariant(!value);

  return true;
}

// All legal cases of these operators are re-written
// any that are left are not in a valid position so they get an error
static void sem_expr_invalid_op(ast_node *ast, CSTR op) {
  report_error(ast, "CQL0492: operator found in an invalid position", op);
  record_error(ast);
}

// The set statement is for local assignment.  We just validate
// that the target exists and is compatible with the source.
// There are special cases for cursor variables, which cannot be set.
static void sem_assign(ast_node *ast) {
  Contract(is_ast_assign(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  ast_node *variable = find_local_or_global_variable(name);

  if (!variable) {
    report_error(ast, "CQL0173: variable not found", name);
    record_error(ast);
    return;
  }

  ast->sem = name_ast->sem = variable->sem;

  sem_t sem_type_var = variable->sem->sem_type;
  Invariant(is_variable(sem_type_var));

  if (is_struct(sem_type_var)) {
    report_error(ast, "CQL0174: cannot set a cursor", name);
    record_error(ast);
    return;
  }

  Invariant(!current_joinscope);
  sem_root_expr(expr, SEM_EXPR_CONTEXT_NONE);

  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  if (!sem_verify_assignment(expr, sem_type_var, expr->sem->sem_type, name)) {
    record_error(name_ast);
    record_error(ast);
  }

  sem_combine_kinds(expr, variable->sem->kind);
  if (is_error(expr)) {
    record_error(ast);
  }

  // We can infer that the left side of `:=` is not null if the right side is
  // not null. Otherwise, we remove any existing improvement as it is no longer
  // valid.
  if (is_not_nullable(expr->sem->sem_type)) {
    sem_set_notnull_improved(name, NULL);
  }
  else {
    sem_unset_notnull_improved(name, NULL);
  }

  variable->sem->sem_type |= SEM_TYPE_WAS_SET;

  sem_set_initialization_improved(name, NULL);
}

static void sem_let_stmt(ast_node *ast) {
  Contract(is_ast_let_stmt(ast) || is_ast_const_stmt(ast));

  EXTRACT_ANY_NOTNULL(variable, ast->left)
  EXTRACT_STRING(name, variable);
  EXTRACT_ANY_NOTNULL(expr, ast->right);

  // LET [name] := [expr] or CONST [name] := [expr]
  if (!sem_verify_legal_variable_name(variable, name)) {
    record_error(ast);
    return;
  }

  Invariant(!current_joinscope);
  sem_root_expr(expr, SEM_EXPR_CONTEXT_NONE);

  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  // the variable is now the exact type of the expression

  sem_t sem_type_var = expr->sem->sem_type;
  sem_type_var &= (SEM_TYPE_NOTNULL | SEM_TYPE_SENSITIVE | SEM_TYPE_CORE);
  sem_type_var |= SEM_TYPE_VARIABLE;

  variable->sem = ast->sem = new_sem(sem_type_var);
  variable->sem->name = name;
  variable->sem->kind = expr->sem->kind;
  add_variable(name, variable);
}

// CONST variable declaration are equivalent to LET declarations, but
// the variable ast has the extra CONST sem_type flag, which marks it immutable
static void sem_const_stmt(ast_node *ast) {
  Contract(is_ast_const_stmt(ast));
  sem_let_stmt(ast);

  EXTRACT_ANY_NOTNULL(variable, ast->left)
  variable->sem->sem_type |= SEM_TYPE_CONSTANT;
}

// In/out processing for a procedure just decodes the AST into the sem_type
// it returns the bits that should be set.
static sem_t sem_opt_inout(ast_node *ast) {
  if (is_ast_in(ast)) {
    // IN
    return SEM_TYPE_IN_PARAMETER;
  }
  else if (is_ast_out(ast)) {
    // OUT
    return SEM_TYPE_OUT_PARAMETER;
  }
  else if (is_ast_inout(ast)) {
    // INOUT
    return SEM_TYPE_IN_PARAMETER | SEM_TYPE_OUT_PARAMETER;
  }
  else {
    Contract(!ast);
    return SEM_TYPE_IN_PARAMETER;
  }
}

// Returns true if the `sem_t` of a variable indicates that initialization
// should be required before the value is used (except when passed as an OUT
// argument), else false.
static bool_t variable_should_require_initialization(sem_t sem_type) {
  Contract(is_variable(sem_type));

  // For now, we only require initialization in the case of nonnull reference
  // types as they presently have no sensible default and will be NULL absent
  // initialization.
  return is_not_nullable(sem_type) && is_ref_type(sem_type);
}

// Returns true if the given `sem_t` of a parameter indicates that
// initialization should be required before the procedure returns, else false.
static bool_t param_should_require_initialization(sem_t sem_type) {
  if (is_in_parameter(sem_type)) {
    // Arguments passed for IN and INOUT parameters must have already been
    // initialized by the caller.
    return false;
  }

  return variable_should_require_initialization(sem_type);
}

// A single a proc parameter, it gets its semantic type by the helper
// for the type of a variable.  The main thing that needs to be done here
// is to ensure the name doesn't conflict, and record it as a new local.
static void sem_param(ast_node *ast) {
  Contract(is_ast_param(ast));
  EXTRACT_ANY(opt_inout, ast->left);
  EXTRACT_NOTNULL(param_detail, ast->right);
  EXTRACT_NAME_AST(name_ast, param_detail->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT_ANY_NOTNULL(data_type, param_detail->right);

  if (symtab_find(locals, name)) {
    report_error(name_ast, "CQL0175: duplicate parameter name", name);
    record_error(ast);
    return;
  }

  sem_data_type_var(data_type);
  if (is_error(data_type)) {
    record_error(ast);
    return;
  }

  sem_t sem_type = data_type->sem->sem_type;
  sem_type |= SEM_TYPE_VARIABLE;
  sem_type |= sem_opt_inout(opt_inout);

  // We set this even if `current_proc` is NULL (i.e., we set it for the DECLARE
  // PROC and DECLARE FUNCTION forms, not just CREATE PROC). The reason for
  // doing this is so that any later parameter declarations that refer to the
  // current procedure using LIKE...ARGUMENTS will have this flag set
  // appropriately.
  if (param_should_require_initialization(sem_type)) {
    sem_type |= SEM_TYPE_INIT_REQUIRED;
  }

  ast->sem = param_detail->sem = name_ast->sem = new_sem(sem_type);

  // [name]
  ast->sem->name = name;
  ast->sem->kind = data_type->sem->kind;

  Invariant(current_variables == locals);
  add_variable(name, ast);
}

// This handles the case where you are using the LIKE proc ARGUMENTS form
// There are quite a few rules here that need to be enforced:
//   * the proc must exist
//   * it must have some args
//   * none of the args may be of type 'object'
//     * because declaring cursors of this form is not yet supported (easy)
//     * because then you have to deal with object<T> in struct_type (not that easy)
//     * because then you have to disallow OUT [cursor] on such cursors (easy)
//     * for now punt on that, as the non-object cases are very valuable
//  With all that done we just make a fake ast node that has the type we need in it
//  and return that.  The type is the usual struct_type
//
// The "likeable_for" arg tells us if we need the result for proc arguments or
// for a value cursor (or equivalent).  If it's proc args then we want to keep
// the OUT arg bit of the arguments.  If it's for values we lose it and just
// keep the procedure shape.
static ast_node *sem_find_likeable_proc_args(ast_node *like_ast, int32_t likeable_for) {
  Contract(is_ast_like(like_ast));
  Contract(likeable_for == LIKEABLE_FOR_ARGS || likeable_for == LIKEABLE_FOR_VALUES);

  EXTRACT_NAME_AST(name_ast, like_ast->left);
  EXTRACT_STRING(like_name, name_ast);

  ast_node *proc= find_proc(like_name);
  if (!proc) {
    report_error(like_ast, "CQL0069: name not found", like_name);
    goto error;
  }

  if (is_error(proc)) {
    report_error(like_ast, "CQL0069: name not found (proc had errors, cannot be used)", like_name);
    goto error;
  }

  EXTRACT_STRING(proc_name, get_proc_name(proc));

  ast_node *result;

  // we're goign to make a synthetic type node for the procedures arguments
  if (yylineno == -1) {
    // set up a rewrite context if one is needed
    // if yylineno is not -1 then something else is already rewriting
    AST_REWRITE_INFO_SET(like_ast->lineno, like_ast->filename);
    result = new_ast_str(like_name);
    AST_REWRITE_INFO_RESET();
  }
  else {
    result = new_ast_str(like_name);
  }

  uint32_t count =0 ;

  ast_node *params = get_proc_params(proc);

  if (!params) {
    report_error(like_ast, "CQL0262: LIKE ... ARGUMENTS used on a procedure with no arguments", like_name);
    goto error;
  }

  for (; params; params = params->right, count++) ;

  CSTR shape_name = dup_printf("%s[arguments]", proc_name);

  sem_struct *sptr = new_sem_struct(shape_name, count);

  params = get_proc_params(proc);

  uint32_t i = 0;
  for (; params; params = params->right, i++) {
    EXTRACT_NOTNULL(param, params->left);

    Invariant(param->sem);
    sem_t sem_type_param = param->sem->sem_type;

    if (likeable_for == LIKEABLE_FOR_VALUES) {
      // strip VARIABLE and OUT, add IN
      // the cursor field will not be the out arg pointer version but the data version
      // and it's no longer a standalone variable
      sem_type_param &= sem_not(SEM_TYPE_OUT_PARAMETER | SEM_TYPE_WAS_SET);
      sem_type_param |= SEM_TYPE_IN_PARAMETER;
    }

    sem_type_param &= sem_not(SEM_TYPE_VARIABLE);

    sptr->semtypes[i] = sem_type_param;
    sptr->names[i] = param->sem->name;
    sptr->kinds[i] = param->sem->kind;
  }

  result->sem = new_sem(SEM_TYPE_STRUCT);
  result->sem->sptr = sptr;
  return result;

error:
    record_error(like_ast);
    record_error(name_ast);
    return NULL;
}

// This is the general helper for handling the "LIKE [name]" form Basically we
// are going to replace the LIKE sequence with a list of names.  We just need to
// find an named object that has a structure type, then return a fresh copy of
// it with a fresh sptr (to prevent aliasing).
// It can be:
//   * a cursor
//   * a proc that returns a result set (or any proc if using ARGUMENTS form)
//   * an interface
//   * a table
//   * a view
//   * an arg bundle (even "ARGUMENTS")
// The source doesn't matter, we just need its shape.  In most cases
// we only need the names, not even the types.  But we might need either.
// (e.g. declare cursor X like Y needs the type info)
//
// We flow "likeable_for" through the search, it tells us if we need the result
// for proc arguments or for a value cursor (or equivalent).  If it's proc args
// then we want to keep the OUT bit of the arguments.  If it's for values
// we lose it and just keep the type info.  This only matters if the source of shape
// is ultimately procedure arguments
cql_noexport ast_node *sem_find_shape_def_base(ast_node *like_ast, int32_t likeable_for) {
  Contract(is_ast_like(like_ast));
  Contract(likeable_for == LIKEABLE_FOR_ARGS || likeable_for == LIKEABLE_FOR_VALUES);

  if (like_ast->right) {
    // from arguments form, only proc names allowed
    // `sem_find_likeable_proc_args` gives us a fresh ast with a fresh sem node
    // and sptr, so we can just return it here.
    return sem_find_likeable_proc_args(like_ast, likeable_for);
  }

  EXTRACT_NAME_AST(name_ast, like_ast->left);
  EXTRACT_STRING(like_name, name_ast);

  ast_node *found_shape = find_local_or_global_variable(like_name);
  if (found_shape) {
    if (!is_cursor(found_shape->sem->sem_type)) {
      report_error(like_ast, "CQL0200: variable is not a cursor", like_name);
      goto error;
    }
  }

  if (!found_shape) {
    // look for an arg bundle match
    found_shape = find_arg_bundle(like_name);
  }

  if (!found_shape) {
    // note: it's ok to use the LIKE construct on deleted tables too, hence even_deleted
    found_shape = find_table_or_view_even_deleted(like_name);
  }

  if (!found_shape) {
    found_shape = find_proc(like_name);
    if (found_shape) {
      if (!found_shape->sem->sptr) {
        report_error(like_ast, "CQL0178: proc has no result", like_name);
        goto error;
      }
    }
  }

  if (!found_shape) {
    found_shape = find_interface_type(like_name);
  }

  if (!found_shape || is_error(found_shape)) {
    report_error(like_ast, "CQL0202: must be a cursor, proc, table, or view", like_name);
    goto error;
  }

  record_ok(like_ast);

  // To prevent aliasing of the sptr (which would make it impossible to use
  // functions like `find_mutable_type` safely), we need to shallow copy the ast
  // and its sem node before cloning the sptr in the next step.
  ast_node *new_shape = _ast_pool_new(ast_node);
  *new_shape = *found_shape;
  new_shape->sem = _ast_pool_new(sem_node);
  *new_shape->sem = *found_shape->sem;

  // We never want `SEM_TYPE_INFERRED_NOTNULL` to propagate via LIKE as it would
  // falsely imply a NOT NULL status, e.g., in `declare C0 cursor like C1`.
  new_shape->sem->sptr = sem_clone_struct_strip_flags(new_shape->sem->sptr, SEM_TYPE_INFERRED_NOTNULL);

  return new_shape;

error:
  record_error(like_ast);
  record_error(name_ast);
  return NULL;
}

// This is the main worker to create a shape for use in a like clause.  We're
// going to get the base name -- the "foo" in "LIKE foo" -- and then if there are
// qualifiers we evaluate those.  The qualifiers were first non-existent
// (i.e. you could only get the exact named shape) and then extended so that you
// could choose a subset of the columns by name e.g. "LIKE foo(x,y,z)" and
// recently you can do "LIKE foo(-x, -y)" meaning everything but those two columns.
//
// This is also terribly handy for debugging because you could do something like:
//
// declare pk cursor like mytable(id1, id2);
// fetch pk from data_cursor(like pk);
// call printf("%s\n", cql_cursor_format(pk));
//
// or declare print_this cursor like mytable(-big_blob);  fetch etc.
//
// you can already do the above if you name the columns, but you can't make a general
// purpose macro that does it for any pk.
//
// We flow "likeable_for" through the search, it tells us if we need the result
// for proc arguments or for a value cursor (or equivalent).  If it's proc args
// then we want to keep the OUT bit of the arguments.  If it's for values
// we lose it and just keep the type info.  This only matters if the source of shape
// is ultimately procedure arguments.
cql_noexport ast_node *sem_find_shape_def(ast_node *shape_def, int32_t likeable_for) {
  Contract(is_ast_shape_def(shape_def));
  Contract(likeable_for == LIKEABLE_FOR_ARGS || likeable_for == LIKEABLE_FOR_VALUES);

  EXTRACT_NOTNULL(like, shape_def->left);
  EXTRACT(shape_exprs, shape_def->right);
  bool_t *desired = NULL;
  ast_node *result = NULL;

  ast_node *base_shape = sem_find_shape_def_base(like, likeable_for);
  if (!base_shape) {
    goto error;
  }

  if (shape_exprs) {
    // at the moment we only have x and -x notation so duplicates don't make any sense
    if (!sem_verify_no_duplicate_shape_exprs(shape_exprs)) {
      goto error;
    }

    sem_struct *sptr_old = base_shape->sem->sptr;
    Invariant(sptr_old);

    uint32_t old_count = sptr_old->count;
    bool_t adding = !!shape_exprs->left->right;

    // set the desired columns to all on or all off depending on if we are adding or not
    desired = (bool_t *)malloc(old_count);
    for (uint32_t i = 0; i < old_count; i++) {
       desired[i] = !adding;
    }

    ast_node *iter = shape_exprs;

    // walk the shape expressions to see which columns we want or do not want
    while (iter) {
      EXTRACT_STRING(name, iter->left->left);
      bool_t adding_item = !!iter->left->right;
      if (adding != adding_item) {
        report_error(iter->left, "CQL0494: mixing adding and removing columns from a shape", name);
        goto error;
      }

      int32_t iold = find_col_in_sptr(sptr_old, name);
      if (iold < 0) {
        report_error(iter->left, "CQL0069: name not found", name);
        goto error;
      }

      desired[iold] = adding;
      iter = iter->right;
    }

    // figure out how many columns in the desired result
    uint32_t count = 0;
    for (uint32_t i = 0; i < old_count; i++) {
      count += desired[i];
    }

    if (count == 0) {
      report_error(shape_exprs, "CQL0495: no columns were selected in the LIKE expression", NULL);
      goto error;
    }

    sem_struct *sptr_new = new_sem_struct("_select_", count);

    int32_t inew = 0;

    // now make the new structure based on the desired columns
    for (uint32_t iold = 0; iold < old_count; iold++) {
      if (desired[iold]) {
        sptr_new->names[inew] = sptr_old->names[iold];
        sptr_new->semtypes[inew] = sptr_old->semtypes[iold];
        sptr_new->kinds[inew] = sptr_old->kinds[iold];
        inew++;
      }
    }

    // this rewrite can nest in the bigger columns rewrite so push/pop needed
    AST_REWRITE_INFO_SAVE();
    AST_REWRITE_INFO_SET(base_shape->lineno, base_shape->filename);
    result = new_ast_shape_def(NULL, NULL);
    result->sem = new_sem(SEM_TYPE_STRUCT);
    result->sem->sptr = sptr_new;
    AST_REWRITE_INFO_RESET();
    AST_REWRITE_INFO_RESTORE();
    goto cleanup;
  }
  else {
    result = base_shape;
    goto cleanup;
  }

error:
  record_error(shape_def);
  result = NULL;

cleanup:
  if (desired) {
    free(desired);
  }

  return result;
}

// All we have to do here is walk the parameter list and use the helper above
// for each parameter.
static void sem_params(ast_node *head, bytebuf *args_info) {
  Contract(is_ast_params(head));

  rewrite_params(head, args_info);
  if (is_error(head)) {
    return;
  }

  // we're only going to record the proc argument shape for
  // create proc statements, we need this stuff for the JSON
  // output so we can emit where the arguments came from.
  // Since we have to do this anyway we're also going to make
  // a fake arg bundle for all the arguments.  By doing this
  // the "from arguments" forms all look exactly the same as
  // any other "from shape" kind of thing so we don't need
  // special code to walk the arguments.  It just looks like a shape.

  CSTR *arg_names = NULL;
  sem_struct *sptr = NULL;

  if (args_info) {
    uint32_t count = args_info->used / sizeof(CSTR) / 3;
    if (count) {
      AST_REWRITE_INFO_SET(head->lineno, head->filename);
      CSTR args = "ARGUMENTS";

      ast_node *ast_args = new_ast_str(args);
      ast_args->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_HAS_SHAPE_STORAGE);
      ast_args->sem->name = args;
      sptr = new_sem_struct(args, count);
      ast_args->sem->sptr = sptr;
      add_arg_bundle(ast_args, args);
      arg_names = (CSTR *)args_info->ptr;

      AST_REWRITE_INFO_RESET();
    }
  }

  uint32_t i = 0;
  for (ast_node *ast = head; ast; ast = ast->right, i++) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left);

    sem_param(param);
    if (is_error(param)) {
      record_error(head);
      return;
    }

    if (sptr) {
      Invariant(i < sptr->count);
      sptr->names[i] = arg_names[i*3];
      sptr->semtypes[i] = param->sem->sem_type;
      sptr->kinds[i] = param->sem->kind;
    }
  }

  record_ok(head);
}

// If we need to implicitly generate locals or a return struct for a select statement
// the all of the columns have to have unique names.  This really can only happen if
// you do something like select * from foo T1 join foo T2 on T1.id = T2.parent_id
// There will be two "id" columns in that result.  Basically you can't use select *
// then because of the code-gen would give errors in naming those columns (and it's
// confusing as hell).
static void sem_validate_unique_names_struct_type(ast_node *ast) {
  Contract(ast);
  Contract(ast->sem);
  Contract(is_struct(ast->sem->sem_type));
  Contract(!is_error(ast));  // already "ok" at least

  sem_struct *sptr = ast->sem->sptr;

  symtab *fields = symtab_new();

  for (uint32_t i = 0; i < sptr->count; i++) {
    if (!symtab_add(fields, sptr->names[i], NULL)) {
      report_error(ast, "CQL0180: duplicate column name in result not allowed", sptr->names[i]);
      record_error(ast);
      break;
    }
  }

  symtab_delete(fields);
  return;
}

// Find the column type of a column in a table. Return 0 if not found
cql_noexport sem_t find_column_type(CSTR table_name, CSTR column_name) {
  ast_node *table_ast = find_table_or_view_even_deleted(table_name);
  if (table_ast) {
    for (uint32_t i = 0; i < table_ast->sem->sptr->count; i++) {
      if (!StrCaseCmp(column_name, table_ast->sem->sptr->names[i])) {
        return table_ast->sem->sptr->semtypes[i];
      }
    }
  }
  return 0;
}

// Find the column kind of a column in a table. Return NULL if not found
static CSTR find_column_kind(CSTR table_name, CSTR column_name) {
  CSTR result = NULL;
  ast_node *table_ast = find_table_or_view_even_deleted(table_name);
  if (table_ast) {
    for (uint32_t i = 0; i < table_ast->sem->sptr->count; i++) {
      if (!StrCaseCmp(column_name, table_ast->sem->sptr->names[i])) {
        result = table_ast->sem->sptr->kinds[i];
        break;
      }
    }
  }
  return result;
}

static void report_dummy_test_error(ast_node *target, CSTR message, CSTR subject, int32_t *error) {
  report_error(target, message, subject);
  record_error(target);
  *error = true;
}

// semantic analysis of dummy_test info. Return true if the node is processed otherwise false
static bool_t sem_autotest_dummy_test(
  ast_node *misc_attr_value_list,
  void *context)
{
  Contract(is_ast_misc_attr_value_list(misc_attr_value_list));

  if (!is_ast_str(misc_attr_value_list->left)) {
    return false;
  }

  EXTRACT_STRING(autotest_attr_name, misc_attr_value_list->left);

  if (!is_autotest_dummy_test(autotest_attr_name)) {
    return false;
  }

  bytebuf column_types = {NULL, 0, 0};
  bytebuf column_names = {NULL, 0, 0};

  int32_t *error = (int32_t *)context;

  // walkthrough dummy_test tree and retreive the table name then the column name
  // of the table name and then the column values of the column names. We repeat
  // it for the next table info.
  for (ast_node *dummy_test_list = misc_attr_value_list->right; dummy_test_list; dummy_test_list = dummy_test_list->right) {
    bytebuf_open(&column_types);
    bytebuf_open(&column_names);

    int32_t column_count = 0;

    // find table name
    if (!is_ast_misc_attr_value_list(dummy_test_list->left) || !is_ast_str(dummy_test_list->left->left)) {
      report_dummy_test_error(
      dummy_test_list->left,
        "CQL0273: autotest attribute has incorrect format (table name should be nested) in",
        "dummy_test",
        error);
      goto cleanup;
    }

    ast_node *table_list = dummy_test_list->left;
    EXTRACT_STRING(table_name, table_list->left);
    ast_node *table = find_table_or_view_even_deleted(table_name);
    if (!table) {
      report_dummy_test_error(
        table_list->left,
        "CQL0274: autotest attribute 'dummy_test' has non existent table",
        table_name,
        error);
      goto cleanup;
    }

    record_ok(table_list->left);

    // find column names
    ast_node *column_name_list = table_list->right;
    if (!is_ast_misc_attr_value_list(column_name_list->left)) {
      report_dummy_test_error(
        table_list->left,
        "CQL0273: autotest attribute has incorrect format (column name should be nested) in",
        "dummy_test",
        error);
      goto cleanup;
    }

    for (ast_node *list = column_name_list->left; list; list = list->right) {
      if (!is_ast_str(list->left)) {
        report_dummy_test_error(
          table_list->left,
          "CQL0273: autotest attribute has incorrect format (column name should be nested) in",
          "dummy_test",
          error);
        goto cleanup;
      }
      ast_node *misc_attr_value = list->left;
      EXTRACT_STRING(column_name, misc_attr_value);
      sem_t col_type = find_column_type(table_name, column_name);
      if (!col_type) {
        report_dummy_test_error(
          misc_attr_value,
          "CQL0275: autotest attribute 'dummy_test' has non existent column",
          column_name,
          error);
        goto cleanup;
      }
      record_ok(misc_attr_value);
      sem_t *col_type_ptr = bytebuf_alloc(&column_types, sizeof(sem_t));
      *col_type_ptr = col_type;
      CSTR *colum_name_ptr = bytebuf_alloc(&column_names, sizeof(CSTR));
      *colum_name_ptr = column_name;
      column_count++;
    }

    // find column values
    if (!is_ast_misc_attr_value_list(column_name_list->right)) {
      report_dummy_test_error(
        table_list->left,
        "CQL0273: autotest attribute has incorrect format (column value should be nested) in",
        "dummy_test",
        error);
      goto cleanup;
    }

    for (ast_node *column_values_list = column_name_list->right; column_values_list; column_values_list = column_values_list->right) {
      if (!is_ast_misc_attr_value_list(column_values_list->left)) {
        report_dummy_test_error(
          table_list->left,
          "CQL0273: autotest attribute has incorrect format (column value should be nested) in",
          "dummy_test",
          error);
        goto cleanup;
      }

      int32_t column_value_count = 0;
      for (ast_node *list = column_values_list->left; list; list = list->right) {

        if (column_value_count >= column_count) {
          report_dummy_test_error(
            table_list->left,
            "CQL0273: autotest attribute has incorrect format (too many column values) in",
            "dummy_test",
            error);
          goto cleanup;
        }

        ast_node *misc_attr_value = list->left;
        sem_t col_type = ((sem_t *)column_types.ptr)[column_value_count];
        sem_t core_type = core_type_of(col_type);

        if (is_ast_uminus(misc_attr_value)) {
          Contract(is_ast_num(misc_attr_value->left));
          misc_attr_value = misc_attr_value->left;
        }

        bool_t ok = false;

        if (is_ast_num(misc_attr_value)) {
           // an integer literal is good for any numeric type
           EXTRACT_NUM_TYPE(num_type, misc_attr_value);

           if (num_type == NUM_INT || num_type == NUM_BOOL) {
             // an integer or bool literal is good for any numeric type
             ok = is_numeric(core_type);
           }
           else if (num_type == NUM_LONG) {
             // NUM_LONG might not fit in REAL, compatible only with itself
             ok = core_type == SEM_TYPE_LONG_INTEGER;
           }
           else {
             Contract(num_type == NUM_REAL);
             // a real literal is only good for a real column
             ok = core_type == SEM_TYPE_REAL;
           }
        }
        else if (is_strlit(misc_attr_value)) {
           // a string literal is ok for any text column
           ok = core_type == SEM_TYPE_TEXT;
        }
        else if (is_ast_null(misc_attr_value)) {
           // the null token is ok for any nullable column
           ok = is_nullable(col_type);
        }
        else if (is_ast_blob(misc_attr_value)) {
           // a blob literal is ok for blob column
           ok = core_type == SEM_TYPE_BLOB;
        }

        if (!ok) {
          report_dummy_test_error(
            misc_attr_value,
            "CQL0276: autotest attribute 'dummy_test' has invalid value type in",
            ((CSTR *) column_names.ptr)[column_value_count],
            error);
          goto cleanup;
        }
        record_ok(misc_attr_value);
        column_value_count++;
      }

      if (column_count != column_value_count) {
        report_dummy_test_error(
          table_list->left,
          "CQL0273: autotest attribute has incorrect format (mismatch number of column and values) in",
          "dummy_test",
          error);
        goto cleanup;
      }
    }

    bytebuf_close(&column_types);
    bytebuf_close(&column_names);
  }

  record_ok(misc_attr_value_list->left);

cleanup:
  if (column_types.ptr) {
     bytebuf_close(&column_types);
  }

  if (column_names.ptr) {
     bytebuf_close(&column_names);
  }
  return true;
}

// Searching for valid cql:autotest=(x,y,z...) attributes
// If we find an invalid form for the attribute or we find a listed item that
// is unknown then we use the context to flag and error (which we report).
// All of these will do complex code gen if an autotest codegen pass is selected
// but for here we just verify that the attribute is of the correct form and hence
// could be used.
static void sem_find_ast_misc_attr_callback(
  CSTR misc_attr_prefix,
  CSTR misc_attr_name,
  ast_node *ast_misc_attr_value_list,
  void *context)
{
  if (misc_attr_prefix &&
      misc_attr_name &&
      !(StrCaseCmp(misc_attr_prefix, "cql")) &&
      !(StrCaseCmp(misc_attr_name, "autotest"))) {
    int32_t *error = (int32_t *)context;

    if (!is_ast_misc_attr_value_list(ast_misc_attr_value_list)) {
      report_dummy_test_error(
        ast_misc_attr_value_list,
        "CQL0277: autotest has incorrect format",
        "no test types specified",
        error);
      return;
    }

    for (ast_node *list = ast_misc_attr_value_list; list; list = list->right) {
      ast_node *misc_attr_value = list->left;
      // We found a nested dummy_test with info
      // [[autotest=(..., (dummy_test, ...)))]]
      if (is_ast_misc_attr_value_list(misc_attr_value)) {
        if (sem_autotest_dummy_test(misc_attr_value, context)) {
          if (*error) {
            record_error(misc_attr_value->left);
          }
        }
        else {
          report_dummy_test_error(
            misc_attr_value->left,
            "CQL0277: autotest has incorrect format",
            "found nested attributes that don't start with dummy_test",
            error);
        }
      }
      else { // autotest attribute
        EXTRACT_STRING(autotest_attr_name, misc_attr_value);
        if (!is_autotest_dummy_table(autotest_attr_name) &&
            !is_autotest_dummy_insert(autotest_attr_name) &&
            !is_autotest_dummy_select(autotest_attr_name) &&
            !is_autotest_dummy_result_set(autotest_attr_name) &&
            !is_autotest_dummy_test(autotest_attr_name)) {
          report_dummy_test_error(
            misc_attr_value,
            "CQL0278: autotest attribute name is not valid",
            autotest_attr_name,
            error);
        }
        else {
          record_ok(misc_attr_value);
        }
      }
    }
  }
}

// semantic analysis of autotest attributes. The autotest attribution should
// look like this:
// @attribute(cql:autotest=(<name>,
//                          <name>,
//                          ...
//                         )
//           )
// <name> can be "dummy_test" or "dummy_table" or "dummy_insert" or "dummy_select" or
// "dummy_result_set"
//
// If informations are added to "dummy_test" attribute then format should look like this:
// @attribute(cql:autotest=(...,
//                          (dummy_test,
//                                    (<table1>,
//                                              (<column_name1>, ...),
//                                              (<column_value1>, ...),
//                                              (<column_value1>, ...)
//                                    ),
//                                    (<table2>,
//                                              ...
//                                    )
//                          ),
//                          ...
//                         )
//           )
//  "..." can be any autotest attribution name except "dummy_test"
static void sem_autotests(ast_node *misc_attrs) {
  Contract(is_ast_misc_attrs(misc_attrs));
  int32_t error = false;

  find_misc_attrs(misc_attrs, sem_find_ast_misc_attr_callback, &error);
  if (error) {
    record_error(misc_attrs);
    return;
  }
  record_ok(misc_attrs);
}

// Check wheter or not the values of the attribution are valid names of columns in the current proc's result_set
static uint32_t sem_column_name_annotation(ast_node *misc_attrs, find_annotation_values find, CSTR target) {
  Contract(is_ast_misc_attrs(misc_attrs));
  Contract(annotation_target == NULL);
  record_ok(misc_attrs);

  annotation_target = target;
  uint32_t result = find(misc_attrs, sem_column_name_exist_in_result_set, misc_attrs);
  annotation_target = NULL;
  return result;
}

// Check the autodrop to make sure it is conformant, it has to be a valid temp table.
static void sem_one_autodrop(CSTR name, ast_node *misc_attr_value, void *context) {
  EXTRACT_NOTNULL(misc_attrs, (ast_node *)context);

  // temp tables are never @deleted, look only for not_deleted tables
  ast_node *temp_table = find_usable_and_not_deleted_table_or_view(
    name,
    misc_attr_value->parent,
    "CQL0181: autodrop temp table does not exist");
  if (!temp_table) {
    record_error(misc_attrs);
    return;
  }

  if (!is_ast_create_table_stmt(temp_table)) {
    report_error(misc_attr_value->parent, "CQL0182: autodrop target is not a table", name);
    record_error(misc_attrs);
    return;
  }

  EXTRACT_NOTNULL(create_table_name_flags, temp_table->left);
  EXTRACT_NOTNULL(table_flags_attrs, create_table_name_flags->left);
  EXTRACT_OPTION(flags, table_flags_attrs->left);

  int32_t temp = flags & TABLE_IS_TEMP;

  if (!temp) {
    report_error(misc_attr_value->parent, "CQL0183: autodrop target must be a temporary table", name);
    record_error(misc_attrs);
    return;
  }

  record_ok(misc_attr_value);
}

// If a stored proc is marked with the autodrop annotation then we automatically drop the indicated
// tables when the proc is finished running.  The attributes should look like this:
// [[autodrop=(table1, table2, ,...)]]
static uint32_t sem_autodrops(ast_node *misc_attrs) {
  Contract(is_ast_misc_attrs(misc_attrs));
  record_ok(misc_attrs);
  return find_autodrops(misc_attrs, sem_one_autodrop, misc_attrs);
}

// when we discover a table parameter we'll see if we can find it
// in the table of names we've seen before.  If we find it, the new
// parameter must have the exact same type as what we already have.
typedef struct bind_equivalence_info {
  symtab *names;
  ast_node *bind_mismatch_error;
} bind_equivalence_info;

// Here we must verify that if we found two table parameters of the same name that they are of the
// same exact type.  Since they have the same name there will be one table binding for the both
// of them and so if their type is not identical then no one binding could satisfy both
static void verify_identical_table_params_callback(void *context, CSTR name, ast_node *cte_decl) {
  bind_equivalence_info *info = (bind_equivalence_info *)context;

  symtab_entry *entry = symtab_find(info->names, name);

  if (!entry) {
    // new name, nothing to check
    symtab_add(info->names, name, cte_decl);
    return;
  }

  // existing name must be identical
  sem_verify_identical_columns((ast_node*)entry->val, cte_decl, name);
  if (is_error(cte_decl)) {
    info->bind_mismatch_error = cte_decl;
  }
}

// If a stored proc is marked with the shared_fragment attribute, we check for the simple
// shared form of one select statement, with no OUT or IN/OUT args
// The attribute should look like this:
// [[shared_fragment]]
static void sem_shared_fragment(ast_node *misc_attrs, ast_node *create_proc_stmt) {
  Contract(is_ast_create_proc_stmt(create_proc_stmt));
  Contract(is_ast_misc_attrs(misc_attrs));

  Contract(!current_joinscope);  // I don't belong inside a select(!)
  EXTRACT_NOTNULL(proc_params_stmts, create_proc_stmt->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_STRING(proc_name, current_proc->left);

  if (stmt_list->right) {
    report_error(stmt_list, "CQL0179: shared fragments must consist of exactly one top level statement", proc_name);
    record_error(misc_attrs);
    record_error(stmt_list);
    record_error(create_proc_stmt);
    return;
  }

  EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

  if (!is_select_variant(stmt) && !is_ast_if_stmt(stmt)) {
    report_error(stmt, "CQL0441: shared fragments may only have IF, SELECT, or WITH...SELECT at the top level", proc_name);
    record_error(misc_attrs);
    record_error(stmt_list);
    record_error(create_proc_stmt);
    return;
  }

  if (is_ast_if_stmt(stmt)) {
    shared_cte_info info;
    bind_equivalence_info bind_info;
    memset(&info, 0, sizeof(info));
    memset(&bind_info, 0, sizeof(bind_info));

    info.context = &bind_info;
    info.callback = verify_identical_table_params_callback;
    bind_info.names = symtab_new();

    sem_accumulate_proc_cte_info(create_proc_stmt, &info);

    symtab_delete(bind_info.names);

    if (info.missing_else) {
      Invariant(is_ast_if_stmt(info.missing_else));
      ast_node *ast = info.missing_else;
      EXTRACT_NOTNULL(if_alt, ast->right);
      Invariant(if_alt->right == NULL); // our missing else

      // The else clause is easy to add it's always in the same place in the AST
      // We make a one statement statement list and plop it in.
      AST_REWRITE_INFO_SET(ast->lineno, ast->filename);
      ast_node *select_nothing_ast = new_ast_select_nothing_stmt();
      ast_node *stmt_list_ast = new_ast_stmt_list(select_nothing_ast, NULL);
      if_alt->right = new_ast_else(stmt_list_ast);
      AST_REWRITE_INFO_RESET();

      // better to do the analysis after the rewrite is closed
      // as it happens this doesn't kick off a new rewrite but
      // in general sem_* might rewrite so we want to be done with our
      // edits before we resume semantic analysis
      sem_select_nothing_stmt(select_nothing_ast);
    }

    if (info.bad_statement_form) {
      report_error(info.bad_statement_form, "CQL0443: shared fragments with conditionals must have exactly one SELECT, or WITH...SELECT in each statement list", proc_name);
      record_error(misc_attrs);
      record_error(stmt_list);
      record_error(create_proc_stmt);
      return;
    }

    if (info.non_select_stmt) {
      report_error(info.non_select_stmt, "CQL0443: shared fragments with conditionals must have exactly SELECT, or WITH...SELECT in each statement list", proc_name);
      record_error(misc_attrs);
      record_error(stmt_list);
      record_error(create_proc_stmt);
      return;
    }

    // This means specifically that we found a case where two table parameters were specified in the
    // fragment that have the same name but are of different types
    // error already reported in this case, we just record the failure and move on
    if (bind_info.bind_mismatch_error) {
      record_error(misc_attrs);
      record_error(stmt_list);
      record_error(create_proc_stmt);
      return;
    }
  }

  for (ast_node *ast = params; ast; ast = ast->right) {
    Contract(is_ast_params(ast));
    EXTRACT_NOTNULL(param, ast->left);

    if (is_out_parameter(param->sem->sem_type)) {
      report_error(stmt_list,  "CQL0208: shared fragments cannot have any out or in/out parameters", param->sem->name);
      record_error(misc_attrs);
      record_error(stmt_list);
      record_error(create_proc_stmt);
      return;
    }
  }
}

// Returns true if any of the "etc" parts of from_etc are present.
// This let's us easily check for the presence of any extra clauses that are
// not allowed in an extension fragment.
static bool_t sem_has_extra_clauses(ast_node *select_from_etc, ast_node *select_orderby) {
  Contract(is_ast_select_orderby(select_orderby));

  bool_t has_extras = false;

  if (select_from_etc) {
    Contract(is_ast_select_from_etc(select_from_etc));

    EXTRACT_NOTNULL(select_where, select_from_etc->right);
    EXTRACT(opt_where, select_where->left);
    EXTRACT_NOTNULL(select_groupby, select_where->right);
    EXTRACT(opt_groupby, select_groupby->left);
    EXTRACT_NOTNULL(select_having, select_groupby->right);
    EXTRACT(opt_having, select_having->left);
    EXTRACT(opt_select_window, select_having->right);

    has_extras |= !!opt_where;
    has_extras |= !!opt_groupby;
    has_extras |= !!opt_having;
    has_extras |= !!opt_select_window;
  }

  EXTRACT(opt_orderby, select_orderby->left);
  EXTRACT_NOTNULL(select_limit, select_orderby->right);
  EXTRACT(opt_limit, select_limit->left);
  EXTRACT_NOTNULL(select_offset, select_limit->right);
  EXTRACT(opt_offset, select_offset->left);

  has_extras |= !!opt_orderby;
  has_extras |= !!opt_limit;
  has_extras |= !!opt_offset;

  return has_extras;
}

// Here were going to verify that the procedure in question implements the indicated interface
// in order to do so it has to have the correct columns with compatible types in any order
// which is to say the procedures result type has to be a superset of the interface columns
//   * note there can be more than one interface
//   * we will eventually allow columns that are compatable with trivial conversion (e.g. not null -> nullable)
static void sem_validate_one_interface(CSTR _Nonnull interface_name, ast_node *_Nonnull attr, void *_Nullable context) {
  ast_node *create_proc_stmt = (ast_node *)context;

  Contract(is_ast_create_proc_stmt(create_proc_stmt));

  symtab *names = symtab_new();
  ast_node *name_ast = get_proc_name(create_proc_stmt);
  EXTRACT_STRING(proc_name, name_ast);

  ast_node *interface = find_interface_type(interface_name);
  if (!interface) {
    report_error(attr, "CQL0482: interface not found", interface_name);
    record_error(attr);
    goto error;
  }

  sem_struct *interface_sptr = interface->sem->sptr;
  sem_struct *proc_sptr = create_proc_stmt->sem->sptr;

  // stash the indices of all the column names in the procedure so that we can find them quickly
  for (uint32_t i = 0; i < proc_sptr->count; i++) {
    symtab_add(names, proc_sptr->names[i], (void *)(uint64_t)i);
  }

  for (uint32_t i = 0; i < interface_sptr->count; ++i) {

    CSTR interface_column_name = interface_sptr->names[i];

    symtab_entry *entry = symtab_find(names, interface_sptr->names[i]);
    if (!entry) {
      CSTR msg = dup_printf("CQL0484: procedure '%s' is missing column '%s' of interface '%s'",
        proc_name, interface_column_name, interface_name);
      report_error(create_proc_stmt, msg, NULL);
      goto error;
    }

    // the column index in the procedure result type can be different, we saved it above
    uint32_t j = (uint32_t)(uint64_t)entry->val;

    sem_t actual_type = proc_sptr->semtypes[j];
    sem_t expected_type = interface_sptr->semtypes[i];

    if (
      core_type_of(actual_type) != core_type_of(expected_type) ||
      is_nullable(actual_type) != is_nullable(expected_type) ||
      sensitive_flag(actual_type) != sensitive_flag(expected_type)
    ) {
      CSTR error = "CQL0485: column types returned by proc need to be the same as defined on the interface";
      report_sem_type_mismatch(expected_type, actual_type, create_proc_stmt, error, interface_column_name);
      goto error;
    }
  }

  goto cleanup;

error:
  record_error(create_proc_stmt);

cleanup:
  symtab_delete(names);
}

// Returns true if all parameters of the current procedure that require
// initialization have been initialized, else false. Any errors that occur will
// be reported as occurring at the location of `error_ast`.
static bool_t sem_validate_current_proc_params_are_initialized(ast_node *error_ast) {
  Contract(current_proc);
  Contract(error_ast);

  // Check the parameters to ensure all have been initialized.
  ast_node *params = get_proc_params(current_proc);
  for (ast_node *param_item = params; param_item; param_item = param_item->right) {
    EXTRACT_NOTNULL(param, param_item->left);
    sem_t sem_type = param->sem->sem_type;
    if (sem_type & SEM_TYPE_INIT_REQUIRED && !(sem_type & SEM_TYPE_INIT_COMPLETE)) {
      EXTRACT_NOTNULL(param_detail, param->right);
      EXTRACT_STRING(name, param_detail->left);
      report_error(error_ast, "CQL0439: nonnull reference OUT parameter possibly not always initialized", name);
      return false;
    }
  }

  return true;
}

// Used for sem_create_proc_stmt() only.
// Here we run the sem analysis for params and stmt_list of the create_proc_stmt ast node.
//
// This returns a bool because it has to handle the null stmt_list case so the usual contract
// of putting the error on the ast doesn't work.  Returns true on error.
static void sem_inside_create_proc_stmt(ast_node *ast) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_STRING(proc_name, current_proc->left);

  if (params) {
    Contract(is_ast_params(params));
  }

  int32_t saved_between_count = between_count;
  has_dml = 0;
  current_variables = locals = symtab_new();
  arg_bundles = symtab_new();
  between_count = 0;
  in_proc_savepoint = false;

  // We push a normal context for all of the statements within the procedure. We
  // do this here rather than simply using `sem_stmt_list` below so that we can
  // verify all of the procedure's parameters have been appropriately
  // initialized before the initialization improvements are unset.
  FLOW_PUSH_CONTEXT_NORMAL();

  // we process the parameter list even if there are no statements
  if (params) {
    bytebuf *args_info = symtab_ensure_bytebuf(proc_arg_info, proc_name);
    sem_params(params, args_info);
    if (is_error(params)) {
      goto error;
    }
  }

  // We have to mark the thing as ok here because it could be called
  // recursively and we want to know if there are any errors so far.
  // the semantic info might be mutated later so don't use the shared ok record
  ast->sem = new_sem(SEM_TYPE_OK);

  if (!stmt_list) {
    if (is_proc_shared_fragment(ast)) {
      report_error(ast, "CQL0440: fragments may not have an empty body", proc_name);
      goto error;
    }
  }
  else {
    // BEGIN [stmt_list] END
    //
    // We avoid pushing a new context so that any initialization improvements
    // are still in effect when we later validate that all parameters have been
    // appropriately initialized.
    sem_stmt_list_in_current_flow_context(stmt_list);
    if (is_error(stmt_list)) {
      goto error;
    }

    if (ast->sem && ast->sem->sptr) {
      ast->sem->sptr = new_sem_struct_strip_table_flags(ast->sem->sptr);
      ast->sem->sptr->struct_name = proc_name;
    }

    if (has_dml) {
      Invariant(ast->sem);
      ast->sem->sem_type |= SEM_TYPE_DML_PROC;
    }
  }

  if (current_proc_contains_try_is_proc_body) {
    // This procedure contains a TRY block that should be treated as the main
    // body of the procedure. Parameter initialization has already been checked
    // accordingly within `sem_trycatch_stmt`.
    //
    // Checking it again here, which we do not do, could very well fail. In
    // fact, not enforcing initialization here is half of the utility of the
    // "cql:try_is_proc_body" attribute at present. (The other half, of course,
    // is that `sem_trycatch_stmt` *does* enforce it.)
  }
  else {
    // Verify that all parameters have been appropriately initialized using the
    // end of the procedure for error reporting. This is the common case.
    if (!sem_validate_current_proc_params_are_initialized(ast)) {
      goto error;
    }
  }

cleanup:
  FLOW_POP_CONTEXT_NORMAL();
  symtab_delete(locals);
  symtab_delete(arg_bundles);
  locals = NULL;
  arg_bundles = NULL;
  current_variables = globals;
  between_count = saved_between_count;
  current_proc_contains_try_is_proc_body = false;

  return;

error:
  record_error(ast);
  goto cleanup;
}

// Helper function to validate that ok_table_scan attribution is semantically correctly.
// ok_table_scan value can only be a table name and should be used in a create proc statement
static void sem_validate_ok_table_scan_value(ast_node *misc_attrs, ast_node *ast_misc_attr_value) {
  if (!is_ast_str(ast_misc_attr_value)) {
    report_error(ast_misc_attr_value, "CQL0325: ok_table_scan attribute must be a name", NULL);
    record_error(ast_misc_attr_value);
    return;
  }

  EXTRACT_STRING(table_name, ast_misc_attr_value);
  if (!find_usable_table_or_view_even_deleted(table_name, misc_attrs, "CQL0326: the table name in ok_table_scan does not exist")) {
    record_error(ast_misc_attr_value);
    return;
  }

  record_ok(ast_misc_attr_value);
}

// This function validates the semantics of the ok_table_scan attribute.
// It can only be assigned to a create proc statement and takes table
// names as value.
// It's used by the test helpers runtime to know on which tables it's are ok to
// have allow table scan in a stored proc.
static void sem_misc_attrs_ok_table_scan(
    CSTR misc_attr_prefix,
    CSTR misc_attr_name,
    ast_node *ast_misc_attr_values,
    ast_node *misc_attrs,
    ast_node *any_stmt) {
  Contract(misc_attr_name);
  Contract(any_stmt);
  Contract(misc_attrs);

  if (!StrCaseCmp(misc_attr_prefix, "cql") &&
      !StrCaseCmp(misc_attr_name, "ok_table_scan")) {
    if (!is_ast_create_proc_stmt(any_stmt)) {
        report_error(misc_attrs, "CQL0329: ok_table_scan attribute can only be used in a create procedure statement", NULL);
        record_error(misc_attrs);
        return;
    }
    else if (is_ast_misc_attr_value_list(ast_misc_attr_values)) {
      // the value in ok_table_scan attributions is a list of value. we have to go
      // through the list and validate each of them.
      for (ast_node *list = ast_misc_attr_values; list; list = list->right) {
        ast_node *ast_misc_attr_value = list->left;
        sem_validate_ok_table_scan_value(misc_attrs, ast_misc_attr_value);
        if (is_error(ast_misc_attr_value)) {
          record_error(misc_attrs);
          return;
        }
      }
    }
    else {
      // The value in ok_table_scan attributions should be str node otherwise it's an error.
      sem_validate_ok_table_scan_value(misc_attrs, ast_misc_attr_values);
      if (is_error(ast_misc_attr_values)) {
        record_error(misc_attrs);
        return;
      }
    }
  }
}

// This function validates the semantics of the no_table_scan attribute.
// The attribute does not take a value and can only be use on create table
// statement.
// It's used by the test helpers runtime to know on which tables it's forbidden
// to have table scan.
static void sem_misc_attrs_no_table_scan(
    CSTR misc_attr_prefix,
    CSTR misc_attr_name,
    ast_node *ast_misc_attr_values,
    ast_node *misc_attrs,
    ast_node *any_stmt) {
  Contract(misc_attr_name);
  Contract(any_stmt);
  Contract(misc_attrs);

  if (ast_misc_attr_values != NULL) {
    report_error(ast_misc_attr_values, "CQL0327: a value should not be assigned to no_table_scan attribute", NULL);
    record_error(ast_misc_attr_values);
    record_error(misc_attrs);
    return;
  }

  if (is_ast_stmt_and_attr(misc_attrs->parent)) {
    ast_node *stmt = misc_attrs->parent->right;
    if (!is_ast_create_table_stmt(stmt)) {
      report_error(misc_attrs, "CQL0328: no_table_scan attribute may only be added to a create table statement", NULL);
      record_error(misc_attrs);
      return;
    }
  }
}

// Validates cql:alias_of attribute.
// The attribute can only be used in a declare func statement.
// It also must have a non-empty string argument.
static void sem_misc_attrs_alias_of(
    CSTR misc_attr_prefix,
    CSTR misc_attr_name,
    ast_node *ast_misc_attr_values,
    ast_node *misc_attrs,
    ast_node *any_stmt) {

  Contract(misc_attr_name);
  Contract(any_stmt);
  Contract(misc_attrs);

  if (is_ast_stmt_and_attr(misc_attrs->parent)) {
    ast_node *stmt = misc_attrs->parent->right;
    if (!is_ast_declare_func_stmt(stmt) && !is_ast_declare_proc_stmt(stmt)) {
      report_error(misc_attrs, "CQL0499: alias_of attribute may only be added to a declare function or declare proc statement", NULL);
      record_error(misc_attrs);
      return;
    }
  }

  if (!is_ast_str(ast_misc_attr_values)) {
      report_error(misc_attrs, "CQL0500: alias_of attribute must be a non-empty string argument.", NULL);
      record_error(misc_attrs);
      return;
  }
}

// Semantic anlysis of ok_table_scan and no_table_scan attribution.
// ok_table_scan: can only be assigned to a create proc statement and
// the value can only be table names.
// no_table_scan: can only be assigned to a create table statement and
// has not value.
static void sem_misc_attrs_callback(
  CSTR misc_attr_prefix,
  CSTR misc_attr_name,
  ast_node *ast_misc_attr_values,
  void *context) {
  Contract(misc_attr_name);
  Contract(context);
  EXTRACT_NOTNULL(misc_attrs, context);

  if (!misc_attr_prefix) {
    return;
  }

  // We can stop as soon as any misc_attr has an error.
  if (is_error(misc_attrs)) {
    return;
  }

  EXTRACT_NOTNULL(stmt_and_attr, misc_attrs->parent);
  EXTRACT_ANY_NOTNULL(any_stmt, stmt_and_attr->right);

  symtab_entry *entry = symtab_find(misc_attributes, misc_attr_name);
  if (entry) {
    ((sem_misc_attribute_callback)entry->val)(
        misc_attr_prefix,
        misc_attr_name,
        ast_misc_attr_values,
        misc_attrs,
        any_stmt);
  }
}

// Semantic analysis of any attributions that can appear in any statement
static void sem_misc_attrs(ast_node *ast) {
  Contract(is_ast_misc_attrs(ast));

  // Assume the node is ok;  only some nodes get semantic analysis.
  record_ok(ast);

  find_misc_attrs(ast, sem_misc_attrs_callback, ast);
}

// Semantic analysis of stored procedures is fairly easy at the core:
//  * check for duplicate names
//  * validate the paramaters are well formed
//  * set the current proc in flight (this not allowed to nest)
//  * recurse on the statement list and prop errors
//  * record the name of the procedure for callers
// In addition, while processing the statement:
//  * the HAS_DML flag is added if any DML/DDL statements are encountered
//    * this will change the emitted signature of the proc to include a sqlite3 *db
//      input argument and it will return a Sqilte error code (e.g. SQLITE_OK)
//  * select statements that are loose in the proc represent the "return" of that
//    select;  this changes the signature to include a sqlite3_stmt **pstmt parameter
//
static void sem_create_proc_stmt(ast_node *ast) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_create_proc_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);
  EXTRACT(stmt_list, proc_params_stmts->right);
  EXTRACT_MISC_ATTRS(ast, misc_attrs);

  // any early exit is an error
  bool_t error = true;

  if (current_proc) {
    report_error(name_ast, "CQL0184: stored procedures cannot be nested", name);
    goto cleanup;
  }

  in_shared_fragment = is_proc_shared_fragment(ast);

  Invariant(!locals);
  Invariant(!local_types);

  // create local storage for named type defined in the proc
  local_types = symtab_new();

  unitary_locals = _ast_pool_new(bytebuf);
  bytebuf_open(unitary_locals);

  // CREATE PROC [name] ( [params] )

  if (find_func(name)) {
    report_error(name_ast, "CQL0185: proc name conflicts with func name", name);
    goto cleanup;
  }

  if (find_interface_type(name)) {
    report_error(name_ast, "CQL0481: proc name conflicts with interface name", name);
    goto cleanup;
  }

  ast_node *existing_proc = find_proc(name);

  if (is_ast_create_proc_stmt(existing_proc)) {
    report_error(name_ast, "CQL0186: duplicate stored proc name", name);
    goto cleanup;
  }

  if (!existing_proc) {
    // proc doesn't exist, ok to add it
    bool_t added = add_proc(ast, name);
    Invariant(added);
  }
  else {
    // replace the declaration with this definition
    // the declare is now upgraded to a (pending) create
    symtab_entry *entry = symtab_find(procs, name);
    entry->val = ast;
  }

  ast_node *schema_attr = find_upgrade_proc(name);
  if (schema_attr) {
    Invariant(is_ast_create_attr(schema_attr) ||
              is_ast_delete_attr(schema_attr) ||
              is_ast_schema_ad_hoc_migration_stmt(schema_attr));

    EXTRACT(version_annotation, schema_attr->left);
    EXTRACT_OPTION(vers, version_annotation->left);

    if (vers != schema_upgrade_version) {
      CSTR msg = dup_printf("CQL0187: @schema_upgrade_version not declared or doesn't match upgrade version %d for proc", vers);
      report_error(name_ast, msg, name);
      goto cleanup;
    }

    if (params) {
      report_error(params, "CQL0233: procedure previously declared as schema upgrade proc, it can have no args", name);
      goto cleanup;
    }
  }

  current_proc = ast;

  sem_inside_create_proc_stmt(ast);
  if (is_error(ast)) {
    goto cleanup;
  }

  if (schema_attr && !has_dml) {
    report_error(name_ast, "CQL0188: procedure is supposed to do schema migration but it doesn't have any DML", name);
    goto cleanup;
  }

  if (is_struct(ast->sem->sem_type)) {
    sem_validate_unique_names_struct_type(ast);
    if (is_error(ast)) {
      goto cleanup;
    }
  }

  if (existing_proc) {
    // we're comparsing the declaration against the definition
    // neither is an alias so we won't mark one as such
    bool_t matching = sem_validate_identical_procs(existing_proc, ast);
    if (!matching) {
      report_error(ast, "CQL0189: procedure declarations/definitions do not match", name);
      goto cleanup;
    }
  }

  // Check for valid autodrops, identity column, or fragment annotations
  // Note: these attribute are ignored on empty procs because they are meaningless.
  if (misc_attrs && stmt_list) {
    bool_t result_set_proc = has_result_set(ast);
    bool_t out_stmt_proc = has_out_stmt_result(ast);
    bool_t out_union_proc = has_out_union_stmt_result(current_proc);

    // no errors at this point
    Invariant(!is_error(misc_attrs));
   
    annotation_target = NULL;

    // If a stored proc is marked with the identity annotation then we generate the
    // "sameness" helper method that checks those columns.  The attributes should look like this:
    // [[identity=(col1, col2, ,...)]]
    uint32_t identity_count = sem_column_name_annotation(misc_attrs, find_identity_columns, "procedure identity");
    if (is_error(misc_attrs)) {
      goto cleanup;
    }

    if (identity_count && !result_set_proc && !out_stmt_proc && !out_union_proc) {
      report_error(misc_attrs, "CQL0240: identity annotation can only go on a procedure that returns a result set", name);
      record_error(misc_attrs);
      goto cleanup;
    }

    if (is_proc_shared_fragment(ast)) {
      sem_shared_fragment(misc_attrs, ast);
      if (is_error(ast)) {
        goto cleanup;
      }
    }

    sem_autotests(misc_attrs);
    if (is_error(misc_attrs)) {
      goto cleanup;
    }

    find_attribute_str(misc_attrs, sem_validate_one_interface, ast, "implements");
    if (is_error(ast)) {
      record_error(misc_attrs);
      goto cleanup;
    }

    uint32_t autodrop_count = sem_autodrops(misc_attrs);
    if (is_error(misc_attrs)) {
      goto cleanup;
    }

    if (autodrop_count) {
      if (!result_set_proc && !out_stmt_proc) {
        // note: out union doesn't need autodrop, it has no auto-fetcher, so autodrop isn't even valid
        report_error(misc_attrs, "CQL0234: autodrop annotation can only go on a procedure that returns a result set", name);
        record_error(misc_attrs);
        goto cleanup;
      }

      if (!has_dml) {
        report_error(misc_attrs, "CQL0236: autodrop annotation can only go on a procedure that uses the database", name);
        record_error(misc_attrs);
        goto cleanup;
      }
    }
  }

  // success!
  error = false;

cleanup:

  if (error) {
    record_error(ast);
  }

  // this has already been set (either the error case or the result)
  Invariant(ast->sem);

  ast->sem->region = current_region;
  name_ast->sem = ast->sem;
  current_proc = NULL;
  SYMTAB_CLEANUP(local_types);
  in_shared_fragment = false;
  BYTEBUF_CLEANUP(unitary_locals);
}

// Validate the name is unique in the given name list and attach the type
// to the name in the semantic type.  The only thing that can go wrong here
// is if the name is not unique.  The type ast has no error cases.
static void sem_typed_name(ast_node *typed_name, symtab *names) {
  Contract(is_ast_typed_name(typed_name));
  EXTRACT_NAME_AST(name_ast, typed_name->left);
  EXTRACT_STRING(name, name_ast);

  if (!symtab_add(names, name, typed_name)) {
    report_error(name_ast, "CQL0190: duplicate column name", name);
    record_error(typed_name);
    return;
  }

  sem_data_type_var(typed_name->right);
  typed_name->sem = typed_name->right->sem;
  typed_name->sem->name = name;
}

// Here we create a structure type from the list of typed names
// First each name is evaluated and checked for duplicates.
// One the types are determined, we create the struct type with
// the correct number of fields and simply copy in the type of
// each name into the sptr.
static void sem_typed_names(ast_node *head) {
  Contract(is_ast_typed_names(head));

  rewrite_typed_names(head);
  if (is_error(head)) {
    return;
  }

  symtab *names = symtab_new();
  uint32_t count = 0;

  for (ast_node *ast = head; ast; ast = ast->right, count++) {
    Contract(is_ast_typed_names(ast));
    EXTRACT(typed_name, ast->left);
    sem_typed_name(typed_name, names);

    if (is_error(typed_name)) {
      record_error(head);
      symtab_delete(names);
      return;
    }
  }

  symtab_delete(names);

  head->sem = new_sem(SEM_TYPE_STRUCT);
  sem_struct *sptr = new_sem_struct("_select_", count);
  head->sem->sptr = sptr;

  int32_t i = 0;
  for (ast_node *ast = head; ast; ast = ast->right, i++) {
    Contract(is_ast_typed_names(ast));
    EXTRACT(typed_name, ast->left);
    sptr->names[i] = typed_name->sem->name;
    sptr->semtypes[i] = typed_name->sem->sem_type;
    sptr->kinds[i] = typed_name->sem->kind;
  }

  Invariant(i == count);
}

// Function declarations are simpler than proc; there is
// no possibility of a result set return, there must be a return type
// (use proc if there is none).  Optional args as usual. Also args can be unchecked.
static void sem_declare_func_stmt(ast_node *ast) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  bool_t select_func = is_ast_declare_select_func_no_check_stmt(ast) || is_ast_declare_select_func_stmt(ast);
  bool_t non_select_func = is_ast_declare_func_no_check_stmt(ast) || is_ast_declare_func_stmt(ast);
  Contract(select_func || non_select_func);

  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT(params, func_params_return->left);
  EXTRACT_ANY_NOTNULL(ret_data_type, func_params_return->right);

  if (current_proc) {
    report_error(name_ast, "CQL0191: declared functions must be top level", name);
    record_error(ast);
    return;
  }

  Invariant(!locals);

  // CREATE FUNC [name] ( [params] ) [ret_data_type]

  if (find_proc(name)) {
    report_error(name_ast, "CQL0192: func name conflicts with proc name", name);
    record_error(ast);
    return;
  }

  ast_node *existing_func = find_func(name);
  ast_node *existing_unchecked_func = find_unchecked_func(name);

  bool_t no_check = is_ast_declare_select_func_no_check_stmt(ast) || is_ast_declare_func_no_check_stmt(ast);

  // Prevent redeclaration of normal function to be unchecked and vice versa
  if ((no_check && existing_func) || (!no_check && existing_unchecked_func))
  {
      report_error(ast, "CQL0486: function cannot be both a normal function and an unchecked function", name);
      record_error(ast);
      return;
  }

  // Check if it's ok to add a checked/unchecked func to their repsective symtabs
  if (no_check) {
    if (!existing_unchecked_func) {
      bool_t added = add_unchecked_func(ast, name);
      Invariant(added);
    }
  }
  else {
    if (!existing_func) {
      bool_t added = add_func(ast, name);
      Invariant(added);
    }
  }

  if (params) {
    current_variables = locals = symtab_new();
    arg_bundles = symtab_new();

    sem_params(params, NULL);

    symtab_delete(locals);
    locals = NULL;
    symtab_delete(arg_bundles);
    arg_bundles = NULL;
    current_variables = globals;

    if (is_error(params)) {
      record_error(ast);
      return;
    }

    if (select_func) {
      for (ast_node *item = params; item; item = item->right) {
        Contract(is_ast_params(item));
        EXTRACT_NOTNULL(param, item->left);
        sem_t sem_type = param->sem->sem_type;
        if (is_out_parameter(sem_type)) {
          report_error(param, "CQL0475: select functions cannot have out parameters", param->sem->name);
          record_error(param);
          record_error(ast);
          return;
        }
      }
    }
  }

  if (is_ast_typed_names(ret_data_type)) {
    sem_typed_names(ret_data_type);
  }
  else {
    sem_data_type_var(ret_data_type);
    if (is_error(ret_data_type)) {
      record_error(ast);
      return;
    }
  }

  // this also promotes errors up from the return type
  name_ast->sem = ast->sem = ret_data_type->sem;

  ast_node *matching_func = no_check ? existing_unchecked_func : existing_func;
  if (matching_func) {
    bool_t matching = sem_validate_identical_funcs(matching_func, ast);
    if (!matching) {
      report_error(name_ast, "CQL0193: duplicate function name", name);
      record_error(ast);
    }
  }

  if (will_add_current_entity()) {
    add_item_to_list(&all_functions_list, ast);
  }
}

// This is a helper function for handling select function declarations
static void sem_declare_select_func_stmt_common(ast_node *ast) {
  Contract(is_ast_declare_select_func_stmt(ast) || is_ast_declare_select_func_no_check_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(func_params_return, ast->right);
  EXTRACT_ANY_NOTNULL(ret_data_type, func_params_return->right);

  sem_declare_func_stmt(ast);
  if (is_error(ast)) {
    return;
  }

  if (symtab_find(builtin_funcs, name)) {
    report_error(name_ast, "CQL0314: select function does not require a declaration, it is a CQL built-in", name);
    record_error(ast);
    return;
  }

  if (core_type_of(ret_data_type->sem->sem_type) == SEM_TYPE_OBJECT) {
    report_error(name_ast, "CQL0347: select function may not return type OBJECT", name);
    record_error(ast);
    return;
  }

  sem_add_flags(ast, SEM_TYPE_SELECT_FUNC);

  bool_t adding_current_entity = will_add_current_entity();

  if (adding_current_entity) {
    add_item_to_list(&all_select_functions_list, ast);
  }
}

// This declares the unchecked parameters version of the function
// The same helper is used for all the declare func cases.  This
// will be a native call with external calling convention just
// like a no check proc.
static void sem_declare_func_no_check_stmt(ast_node *ast) {
  Contract(is_ast_declare_func_no_check_stmt(ast));
  sem_declare_func_stmt(ast);
}

// This declares a UDF that is known to SQLite.
// Note that we cannot verify that SQLite actually knows this UDF
// You have to take steps yourself to register the UDF or there will
// be run time errors.
static void sem_declare_select_func_stmt(ast_node *ast) {
  Contract(is_ast_declare_select_func_stmt(ast));
  sem_declare_select_func_stmt_common(ast);
}

// This is similar to sem_declare_select_func_stmt, except
// parameters are marked to be unchecked. So calls to this function
// won't have their arguments type checked.
static void sem_declare_select_func_no_check_stmt(ast_node *ast) {
  Contract(is_ast_declare_select_func_no_check_stmt(ast));
  sem_declare_select_func_stmt_common(ast);
}

// If we are processing an enumeration you are allowed to use the previous
// values of the enum in later values, so for instance you could do this
//   declare enum foo (
//     big = 100,
//     medium = big/2,
//     small = medium/2
//  );
//
// This code recursively walks enum tree and replaces names it can
// with names from the enum that is currently being declared.
// This is the only place unqualified enum names can appear.
//
// Note that qualified names are untouched and the current enum is not
// yet in scope.
static void sem_replace_seen_enum_values(ast_node *ast, symtab *names) {
  Contract(ast);

  // we're lookign only for unqualified names
  if (is_ast_dot(ast) || is_strlit(ast)) {
     return;
  }

  if (!is_ast_str(ast)) {
    if (ast_has_left(ast)) {
       sem_replace_seen_enum_values(ast->left, names);
    }
    if (ast_has_right(ast)) {
       sem_replace_seen_enum_values(ast->right, names);
    }
    return;
  }

  // this name might be one of the enums for the enum in flight
  EXTRACT_STRING(name, ast);

  symtab_entry *entry = symtab_find(names, name);
  ast_node *enum_value = entry ? (ast_node*)(entry->val) : NULL;

  // this is an evaluated enum, previously seen
  if (enum_value) {
    // it *must* have been evaluated
    Invariant(enum_value->left);
    Invariant(enum_value->left->sem);
    Invariant(enum_value->left->sem->value);

    ast_node *ast_new = eval_set(ast, enum_value->left->sem->value);
    sem_root_expr(ast_new, SEM_EXPR_CONTEXT_NONE);
    ast->sem = ast_new->sem;
  }
}

// Enums are a way of declaring scoped numeric constants, the name
// reference of the enum will be rewritten wherever it appears so that
// neither the C compiler nor SQLite will ever see a enum name.  Which
// is good because neither would know its meaning.
// Declaration follows the usual rules.
//   * the name must be unique or else the declaration must be identical
//     to any we've seen before.
//   * the enum member names must be unique
//   * the values must be valid expressions that can be resolved, all
//     the values will be cast to the type of the enum
//   * if there is no value specified then the value is one greater than
//     the last value seen, or 1 if it is the first value
//   * the value expressions can include other enums (because those will
//     become constants) and they can include names that were previously
//     defined in this enum, those are replaced with constants in a pre-step.
static void sem_declare_enum_stmt(ast_node *ast) {
  Contract(is_ast_declare_enum_stmt(ast));
  EXTRACT_NOTNULL(typed_name, ast->left);
  EXTRACT_NOTNULL(enum_values, ast->right);
  EXTRACT_NAME_AST(name_ast, typed_name->left);
  EXTRACT_STRING(name, name_ast);
  sem_data_type_column(typed_name->right);
  typed_name->sem = typed_name->right->sem;
  typed_name->sem->sem_type |= SEM_TYPE_NOTNULL;
  typed_name->sem->name = name;
  typed_name->sem->kind = name;

  if (current_proc) {
    report_error(name_ast, "CQL0358: declared enums must be top level", name);
    record_error(ast);
    return;
  }

  ast_node *existing_enum = find_enum(name);

  ast->sem = typed_name->sem;
  symtab *names = symtab_new();
  sem_t sem_type_enum = typed_name->sem->sem_type;

  eval_node result = EVAL_NIL;
  result.int32_value = 0;
  result.sem_type = SEM_TYPE_INTEGER;

  while (enum_values) {
     EXTRACT_NOTNULL(enum_value, enum_values->left);
     EXTRACT_NAME_AST(enum_name_ast, enum_value->left);
     EXTRACT_STRING(enum_name, enum_name_ast);
     EXTRACT_ANY(expr, enum_value->right);

     if (!symtab_add(names, enum_name, enum_value)) {
       report_error(enum_value, "CQL0354: duplicate enum member", enum_name);
       record_error(ast);
       goto cleanup;
     }

     if (expr) {
       sem_replace_seen_enum_values(expr, names);
       sem_root_expr(expr, SEM_EXPR_CONTEXT_NONE);
       eval(expr, &result);

       if (result.sem_type == SEM_TYPE_ERROR || result.sem_type == SEM_TYPE_NULL) {
         report_error(enum_value, "CQL0355: evaluation failed", enum_name);
         record_error(ast);
         goto cleanup;
       }
     }
     else {
       eval_add_one(&result);
     }

     eval_cast_to(&result, ast->sem->sem_type);
     enum_name_ast->sem = new_sem(sem_type_enum);
     enum_name_ast->sem->value = _ast_pool_new(eval_node);
     *enum_name_ast->sem->value = result;

     enum_values = enum_values->right;
  }

  if (existing_enum) {
    bool_t matching = sem_validate_identical_ddl(ast, existing_enum);
    if (!matching) {
      report_error(ast, "CQL0356: enum definitions do not match", name);
      record_error(ast);
      goto cleanup;
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      sem_add_flags(ast, SEM_TYPE_ALIAS);
    }
  }
  else {
    // note that enums  get a slightly different treatment when in previous schema
    // validation mode.  Most entites are not added to the name tables at all
    // we check it as we visit it and then move on;   We can't do that with enums
    // because they are used by later things (e.g. default values) and the "new" enums
    // (before the @previous_schema  marker) might be very different. We need the "old"
    // enums to calculate the default values or whatever and make sure they haven't changed.
    // So we can't just check them and move on like we do with other stuff.
    // At the end we'll have two symbol tables, the second of which we'll end up discarding.

    bool_t adding_current_entity = will_add_current_entity();

    // this enum is now visible, we still do this (even if previous schema mode)
    bool_t added = add_enum(ast, name);
    Invariant(added);

    // when processing previous schema we don't add the enum to the all enums list
    // so that it won't show up in JSON etc.
    if (adding_current_entity) {
      add_item_to_list(&all_enums_list, ast);

      // Add this enum to the list of global types like that enums and declare name types
      // can be search from a single storage.
      if (!add_named_type(name, ast)) {
        goto cleanup;
      }
    }
  }

cleanup:
   symtab_delete(names);
}

// Variables groups give us a convenient way of declare a bunch of unscoped
// variables that can be emitted as a unit.  This is a mirror to the enum
// and constant patterns.  The problem we're solving here is that if
// you declare a global variable then there is no way to just "extern" said
// variable.  The CQL declaration *is* the definition.  The group mechanism
// only gives you the extern declarations when you mention the group.  Though
// semantically this means nothing, they are still declared as usual.  When
// we go to codegen we emit (e.g.) "extern int foo".  To get the definition,
// you do "@emit_variable_group foo" then we will emit "int foo".  This
// mirrors enums and constants which have the same problem and solve it the
// same way.
static void sem_declare_group_stmt(ast_node *ast) {
  Contract(is_ast_declare_group_stmt(ast));

  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(stmt_list, ast->right);

  if (current_proc) {
    report_error(name_ast, "CQL0462: group declared variables must be top level", name);
    record_error(ast);
    return;
  }

  // We check for an existing variable group with the same name before analyzing
  // `stmt_list` so that we can bail out early if `ast` is an identical
  // redeclaration. If we didn't return early for the identical case, we'd run
  // into duplicate variable name errors when calling `sem_one_stmt` further
  // down.

  ast_node *existing_variable_group = find_variable_group(name);

  if (existing_variable_group) {
    bool_t matching = sem_validate_identical_ddl(ast, existing_variable_group);
    if (!matching) {
      report_error(ast, "CQL0463: variable definitions do not match in group", name);
      record_error(ast);
      return;
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      record_ok(ast);
      sem_add_flags(ast, SEM_TYPE_ALIAS);
      return;
    }

    record_ok(ast);
    return;
  }

  symtab_add(variable_groups, name, ast);

  while (stmt_list) {
     EXTRACT_ANY_NOTNULL(stmt, stmt_list->left);

     sem_one_stmt(stmt);
     if (is_error(stmt)) {
        record_error(ast);
        return;
     }

     stmt_list = stmt_list->right;
  }

  record_ok(ast);
}

// Here we will eventually emit the the actual group variable definitions into
// the output stream. In semantic analysis we only have to verify that the group
// name is valid. See `sem_declare_group_stmt` above for more details.
static void sem_emit_group_stmt(ast_node *ast) {
  Contract(is_ast_emit_group_stmt(ast));
  EXTRACT(name_list, ast->left);

  while (name_list) {
    EXTRACT_NAME_AST(name_ast, name_list->left);
    EXTRACT_STRING(name, name_ast);

    if (!find_variable_group(name)) {
      report_error(name_ast, "CQL0464: group not found", name);
      record_error(ast);
      return;
    }

    name_list = name_list->right;
  }

  record_ok(ast);
}

// Constant groups are a way of declaring arbitrary unscoped constants, the name
// reference of the constant will be rewritten wherever it appears so that
// neither the C compiler nor SQLite will ever see a constant name.  Which
// is good because neither would know its meaning.
// Declaration follows the usual rules.
//   * the group name must be unique or else the declaration must be identical
//     to any we've seen before.
//   * the constant names must be unique
//   * the values must be valid expressions that can be resolved
//   * the value expressions can include other constants
//   * numeric constants expressions are evaluated at compile time
//   * string constants must be a string literal
static void sem_declare_const_stmt(ast_node *ast) {
  Contract(is_ast_declare_const_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(const_values, ast->right);

  if (current_proc) {
    report_error(name_ast, "CQL0358: declared constants must be top level", name);
    record_error(ast);
    return;
  }

  ast_node *existing_constant_group = find_constant_group(name);

  if (!existing_constant_group) {
    symtab_add(constant_groups, name, ast);
  }

  eval_node result = EVAL_NIL;

  while (const_values) {
     EXTRACT_NOTNULL(const_value, const_values->left);
     EXTRACT_NAME_AST(const_name_ast, const_value->left);
     EXTRACT_STRING(const_name, const_name_ast);
     EXTRACT_ANY(expr, const_value->right);

     if (!existing_constant_group) {
       if (!symtab_add(constants, const_name, const_value)) {
         report_error(const_value, "CQL0354: duplicate constant name", const_name);
         record_error(ast);
         return;
       }
     }

     sem_root_expr(expr, SEM_EXPR_CONTEXT_NONE);
     if (is_error(expr)) {
        record_error(ast);
        return;
     }

     // refetch, this could be rewritten
     expr = const_value->right;

     if (is_numeric(expr->sem->sem_type)) {
       eval(expr, &result);

       if (result.sem_type != SEM_TYPE_ERROR && result.sem_type != SEM_TYPE_NULL) {
         const_value->sem = expr->sem;
         const_name_ast->sem = expr->sem;
         const_name_ast->sem->value = _ast_pool_new(eval_node);
         *const_name_ast->sem->value = result;
         const_values = const_values->right;
         continue;
       }
     }
     else if (is_strlit(expr)) {
       const_name_ast->sem = expr->sem;
       const_value->sem = expr->sem;
       const_values = const_values->right;
       continue;
     }

     CHARBUF_OPEN(tmp);
     bprintf(&tmp, "%s = ", const_name);
     CSTR expr_text = dup_expr_text_buffer(&tmp, expr);

     report_error(expr, "CQL0177: global constants must be either constant numeric expressions or string literals", expr_text);
     record_error(expr);
     record_error(ast);
     CHARBUF_CLOSE(tmp);
     return;

  }

  if (existing_constant_group) {
    bool_t matching = sem_validate_identical_ddl(ast, existing_constant_group);
    if (!matching) {
      report_error(ast, "CQL0356: const definitions do not match", name);
      record_error(ast);
      return;
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      record_ok(ast);
      sem_add_flags(ast, SEM_TYPE_ALIAS);
      return;
    }
  }
  else {
    // note that consts get a slightly different treatment when in previous schema
    // validation mode.  Most entites are not added to the name tables at all
    // we check it as we visit it and then move on;   We can't do that with consts
    // because they are used by later things (e.g. default values) and the "new" constants
    // (before the @previous_schema  marker) might be very different. We need the "old"
    // consts to calculate the default values or whatever and make sure they haven't changed.
    // So we can't just check them and move on like we do with other stuff.
    // At the end we'll have two symbol tables, the second of which we'll end up discarding.

    bool_t adding_current_entity = will_add_current_entity();

    // when processing previous schema we don't add the const to the all consts list
    // so that it won't show up in JSON etc.
    if (adding_current_entity) {
      add_item_to_list(&all_constant_groups_list, ast);
    }
  }

  record_ok(ast);
}

// Declares an external procedure that can be called with any combination of C args
// this is intended for procedures like `printf` that cannot be readily described with
// CQL strict types.
static void sem_declare_proc_no_check_stmt(ast_node *ast) {
  Contract(is_ast_declare_proc_no_check_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  if (find_proc(name)) {
    report_error(ast, "CQL0404: procedure cannot be both a normal procedure and an unchecked procedure", name);
    record_error(ast);
    return;
  }

  if (find_interface_type(name)) {
    report_error(ast, "CQL0481: proc name conflicts with interface name", name);
    record_error(ast);
    return;
  }

  // it can be added more than once, no need to check the return code
  add_unchecked_proc(ast, name);
  record_ok(ast);
}

// There are three forms of this declaration:
// 1. a regular proc with no DML
//    declare proc X(id integer);
// 2. a regular proc that uses DML (needs a db paramter and returns rc)
//    declare proc X(id integer) using transaction;
// 3. a proc that returns a result set, you provide the result columns
//    declare proc X(id integer) : (A bool not null, B text);
static void sem_declare_proc_stmt(ast_node *ast) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_declare_proc_stmt(ast));
  EXTRACT_NOTNULL(proc_name_type, ast->left);
  EXTRACT_NAME_AST(name_ast, proc_name_type->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_OPTION(type, proc_name_type->right);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT(params, proc_params_stmts->left);

  if (current_proc) {
    report_error(name_ast, "CQL0194: declared procedures must be top level", name);
    record_error(ast);
    return;
  }

  Invariant(!locals);

  // CREATE PROC [name] ( [params] )

  if (find_unchecked_proc(name)) {
    report_error(ast, "CQL0404: procedure cannot be both a normal procedure and an unchecked procedure", name);
    record_error(ast);
    return;
  }

  if (find_func(name)) {
    report_error(name_ast, "CQL0195: proc name conflicts with func name", name);
    record_error(ast);
    return;
  }

  if (find_interface_type(name)) {
    report_error(ast, "CQL0481: proc name conflicts with interface name", name);
    record_error(ast);
    return;
  }

  ast_node *existing_proc = find_proc(name);
  if (!existing_proc) {
    // proc doesn't exist, ok to add it
    bool_t added = add_proc(ast, name);
    Invariant(added);
  }

  if (params) {
    current_variables = locals = symtab_new();
    arg_bundles = symtab_new();

    sem_params(params, NULL);

    symtab_delete(locals);
    locals = NULL;
    symtab_delete(arg_bundles);
    arg_bundles = NULL;
    current_variables = globals;

    if (is_error(params)) {
      record_error(ast);
      return;
    }
  }

  if (type & PROC_FLAG_STRUCT_TYPE) {
    EXTRACT_NOTNULL(typed_names, proc_params_stmts->right);
    sem_typed_names(typed_names);

    if (is_error(typed_names)) {
      record_error(ast);
      return;
    }

    ast->sem = typed_names->sem;
    ast->sem->sptr->struct_name = name;
  }
  else {
    ast->sem = new_sem(SEM_TYPE_OK);
  }

  if (type & PROC_FLAG_USES_OUT) {
    sem_add_flags(ast, SEM_TYPE_USES_OUT);
  }

  if (type & PROC_FLAG_USES_DML) {
    sem_add_flags(ast, SEM_TYPE_DML_PROC);
  }

  if (type & PROC_FLAG_USES_OUT_UNION) {
    sem_add_flags(ast, SEM_TYPE_USES_OUT_UNION);
  }

  name_ast->sem = ast->sem;

  if (existing_proc) {
    bool_t matching = sem_validate_identical_procs(existing_proc, ast);
    if (!matching) {
      report_error(ast, "CQL0196: procedure declarations/definitions do not match", name);
      record_error(ast);
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      sem_add_flags(ast, SEM_TYPE_ALIAS);
    }
  }
}

static void sem_declare_interface_stmt(ast_node *ast) {
  Contract(!current_joinscope);  // I don't belong inside a select(!)
  Contract(is_ast_declare_interface_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left)
  EXTRACT_STRING(name, ast->left);
  EXTRACT_NOTNULL(proc_params_stmts, ast->right);
  EXTRACT_NOTNULL(typed_names, proc_params_stmts->right);

  if (current_proc) {
    report_error(name_ast, "CQL0480: declared interface must be top level", name);
    record_error(ast);
    return;
  }

  Invariant(!locals);

  if (find_unchecked_proc(name) || find_proc(name)) {
    report_error(ast, "CQL0478: interface name conflicts with procedure name", name);
    record_error(ast);
    return;
  }

  if (find_func(name)) {
    report_error(name_ast, "CQL0477: interface name conflicts with func name", name);
    record_error(ast);
    return;
  }

  ast_node *existing_interface = find_interface_type(name);
  if (!existing_interface) {
    bool_t added = add_interface_type(ast, name);
    Invariant(added);
  }

  sem_typed_names(typed_names);

  if (is_error(typed_names)) {
    record_error(ast);
    return;
  }

  ast->sem = typed_names->sem;
  ast->sem->sptr->struct_name = name;

  if (existing_interface) {
    bool_t matching = sem_validate_identical_text(existing_interface, ast, gen_one_stmt, NULL);

    if (!matching) {
      report_error(ast, "CQL0479: interface declarations do not match", name);
      record_error(ast);
    }
    else {
      // this will let us find the duplicate later, it marks this as not authoritative
      sem_add_flags(ast, SEM_TYPE_ALIAS);
    }
  }
}

// This helper verifies that the name of a variable is ok in the current scope
//  * globals cannot conflict with globals or table/view names
//  * locals cannot conflict with each other
//  * scopes do not nest in CQL so any local is the same anywhere no matter
//    where it appears, it can be used any point later.  This could be changed.
static bool_t sem_verify_legal_variable_name(ast_node *variable, CSTR name) {
  // Do not erroneously warn about duplicate variables if we're reanalyzing
  // a statement list within a loop.
  if (current_loop_analysis_state != LOOP_ANALYSIS_STATE_REANALYZE) {
    if (symtab_find(current_variables, name)) {
      report_error(variable, "CQL0197: duplicate variable name in the same scope", name);
      return false;
    }
  }

  // global variables can't conflict with table names, not even deleted table names
  if (current_variables == globals && find_table_or_view_even_deleted(name)) {
    report_error(variable, "CQL0198: global variable hides table/view name", name);
    return false;
  }

  return true;
}

// This declares a new local or global variable that is not a cursor.
// The type is computed with the same helper that is used for analyzing
// column definitions.  Once we have the type we walk the list of variable
// names, check them for duplicates and such (see above) and assign their type.
// Variables gain the SEM_TYPE_VARIABLE info in their semantic node and
// their sem->name field is set.  Later if any case-insensitive match
// hits the variable, the sem->name field can be used to get the canonical name.
static void sem_declare_vars_type(ast_node *declare_vars_type) {
  Contract(is_ast_declare_vars_type(declare_vars_type));
  EXTRACT_NOTNULL(name_list, declare_vars_type->left);
  EXTRACT_ANY_NOTNULL(data_type, declare_vars_type->right);

  // DECLARE [name_list] [data_type]
  sem_data_type_var(data_type);
  if (is_error(data_type)) {
    record_error(declare_vars_type);
    return;
  }
  sem_t sem_type = data_type->sem->sem_type;
  Invariant(is_unitary(sem_type));

  bool_t error = false;

  for (ast_node *ast = name_list; ast; ast = ast->right) {
    EXTRACT_ANY_NOTNULL(variable, ast->left);
    EXTRACT_STRING(name, variable);

    if (!sem_verify_legal_variable_name(variable, name)) {
      record_error(variable);
      record_error(ast);
      error = true;
      continue;
    }

    variable->sem = ast->sem = new_sem(sem_type | SEM_TYPE_VARIABLE);
    if (variable_should_require_initialization(variable->sem->sem_type)) {
      variable->sem->sem_type |= SEM_TYPE_INIT_REQUIRED;
    }
    variable->sem->name = name;
    variable->sem->kind = data_type->sem->kind;
    add_variable(name, variable);
  }

  if (error) {
    record_error(declare_vars_type);
  }
  else {
    declare_vars_type->sem = new_sem(sem_type);
    declare_vars_type->sem->kind = data_type->sem->kind;
  }
}

// This declare a new local or global name for a type. It validate
// the data type and store the name declared. The name can be use
// in any places in the cql syntax where data type are.
static void sem_declare_named_type(ast_node *ast) {
  Contract(is_ast_declare_named_type(ast));
  EXTRACT_ANY(name_ast, ast->left);
  EXTRACT_ANY_NOTNULL(data_type, ast->right);
  EXTRACT_STRING(name, name_ast);

  // DECLARE TYPE [name] [data_type]
  sem_data_type_var(data_type);
  if (is_error(data_type)) {
    record_error(ast);
    return;
  }

  // this also promotes errors up from the data type
  name_ast->sem = ast->sem = data_type->sem;

  if (!is_error(ast)) {
    if (!add_named_type(name, ast)) {
      return;
    }
  }
}

// There are two forms of the declare cursor, both of which allow this
// code to infer the type of the cursor.
//   * declare foo cursor for select etc.
//     * the type of the cursor is the net struct type of the select list
//   * declare foo cursor for call proc();
//     * proc must be statement that produces a result set via select (see above)
//     * the type of the cursor is the struct of the select returned by the proc
//     * note if there is more than one loose select in the proc they must match exactly
//   * cursor names have the same rules duplicates as other variables
// With this in mind, both cases simply recurse on either the select or the call
// and then pull out the struct type and use it for the cursor.
static void sem_declare_cursor(ast_node *ast) {
  Contract(is_ast_declare_cursor(ast));
  EXTRACT_ANY_NOTNULL(cursor, ast->left);
  EXTRACT_STRING(name, cursor);

  sem_t out_union_and_dml = 0;

  EXTRACT_ANY_NOTNULL(row_source, ast->right);

  if (is_row_source(row_source)) {

    // DECLARE [name] CURSOR FOR [select_stmt]
    // DECLARE [name] CURSOR FOR [explain_stmt]
    // etc.
    sem_any_row_source(row_source);
    if (is_error(row_source)) {
      record_error(ast);
      return;
    }

    // We need to know whether or not the cursor source of data is a DML.
    // A DML source require a not null db pointer. This info is used to
    // decided whether we can do encoding/decoding of result_set's fields.
    out_union_and_dml = SEM_TYPE_DML_PROC;
    has_dml = 1;
  }
  else if (is_insert_stmt(row_source) || is_delete_stmt(row_source) || is_update_stmt(row_source)) {
    report_error(row_source, "CQL0168: statement requires a RETURNING clause to be used as a source of rows", NULL);
    record_error(row_source);
    record_error(ast);
    return;
  }
  else if (is_ast_call_stmt(row_source)) {
    EXTRACT_NOTNULL(call_stmt, row_source);

    // DECLARE [name] CURSOR FOR [call_stmt]]
    sem_call_stmt_opt_cursor(call_stmt, name);
    if (is_error(call_stmt)) {
      record_error(ast);
      return;
    }

    if (!is_struct(call_stmt->sem->sem_type)) {
      report_error(call_stmt, "CQL0199: cursor requires a procedure that returns a result set via select", name);
      record_error(ast);
      return;
    }

    if (has_out_stmt_result(call_stmt)) {
      report_error(ast, "CQL0270: use FETCH FROM for procedures that returns a cursor with OUT", name);
      record_error(ast);
      return;
    }

    out_union_and_dml = has_out_union_stmt_result(call_stmt) ? SEM_TYPE_USES_OUT_UNION : 0;
    // We need to know whether or not the cursor source of data is a DML.
    // A DML source require a not null db pointer. This info is used to
    // decided whether we can do encoding/decoding of result_set's fields.
    out_union_and_dml |= call_stmt->sem->sem_type & SEM_TYPE_DML_PROC;
  }
  else {
    sem_declare_cursor_for_expr(ast);
    return;
  }

  if (!sem_verify_legal_variable_name(ast, name)) {
    record_error(ast->left);
    record_error(ast);
    return;
  }

  // SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE <=> it's a cursor
  cursor->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | out_union_and_dml);
  cursor->sem->sptr = ast->right->sem->sptr;
  cursor->sem->name = name;
  ast->sem = cursor->sem;

  add_variable(name, cursor);
}

// This is the "unboxing" primitive for cursors.  The idea here is that
// you have an object variable with a statement in it and you want to
// make a cursor over that statement.
static void sem_declare_cursor_for_expr(ast_node *ast) {
  Contract(is_ast_declare_cursor(ast));
  EXTRACT_ANY_NOTNULL(cursor, ast->left);
  EXTRACT_ANY_NOTNULL(expr, ast->right);
  EXTRACT_STRING(name, cursor);

  // DECLARE cursor_name CURSOR FOR expr

  if (!sem_verify_legal_variable_name(ast, name)) {
    record_error(ast->left);
    record_error(ast);
    return;
  }

  sem_root_expr(expr, SEM_EXPR_CONTEXT_NONE);
  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  // the indicated type must be a valid shape name (one we could use in LIKE T)
  ast_node *like_target = sem_find_likeable_from_expr_type(expr);
  if (!like_target) {
    record_error(ast);
    return;
  }

  sem_t cursor_flags = SEM_TYPE_BOXED;
  if (ends_in_set(expr->sem->kind)) {
    cursor_flags = SEM_TYPE_USES_OUT_UNION;
  }

  // the cursor is marked as BOXED because there is a boxed object controlling its lifetime

  // SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE <=> it's a cursor
  cursor->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | cursor_flags);
  cursor->sem->sptr = like_target->sem->sptr;
  cursor->sem->name = name;
  ast->sem = cursor->sem;

  add_variable(name, cursor);
}

// Verify that the indicated variable has a valid cursor type
// and return the type associated with it.  The rules are:
//  * the variable must be of type object<T CURSOR> or object<T SET> for some T
//  * the T part must be a "likeable" expression (i.e. a shape)
// there is some string massaging to check for and remove the
// " CURSOR" or " SET" and a temporary node is created so we can re-use
// the usual likeable name check.
cql_noexport ast_node *sem_find_likeable_from_expr_type(ast_node *expr) {
  // it has to be a typed object expression
  if (!is_object(expr->sem->sem_type) || !expr->sem->kind) {
    CSTR expr_text = dup_expr_text(expr);
    report_error(expr, "CQL0346: expression must be of type object<T cursor> where T is a valid shape name", expr_text);
    return NULL;
  }

  CSTR kind = expr->sem->kind;

  size_t len = strlen(kind);
  size_t len_tail = ends_in_cursor(kind);
  if (!len_tail) {
    len_tail = ends_in_set(kind);
    if (!len_tail) {
      CSTR expr_text = dup_expr_text(expr);
      report_error(expr, "CQL0343: variable must be of type object<T CURSOR> or object<T SET> where T is a valid shape name", expr_text);
      return NULL;
    }
  }

  // now we extract just the type name having ignored the " CURSOR" part.
  CHARBUF_OPEN(tmp);
  for (int32_t i = 0; i < len - len_tail; i++) {
    bputc(&tmp, kind[i]);
  }

  // We make a like node for the object type (which is itself not in AST here)
  // so that we can use the standard likeable helpers for error checking
  AST_REWRITE_INFO_SET(expr->lineno, expr->filename);
  ast_node *type_node = new_ast_str(tmp.ptr);
  ast_node *like_node = new_ast_like(type_node, NULL);
  AST_REWRITE_INFO_RESET();

  CHARBUF_CLOSE(tmp);

  // the indicated type must be a valid shape name (one we could use in LIKE T)
  ast_node *like_target = sem_find_shape_def_base(like_node, LIKEABLE_FOR_VALUES);

  // we have already checked the name when the object was declared, or else we made the name ourselves
  // in all these cases it MUST be valid already or else something is seriously wrong.
  Invariant(like_target);

  return like_target;
}

// This is the boxing primitive for cursors.  We will take the statement cursor
// and construct an object variable with a type name that corresponds to the
// shape of the cursor.  This variable can then be passed around as usual
// and at a later time you can extract the underlying statement with the
// unboxing primitive above.  There are a number of things that can go wrong
// here.  There must be a suitable cursor, a suitable shape, and the shape
// must exactly match the cursor shape for starters.
static void sem_set_from_cursor(ast_node *ast) {
  Contract(is_ast_set_from_cursor(ast));
  EXTRACT_ANY_NOTNULL(cursor, ast->right);
  EXTRACT_STRING(cursor_name, cursor);
  EXTRACT_STRING(var_name, ast->left);

  // must be a valid cursor
  sem_cursor(cursor);
  if (is_error(cursor)) {
    record_error(ast);
    return;
  }

  // SET [name] FROM CURSOR [cursor_name]
  ast_node *var = find_local_or_global_variable(var_name);

  if (!var) {
    report_error(ast, "CQL0173: variable not found", var_name);
    record_error(ast);
    return;
  }

  ast->left->sem = var->sem;

  // the indicated type must be a valid shape name (one we could use in LIKE T)
  ast_node *like_target = sem_find_likeable_from_expr_type(var);
  if (!like_target) {
    record_error(ast);
    return;
  }

  // the cursor has to be a statement cursor
  if (cursor->sem->sem_type & SEM_TYPE_VALUE_CURSOR) {
    report_error(cursor,
       "CQL0261: cursor did not originate from a SQLite statement, it only has values", cursor->sem->name);
    record_error(ast);
    return;
  }

  sem_verify_identical_columns(like_target, cursor, "in the cursor and the variable type");
  if (is_error(cursor)) {
    record_error(ast);
    return;
  }

  // Tag the cursor *variable* (i.e. the AST from the original definition site
  // of the cursor) as a boxed cursor. This is necessary because we need to
  // have this information available when we process the declaration in codegen
  // before we see that it was boxed.
  ast_node *cursor_var = find_local_or_global_variable(cursor->sem->name);
  Invariant(cursor_var);
  Invariant(is_cursor(cursor_var->sem->sem_type));
  sem_add_flags(cursor_var, SEM_TYPE_BOXED);

  ast->sem = cursor_var->sem;
}

// Here we're going to make a new value cursor using the indicated name for the shape.
// The name has to be "likeable" meaning it refers to some named thing with a shape
// such as a table, a view, another cursor, or a procedure that returns a result set.
// These are the so called "value cursors" in that they have no underlying statement
// that they move through.  You can just load them up with a row and pass them around.
static void sem_declare_cursor_like_name(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_name(ast));
  EXTRACT_ANY_NOTNULL(new_cursor_ast, ast->left);
  EXTRACT_STRING(new_cursor_name, new_cursor_ast);
  EXTRACT_ANY_NOTNULL(shape_def, ast->right);

  // no duplicates allowed
  if (!sem_verify_legal_variable_name(ast, new_cursor_name)) {
    record_error(new_cursor_ast);
    record_error(ast);
    return;
  }

  // must be a valid shape
  ast_node *found_shape = sem_find_shape_def(shape_def, LIKEABLE_FOR_VALUES);
  if (!found_shape) {
    record_error(ast);
    return;
  }

  // good to go, make our cursor, with storage.
  shape_def->sem = found_shape->sem;
  new_cursor_ast->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | SEM_TYPE_VALUE_CURSOR | SEM_TYPE_HAS_SHAPE_STORAGE);
  new_cursor_ast->sem->sptr = found_shape->sem->sptr;
  new_cursor_ast->sem->name = new_cursor_name;
  ast->sem = new_cursor_ast->sem;

  add_variable(new_cursor_name, new_cursor_ast);
}

// Here we make a value cursor from the template of a select statement.
// The select statement only provides type shape, it's the most flexible way to
// create a structure type.  Note:  we want to add other ways like a table name
// or the name of another cursor.  But for now we have the most powerful one
// if also the most verbose.
// * The select must be itself valid.
// * The cursor name must be unique
static void sem_declare_cursor_like_select(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_select(ast));
  Contract(is_select_variant(ast->right));
  EXTRACT_ANY_NOTNULL(cursor, ast->left);
  EXTRACT_STRING(name, cursor);

  EXTRACT_ANY_NOTNULL(select_stmt, ast->right);

  // DECLARE [name] CURSOR LIKE [select_stmt]
  {
    // the select statement doesn't count as DML because we won't be running it
    bool_t has_dml_saved = has_dml;
    // this handles more than select but that's ok
    sem_any_row_source(select_stmt);
    has_dml = has_dml_saved;
  }

  if (is_error(select_stmt)) {
    record_error(ast);
    return;
  }

  sem_verify_no_anon_no_null_columns(select_stmt);
  if (is_error(select_stmt)) {
    record_error(ast);
    return;
  }

  if (!sem_verify_legal_variable_name(ast, name)) {
    record_error(ast->left);
    record_error(ast);
    return;
  }

  // SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE <=> it's a cursor
  cursor->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | SEM_TYPE_VALUE_CURSOR | SEM_TYPE_HAS_SHAPE_STORAGE);
  cursor->sem->sptr = select_stmt->sem->sptr;
  cursor->sem->name = name;
  ast->sem = cursor->sem;

  add_variable(name, cursor);
}


// Here we make a value cursor from a list of typed names
// * the typed names must be valid types/names with no duplicate column names etc.
//   * they make include rewrites using LIKE internally
// * The cursor name must be unique
static void sem_declare_cursor_like_typed_names(ast_node *ast) {
  Contract(is_ast_declare_cursor_like_typed_names(ast));
  EXTRACT_NOTNULL(typed_names, ast->right);
  EXTRACT_ANY_NOTNULL(cursor, ast->left);
  EXTRACT_STRING(name, cursor);

  // DECLARE [name] CURSOR LIKE ( [select_stmt] )

  sem_typed_names(typed_names);
  if (is_error(typed_names)) {
    record_error(ast);
    return;
  }

  if (!sem_verify_legal_variable_name(ast, name)) {
    record_error(ast->left);
    record_error(ast);
    return;
  }

  // SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE <=> it's a cursor
  cursor->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | SEM_TYPE_VALUE_CURSOR | SEM_TYPE_HAS_SHAPE_STORAGE);
  cursor->sem->sptr = typed_names->sem->sptr;
  cursor->sem->name = name;
  ast->sem = cursor->sem;

  add_variable(name, cursor);
}


// Here we're just checking that the proc mentioned in the call statement uses the OUT cursor form
static void sem_call_stmt_has_out_stmt_result_for_cursor(ast_node *call_stmt, CSTR name) {
  Contract(is_ast_call_stmt(call_stmt));

  if (!has_out_stmt_result(call_stmt)) {
    report_error(call_stmt, "CQL0203: cursor requires a procedure that returns a cursor with OUT", name);
    record_error(call_stmt);
    return;
  }
}

// This statement declares a cursor that will be based on the return type of a procedure
// when using this form the cursor is also fetched, hence the name.  The fetch result of
// there stored proc will be used for the value.  At this point we use its type only.
// * the call must be semantically valid
// * the procedure must return an OUT parameter (not a result set)
// * the cursor name must be unique
static void sem_declare_value_cursor(ast_node *ast) {
  Contract(is_ast_declare_value_cursor(ast));
  EXTRACT_ANY_NOTNULL(cursor, ast->left);
  EXTRACT_STRING(name, cursor);

  EXTRACT_NOTNULL(call_stmt, ast->right);

  // DECLARE [name] CURSOR FETCH FROM [call_stmt]]
  sem_call_stmt_opt_cursor(call_stmt, name);
  if (is_error(call_stmt)) {
    record_error(ast);
    return;
  }

  sem_call_stmt_has_out_stmt_result_for_cursor(call_stmt, name);
  if (is_error(call_stmt)) {
    record_error(ast);
    return;
  }

  if (!sem_verify_legal_variable_name(ast, name)) {
    record_error(ast->left);
    record_error(ast);
    return;
  }

  // SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE <=> it's a cursor
  cursor->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_VARIABLE | SEM_TYPE_VALUE_CURSOR | SEM_TYPE_HAS_SHAPE_STORAGE);
  cursor->sem->sptr = ast->right->sem->sptr;
  cursor->sem->name = name;
  cursor->sem->sem_type |= call_stmt->sem->sem_type & SEM_TYPE_DML_PROC;
  ast->sem = cursor->sem;

  add_variable(name, cursor);
}

static ast_node *sem_synthesize_current_locals() {
  if (!current_proc) {
    return NULL;
  }

  AST_REWRITE_INFO_SET(current_proc->lineno, current_proc->filename);
  CSTR locals_name = "LOCALS";

  uint32_t usable_locals = unitary_locals->used / sizeof(ast_node *);
  ast_node **l_syms = (ast_node **)unitary_locals->ptr;

  sem_struct *sptr = new_sem_struct(locals_name, usable_locals);

  ast_node *ast_locals = new_ast_str(locals_name);
  ast_locals->sem = new_sem(SEM_TYPE_STRUCT | SEM_TYPE_HAS_SHAPE_STORAGE);
  ast_locals->sem->name = locals_name;
  ast_locals->sem->sptr = sptr;

  for (uint32_t i = 0; i < usable_locals; i++) {
    ast_node *var = l_syms[i];
    Invariant(is_unitary(var->sem->sem_type));

    sptr->names[i] = var->sem->name;
    sptr->kinds[i] = var->sem->kind;
    sptr->semtypes[i] = var->sem->sem_type;
  }

  AST_REWRITE_INFO_RESET();

  return ast_locals;
}


// Try to analyze the name first as an arg bundle, and that fails, then try as a cursor
// these are the two shapes that hold data.
cql_noexport void sem_any_shape(ast_node *ast) {
  EXTRACT_STRING(name, ast);
  ast_node *shape = find_arg_bundle(name);

  if (shape) {
    ast->sem = shape->sem;
    return;
  }

  // give better error messages if the shape is "ARGUMENTS"
  if (!strcmp("ARGUMENTS", name)) {
    if (current_proc) {
      EXTRACT_STRING(proc_name, get_proc_name(current_proc));
      report_error(ast, "CQL0340: FROM ARGUMENTS used in a procedure with no arguments", proc_name);
    }
    else {
      report_error(ast, "CQL0163: FROM ARGUMENTS construct is only valid inside a procedure", NULL);
    }
    record_error(ast);
    return;
  }

  // try it as a cursor (whatever error happens here will be the final answer)
  sem_cursor(ast);
}

// Cursors appear in only a few places legally as an actual cursor:
//
//  * fetch cursor [one of the fetch flavors]
//  * close cursor
//  * on the left side of X.field where X is a cursor that was autofetched
//  * on the right side of a `declare cursor C like ...` statement.
//
//  In those cases, we specifically verify that is, in fact, a cursor.  In other
//  cases, the name of a cursor refers to a boolean that indicates whether the
//  cursor presently has a value.
cql_noexport void sem_cursor(ast_node *ast) {
  if (!is_id(ast)) {
    CSTR expr_text = dup_expr_text(ast);
    report_error(ast, "CQL0205: not a cursor", expr_text);
    record_error(ast);
    return;
  }

  EXTRACT_STRING(name, ast);

  sem_resolve_id(ast, name, NULL);
  if (is_error(ast)) {
    return;
  }

  if (!is_cursor(ast->sem->sem_type)) {
    report_error(ast, "CQL0205: not a cursor", name);
    record_error(ast);
    return;
  }
}

// If we can consume the ast as a cursor then do so
// used if we might have a cursor context
static bool_t sem_try_as_cursor(ast_node *ast, bool_t *hard_fail) {
  *hard_fail = false;

  if (!is_id(ast)) {
    return false;
  }

  EXTRACT_STRING(name, ast);

  sem_resolve_id(ast, name, NULL);
  if (is_error(ast)) {
    // don't try again, we have no hope of this ever resolving
    *hard_fail = true;
    return false;
  }

  return is_cursor(ast->sem->sem_type);
}

// Information about switch cases, and the origin of the constants
// this will be used to ensure enums are covered and there are no duplicates in the case list.
typedef struct case_val {
  int64_t value;
  ast_node *source;
} case_val;

// Switch cases semantic analysis:
// * the case expressions must be constant expressions
// * the case expressions must promote to the type of the expression with no loss
// * if all_values was specified you can't use else or it's a joke
static void sem_switch_expr_list(ast_node *ast, sem_t core_type, bytebuf *case_data) {
  Contract(is_ast_expr_list(ast));
  ast_node *head = ast;

  while (ast) {
    Contract(is_ast_expr_list(ast));
    EXTRACT_ANY_NOTNULL(expr, ast->left);
    sem_root_expr(expr, SEM_EXPR_CONTEXT_NONE);
    if (is_error(expr)) {
      record_error(head);
      return;
    }
    // we're going to do an immediate eval and it might have been replaced
    // by enum rewrite.. so we have to fetch the node again.
    expr = ast->left;
    Invariant(expr);

    sem_t core_type_expr = core_type_of(expr->sem->sem_type);
    if (core_type_expr > core_type) {
      report_error(expr, "CQL0382: type of a WHEN expression is bigger than the type of the SWITCH expression", NULL);
      record_error(head);
      return;
    }

    eval_node result = EVAL_NIL;
    eval(expr, &result);

    if (result.sem_type == SEM_TYPE_ERROR) {
      report_error(expr, "CQL0380: WHEN expression cannot be evaluated to a constant", NULL);
      record_error(head);
      return;
    }

    eval_cast_to(&result, SEM_TYPE_LONG_INTEGER);

    case_val val = {
      .value = result.int64_value,
      .source = expr
    };

    bytebuf_append(case_data, &val, sizeof(val));
    ast = ast->right;
  }

  record_ok(head);
}

static int case_val_comparator(const void *v1, const void *v2) {
  case_val *c1 = (case_val *)v1;
  case_val *c2 = (case_val *)v2;

  if (c1->value < c2->value) return -1;
  if (c1->value > c2->value) return 1;
  return 0;
}

// Here we have a few things to do:
//  * first we verify that the switch expression is indeed an enum type
//  * we already know that the type of the expression is integral so we don't have to check that again
//  * at that point we need all the enum values, we get all the ones that do not start with "_"
//     * this allows you to have psuedo-values like "_max" in your enum, simple convention
//  * the enum may have aliases so we have to dedupe the values, this gives us the final count of items
//     * we can de-dupe in place
//  * then we sort the enum values, the case values are already sorted from the duplicates check
//  * then we merge the case values and the enum values
//    * we only need one index since we are going to error out at the first divergence of the merge
//    * we report extra values on either side as "missing" or "invalid"
//  * if the merge ends prematurely, whichever side has more values yields an error for missing or extra values
// After that clean up the memory and we're done...
static void sem_check_all_values_condition(ast_node *expr, bytebuf *case_buffer) {
  bytebuf *enum_buffer = _ast_pool_new(bytebuf);
  bytebuf_open(enum_buffer);

  uint32_t case_count = case_buffer->used / sizeof(case_val);
  case_val *case_vals = (case_val *)case_buffer->ptr;

  CSTR kind = expr->sem->kind;
  ast_node *enum_stmt = NULL;

  if (!kind || !(enum_stmt = find_enum(kind))) {
    report_error(expr, "CQL0386: SWITCH ... ALL VALUES is used but the switch expression is not an enum type", NULL);
    record_error(expr);
    goto cleanup;
  }

  Invariant(is_ast_declare_enum_stmt(enum_stmt));

  // enumerate the list of enums and get their values, convert them all to LONG and then add them to the list
  EXTRACT_NOTNULL(enum_values, enum_stmt->right);

  while (enum_values) {
     EXTRACT_NOTNULL(enum_value, enum_values->left);
     EXTRACT_STRING(enum_member, enum_value->left);

     if (enum_member[0] != '_') {
       eval_node result = *enum_value->left->sem->value;
       eval_cast_to(&result, SEM_TYPE_LONG_INTEGER);

       case_val val = {
         .value = result.int64_value,
         .source = enum_value
       };

       bytebuf_append(enum_buffer, &val, sizeof(val));
     }

     enum_values = enum_values->right;
  }

  size_t enum_count = enum_buffer->used / sizeof(case_val);
  case_val *enum_vals = (case_val *)enum_buffer->ptr;
  qsort(enum_vals, enum_count, sizeof(case_val), case_val_comparator);

  // dedupe the enumeration cases, there are sometimes aliases
  // e.g. declare enum integer ( x = 1, another_name_for_x = 1);

  uint32_t i = 0;
  uint32_t j = 0;

  for (i = 0; i < enum_count - 1; i++) {
    Invariant(j <= i);
    if (enum_vals[i].value == enum_vals[i+1].value) {
      continue;
    }
    enum_vals[j++] = enum_vals[i];
  }

  // Now do a merge to find the differences
  // NOTE: we only need one index since we stop at the first difference

  Invariant(j < enum_count);
  enum_vals[j++] = enum_vals[i];
  enum_count = j;

  i = 0;
  while (i < case_count && i < enum_count) {
    if (case_vals[i].value < enum_vals[i].value) {
      CSTR errant = dup_printf("%lld", (llint_t)case_vals[i].value);
      report_error(case_vals[i].source, "CQL0388: a value exists in the switch that is not present in the enum", errant);
      record_error(expr);
      goto cleanup;
    }

    if (case_vals[i].value > enum_vals[i].value) {
      EXTRACT_STRING(enum_member, enum_vals[i].source->left);
      report_error(expr, "CQL0387: a value exists in the enum that is not present in the switch", enum_member);
      record_error(expr);
      goto cleanup;
    }
    i++;
  }

  // if either side has left over members that's an error

  if (i < case_count) {
    Invariant(i == enum_count);
    CSTR errant = dup_printf("%lld", (llint_t)case_vals[i].value);
    report_error(case_vals[i].source, "CQL0388: a value exists in the switch that is not present in the enum", errant);
    record_error(expr);
    goto cleanup;
  }

  if (i < enum_count) {
    Invariant(i == case_count);
    EXTRACT_STRING(enum_member, enum_vals[i].source->left);
    report_error(expr, "CQL0387: a value exists in the enum that is not present in the switch", enum_member);
    record_error(expr);
    goto cleanup;
  }

cleanup:
  BYTEBUF_CLEANUP(enum_buffer);
}

// Switch cases semantic analysis:
// * the case expressions must be constant expressions
// * the case expressions must promote to the type of the expression with no loss
// * the statement list must have no errors
// * the expressions can't be just "else..."
// * if all_values was specified you can't use else or it's a joke
static void sem_switch_cases(ast_node *ast, ast_node *expr, bool_t all_values) {
  Contract(is_ast_switch_case(ast));

  sem_t core_type = core_type_of(expr->sem->sem_type);
  bytebuf *case_buffer = _ast_pool_new(bytebuf);
  bytebuf_open(case_buffer);

  ast_node *head = ast;
  int32_t stmt_lists = 0;
  bool_t has_else = false;

  // We push a new branch group for two reasons:
  //
  // 1. It allows each branch of the SWITCH to be analyzed independently with
  //    respect to improvements.
  //
  // 2. If every branch makes the same improvement and an ELSE branch or ALL
  //    VALUES is present, we can retain the improvement after the SWITCH.
  FLOW_PUSH_CONTEXT_BRANCH_GROUP();

  while (ast) {
    EXTRACT_NOTNULL(connector, ast->left);
    EXTRACT(stmt_list, connector->right);

    bool_t branch_error = false;

    FLOW_PUSH_CONTEXT_BRANCH();

    // first check for expression list, this is a WHEN x,y,z THEN clause
    if (connector->left) {
      EXTRACT_NOTNULL(expr_list, connector->left);

      sem_switch_expr_list(expr_list, core_type, case_buffer);
      if (is_error(expr_list)) {
        record_error(head);
        branch_error = true;
      }
    }
    else {
      // no expr list corresponds to the else case
      Invariant(ast != head);  // 'else' is never first!
      Invariant(!ast->right);  // 'else' is always last!
      Invariant(stmt_list);    // 'else' always has a statement list

      has_else = true;

      if (all_values) {
        report_error(ast, "CQL0383: switch ... ALL VALUES is useless with an ELSE clause", NULL);
        record_error(head);
        branch_error = true;
      }
    }

    // no stmt list corresponds to WHEN ... THEN NOTHING
    if (!branch_error && stmt_list) {
      stmt_lists++;
      sem_stmt_list_in_current_flow_context(stmt_list);
      if (is_error(stmt_list)) {
        record_error(head);
        branch_error = true;
      }
    }

    FLOW_POP_CONTEXT_BRANCH();

    if (branch_error) {
      goto cleanup;
    }

    ast = ast->right;
  }

  if (stmt_lists == 0) {
    report_error(head, "CQL0384: switch statement did not have any actual statements in it", NULL);
    record_error(head);
    goto cleanup;
  }

  // check for duplicate cases in the case list

  size_t case_count = case_buffer->used / sizeof(case_val);
  case_val *case_vals = (case_val *)case_buffer->ptr;
  qsort(case_vals, case_count, sizeof(case_val), case_val_comparator);
  Invariant(case_count > 0);  // enforced by grammar

  for (int32_t i = 0; i < case_count - 1; i++) {
    if (case_vals[i].value == case_vals[i+1].value) {
      CSTR duplicate = dup_printf("%lld", (long long)case_vals[i].value);
      report_error(case_vals[i].source, "CQL0385: WHEN clauses contain duplicate values", duplicate);
      record_error(head);
      goto cleanup;
    }
  }

  if (all_values) {
    sem_check_all_values_condition(expr, case_buffer);
    if (is_error(expr)) {
      record_error(head);
      goto cleanup;
    }
    flow_set_context_branch_group_covers_all_cases(true);
  }
  else {
    flow_set_context_branch_group_covers_all_cases(has_else);
  }

  record_ok(head);

cleanup:
  FLOW_POP_CONTEXT_BRANCH_GROUP();
  BYTEBUF_CLEANUP(case_buffer);
}

// Switch statement semantic analysis:
// * the type of the switch expression must be integral (i.e. bool, integer, long_int)
// * the type must be not null
// * the case expressions must be constant expressions
// * the case expressions must promote to the type of the expression with no loss
// * the expressions can't be just "else..."
// NYI: If ALL VALUES is specified then:
//  * the type of switch expression must be an enum
//  * all the values in the enum must be covered by the switch
//  * if all_values was specified you can't use else or it's a joke
static void sem_switch_stmt(ast_node *ast) {
  Contract(is_ast_switch_stmt(ast));
  EXTRACT_OPTION(all_values, ast->left);
  EXTRACT_NOTNULL(switch_body, ast->right);
  EXTRACT_ANY_NOTNULL(expr, switch_body->left);
  EXTRACT_NOTNULL(switch_case, switch_body->right);

  // SWITCH [expr] [switch_body] END
  // SWITCH [expr] ALL VALUES [switch_body] END

  bool_t in_switch_saved = in_switch;
  in_switch = true;

  sem_root_expr(expr, SEM_EXPR_CONTEXT_NONE);
  if (is_error(expr)) {
    record_error(ast);
    goto cleanup;
  }

  sem_t core_type = core_type_of(expr->sem->sem_type);
  if (!is_any_int(core_type) || is_nullable(expr->sem->sem_type)) {
    report_error(expr, "CQL0381: case expression must be a not-null integral type", NULL);
    record_error(ast);
    goto cleanup;
  }

  sem_switch_cases(switch_case, expr, !!all_values);
  if (is_error(switch_case)) {
    record_error(ast);
    goto cleanup;
  }

  record_ok(ast);

cleanup:
  in_switch = in_switch_saved;
}

// While semantic analysis is super simple.
//  * the condition must be numeric
//  * the statement list must be error-free
//  * loop_depth is increased allowing the use of interior leave/continue
static void sem_while_stmt(ast_node *ast) {
  Contract(is_ast_while_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(stmt_list, ast->right);

  // WHILE [expr] BEGIN [stmt_list] END

  sem_numeric_expr(expr, ast, "WHILE", SEM_EXPR_CONTEXT_NONE);

  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  if (stmt_list) {
    loop_depth++;

    sem_stmt_list_within_loop(stmt_list, expr);

    loop_depth--;

    if (is_error(stmt_list)) {
      record_error(ast);
      return;
    }
  }

  record_ok(ast);
}

// For semantic analysis is super simple.
//  * the condition must be numeric
//  * the statement lists must be error-free
//  * loop_depth is increased allowing the use of interior leave/continue
static void sem_for_stmt(ast_node *ast) {
  Contract(is_ast_for_stmt(ast));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT(for_info, ast->right);

  // FOR expr; stmt_list; BEGIN [stmt_list] END

  sem_numeric_expr(expr, ast, "FOR", SEM_EXPR_CONTEXT_NONE);

  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  // the loop body has to go first, anything potentially
  // declared in the update statements is logically after
  // the loop body.  For instance if there is a let
  // statement in those statements in must not be visible
  // in the loop.
  if (for_info->right) {
    loop_depth++;

    sem_stmt_list_within_loop(for_info->right, expr);

    loop_depth--;

    if (is_error(for_info->right)) {
      record_error(ast);
      return;
    }
  }

  // this has to go second, it might declare stuff
  // that the main body should not have access to.
  // those declarations are ok to use after the loop
  Contract(is_ast_stmt_list(for_info->left));
  sem_stmt_list(for_info->left);
  if (is_error(for_info->left)) {
    record_error(ast);
    return;
  }


  record_ok(ast);
}

// Loop analysis is just as simple as "while" -- because the loop_stmt
// literally has an embedded fetch, you simply use the fetch helper to
// validate that the fetch is good and then visit the statement list.
// Loop depth is increased as with while.
static void sem_loop_stmt(ast_node *ast) {
  Contract(is_ast_loop_stmt(ast));
  EXTRACT_NOTNULL(fetch_stmt, ast->left);
  EXTRACT(stmt_list, ast->right);

  // LOOP [fetch_stmt] BEGIN [stmt_list] END

  sem_fetch_stmt(fetch_stmt);
  if (is_error(fetch_stmt)) {
    record_error(ast);
    return;
  }

  if (stmt_list) {
    loop_depth++;

    EXTRACT_ANY_NOTNULL(condition, fetch_stmt->left);
    sem_stmt_list_within_loop(stmt_list, condition);

    loop_depth--;

    if (is_error(stmt_list)) {
      record_error(ast);
      return;
    }
  }

  record_ok(ast);
}

// extracts the name from a name_list
static CSTR name_from_name_list_node(ast_node *ast) {
  Contract(is_ast_name_list(ast));
  EXTRACT_STRING(name, ast->left);
  return name;
}

// extracts the name from a region_spec
static CSTR name_from_region_list_node(ast_node *ast) {
  Contract(is_ast_region_list(ast));
  EXTRACT_NOTNULL(region_spec, ast->left);
  EXTRACT_STRING(name, region_spec->left);
  return name;
}

// extracts the name from a shape_expr
static CSTR name_from_shape_expr_node(ast_node *ast) {
  Contract(is_ast_shape_exprs(ast));
  EXTRACT_NOTNULL(shape_expr, ast->left);
  EXTRACT_STRING(name, shape_expr->left);
  return name;
}

typedef CSTR (*name_func)(ast_node *ast);

// There are many cases where we have a list of things (which means you follow it
// by going ->right at each node until null) where there are names in the left
// payload.  The payload can be slightly different but this helps us to find
// any duplicates regardless of where the name is.  You provide a function that
// extracts the name from the left.  This is n^2 which ends up being mostly ok
// because n is usually pretty small.  Like single digits.  If it ever matters
// this could use a temporary name table to do the job.
static bool_t sem_verify_no_duplicate_names_func(ast_node *list, name_func func) {
  Contract(list);
  Contract(func);

  // Walk starting from the current node looking for any duplicate name
  // later in the list.
  for (ast_node *a1 =list; a1; a1 = a1->right) {
    CSTR n1 = func(a1);
    Contract(n1);

    for (ast_node *a2 = a1->right; a2; a2 = a2->right) {
      CSTR n2 = func(a2);
      Contract(n2);

      if (!StrCaseCmp(n1, n2)) {
        report_error(a2->left, "CQL0206: duplicate name in list", n2);
        return false;
      }
    }
  }
  return true;
}

// There are many cases where a list of names must have no duplicates;
// This helper walks the list and reports an error if there are two
// names that are case-insensitively the same.
static bool_t sem_verify_no_duplicate_names(ast_node *name_list) {
  Contract(is_ast_name_list(name_list));
  return sem_verify_no_duplicate_names_func(name_list, name_from_name_list_node);
}

// There are many cases where a list of names must have no duplicates;
// This helper walks the list and reports an error if there are two
// names that are case-insensitively the same.
static bool_t sem_verify_no_duplicate_shape_exprs(ast_node *shape_exprs) {
  Contract(is_ast_shape_exprs(shape_exprs));
  return sem_verify_no_duplicate_names_func(shape_exprs, name_from_shape_expr_node);
}

// Just like the above except it's a region list (so there is an extra node in the AST)
static bool_t sem_verify_no_duplicate_regions(ast_node *region_list) {
  Contract(is_ast_region_list(region_list));
  return sem_verify_no_duplicate_names_func(region_list, name_from_region_list_node);
}

// Verifies that an expression passed as an OUT or INOUT argument for a call is
// the name of a valid variable. If it is not, reports an error indicating for
// which parameter such a name was expected.
static void sem_validate_arg_is_name_of_existing_variable(ast_node *arg, CSTR param_name) {
  if (!is_id_or_dot(arg)) {
    goto error;
  }

  EXTRACT_NAME_AND_SCOPE(arg);
  sem_t *type = NULL;
  sem_resolve_id_with_type(arg, name, scope, &type);
  if (is_error(arg)) {
    return;
  }

  if (!is_variable(arg->sem->sem_type)) {
    goto error;
  }

  // Check that our variable is not a cursor used as a boolean expression. We
  // must check the original binding `*type`, not `arg->sem->sem_type`, because
  // `SEM_TYPE_STRUCT` is only set on the original binding.
  if (!type || is_struct(*type)) {
    goto error;
  }

  return;

error:
  report_error(arg, "CQL0207: expected a variable name for OUT or INOUT argument", param_name);
  record_error(arg);
}


// Analyzes an argument passed for an OUT or INOUT parameter by verifying that
// it is a valid variable and that it has been initialized (if necessary), and
// then sets appropriate improvements.
static void sem_arg_for_out_param(ast_node *arg, ast_node *param) {
  Contract(arg);
  Contract(is_ast_param(param));

  sem_validate_arg_is_name_of_existing_variable(arg, param->sem->name);
  if (is_error(arg)) {
    return;
  }

  // Check to see if `arg` is being passed as an INOUT argument.
  if (is_in_parameter(param->sem->sem_type)) {
    // The caller is responsible for the initialization of arguments passed for
    // INOUT parameters. We already checked that we have a variable above, so
    // now we just need to verify that it has been appropriately initialized.
    sem_validate_variable_referenced_is_initialized_if_required(arg);
    if (is_error(arg)) {
      return;
    }
  }

  EXTRACT_NAME_AND_SCOPE(arg);

  // If `arg` is being passed for an OUT parameter of a nullable type, it could
  // be set to NULL; if it is being passed for an OUT parameter of a nonnull
  // type, then the name/scope pair must refer to a declared-nonnull type (which
  // can be neither improved nor unimproved), and so there is no harm in calling
  // this.
  sem_unset_notnull_improved(name, scope);

  // The callee will initialize the variable during its execution (unless the
  // callee throws, in which case all execution will either effectively stop
  // or a TRY block in the caller or further up the stack will safely bound
  // the initialization improvement).
  sem_set_initialization_improved(name, scope);

  ast_node *variable = find_local_or_global_variable(arg->sem->name);
  if (variable) {
    variable->sem->sem_type |= SEM_TYPE_WAS_SET;
  }
}

// Given an argument that (typically) has not yet been checked and a formal
// parameter that has been, check the argument and verify that it is allowed to
// be passed for that particular parameter.
static bool_t sem_validate_arg_vs_formal(ast_node *arg, ast_node *param) {
  Contract(arg);
  Contract(param);
  Contract(param->sem);

  sem_t sem_type_param = param->sem->sem_type;

  // As a first step, we check the argument itself.
  if (is_cursor_formal(sem_type_param)) {
    // a cursor arg demands a cursor expression, any such cursor will do
    sem_cursor(arg);
    if (is_error(arg)) {
      return false;
    }

    if (!is_auto_cursor(arg->sem->sem_type)) {
      report_error(arg, "CQL0067: cursor was not used with 'fetch [cursor]'", arg->sem->name);
      record_error(arg);
      return false;
    }

    ast_node *var = find_local_or_global_variable(arg->sem->name);
    Invariant(var); // we know the cursor exists and is unique already
    var->sem->sem_type |= SEM_TYPE_SERIALIZE;
    return true;
  }
  else if (is_out_parameter(sem_type_param)) {
    sem_arg_for_out_param(arg, param);
    if (is_error(arg)) {
      return false;
    }
  }
  else {
    // In the case of an IN-only parameter, we allow an expression.
    sem_arg_expr(arg, false);
    if (is_error(arg)) {
      return false;
    }
  }

  sem_t sem_type_arg = arg->sem->sem_type;

  // Now, we can check it against what was expected. Note that it's possible to
  // be both in and out in which case both validations have to happen.

  if (is_in_parameter(sem_type_param)) {
    // you have to be able to "assign" the arg to the param
    if (!sem_verify_assignment(arg, sem_type_param, sem_type_arg, param->sem->name)) {
      return false;
    }
  }

  // the formal and the argument must match object types as well (if present)
  sem_combine_kinds(arg, param->sem->kind);
  if (is_error(arg)) {
    return false;
  }

  if (is_out_parameter(sem_type_param)) {
    // We already checked this above when checking the arg itself.
    Invariant(is_variable(sem_type_arg));

    // you have to be able to "assign" the param to the arg (reverse of in)
    if (!sem_verify_assignment(arg, sem_type_arg, sem_type_param, arg->sem->name)) {
      return false;
    }

    if (core_type_of(sem_type_param) != core_type_of(sem_type_arg)) {
      CSTR error_message = "CQL0209: proc out parameter: arg must be an exact type match";
      report_sem_type_mismatch(sem_type_param, sem_type_arg, arg, error_message, arg->sem->name);
      return false;
    }

    if (is_nullable(sem_type_param) != is_nullable(sem_type_arg)) {

      // not null _out_ parameters can be satisfied by nullable arguments for reference types
      bool_t different_ok =
         !is_in_parameter(sem_type_param) &&
         is_out_parameter(sem_type_param) &&
         is_ref_type(sem_type_param) &&
         !is_nullable(sem_type_param) &&
         is_nullable(sem_type_arg);

      if (different_ok) {
         // this is ok, a nullable ref arg can stand in for a not nullable out param
         // the nullable arg will just end up being not null
      }
      else {
        CSTR error_message = "CQL0210: proc out parameter: arg must be an exact type match (even nullability)";
        report_sem_type_mismatch(sem_type_param, sem_type_arg, arg, error_message, arg->sem->name);
        return false;
      }
    }
  }

  return true;
}

// Pointer tag indicating an id that is passed as an OUT or INOUT argument.
static const uintptr_t id_out_tag_bit = 0x1;

// Given a (possibly) tagged id, return an untagged, deferencable pointer.
static ast_node *id_from_out_tagged_id(ast_node *tagged_id) {
  return (ast_node *)((uintptr_t)tagged_id & ~id_out_tag_bit);
}

// Given an id, return the tagged version.
static ast_node *out_tagged_id_from_id(ast_node *id) {
 return (ast_node *)((uintptr_t)id | id_out_tag_bit);
}

// Returns true if `id` is tagged, else false.
static bool_t is_id_out_tagged(ast_node *id) {
  return !!((uintptr_t)id & id_out_tag_bit);
}

cql_noexport bool_t is_alias_ast(ast_node *_Nonnull ast) {
 Contract(ast);
 return ast->sem && (ast->sem->sem_type & SEM_TYPE_ALIAS);
}

// Compares the names of two (possibly) tagged ids in a manner such that
// `out_tagged_id_comparator` can be used as a comparator for `qsort`. If the
// names match, we then compare by line number so that, if we later report an
// error, we can easily point to the first use.
static int out_tagged_id_comparator(const void *a, const void *b) {
  ast_node *id_a = id_from_out_tagged_id(*(ast_node **)a);
  ast_node *id_b = id_from_out_tagged_id(*(ast_node **)b);
  EXTRACT_STRING(a_name, id_a);
  EXTRACT_STRING(b_name, id_b);

  int result = strcmp(a_name, b_name);
  if (!result) {
    return id_a->lineno > id_b->lineno ? 1 : id_a->lineno < id_b->lineno ? -1 : 0;
  }

  return result;
}

// Returns true if all OUT and INOUT arguments in `arg_list` are unique with
// respect to all other arguments (including IN arguments), else false. If OUT
// and INOUT arguments were allowed to alias, setting a variable passed in via
// an OUT or INOUT parameter could cause the values of other parameters to be
// unexpectedly mutated.
static bool_t sem_validate_out_args_are_unique(ast_node *arg_list, ast_node *params) {
  Contract(!arg_list || is_ast_arg_list(arg_list) || is_ast_expr_list(arg_list));
  Contract(!params || is_ast_params(params));

  // Count up the ids passed as arguments so that we can allocate an array of
  // the correct size to hold all of them. As a minor optimization, we also
  // check whether we have at least one OUT or INOUT argument so we can bail out
  // early if we don't.
  //
  // NOTE: Technically, we only count ids with an associated parameter. If this
  // procedure is called after checking that the correct number of arguments
  // were provided, we'll always have enough parameters to count all of the ids
  // and will check all of the arguments for aliasing. If not, we'll check just
  // the arguments that have parameters and the caller can then fail due to
  // excess arguments later on. The caller decides which behavior it prefers.
  uint32_t ids_count = 0;
  bool_t has_out_argument = false;
  ast_node *arg_item = arg_list;
  ast_node *param_item = params;
  for (; arg_item && param_item; arg_item = arg_item->right, param_item = param_item->right) {
    EXTRACT_ANY_NOTNULL(arg, arg_item->left);
    if (!is_id(arg)) {
      continue;
    }
    ids_count++;
    EXTRACT_NOTNULL(param, param_item->left);
    if (is_out_parameter(param->sem->sem_type)) {
      has_out_argument = true;
    }
  }

  // If there isn't at least one OUT or INOUT argument, or if we don't have at
  // least two ids, there can be no aliasing.
  if (!has_out_argument || ids_count < 2) {
    return true;
  }

  // Put all of the ids into an array, tagging the ones that were used for OUT
  // or INOUT arguments. We do this because the arguments themselves do not
  // contain whether or not they were used as OUT or INOUT arguments in their
  // sem nodes: That information is only present in the associated parameter.
  // Tagging ids gives us an easy way to track OUT/INOUT usage without having to
  // later unset anything on the ids themselves.
  ast_node **ids = _ast_pool_new_array(ast_node *, ids_count);
  ast_node **ids_ptr = ids;
  arg_item = arg_list;
  param_item = params;
  for (; arg_item && param_item; arg_item = arg_item->right, param_item = param_item->right) {
    EXTRACT_ANY_NOTNULL(arg, arg_item->left);
    if (!is_id(arg)) {
      continue;
    }
    EXTRACT_NOTNULL(param, param_item->left);
    *ids_ptr++ = is_out_parameter(param->sem->sem_type) ? out_tagged_id_from_id(arg) : arg;
  }

  // Sort them by name, then by line number.
  qsort(ids, ids_count, sizeof(ast_node *), out_tagged_id_comparator);

  // Look for duplicates involving an OUT or INOUT usage.
  for (uint32_t i = 1; i < ids_count; i++) {
    // If either the current id or previous id is tagged, and if their names
    // match, it must be the case that an OUT or INOUT argument is aliased.
    if (is_id_out_tagged(ids[i - 1]) || is_id_out_tagged(ids[i])) {
      ast_node *previous_id = id_from_out_tagged_id(ids[i - 1]);
      ast_node *id = id_from_out_tagged_id(ids[i]);
      EXTRACT_STRING(previous_id_name, previous_id);
      EXTRACT_STRING(id_name, id);
      if (!strcmp(previous_id_name, id_name)) {
        // We sorted by name and then by line number, so `previous_id` is
        // guaranteed to contain the earliest line number we could report.
        CSTR msg = "CQL0426: OUT or INOUT argument cannot be used again in same call";
        report_error(previous_id, msg, id_name);
        return false;
      }
    }
  }

  return true;
}

// This is the core helper method for procedure calls and function calls.
// It validates that the type and number of arguments are compatible for the
// call in question. When we get here, we typically have a list of unchecked
// arguments in arg_list and the formals to verify against in params. (In the
// case of recursive expressions, arg_list may have already been checked.)
// Errors will be recorded on the given ast.  Since the shape of the tree
// varies slightly between function and procedure calls, this helper expects to
// have the items harvested and ready to go.
//
// Semantic rules:
//  * for all cases each argument must be error-free (no internal type
//    conflicts)
//  * for known procs
//    * the call has to have the correct number of arguments
//    * if the formal is an out parameter the argument must be a variable
//      * the type of the variable must be an exact type match for the formal
//    * non-out parameters must be type-compatible, but exact match is not
//      required
static void sem_validate_args_vs_formals(ast_node *ast, CSTR name, ast_node *arg_list, ast_node *params, bool_t proc_as_func) {
  ast_node *arg_item = arg_list;
  ast_node *param_item = params;
  int iarg = 1;

  // First, we check the arguments themselves.
  for (; arg_item && param_item; arg_item = arg_item->right, param_item = param_item->right, iarg++) {
    EXTRACT_ANY_NOTNULL(arg, arg_item->left);
    EXTRACT_NOTNULL(param, param_item->left);

    if (!sem_validate_arg_vs_formal(arg, param)) {
      CSTR err_msg = dup_printf(
          "additional info: calling '%s' argument #%d intended for parameter '%s' has the problem",
          name, iarg, param->sem->name);
      report_error(arg, err_msg, NULL);
      record_error(ast);
      return;
    }

    // The proc-as-func case is only allowed for procedures with zero or more
    // IN parameters followed by exactly one OUT (but not INOUT) parameter.
    if (proc_as_func && is_out_parameter(param->sem->sem_type)) {
      if (is_in_parameter(param->sem->sem_type)) {
        report_error(ast, "CQL0424: procedure with INOUT parameter used as function", name);
        record_error(ast);
        return;
      }
      if (param_item->right) {
        report_error(ast, "CQL0425: procedure with non-trailing OUT parameter used as function", name);
        record_error(ast);
        return;
      }
    }
  }

  // If we used up all the args and it's a proc as func case then we have one
  // last chance to be correct, there has to be exactly one out argument left
  // we'll treat that as the virtual return.
  if (proc_as_func && !arg_item && param_item && !param_item->right) {
    EXTRACT_NOTNULL(param, param_item->left);

    Invariant(param->sem);
    Invariant(is_unitary(param->sem->sem_type)); // params can't be structs or cursors

    sem_t sem_type_param = param->sem->sem_type;

    if (!is_out_parameter(sem_type_param) || is_in_parameter(sem_type_param)) {
      report_error(param, "CQL0211: procedure without trailing OUT parameter used as function", name);
      record_error(ast);
      return;
    }

    ast->sem = new_sem(core_type_of(sem_type_param) | not_nullable_flag(sem_type_param) | sensitive_flag(sem_type_param));
    ast->sem->kind = param->sem->kind;
    return;
  }

  if (param_item) {
    report_error(ast, "CQL0212: too few arguments provided to procedure", name);
    record_error(ast);
    return;
  }

  // if any args are left that's an error
  // if items matches and it's proc as func then the last arg was provided, that's also an error
  if (arg_item || proc_as_func) {
    report_error(ast, "CQL0235: too many arguments provided to procedure", name);
    record_error(ast);
    return;
  }

  // Finally, we check whether or not any OUT or INOUT arguments are aliased.
  if (!sem_validate_out_args_are_unique(arg_list, params)) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// This is the sematic analysis for a call statement.  There are three ways
// that a call can happen:
//   * signatures of procedures that we know in full:
//     * call foo();
//     * declare cursor for call foo();
//   * some external call to some outside function we don't know
//     * e.g. call printf('hello, world\n');
//
// The cursor form can be used if and only if the procedure has a loose select
// or a call to a procedure with a loose select. In that case the procedure will
// have a structure type, rather than just "ok" (the normal signature for a proc).
// If the user is attempting to do the second case, cursor_name will be set and
// the appropriate verification happens here.
//
// Note:  Recursively calling fetch cursor is not really doable in general
// because at the point of the call we might not yet know that the method
// does in fact return a select.  You could make it work if you put the select
// before the recursive call.
//
// Semantic rules:
//  * for all cases each argument must be error-free (no internal type conflicts)
//  * for known procs
//    * the call has to have the correct number of arguments
//    * if the formal is an out parameter the argument must be a variable
//      * the type of the variable must be an exact type match for the formal
//    * non-out parameters must be type-compatible, but exact match is not required
static void sem_call_stmt_opt_cursor(ast_node *ast, CSTR cursor_name) {
  Contract(is_ast_call_stmt(ast));
  EXTRACT_NAME_AST(name_ast, ast->left);
  EXTRACT(arg_list, ast->right);
  EXTRACT_STRING(name, name_ast);

  // expand '*' into FROM LOCALS LIKE [target_of_call] ARGUMENTS
  if (!rewrite_ast_star_if_needed(arg_list, name_ast)) {
    record_error(ast);
    return;
  }

  ast_node *proc_stmt = find_proc(name);

  if (!proc_stmt && !find_unchecked_proc(name)) {
    report_error(ast, "CQL0323: calls to undeclared procedures are forbidden; declaration missing or typo", name);
    record_error(ast);
    return;
  }

  // Not found is not an error in this case (is_error will return on null)
  if (proc_stmt && is_error(proc_stmt)) {
    report_error(ast, "CQL0213: procedure had errors, can't call", name);
    record_error(ast);
    return;
  }

  if (proc_stmt &&
    is_ast_create_proc_stmt(proc_stmt) &&
    is_proc_shared_fragment(proc_stmt) &&
    !is_ast_shared_cte(ast->parent)) {
      report_error(ast, "CQL0434: shared fragments may not be called outside of a SQL statement", name);
      record_error(ast);
      return;
  }

  if (proc_stmt && is_struct(proc_stmt->sem->sem_type)) {
    if (!cursor_name && !current_proc && !in_shared_fragment_call) {
      report_error(ast, "CQL0214: procedures with results can only be called using a cursor in global context", name);
      record_error(ast);
      return;
    }
  }

  // expand any FROM forms in the arg list
  if (!rewrite_shape_forms_in_list_if_needed(arg_list)) {
    record_error(ast);
    return;
  }

  record_ok(name_ast);

  // If known proc, do additional validation
  if (proc_stmt) {
    Contract(is_proc(proc_stmt));
    EXTRACT_NOTNULL(proc_params_stmts, proc_stmt->right);
    EXTRACT(params, proc_params_stmts->left);

    name_ast->sem = proc_stmt->sem;

    has_dml |= is_dml_proc(proc_stmt->sem->sem_type);

    sem_validate_args_vs_formals(ast, name, arg_list, params, NORMAL_CALL);

    // The call may have mutated any or all of the currently improved globals,
    // so we simply invalidate all of them. We do this before returning in the
    // case of an error so that subsequently checked statements have a slightly
    // more accurate view of what can no longer be considered improved.
    sem_unset_global_notnull_improvements();

    if (is_error(ast)) {
      return;
    }
  }
  else {
    // compute semantic type of each arg, reporting errors
    sem_validate_args(ast, arg_list);
    if (is_error(ast)) {
      return;
    }
  }

  sem_proc_call_post_check(name, ast, arg_list);
  if (is_error(ast)) {
    return;
  }

  ast->sem = name_ast->sem;
}

// some procedures require additional checks, so far only two
// if this list grows we'll use a name table like the other cases
static void sem_proc_call_post_check(CSTR name, ast_node *ast, ast_node *arg_list) {
  Contract(is_ast_call_stmt(ast));
  Contract(!is_error(ast));
  Contract(name);

  if (!StrCaseCmp("cql_cursor_from_blob", name)) {
    // additional validation for cql_cursor_from_blob -- ensure blob is compatible
    Contract(is_ast_arg_list(arg_list));
    EXTRACT_ANY_NOTNULL(cursor, arg_list->left);
    EXTRACT_ANY_NOTNULL(blob, arg_list->right->left);

    // the final error is set by the helper, 'ast' will have the code regardless
    sem_validate_cursor_blob_compat(ast, cursor, blob, blob, cursor);

    if (!is_error(ast)) {
      // This type of fetch can fail with an exception. If it does not, we
      // definitely have a row. If it does, we'll be bumped out of the nearest
      // enclosing jump context and this improvement will be unset
      // appropriately.
      sem_set_has_row_improved(cursor->sem->name);
    }
  }
  else if (!StrCaseCmp("cql_cursor_to_blob", name)) {
    // additional validation for cql_cursor_to_blob -- ensure blob is compatible
    Contract(is_ast_arg_list(arg_list));
    EXTRACT_ANY_NOTNULL(cursor, arg_list->left);
    EXTRACT_ANY_NOTNULL(blob, arg_list->right->left);

    // the final error is set by the helper, 'ast' will have the code regardless
    sem_validate_cursor_blob_compat(ast, cursor, blob, cursor, blob);
  }
}

// The fetch statement has two forms:
//   * fetch C into var1, var2, var3 etc.
//   * fetch C;
// The second form is called the auto_cursor.
// In the first form the variables of the cursor must be assignment compatible
// with declared structure type of the cursor and the count must be correct.
// In the second form, the codegen will implicitly create local variables that
// are exactly the correct type, but that's later.  Since no semantic error is
// possible in that case we simply record that this is an auto_cursor and then
// later we will allow the use of C.field during analysis.
// Of course "C" must be a valid cursor.
static void sem_fetch_stmt(ast_node *ast) {
  Contract(is_ast_fetch_stmt(ast));
  EXTRACT_ANY_NOTNULL(cursor, ast->left);
  EXTRACT(name_list, ast->right);

  // FETCH [name] [ INTO [name_list] ]

  sem_cursor(cursor);
  if (is_error(cursor)) {
    record_error(ast);
    return;
  }

  if (cursor->sem->sem_type & SEM_TYPE_VALUE_CURSOR) {
    report_error(cursor, "CQL0215: value cursors are not used with FETCH C, or FETCH C INTO", cursor->sem->name);
    record_error(ast);
    return;
  }

  if (!name_list) {
    sem_validate_unique_names_struct_type(cursor);
    if (is_error(cursor)) {
      record_error(ast);
      return;
    }

    sem_verify_no_anon_no_null_columns(cursor);
    if (is_error(cursor)) {
      record_error(ast);
      return;
    }

    // Tag the cursor *variable* (i.e. the AST from the original definition site
    // of the cursor) as an auto cursor. This is necessary because we need to
    // have this information available during codegen before we see that the
    // cursor was used in a fetch.  So we leave this breadcrumb.
    ast_node *cursor_var = find_local_or_global_variable(cursor->sem->name);
    Invariant(cursor_var);
    Invariant(is_cursor(cursor_var->sem->sem_type));
    sem_add_flags(cursor_var, SEM_TYPE_HAS_SHAPE_STORAGE);

    // We also tag the cursor in `ast`, both for clarity (i.e. so we can see
    // that the cursor has the auto_cursor flag set in tests) and because
    // codegen will look for the flag on `ast` itself (which gets it from the
    // following assignment).
    sem_add_flags(cursor, SEM_TYPE_HAS_SHAPE_STORAGE);
    ast->sem = cursor->sem;

    // Remove nullability improvements from all of the fields.
    sem_struct *sptr = cursor_var->sem->sptr;
    for (uint32_t i = 0; i < sptr->count; i++) {
      sem_unset_notnull_improved(sptr->names[i], cursor->sem->name);
    }

    // The "FETCH c" form is not guaranteed to give us a row.
    sem_unset_has_row_improved(cursor->sem->name);

    return;
  }

  if (!sem_verify_no_duplicate_names(name_list)) {
    record_error(ast);
    return;
  }

  // ensure the types match

  uint32_t icol = 0;
  uint32_t cols = cursor->sem->sptr->count;
  ast_node *item = name_list;
  for (item = name_list; item && icol < cols; item = item->right, icol++) {
    EXTRACT_NAME_AST(var_name_ast, item->left);
    EXTRACT_STRING(name, var_name_ast);

    ast_node *variable = find_local_or_global_variable(name);
    if (!variable) {
      report_error(var_name_ast, "CQL0216: FETCH variable not found", name);
      record_error(ast);
      return;
    }

    var_name_ast->sem = variable->sem;

    sem_t sem_type_cursor = cursor->sem->sptr->semtypes[icol];
    sem_t sem_type_variable = variable->sem->sem_type;

    // there are no object columns and therefore no object cursors, any such creature was long ago eliminated
    Invariant(!is_object(sem_type_cursor));

    if (!sem_verify_assignment(var_name_ast, sem_type_variable, sem_type_cursor, name)) {
      record_error(ast);
      return;
    }

    // For the time being, unlike SET, we do not allow FETCH INTO to both unset
    // and set nullability improvements because we do not yet have a way of
    // enforcing that the programmer verified that the fetch itself was
    // successful. If it did set nullability improvements, code like the
    // following would erroneously report a redundant IS NOT NULL check which
    // might then encourage the programmer to remove the IS NOT NULL check
    // rather than add the appropriate has-row check:
    //
    //   DECLARE x TEXT;
    //   FETCH cursor_with_text_notnull_column INTO x;
    //   -- an error would be issued here due to IS NOT NULL, but x CAN be null!
    //   IF x IS NOT NULL THEN
    //     ...
    //   END IF;
    //
    // This will be revisited once CQL has added a notion of has-row
    // improvements for cursors.
    sem_unset_notnull_improved(name, NULL);

    // Even though the fetch may have failed, we optimistically consider the
    // variable to have been initialized. In essence, this is no different from
    // fetching into an auto cursor and then using SET to initialize a variable
    // by setting it to the value of one of the cursor's fields (even though the
    // fetch could have failed), which we also allow. Again, this will be
    // revisited in the future once has-row improvements have been added.
    sem_set_initialization_improved(name, NULL);

    variable->sem->sem_type |= SEM_TYPE_WAS_SET;
  }

  if (icol != cols || item) {
    report_error(ast, "CQL0217: number of variables did not match count of columns in cursor", cursor->sem->name);
    record_error(ast);
    return;
  }

  // Tag the cursor *variable* (i.e. the AST from the original definition site
  // of the cursor) with FETCH_INTO. This is necessary because we need to
  // have this information available during codegen before we see that the
  // cursor was used in a fetch.  So we leave this breadcrumb.

  ast_node *cursor_var = find_local_or_global_variable(cursor->sem->name);
  Invariant(cursor_var);
  Invariant(is_cursor(cursor_var->sem->sem_type));
  sem_add_flags(cursor_var, SEM_TYPE_FETCH_INTO);

  ast->sem = cursor_var->sem;
}

// In this form we're working on a cursor that is going to be loaded by making a call.  This call statement
// must be using the OUT statement and its OUT value must exactly match the shape of the target cursor.
static void sem_fetch_call_stmt(ast_node *ast) {
  Contract(is_ast_fetch_call_stmt(ast));
  Contract(is_ast_call_stmt(ast->right));
  EXTRACT_ANY_NOTNULL(cursor, ast->left)
  EXTRACT_STRING(cursor_name, cursor);
  EXTRACT_ANY_NOTNULL(call_stmt, ast->right);

  // FETCH [cursor] FROM CALL [call_stnmt]

  sem_call_stmt_opt_cursor(call_stmt, cursor_name);
  if (is_error(call_stmt)) {
    record_error(ast);
    return;
  }

  sem_call_stmt_has_out_stmt_result_for_cursor(call_stmt, cursor_name);
  if (is_error(call_stmt)) {
    record_error(ast);
    return;
  }

  sem_cursor(cursor);
  if (is_error(cursor)) {
    record_error(ast);
    return;
  }

  sem_verify_identical_columns(cursor, call_stmt, "receiving cursor from call");
  if (is_error(call_stmt)) {
    record_error(ast);
    return;
  }

  // The "FROM CALL" form is not guaranteed to give us a row.
  sem_unset_has_row_improved(cursor_name);

  record_ok(ast);
}

// Fetch the next statement assuming we're on a statement
// this is only tricky because the parent node might not be a statement
// list due to the way attributes on statements work.
static ast_node *get_next_stmt(ast_node *ast) {
  ast_node *parent = ast->parent;

  if (is_ast_stmt_list(parent)) {
    return parent->right;
  }

  EXTRACT_NOTNULL(stmt_and_attr, parent);
  EXTRACT_NOTNULL(stmt_list, stmt_and_attr->parent);
  return stmt_list->right;
}

// Some of the control flow statements like LEAVE, CONTINUE, and RETURN should have nothing
// after them.  This handles those cases in a uniform way.
static void sem_last_statement_in_block(ast_node *ast) {
  if (get_next_stmt(ast)) {
    report_error(ast, "CQL0308: statement should be the last thing in a statement list", NULL);
    record_error(ast);
  }
  else {
    record_ok(ast);
  }
}

// We just need to ensure that continue is inside a loop.
static void sem_continue_stmt(ast_node *ast) {
  Contract(is_ast_continue_stmt(ast));

  // CONTINUE
  if (loop_depth == 0) {
    report_error(ast, "CQL0218: continue must be inside of a 'loop' or 'while' statement", NULL);
    record_error(ast);
    return;
  }

  sem_last_statement_in_block(ast);
}

// We just need to ensure that leave is inside a loop.
static void sem_leave_stmt(ast_node *ast) {
  Contract(is_ast_leave_stmt(ast));

  // LEAVE
  if (loop_depth == 0 && !in_switch) {
    report_error(ast, "CQL0219: leave must be inside of a 'loop', 'while', or 'switch' statement", NULL);
    record_error(ast);
    return;
  }

  sem_last_statement_in_block(ast);
}

// Return should not appear at the top level, it's redundant.  It also should be
// the last thing in a statement block.
static void sem_return_common(ast_node *ast) {
  Contract(is_ast_return_stmt(ast) || is_ast_rollback_return_stmt(ast) || is_ast_commit_return_stmt(ast));

  // RETURN
  if (sem_stmt_level <= 1) {
    report_error(ast, "CQL0307: return statement should be in a procedure and not at the top level", NULL);
    record_error(ast);
    return;
  }

  // for sure in a statement now due to the above
  Invariant(current_proc);

  // Since this is a potential exit point of the current procedure, all
  // parameters requiring initialization should have been initialized by now.
  if (!sem_validate_current_proc_params_are_initialized(ast)) {
    record_error(ast);
    return;
  }

  sem_last_statement_in_block(ast);
}

// The usual return rules plus a return statement may not appear inside of a proc savepoint
// you have to use either rollback or commit return.
static void sem_return_stmt(ast_node *ast) {
  if (in_proc_savepoint) {
    report_error(ast, "CQL0352: use COMMIT RETURN or ROLLBACK RETURN in within a proc savepoint block", NULL);
    record_error(ast);
    return;
  }
  sem_return_common(ast);
}

// Must be inside of a proc savepoint plus the usual return rules
static void sem_commit_return_stmt(ast_node *ast) {
  Contract(is_ast_commit_return_stmt(ast));

  if (!in_proc_savepoint) {
    report_error(ast, "CQL0350: statement must appear inside of a PROC SAVEPOINT block", NULL);
    record_error(ast);
    return;
  }

  // and the usual return rules
  sem_return_common(ast);
}

// Must be inside of a proc savepoint plus the usual return rules
static void sem_rollback_return_stmt(ast_node *ast) {
  Contract(is_ast_rollback_return_stmt(ast));

  if (!in_proc_savepoint) {
    report_error(ast, "CQL0350: statement must appear inside of a PROC SAVEPOINT block", NULL);
    record_error(ast);
    return;
  }

  // and the usual return rules
  sem_return_common(ast);
}

// The rules here:
//  * it must be in a procedure
//  * it must be at the top level
static void sem_proc_savepoint_stmt(ast_node *ast)
{
  Contract(is_ast_proc_savepoint_stmt(ast));
  EXTRACT(stmt_list, ast->left);

  if (!current_proc || sem_stmt_level != 1 ) {
    report_error(ast, "CQL0351: statement should be in a procedure and at the top level", NULL);
    record_error(ast);
    return;
  }

  Invariant(!in_proc_savepoint);

  if (stmt_list) {
   in_proc_savepoint = true;
   // We avoid making a new context here so that any improvements made within
   // the statement list will persist after the end of the PROC SAVEPOINT
   // statement. This is safe because we enter it unconditionally and because
   // the only way to jump out early is to jump out of the entire procedure.
   sem_stmt_list_in_current_flow_context(stmt_list);
   in_proc_savepoint = false;

   if (is_error(stmt_list)) {
     record_error(ast);
     return;
    }
  }

  record_ok(ast);
}

// If [[try_is_proc_body]] is present, performs additional analysis
// using the try/catch AST provided as `context` such that the statement list of
// the TRY is treated as though it were the main body of the procedure. In
// particular, it ensures that all parameters of the current procedure have been
// initialized by the end of the TRY and prevents `sem_inside_create_proc_stmt`
// from later doing the same at the end of the procedure.
//
// The reason why [[try_is_proc_body]] is needed is that users, for
// various reasons, sometimes need to wrap certain stored procedures in a
// try/catch such that custom error handling or logging can be implemented. In
// doing so, however, they break our assumptions about things like
// initialization of OUT parameters: We normally enforce that parameters must be
// initialized by the end of a procedure, but, if the procedure is wrapped in a
// try/catch so that the CATCH can help perform some custom error reporting
// (e.g., log the error and then rethrow the exception), any initialization
// improvements made in the TRY will be unset at the end of the procedure.
//
// A somewhat contrived example use case for this is as follows:
/*
//   #define LOGGING_PROC_BEGIN \
//     BEGIN \
//       LET error_in_try := FALSE; \
//       [[try_is_proc_body]] \
//       TRY
//
//   #define LOGGING_PROC_END \
//       CATCH \
//         SET error_in_try := TRUE; \
//       END; \
//       IF error_in_try THEN \
//         CALL some_proc_that_logs_and_rethrows(__FILE__, __LINE__); \
//       END IF; \
//     END
//
//   CREATE PROC some_proc(OUT x TEXT NOT NULL)
//   LOGGING_PROC_BEGIN
//     IF some_condition THEN
//       SET x := some_value;
//     ELSE
//       SET x := get_another_value_or_throw()
//     END IF;
//   LOGGING_PROC_END;
*/
// As can be seen above, the main part of the procedure does, in fact, always
// initialize x unless an exception occurs -- and, if it does, the handling
// within LOGGING_PROC_END will take care of it. Our normal analyses cannot
// understand that though. By giving programmers a way to explicitly indicate
// that this pattern is in effect, we can know to ensure that x is initialized
// within what is, conceptually, the main body of the procedure (i.e., the TRY)
// and then not worry about it later on.
//
// NOTE: It is very possible to misuse [[try_is_proc_body]] such
// that parameter initialization checking becomes useless. There is nothing we
// can do about that here: We must simply assume the programmer has used it
// appropriately.
void sem_find_ast_misc_attr_trycatch_is_proc_body_callback(
  CSTR _Nullable misc_attr_prefix,
  CSTR _Nonnull misc_attr_name,
  ast_node *_Nullable ast_misc_attr_value_list,
  void *_Nullable context)
{
  Contract(misc_attr_name);
  Contract(is_ast_trycatch_stmt(context));

  if (!misc_attr_prefix || StrCaseCmp(misc_attr_prefix, "cql") || StrCaseCmp(misc_attr_name, "try_is_proc_body")) {
    return;
  }

  ast_node *ast = context;

  if (ast_misc_attr_value_list) {
    report_error(ast_misc_attr_value_list, "CQL0445: [[try_is_proc_body]] accepts no values", NULL);
    record_error(ast);
    return;
  }

  if (current_proc_contains_try_is_proc_body) {
    report_error(
      context,
      "CQL0446: [[try_is_proc_body]] cannot be used more than once per procedure",
      NULL
    );
    record_error(ast);
    return;
  }

  // Set this so `sem_inside_create_proc_stmt` knows not to perform the
  // initialization check later on.
  current_proc_contains_try_is_proc_body = true;

  // Use the end of the TRY block for error reporting if it has any statements,
  // else just use the whole block since we have nothing better.
  EXTRACT_NAMED(try_list, stmt_list, ast->left);
  if (!sem_validate_current_proc_params_are_initialized(try_list ? try_list : ast)) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// No analysis needed here other than that the two statement lists are ok.
static void sem_trycatch_stmt(ast_node *ast) {
  Contract(is_ast_trycatch_stmt(ast));
  EXTRACT_NAMED(try_list, stmt_list, ast->left);
  EXTRACT_NAMED(catch_list, stmt_list, ast->right);

  bool_t error = false;

  // We assume any statement within the TRY can throw. Using a jump context
  // keeps things safe in the presence of code like the following:
  //
  //   DECLARE x INT;
  //   SET x := 42;
  //   TRY
  //     IF some_condition THEN
  //       SET x := NULL;
  //       IF another_condition THEN
  //         THROW;
  //       END IF;
  //       SET x := 100; -- may never happen
  //     ELSE
  //       -- do nothing; neutral for x
  //     END IF;
  //     -- x is still nonnull here as the outer IF was neutral for x
  //   CATCH
  //     -- x must be nullable here as the final SET may have not occurred
  //   END;
  //   -- x must also be nullable here
  //
  // If we did not use a jump context, x would be nonnull after the TRY because
  // the set to NULL was neutralized by the subsequent set to 100 in the same
  // branch.
  FLOW_PUSH_CONTEXT_JUMP();

  if (try_list) {
    sem_stmt_list_in_current_flow_context(try_list);
    error = is_error(try_list);
  }

  if (!error) {
    EXTRACT_MISC_ATTRS(ast, misc_attrs);
    if (misc_attrs) {
      // If the "cql:try_is_proc_body" attribute is set, we need to check it as
      // though it were the true body of the procedure.
      find_misc_attrs(misc_attrs, sem_find_ast_misc_attr_trycatch_is_proc_body_callback, ast);
      error = is_error(ast);
    }
  }

  FLOW_POP_CONTEXT_JUMP();

  if (!error && catch_list) {
    sem_stmt_list(catch_list);
    error = is_error(catch_list);
  }

  if (error) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// Throw can literally go anywhere, so it's ok.
static void sem_throw_stmt(ast_node *ast) {
  Contract(is_ast_throw_stmt(ast));

  // "throw" implies that we have a return code which implies all of the proc
  // things as surely as if we had used the database.  We need to be a proc
  // with a result code.
  has_dml = 1;

  // ok to throw at the end of any block
  sem_last_statement_in_block(ast);
}

static void sem_verify_transaction_ok(ast_node *ast) {
  if (enforcement.strict_transaction) {
    report_error(ast, "CQL0366: transaction operations disallowed while STRICT TRANSACTION enforcement is on.", NULL);
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// Begin trans can go anywhere, it's ok.
static void sem_begin_trans_stmt(ast_node *ast) {
  Contract(is_ast_begin_trans_stmt(ast));
  sem_verify_transaction_ok(ast);
}

// Commit trans can go anywhere, it's ok.
static void sem_commit_trans_stmt(ast_node *ast) {
  Contract(is_ast_commit_trans_stmt(ast));
  sem_verify_transaction_ok(ast);
}

// Rollback trans can go anywhere but if you're using the format
// where you rollback to a particular save point then we must have
// seen that name in a savepoint statement or it's an error.
static void sem_rollback_trans_stmt(ast_node *ast) {
  Contract(is_ast_rollback_trans_stmt(ast));

  if (!ast->left) {
    sem_verify_transaction_ok(ast);
    return;
  }

  EXTRACT_STRING(name, ast->left);
  if (!symtab_find(savepoints, name)) {
    report_error(ast, "CQL0220: savepoint has not been mentioned yet, probably wrong", name);
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// The savepoint statement can go anywhere but we do record this savepoint name
// as having been seen so we can verify it in rollback.
static void sem_savepoint_stmt(ast_node *ast) {
  Contract(is_ast_savepoint_stmt(ast));

  EXTRACT_STRING(name, ast->left);

  // these don't have lexical semantics but at least we can verify that
  // you don't try to release or rollback to a savepoint we've never seen before
  symtab_add(savepoints, name, ast);  // if already exits, no problem.

  record_ok(ast);
}

// Release savepoint can go anywhere but we must have
// seen that name in a savepoint statement or it's an error.
static void sem_release_savepoint_stmt(ast_node *ast) {
  Contract(is_ast_release_savepoint_stmt(ast));

  EXTRACT_STRING(name, ast->left);

  if (!symtab_find(savepoints, name)) {
    report_error(ast, "CQL0221: savepoint has not been mentioned yet, probably wrong", name);
    record_error(ast);
    return;
  }

  record_ok(ast);
}

// For close [cursor], we just validate that the name is in fact a cursor.
static void sem_close_stmt(ast_node *ast) {
  Contract(is_ast_close_stmt(ast));
  EXTRACT_ANY_NOTNULL(cursor, ast->left);

  // CLOSE [name]

  sem_cursor(cursor);
  if (is_error(cursor)) {
    record_error(ast);
    return;
  }

  if (cursor->sem->sem_type & SEM_TYPE_BOXED) {
    EXTRACT_STRING(name, cursor);
    report_error(ast, "CQL0391: CLOSE cannot be used on a boxed cursor", name);
    record_error(ast);
    return;
  }

  ast->sem = cursor->sem;
}

// `@op` statement is used to declare function transforms for various
// operations. There are limited errors cases here, mainly the type required for
// the transform might be an invalid one -- the only way that can happen is if
// the type is an identifier and the identifer is not a type alias.  All other
// types are valid by construction. Once we've ruled that out, we can record the
// type and the operation in the symbol table, the value is the name of the
// function to use if that shape is encountered.  The function name must be a
// valid *eventually* at the point of the transform.  The transform can fail
// even if we apply it.  We won't know until we see the actual call site and
// operands.  For now we store the mapping.
static void sem_op_stmt(ast_node *ast) {
  Contract(is_ast_op_stmt(ast));
  EXTRACT_ANY_NOTNULL(data_type, ast->left);
  EXTRACT_ANY_NOTNULL(v1, ast->right);
  EXTRACT_ANY_NOTNULL(v2, v1->right);
  EXTRACT_STRING(op, v1->left);
  EXTRACT_STRING(func, v2->left);
  EXTRACT_STRING(targ, v2->right);

  // we check for the special "non-type" identifiers first
  CSTR key = NULL;
  if (is_ast_str(data_type)) {
    EXTRACT_STRING(special, data_type);

    if (!StrCaseCmp("cursor", special)) {
      key = dup_printf("cursor:%s:%s", op, func);
    }
    else if (!StrCaseCmp("null", special)) {
      key = dup_printf("null:%s:%s", op, func);
    }
  }

  // if it's not one of those then we need to:
  // 1. check that the type is valid
  // 2. extract the name of the core type
  // 3. extract the kind if there is one
  // 4. build the key
  if (!key) {
    sem_data_type_var(data_type);
    if (is_error(data_type)) {
      record_error(ast);
      return;
    }

    sem_t sem_type = data_type->sem->sem_type;
    CSTR kind = data_type->sem->kind;
    CSTR type_string = rewrite_type_suffix(sem_type);

    if (kind) {
      key = dup_printf("%s<%s>:%s:%s", type_string, kind, op, func);
    }
    else {
      key = dup_printf("%s:%s:%s", type_string, op, func);
    }
  }

  // Change or add the entry in the symbol table as required; note that key must
  // be durable, it isn't explicitly freed it has to come from the ast pool or
  // another auto-release pool.
  Invariant(key);
  symtab_entry *entry = symtab_find(ops, key);
  if (entry) {
    entry->val = (void*)targ;
  }
  else {
    symtab_add(ops, key, (void*)targ);
  }

  record_ok(ast);
}

// For out [cursor], we first validate that the name is a cursor
// then we set the output type of the procedure we're in accordingly
static void sem_out_any(ast_node *ast) {
  Contract(is_ast_out_stmt(ast) || is_ast_out_union_stmt(ast));
  EXTRACT_ANY_NOTNULL(cursor, ast->left);

  if (!current_proc) {
    report_error(ast, "CQL0222: out cursor statement only makes sense inside of a procedure", NULL);
    record_error(ast);
    return;
  }

  // OUT [name]

  sem_cursor(cursor);
  if (is_error(cursor)) {
    record_error(ast);
    return;
  }

  if (!is_auto_cursor(cursor->sem->sem_type)) {
    report_error(ast, "CQL0223: cursor was not fetched with the auto-fetch syntax 'fetch [cursor]'", cursor->sem->name);
    record_error(ast);
    return;
  }

  ast->sem = cursor->sem;
  sem_update_proc_type_for_select(ast);
}

static void sem_out_stmt(ast_node *ast) {
  Contract(is_ast_out_stmt(ast));
  sem_out_any(ast);
}

static void sem_out_union_stmt(ast_node *ast) {
  Contract(is_ast_out_union_stmt(ast));
  sem_out_any(ast);
}

static void sem_out_union_parent_child_stmt(ast_node *ast) {
  Contract(is_ast_out_union_parent_child_stmt(ast));
  rewrite_out_union_parent_child_stmt(ast);

  // analyze the first statement of the rewrite; the rest of the rewrite will
  // proceed normally as we march through the statement list
  sem_one_stmt(ast);
}

// echo is valid in any context
static void sem_echo_stmt(ast_node *ast) {
  Contract(is_ast_echo_stmt(ast));
  EXTRACT_STRING(str, ast->right);

  record_ok(ast);
}

static void sem_previous_schema_stmt(ast_node *ast) {
  Contract(is_ast_previous_schema_stmt(ast));

  sem_setup_region_filters();

  if (current_proc) {
    report_error(ast, "CQL0225: switching to previous schema validation mode must be outside of any proc", NULL);
    record_error(ast);
    return;
  }

  if (schema_upgrade_version > 0) {
    report_error(ast, "CQL0254: switching to previous schema validation mode not allowed if @schema_upgrade_version was used", NULL);
    record_error(ast);
    return;
  }

  validating_previous_schema = true;
  reset_enforcements();
  enforcement.strict_cast = false;  // this is normally on by default, we want no strict in previous schema

  // we're entering the previous schema section, the regions will be redeclared.
  // later we'll want to validate against these;  we have to save the current
  // regions and begin fresh or there will be bogus duplicate region declaration
  // warnings. see the processing in sem_declare_schema_region_stmt which shows
  // how regions are different than other entities.  This "duplicate" business
  // is handled differently for regions.
  new_regions = schema_regions;
  new_enums = enums;

  // this is all it takes to start fresh...
  schema_regions = symtab_new();
  enums = symtab_new();

  deployable_validations = _ast_pool_new(bytebuf);
  bytebuf_open(deployable_validations);

  reverse_list(&all_subscriptions_list);
  next_subscription = all_subscriptions_list;
  found_subscription_error = false;

  record_ok(ast);
}

// When upgrading the DDL it's necessary to emit create table statements
// for the original version of the schema.  These create statements conflict
// with the current version of the schema.  This attribute tells CQL to
// 1) ignore DDL in stored procs for declaration purposes; only DDL outside of a proc counts
// 2) do not make any columns "deleted" thereby allowing all annotations to be present
//    so they can be used to validate other aspects of the migration script.
static void sem_schema_upgrade_script_stmt(ast_node *ast) {
  Contract(is_ast_schema_upgrade_script_stmt(ast));

  if (current_proc) {
    report_error(ast, "CQL0226: schema upgrade declaration must be outside of any proc", NULL);
    record_error(ast);
    return;
  }

  if (tables->count) {
    report_error(ast, "CQL0227: schema upgrade declaration must come before any tables are declared", NULL);
    record_error(ast);
    return;
  }

  schema_upgrade_script = 1;
  record_ok(ast);
}

// For sql stored procs that are supposed to update previous schema versions
// you can use this attribute to put CQL into that mindset.  This will make
// the columns deleted for the version in question rather than the current version.
// This is important because older schema migration procs might still refer to
// old columns.  Those columns truly exist at that schema version.
static void sem_schema_upgrade_version_stmt(ast_node *ast) {
  Contract(is_ast_schema_upgrade_version_stmt(ast));
  EXTRACT_OPTION(vers, ast->left);

  if (vers <= 0) {
    report_error(ast, "CQL0228: schema upgrade version must be a positive integer", NULL);
    record_error(ast);
    return;
  }

  if (schema_upgrade_version > 0) {
    report_error(ast, "CQL0229: schema upgrade version declaration may only appear once", NULL);
    record_error(ast);
    return;
  }

  if (current_proc) {
    report_error(ast, "CQL0230: schema upgrade version declaration must be outside of any proc", NULL);
    record_error(ast);
    return;
  }

  if (tables->count) {
    report_error(ast, "CQL0231: schema upgrade version declaration must come before any tables are declared", NULL);
    record_error(ast);
    return;
  }

  schema_upgrade_version = vers;

  record_ok(ast);
}

// forward to the more general version with no cursor
static void sem_call_stmt(ast_node *ast) {
  sem_call_stmt_opt_cursor(ast, NULL);
  if (is_struct(ast->sem->sem_type)) {
    sem_update_proc_type_for_select(ast);
  }
}

// the this form declares all the out arguments of a procedure call and calls
// the procedure.  If the out arguments already exist, they are not re-declared.
// The resulting call and out arguments might still have errors.
static void sem_declare_out_call_stmt(ast_node *ast) {
  Contract(is_ast_declare_out_call_stmt(ast));
  EXTRACT_NOTNULL(call_stmt, ast->left);
  EXTRACT_NAME_AST(name_ast, call_stmt->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT(arg_list, call_stmt->right);

  ast_node *proc_stmt = find_proc(name);

  if (!proc_stmt) {
    report_error(ast, "CQL0389: DECLARE OUT requires that the procedure be already declared", name);
    record_error(ast);
    return;
  }

  // The semantic info for the proc is useless if it had errors, can't use it
  if (is_error(proc_stmt)) {
    report_error(ast, "CQL0213: procedure had errors, can't call", name);
    record_error(ast);
    return;
  }

  ast_node *params = get_proc_params(proc_stmt);

  int32_t out_args = 0;

  for (; params && arg_list; params = params->right, arg_list = arg_list->right) {
    EXTRACT_NOTNULL(param, params->left);

    Invariant(param->sem);
    sem_t sem_type_param = param->sem->sem_type;

    if (is_in_parameter(sem_type_param)) {
      // in or in/out we skip
      continue;
    }

    Invariant(is_out_parameter(sem_type_param));  // that's all that's left
    out_args++;

    EXTRACT_ANY_NOTNULL(arg, arg_list->left);

    if (!is_id(arg)) {
      report_error(arg, "CQL0207: expected a variable name for OUT or INOUT argument", param->sem->name);
      record_error(ast);
      return;
    }

    EXTRACT_STRING(var_name, arg);

    if (arg->sem && arg->sem->sem_type & SEM_TYPE_IMPLICIT) {
      // If we're here, we must be reanalyzing a statement list as the implicit
      // flag is already set on `arg`.
      Invariant(current_loop_analysis_state == LOOP_ANALYSIS_STATE_REANALYZE);
      // We also must have already made a variable for this argument.
      symtab_entry *entry = symtab_find(current_variables, var_name);
      Invariant(entry);
      // That variable doesn't have the implicit flag set because we pulled it
      // off later in this function during the first loop analysis pass.
      ast_node *variable = entry->val;
      Invariant(!(variable->sem->sem_type & SEM_TYPE_IMPLICIT));
      // However, if it doesn't have it, we'll run into an issue when we call
      // `sem_call_stmt` below. When the type of `arg` would eventually looked
      // up during that call in `sem_resolve_id_expr`, the variable would
      // already be in scope (*without* the implicit flag set), its type would
      // be written into `arg`, and the implicit flag would be effectively
      // removed from `arg`. We'd then fail to emit the required variable
      // declaration during codegen due to the lack of the flag.
      //
      // The fix is to simply put the implicit flag back onto the variable
      // itself. Doing this allows the remainder of this function to work as it
      // did during the first loop analysis pass: It'll be on the variable for
      // `sem_call_stmt`, then we'll pull it back off at the end.
      variable->sem->sem_type |= SEM_TYPE_IMPLICIT;
      continue;
    }

    if (!symtab_find(current_variables, var_name)) {
      sem_t sem_type_var = param->sem->sem_type;
      sem_type_var &= (SEM_TYPE_NOTNULL | SEM_TYPE_SENSITIVE | SEM_TYPE_CORE);
      sem_type_var |= SEM_TYPE_VARIABLE | SEM_TYPE_IMPLICIT;

      AST_REWRITE_INFO_SET(name_ast->lineno, name_ast->filename);
      ast_node *variable = new_ast_str(var_name);
      variable->sem = ast->sem = new_sem(sem_type_var);
      variable->sem->name = var_name;
      variable->sem->kind = param->sem->kind;
      add_variable(var_name, variable);
      AST_REWRITE_INFO_RESET();
    }
  }

  if (out_args == 0) {
    report_error(name_ast, "CQL0390: DECLARE OUT CALL used on a procedure with no missing OUT arguments", name);
    record_error(ast);
    return;
  }

  sem_call_stmt(call_stmt);
  if (is_error(call_stmt)) {
    record_error(ast);
    return;
  }

  // Now we have to do a final swizzle, we want the call to have the IMPLICIT flag
  // on the variable usages just as we set up above, but we only want *this* call
  // to have them.  The flag must now be removed from the actual variables.  So we
  // do the walk the code generator is going to do but sort of in reverse... we're
  // wanting variables to undecorate.  The IMPLICIT bits are the bread crumbs we need.

  arg_list = call_stmt->right;

  for (; arg_list; arg_list = arg_list->right) {
    EXTRACT_ANY_NOTNULL(arg, arg_list->left);
    if (arg->sem->sem_type & SEM_TYPE_IMPLICIT) {
      EXTRACT_STRING(var_name, arg);
      symtab_entry *entry = symtab_find(current_variables, var_name);
      Invariant(entry);  // we just added it!
      ast_node *var = (ast_node*)(entry->val);
      // This must be the case as the same variable may only appear once if used
      // as an OUT or INOUT argument.
      Invariant(var->sem->sem_type & SEM_TYPE_IMPLICIT);
      // take it off the variable (so later uses will not get the mark)
      var->sem->sem_type &= sem_not(SEM_TYPE_IMPLICIT);
      // the implicit bit stays on the expression
    }
  }

  record_ok(ast);
}

// This is the main entry point for any kind of statement.  When we don't know
// what the statement is yet (such as we're walking a statement list) this will
// dispatch to the correct method.  Also, the top level statement captures
// any errors.
cql_noexport void sem_one_stmt(ast_node *stmt) {
  CHARBUF_OPEN(errbuf);
  bool_t capture_now = options.print_ast && error_capture == NULL;

  if (capture_now) {
    error_capture = &errbuf;
  }

  ast_node *stmt_and_attr = NULL;
  bool_t error = false;
  // We need to validate attributions of a statement, such as cql:ok_table_scan
  // or cql:no_table_scan which can only appear on a specific type of stmt.
  // We also need to do basic validation of the attributes, in case of const expressions.
  if (is_ast_stmt_and_attr(stmt->parent)) {
    stmt_and_attr = stmt->parent;
    EXTRACT_NOTNULL(misc_attrs, stmt_and_attr->left);

    // first check for expression failures with no regard to the particular attribute
    sem_misc_attrs_basic(misc_attrs);
    if (is_error(misc_attrs)) {
      record_error(stmt_and_attr);
      record_error(stmt);
      error = true;
    }
    else {
      sem_misc_attrs(misc_attrs);
      if (is_error(misc_attrs)) {
        record_error(stmt_and_attr);
        record_error(stmt);
        error = true;
      }
    }
  }

  if (!error) {
    symtab_entry *entry = symtab_find(non_sql_stmts, stmt->type);
    if (entry) {
      ((void (*)(ast_node*))entry->val)(stmt);
    }
    else {
      // If you use any of the following then you are a DML proc.
      has_dml = 1;
      entry = symtab_find(sql_stmts, stmt->type);

      // These are all the statements there are, we have to find it in this table
      // or else someone added a new statement and it isn't supported yet.
      Invariant(entry);
      ((void (*)(ast_node*))entry->val)(stmt);
    }
  }

  error |= is_error(stmt);
  // if stmt_and_attr exist then we should report the error to it since it's the root node
  // of a cql statement.
  if (stmt_and_attr) {
    error ? record_error(stmt_and_attr) : record_ok(stmt_and_attr);
  }

  if (capture_now) {
    cql_attach_captured_errors(stmt);
    error_capture = NULL;
  }

  if (is_control_stmt(stmt)) {
    flow_set_context_always_jumps(true);
  }

  CHARBUF_CLOSE(errbuf);
}

// We're just going to walk the tree of attribute values here
// looking for any CONST expressions.  If we find one, we evaluate
// that.  Anything that's not a CONST express is known to be a literal
// or just a name.
static void sem_misc_attr_value(ast_node *ast) {
  // nested attributes, we just recurse on those
  if (is_ast_misc_attr_value_list(ast)) {
    for (ast_node *item = ast; item; item = item->right) {
      sem_misc_attr_value(item->left);
      if (is_error(item->left)) {
        record_error(item);
        record_error(ast);
        return;
      }
    }
  }
  else if (is_ast_const(ast)) {
    // if the ast is bad the error will prop, this evaluates the const
    sem_root_expr(ast, SEM_EXPR_CONTEXT_NONE);
    if (is_error(ast)) {
      // ast already marked with is_error
      return;
    }
  }
  record_ok(ast);
}

// This is the basic checking of misc attributes we always do.
// The point of this is to find any constant expressions and replace
// them with actual literals and reveal any errors in those expressions.
// Most attributes don't need any processing because they are arbitrary names
// or regular literals.
static void sem_misc_attrs_basic(ast_node *ast) {
  Contract(is_ast_misc_attrs(ast));

  ast_node *head = ast;

  while (ast) {
    EXTRACT(misc_attr, ast->left);
    EXTRACT_ANY(misc_attr_value, misc_attr->right);

    if (misc_attr_value) {
      sem_misc_attr_value(misc_attr_value);
      if (is_error(misc_attr_value)) {
        record_error(head);
        return;
      }
    }
    ast = ast->right;
  }
  record_ok(head);
}

// Like `sem_stmt_list`, but does not create a new flow context. This is useful
// for cases where we want to analyze a statement list within a particular type
// of flow context (e.g., a branch context) or within a particular instance of
// an existing context.
static void sem_stmt_list_in_current_flow_context(ast_node *head) {
  Contract(head);

  sem_stmt_level++;

  bool_t error = false;
  for (ast_node *ast = head; ast; ast = ast->right) {
    // ensures we always clear this before ending any top level statement
    Invariant(!in_backing_rewrite);
    ast_node *stmt = first_stmt_in_stmt_list(ast);
    sem_one_stmt(stmt);
    if (is_error(stmt)) {
      error = true;
    }
  }

  // if anything went wrong, then report the error on the statement list
  if (error) {
    record_error(head);
  }
  else {
    record_ok(head);
  }

  sem_stmt_level--;
}

// This helper just walks the list and processes each statement.  If anything
// goes wrong the first node in the list is marked as "error" so that callers
// can see that the net statement list is in error without walking each node.
static void sem_stmt_list(ast_node *head) {
  // ensures we always clear this before ending any top level statement
  Invariant(!in_backing_rewrite);

  // For any list of statements, any improvements made within cannot be assumed
  // to be valid afterwards. We therefore need to create a new context.
  FLOW_PUSH_CONTEXT_NORMAL();

  sem_stmt_list_in_current_flow_context(head);

  FLOW_POP_CONTEXT_NORMAL();
}

// Like `sem_stmt_list`, but specifically for lists of statements within loops
// (e.g., WHILE and LOOP). The optional `true_expr` argument is used to set
// positive improvements via the knowledge that `true_expr` must have been true
// if the body of the loop is presently executing. (Due to the fact that one can
// jump out of a loop, no assumptions can be made about `true_expr` after the
// loop exits, and so no negative improvements are set.)
static void sem_stmt_list_within_loop(ast_node *stmt_list, ast_node *true_expr) {
  Contract(stmt_list);

  loop_analysis_state saved_loop_analysis_state = current_loop_analysis_state;
  bool_t is_top_level_loop = false;

recurse:
  switch (current_loop_analysis_state) {
    case LOOP_ANALYSIS_STATE_NONE:
      is_top_level_loop = true;
      current_loop_analysis_state = LOOP_ANALYSIS_STATE_ANALYZE;
      // Save a stack frame and avoid implicit fallthrough.
      goto recurse;
    case LOOP_ANALYSIS_STATE_ANALYZE: {
      // Analyze the statement list within a jump context. The jump context
      // ensures that any improvements in effect before the loop which are unset
      // within the loop, then re-set later in the loop, are re-unset after the
      // loop. See `_flow_pop_context_jump` for an example of why this is
      // necessary.
      FLOW_PUSH_CONTEXT_JUMP();
      if (true_expr) {
        sem_set_improvements_for_true_condition(true_expr);
      }
      sem_stmt_list_in_current_flow_context(stmt_list);
      FLOW_POP_CONTEXT_JUMP();
      if (is_error(stmt_list)) {
        goto cleanup;
      }
      // We only want to perform reanalysis if this is a top-level loop. Doing
      // it for every loop would not only result in a lot of unnecessary work,
      // it would also cause problems for other parts of the code that need to
      // have the final set of improvements to do their job properly (e.g.,
      // `sem_resolve_id_expr`) -- we cannot have the final set of improvements
      // for a particular loop until all the preceding portions of all enclosing
      // loops also have their final sets.
      if (is_top_level_loop) {
        current_loop_analysis_state = LOOP_ANALYSIS_STATE_REANALYZE;
        goto recurse;
      }
      break;
    }
    case LOOP_ANALYSIS_STATE_REANALYZE: {
      // Analyze the statement list again. This is necessary so that any
      // un-improvements via statements later in the loop can appropriately
      // negatively affect statements earlier in the loop should evaluation of
      // the loop repeat. If we didn't do this, code such as the following would
      // not result in an error:
      //
      //   DECLARE x INT;
      //   SET x := 1;
      //   WHILE some_condition
      //   BEGIN
      //     CALL requires_int_notnull(x);
      //     SET x := NULL;
      //   END;
      //
      // NOTE: We create another jump context here, but a normal context would
      // work just as well because any improvements in effect before the loop that
      // needed to be unset to ensure safety were already unset above.
      FLOW_PUSH_CONTEXT_JUMP();
      if (true_expr) {
        sem_set_improvements_for_true_condition(true_expr);
      }
      sem_stmt_list_in_current_flow_context(stmt_list);
      FLOW_POP_CONTEXT_JUMP();
      if (is_error(stmt_list)) {
        goto cleanup;
      }
      break;
    }
  }

cleanup:
  current_loop_analysis_state = saved_loop_analysis_state;
}

// Expression type for numeric primitives
static void sem_expr_num(ast_node *ast, CSTR cstr) {
  Contract(is_ast_num(ast));

  // we've processed this node before, we want to save the type kind
  // if there is one from previous constant folding
  if (ast->sem) {
    return;
  }

  EXTRACT_NUM_TYPE(num_type, ast);
  switch (num_type) {
  case NUM_BOOL:
    ast->sem = new_sem(SEM_TYPE_BOOL | SEM_TYPE_NOTNULL);
    break;

  case NUM_INT:
    ast->sem = new_sem(SEM_TYPE_INTEGER | SEM_TYPE_NOTNULL);
    break;

  case NUM_LONG:
    ast->sem = new_sem(SEM_TYPE_LONG_INTEGER | SEM_TYPE_NOTNULL);
    break;

  default:
    // this is all that's left
    Contract(num_type == NUM_REAL);
    ast->sem = new_sem(SEM_TYPE_REAL | SEM_TYPE_NOTNULL);
    break;
  }
}

// Expression type for blob literals, valid only in a SQL context
static void sem_expr_blob(ast_node *ast, CSTR cstr) {
  Contract(is_ast_blob(ast));

  if (CURRENT_EXPR_CONTEXT_IS(SEM_EXPR_CONTEXT_NONE)) {
    report_error(ast, "CQL0313: blob literals may only appear in the context of a SQL statement", NULL);
    record_error(ast);
    return;
  }

  // blob literal
  ast->sem = new_sem(SEM_TYPE_BLOB | SEM_TYPE_NOTNULL);
}

// Expression type for string or identifier primitives
static void sem_expr_str(ast_node *ast, CSTR cstr) {
  Contract(is_ast_str(ast));
  EXTRACT_STRING(str, ast);
  if (is_strlit(ast)) {
    // note str is the lexeme, so it is still quoted and escaped
    ast->sem = new_sem(SEM_TYPE_TEXT | SEM_TYPE_NOTNULL);
  }
  else {
    sem_resolve_id_expr(ast, str, NULL);
  }
}

// Expression type for constant NULL
static void sem_expr_null(ast_node *ast, CSTR cstr) {
  Contract(is_ast_null(ast));
  // null literal
  ast->sem = new_sem(SEM_TYPE_NULL);
}

// The dot transform is the last chance for a valid expression
// at this point.  That means we need 1) a valid left side, and
// 2) a property that has a mapping to a function.  If any of
// this fails we will mark the expression as an error.
// The way this is going to work is if the transform is an option
// we will try it. If there is no mapping the transform will produce
// an meaningful error when evaluation proceeds.
static void sem_validate_dot_transform(ast_node *ast, CSTR op) {
  Contract(is_ast_dot(ast));
  Contract(is_id(ast->right));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_STRING(name, ast->right);

  sem_expr(expr);
  if (is_error(expr)) {
    record_error(ast);
    return;
  }

  if (!expr->sem->kind) {
    report_error(expr, "CQL0470: operation is only available for types with a declared type kind like object<something>", ".");
    record_error(expr);
    record_error(ast);
    return;
  }

  rewrite_dot_as_call(ast, op);
  record_ok(ast);
}

// Expression type for scoped name.
static void sem_expr_dot(ast_node *ast, CSTR cstr) {
  Contract(is_ast_dot(ast));
  Contract(is_id(ast->right));
  EXTRACT_ANY_NOTNULL(expr, ast->left);
  EXTRACT_STRING(name, ast->right);

  // if this is normal name syntax we have to first see
  // if this resolves in the usual way.  This unfortunately
  // means that we get two lookups.  We can do better than
  // this but keeping it simple for now.
  if (is_id(expr)) {
    EXTRACT_STRING(scope, expr);
    // if we can resolve it the usual way then do
    sem_resolve_id_expr(ast, name, scope);
    if (is_error(ast) || !ast->sem->name || strcmp(ast->sem->name, "$rewrite")) {
      // it's an error or it evaluated to something legit that isn't a rewrite request
      // whichever of these it is, we're done here.
      return;
    }
  }

  // If we get here we have to rewrite the dot as a call, it's our last chance
  // an error at this point means that we can't even attempt the transform.
  sem_validate_dot_transform(ast, "get");
  if (!is_error(ast)) {
    // If we rewrote it, we need to reanalyze the new expression.
    // If there was no mapping this will fail.
    sem_expr(ast);
  }
}

// This function is used to detect the pattern that leaks memory on SQLite.
// The context is an INSERT statement that is using a SELECT for its data
// the patterns detected that might leak are:
//   insert X
//     select * from X join Y
//
//   insert X
//     select * from X
//     union all
//     select * from Y
//
// The error tells you to replace these with something like
//
//   with cte(*) as (select * from X join Y)
//     insert X select * from cte;
//
// The idea is that the select that forms the insert cannot have a top level operand
// like join or union.  But you can nest one without problem.
//
// Also ok:
//
//   insert X
//     select * from (select * from X join Y)
//
// So here we look at the various select forms:
//   * explain form -> can't happen
//   * with form : look at the inner select and verify that
//   * select form:
//     * if compound report error
//     * if VALUES -> ok
//     * if not compound, report error if top node is a join
static bool_t sem_select_stmt_is_mixed_results(ast_node *ast) {
  Contract(is_select_variant(ast));
  Contract(!is_ast_explain_stmt(ast));  // disallowed by grammar

  ast_node *select_stmt;

  // first extract the select stmt out of the WITH form if needed
  if (is_ast_select_stmt(ast)) {
    select_stmt = ast;
  }
  else {
    Contract(is_ast_with_select_stmt(ast));
    EXTRACT_ANY_NOTNULL(with_prefix, ast->left)
    EXTRACT(cte_tables, with_prefix->left);
    // extract the main select out of the with, this is where we will look for the
    // top level join
    select_stmt = ast->right;
  }

  // Get the select_core, there must be one
  Invariant(is_ast_select_stmt(select_stmt));
  EXTRACT_NOTNULL(select_core_list, select_stmt->left);
  EXTRACT_NOTNULL(select_core, select_core_list->left);

  // if compound, this is the error case
  if (select_core_list->right) {
    return true;
  }

  EXTRACT_ANY(any_select_opts, select_core->left);
  EXTRACT_ANY_NOTNULL(select_core_right, select_core->right);

  // the core might be VALUES -> that's ok
  if (is_ast_select_values(any_select_opts)) {
    // VALUES [values]
    Contract(is_ast_values(select_core_right));
    return false;
  }

  // ok to traverse to query parts now
  Contract(is_ast_select_expr_list_con(select_core_right));
  EXTRACT_NOTNULL(select_expr_list_con, select_core->right);
  EXTRACT_NOTNULL(select_from_etc, select_expr_list_con->right);
  EXTRACT_ANY(query_parts, select_from_etc->left);

  // if top query part is a join -> this is the bad case
  return is_ast_join_clause(query_parts);
}

// helper function to check if a select expression with a built-in aggregate function will always return a row
static bool_t sem_check_aggregate_select_expr_must_return_a_row(ast_node *ast, ast_node *select_where) {
  Contract(is_ast_select_stmt(ast));
  Contract(is_ast_select_where(select_where));

  EXTRACT_NOTNULL(select_groupby, select_where->right);
  EXTRACT(opt_groupby, select_groupby->left);

  EXTRACT_NOTNULL(select_orderby, ast->right);
  EXTRACT_NOTNULL(select_limit, select_orderby->right);
  EXTRACT(opt_limit, select_limit->left);
  EXTRACT_NOTNULL(select_offset, select_limit->right);
  EXTRACT(opt_offset, select_offset->left);

  // Assume any OFFSET or GROUP BY clause may lead to aggregation not return a row. OFFSETs with constant of 0 or less
  // are no-ops, but won't be considered
  if (is_ast_opt_offset(opt_offset) || is_ast_opt_groupby(opt_groupby)) {
    return false;
  }

  // When LIMIT is used, if it cannot evaluate to a positive constant, then it might not return a row
  if (!opt_limit) {
    // Short circuit and allow error handling to kick in elsewhere
    return true;
  }
  else {
    eval_node result = EVAL_NIL;
    eval(opt_limit->left, &result);

    if (result.sem_type != SEM_TYPE_ERROR && result.sem_type != SEM_TYPE_NULL) {
      eval_cast_to(&result, SEM_TYPE_LONG_INTEGER);
      return result.int64_value >= 1;
    }
    else {
      return false;
    }
  }

  return true;
}

// Only for use in (select expr ...) so there is known to be exactly one item in the
// select list.  This tells us if there is some way we can know that there will be
// a row for sure in such an expression.  There are assorted special cases that are
// helpful to handle such as:
//   there is no FROM and no WHERE  e.g. (select 1)
//   the select list is only COUNT or TOTAL e.g. (select count(*) from somewhere)
// anything that looks complicated -> we assume it might not return rows
static bool_t sem_select_expr_must_return_a_row(ast_node *ast) {
  // we only handle simple select forms, WITH etc. are assumed to be complex
  // and might return null or whatever...

  // a with_select or query plan or some such... not simple
  if (!is_ast_select_stmt(ast)) {
    return false;
  }

  // In a simple select statement (not compound or otherwise weird, like (select 1)
  // the lack of a from clause means we can't be in the zero row case so no need
  // to remove nullability there either.
  EXTRACT_NOTNULL(select_core_list, ast->left);
  EXTRACT_NOTNULL(select_core, select_core_list->left);
  EXTRACT_NOTNULL(select_expr_list_con, select_core->right);
  EXTRACT_NOTNULL(select_from_etc, select_expr_list_con->right);
  EXTRACT_ANY(query_parts, select_from_etc->left);
  EXTRACT_NOTNULL(select_where, select_from_etc->right);
  EXTRACT(opt_where, select_where->left);

  // compound query is not simple (it could have INTERSECT or some such)
  if (select_core_list->right) {
    return false;
  }

  // No query_parts and opt_where means there is no FROM/WHERE clause, so the
  // result can't be nullable due to zero rows.  It might be nullable for other
  // reasons already computed so the flag bit just stays

  // note (SELECT EXISTS(whatever)) will fall into this form because there is
  // no top level from or where clause.  Also exists isn't a proc call so it's not the next case

  if (!query_parts && !opt_where) {
    return true;
  }

  // One last chance, a simple select list with just COUNT or EXISTS is also for sure
  // going to return a row, we can handle that.

  EXTRACT_ANY_NOTNULL(select_expr_list, select_expr_list_con->left);

  // select * or T.* or some such have been rewritten away so we know this is a
  // select expression. We have a shot at this, it could be one of the safe ones
  EXTRACT_NOTNULL(select_expr, select_expr_list->left);

  // remember only 1 arg cases are allowed in this func, this is the (select expr..) node
  Contract(select_expr_list->right == NULL);
  EXTRACT_ANY_NOTNULL(expr, select_expr->left);

  // the special cases are calls, if it's not a call we're done
  if (!is_ast_call(expr)) {
    return false;
  }

  // built-in aggregate functions clause might always return at least one row
  EXTRACT_STRING(name, expr->left);
  if (
    !StrCaseCmp("avg", name) ||
    !StrCaseCmp("count", name) ||
    !StrCaseCmp("group_concat", name) ||
    !StrCaseCmp("sum", name) ||
    !StrCaseCmp("total", name)
  ) {
    return sem_check_aggregate_select_expr_must_return_a_row(ast, select_where);;
  }

  // min and max are aggregate functions if they have exactly one argument, they are scalar functions if they have two
  // or more arguments
  if (
    !StrCaseCmp("max", name) ||
    !StrCaseCmp("min", name)
  ) {
      EXTRACT_ANY_NOTNULL(call_arg_list, expr->right);
      EXTRACT_ANY_NOTNULL(arg_list, call_arg_list->right);

      uint32_t arg_count = 0;
      for (ast_node *item = arg_list; item; item = item->right) arg_count++;

      if (arg_count == 1) {
        return sem_check_aggregate_select_expr_must_return_a_row(ast, select_where);
      }
  }

  return false;
}

// Expression type for nested select expression
static void sem_expr_select(ast_node *ast, CSTR cstr) {
  Contract(is_select_variant(ast));
  EXTRACT_ANY_NOTNULL(parent, ast->parent);

  // this tells us if we might be the left side of a select if nothing
  bool_t in_select_if_nothing =
     is_ast_select_if_nothing_throw_expr(parent) ||
     is_ast_select_if_nothing_expr(parent) ||
     is_ast_select_if_nothing_or_null_throw_expr(parent) ||
     is_ast_select_if_nothing_or_null_expr(parent);

  if (in_select_if_nothing && current_expr_context != SEM_EXPR_CONTEXT_NONE) {
    report_error(parent, "CQL0369: (SELECT ... IF NOTHING) construct is for use in top level expressions, not inside of other DML", NULL);
    record_error(ast);
    return;
  }

  if (current_expr_context == SEM_EXPR_CONTEXT_CONSTRAINT) {
    report_error(ast, "CQL0394: nested select expressions may not appear inside of a constraint expression", NULL);
    record_error(ast);
    return;
  }

  // (select ...)
  sem_select_rewrite_backing(ast);
  if (is_error(ast)) {
    return;
  }

  // For purposes of testing "strict if nothing", a select on the left side of the if nothing
  // operator is in an if nothing context  but the right side is not in an if nothing context.
  //  e.g.
  // in (select foo from bar if nothing (select baz)) the (select baz) is not in an
  // if nothing context and hence would generate an error if "strict if nothing" is on.
  // Inside of SQL is ok in all cases
  // Trivial selects (e.g. (select <expr>)) are always ok

  bool_t invalid_select  =
    enforcement.strict_if_nothing &&
    current_expr_context == SEM_EXPR_CONTEXT_NONE &&
    !(in_select_if_nothing && parent->left == ast) &&
    !sem_select_expr_must_return_a_row(ast);

  if (invalid_select) {
    report_error(ast, "CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'", NULL);
    record_error(ast);
    return;
  }

  Invariant(is_struct(ast->sem->sem_type));
  sem_struct *sptr = ast->sem->sptr;
  Invariant(sptr);
  if (sptr->count != 1) {
    report_error(ast, "CQL0232: nested select expression must return exactly one column", NULL);
    record_error(ast);
    return;
  }

  // select expressions might return zero rows and become null like that,
  // so we usually have to remove the notnull bit from the type.
  bool_t remove_notnull = 1;

  if (current_expr_context == SEM_EXPR_CONTEXT_NONE) {
    // In a non-sql context (e.g. set x := (select 1); )
    // a row is expected or there is an exception.
    // So no need to remove nullability there.
    remove_notnull = 0;
  }
  else if (sem_select_expr_must_return_a_row(ast)) {
    // any of the forms that are known to return a row such as
    //  * no where clause
    //  * no from clause
    //  * select list uses only exists or count
    // in those cases zero rows isn't an option so we don't have to concern ourselves removing nullability
    remove_notnull = 0;
  }

  sem_t sem_type = sptr->semtypes[0];

  if (sem_type == SEM_TYPE_NULL) {
     report_error(ast, "CQL0374: SELECT expression is equivalent to NULL", NULL);
     record_error(ast);
     return;
  }

  // and boom remove the bit if we're supposed to remove it (most times except the above exceptions)
  if (remove_notnull) {
    sem_type &= sem_not(SEM_TYPE_NOTNULL);
  }

  ast->sem = new_sem(sem_type);
  ast->sem->name = sptr->names[0];
  ast->sem->kind = sptr->kinds[0];
}

// If nothing throw is exactly the same as a normal select expr
// the only difference is that it is legal inside of strict select if nothing
// because the user has made the throw explicit so they're saying they
// know it's gonna throw and that's ok.
static void sem_expr_select_if_nothing_throw(ast_node *ast, CSTR op) {
  Contract(is_ast_select_if_nothing_throw_expr(ast));
  EXTRACT_ANY_NOTNULL(select_expr, ast->left);
  sem_expr_select(select_expr, op);
  ast->sem = select_expr->sem;
}

// just like the above except we can mark the return type to be not null
static void sem_expr_select_if_nothing_or_null_throw(ast_node *ast, CSTR op) {
  Contract(is_ast_select_if_nothing_or_null_throw_expr(ast));
  EXTRACT_ANY_NOTNULL(select_expr, ast->left);
  sem_expr_select(select_expr, op);
  ast->sem = select_expr->sem;
  if (!is_error(ast)) {
    sem_add_flags(ast, SEM_TYPE_NOTNULL);
  }
}

// Despite the unusual nature of SELECT .. IF NOTHING ... the net semantic rules
// are basically exactly the same as any normal binary operator.
//   * types must be compatible
//   * the net type is the promoted type of left and right
//   * nullable or sensitive if either is nullable or sensitive
//   * type kind must be compatible
//   * special case SELECT ... IF NOTHING OR NULL ... is not null if the right are is not null
static void sem_expr_select_if_nothing(ast_node *ast, CSTR op) {
  // same rules for both forms
  Contract(is_ast_select_if_nothing_expr(ast) || is_ast_select_if_nothing_or_null_expr(ast));

  sem_t core_type_left, core_type_right, combined_flags;
  if (!sem_binary_prep(ast, &core_type_left, &core_type_right, &combined_flags)) {
    return;
  }

  if (error_any_object(ast, core_type_left, core_type_right, op)) {
    return;
  }

  if (!sem_verify_compat(ast, ast->left->sem->sem_type, ast->right->sem->sem_type, op)) {
    return;
  }

  sem_t core_type = sem_combine_types(core_type_left, core_type_right);

  CSTR kind = sem_combine_kinds(ast->right, ast->left->sem->kind);
  if (is_error(ast->right)) {
    record_error(ast);
    return;
  }

  if (is_ast_select_if_nothing_or_null_expr(ast)) {
    if (is_nullable(ast->right->sem->sem_type)) {
      if (is_ast_null(ast->right)) {
        report_error(ast, "CQL0372: SELECT ... IF NOTHING OR NULL THEN NULL is redundant; use SELECT ... IF NOTHING THEN NULL instead", NULL);
        record_error(ast);
        return;
      }
    }
    else {
      // if the right arg is not null then the expression is not null because it's like a builtin ifnull
      combined_flags |= SEM_TYPE_NOTNULL;
    }
  }

  ast->sem = new_sem(core_type | combined_flags);
  ast->sem->kind = kind;
}

// At this point all processing of input is complete.  So now we walk all the tables
// that we ever saw and visit any that have not already been validated.  This is
// the set of tables not present in the previous schema.  All of these must be
// marked with @create.
//
// Note: this processing does not happen in the context of a statement
// so we have to do our own error capture logic.
static void sem_validate_all_tables_not_in_previous(ast_node *root) {
  CHARBUF_OPEN(err_msg);
  bprintf(&err_msg, "CQL0309: new table must be added with @create(%d) or later", max_previous_schema_version);

  for (list_item *item = all_tables_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_create_table_stmt(ast));

    // no need to report on tables that are already in error state
    // backed tables are likewise exempted
    if (!is_error(ast) && !is_backed(ast->sem->sem_type)) {
      EXTRACT_NOTNULL(create_table_name_flags, ast->left);
      EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
      EXTRACT_STRING(name, name_ast);

      sem_validate_old_object_or_marked_create(root, ast, err_msg.ptr, name);
    }
  }

  CHARBUF_CLOSE(err_msg);
}

// Verify that either:
// * the object either previously existed (and hence previously validated)
// * or, the object has been marked as new in the current schema version.
//
// Note: this processing does not happen in the context of a statement
// so we have to do our own error capture logic.
static void sem_validate_old_object_or_marked_create(ast_node *root, ast_node *ast, CSTR err_msg, CSTR name) {
  Contract(root);
  Contract(ast);
  Contract(err_msg);
  Contract(name);

  // if the object has other errors we don't need to check its version info right now, that's just spurious
  if (is_error(ast)) {
    return;
  }

  // if the object was already checked by previous schema, we don't have to do anything
  if (is_validated(ast->sem->sem_type)) {
    return;
  }

  // If the object is marked as created at or after the previous schema version
  // then it's good.
  if (ast->sem->create_version >= max_previous_schema_version) {
    return;
  }

  // Direct to @recreate is also ok
  if (ast->sem->recreate) {
    return;
  }

  report_and_capture_error(root, ast, err_msg, name);
}

// At this point all processing of input is complete.  So now we walk all the tables
// that left the @recreate plan and make sure they entered the strong plan at the right
// version number.
//
// Note: this processing does not happen in the context of a statement
// so we have to do our own error capture logic.
static void sem_validate_all_prev_recreate_tables(ast_node *root) {
  CHARBUF_OPEN(err_msg);
  bprintf(&err_msg, "CQL0399: table must leave @recreate management with @create(%d) or later", max_previous_schema_version);

  for (list_item *item = all_prev_recreate_tables; item; item = item->next) {
    ast_node *ast = item->ast;

    EXTRACT_NOTNULL(create_table_name_flags, ast->left);
    EXTRACT_NAME_AST(name_ast, create_table_name_flags->right);
    EXTRACT_STRING(name, name_ast);

    sem_validate_marked_create_or_delete(root, ast, err_msg.ptr, name);
  }

  CHARBUF_CLOSE(err_msg);
}

// Verify that either:
// * the object was created at a late enough version
// * or, the object was deleted at a late enough version
//
// Note: if it's both we will have previously validated that the versions are compatible with each other
//
// Note: this processing does not happen in the context of a statement
// so we have to do our own error capture logic.
static void sem_validate_marked_create_or_delete(ast_node *root, ast_node *ast, CSTR err_msg, CSTR name) {
  Contract(root);
  Contract(ast);
  Contract(err_msg);
  Contract(name);

  Invariant(is_ast_create_table_stmt(ast));

  // If the object is marked as created at or after the previous schema version
  // then it's good.
  if (ast->sem->create_version >= max_previous_schema_version) {
    return;
  }

  report_and_capture_error(root, ast, err_msg, name);
}

// At this point all processing of input is complete.  So now we walk all the
// created columns.
// Note: this processing does not happen in the context of a statement
// so we have to do our own error capture logic.
static void sem_validate_all_columns_not_in_previous(ast_node *root) {
  CHARBUF_OPEN(err_msg);
  bprintf(&err_msg, "CQL0310: new column must be added with @create(%d) or later", max_previous_schema_version);

  for (list_item *item = created_columns; item; item = item->next) {
    ast_node *def = item->ast;
    Invariant(is_ast_col_def(def));

    EXTRACT_NOTNULL(col_def_type_attrs, def->left);
    EXTRACT_NOTNULL(col_def_name_type, col_def_type_attrs->left);
    EXTRACT_NAME_AST(name_ast, col_def_name_type->left);
    EXTRACT_STRING(name, name_ast);

    sem_validate_old_object_or_marked_create(root, def, err_msg.ptr, name);
  }
  CHARBUF_CLOSE(err_msg);
}

static void sem_enforcement_options(ast_node *ast, bool_t strict) {
  EXTRACT_OPTION(option, ast);

  switch (option) {
    case ENFORCE_STRICT_JOIN:
      enforcement.strict_join = strict;
      break;

    case ENFORCE_FK_ON_UPDATE:
      enforcement.strict_fk_update = strict;
      break;

    case ENFORCE_UPSERT_STMT:
      enforcement.strict_upsert_stmt = strict;
      break;

    case ENFORCE_WINDOW_FUNC:
      enforcement.strict_window_func = strict;
      break;

    case ENFORCE_CAST:
      enforcement.strict_cast = strict;
      break;

    case ENFORCE_WITHOUT_ROWID:
      enforcement.strict_without_rowid = strict;
      break;

    case ENFORCE_TRANSACTION:
      enforcement.strict_transaction = strict;
      break;

    case ENFORCE_SELECT_IF_NOTHING:
      enforcement.strict_if_nothing = strict;
      break;

    case ENFORCE_INSERT_SELECT:
      enforcement.strict_insert_select = strict;
      break;

    case ENFORCE_TABLE_FUNCTION:
      enforcement.strict_table_function = strict;
      break;

    case ENFORCE_IS_TRUE:
      enforcement.strict_is_true = strict;
      break;

    case ENFORCE_SIGN_FUNCTION:
      enforcement.strict_sign_function = strict;
      break;

    case ENFORCE_CURSOR_HAS_ROW:
      enforcement.strict_cursor_has_row = strict;
      break;

    case ENFORCE_UPDATE_FROM:
      enforcement.strict_update_from = strict;
      break;

    case ENFORCE_AND_OR_NOT_NULL_CHECK:
      enforcement.strict_and_or_not_null_check = strict;
      break;

    default:
      // this is all that's left
      Contract(option == ENFORCE_FK_ON_DELETE);
      enforcement.strict_fk_delete = strict;
      break;
  }
}

// At this point all processing of input is complete.  So now we walk all the ad hoc rules
// that we ever saw and visit any that have not already been validated.  This is
// the set of rules not present in the previous schema.  All of these must be
// marked at the most recent version.
//
// Note: this processing does not happen in the context of a statement
// so we have to do our own error capture logic.
static void sem_validate_all_ad_hoc_not_in_previous(ast_node *root) {
  CHARBUF_OPEN(err_msg);
  bprintf(&err_msg, "new ad hoc rule must be added at version %d or later", max_previous_schema_version);

  for (list_item *item = all_ad_hoc_list; item; item = item->next) {
    ast_node *ast = item->ast;
    Invariant(is_ast_schema_ad_hoc_migration_stmt(ast));

    EXTRACT(version_annotation, ast->left);
    EXTRACT_STRING(name, version_annotation->right);

    sem_validate_old_object_or_marked_create(root, ast, err_msg.ptr, name);
  }

  CHARBUF_CLOSE(err_msg);
}

// switch to strict mode
static void sem_enforce_strict_stmt(ast_node * ast) {
  Contract(is_ast_enforce_strict_stmt(ast));
  sem_enforcement_options(ast->left, 1);
  record_ok(ast);
}

// switch to normal mode
static void sem_enforce_normal_stmt(ast_node * ast) {
  Contract(is_ast_enforce_normal_stmt(ast));
  sem_enforcement_options(ast->left, 0);
  record_ok(ast);
}

static void reset_enforcements() {
  memset(&enforcement, 0, sizeof(enforcement));
  enforcement.strict_cast = true;
}

// reset all to normal mode
static void sem_enforce_reset_stmt(ast_node * ast) {
  Contract(is_ast_enforce_reset_stmt(ast));
  reset_enforcements();
  record_ok(ast);
}

// save current enforcement options
static void sem_enforce_push_stmt(ast_node *ast) {
  Contract(is_ast_enforce_push_stmt(ast));
  // this item will be freed with the pool
  enforcement_stack_record *item = _ast_pool_new(enforcement_stack_record);
  item->options = enforcement;
  item->next = enforcement_stack;
  enforcement_stack = item;
  record_ok(ast);
}

// restore previous options
static void sem_enforce_pop_stmt(ast_node *ast) {
  Contract(is_ast_enforce_pop_stmt(ast));
  enforcement_stack_record *item = enforcement_stack;

  if (!item) {
    report_error(ast, "CQL0365: @enforce_pop used but there is nothing to pop", NULL);
    record_error(ast);
    return;
  }

  enforcement = item->options;
  enforcement_stack = item->next;
  record_ok(ast);
}

// Ensure that the schema directives are not inside of a procedure
static bool_t verify_schema_region_out_of_proc(ast_node *ast) {
  if (current_proc) {
    report_error(ast, "CQL0248: schema region directives may not appear inside of a procedure", NULL);
    return false;
  }

  return true;
}


// Checks to see if a given region has any links that peek into the middle of an owned
// Section; these are illegal
static void sem_validate_region_links(ast_node *ast) {
  Contract(is_region(ast));
  EXTRACT_STRING(name, ast->left);

  EXTRACT(region_list, ast->right);
  for (ast_node *item = region_list; item; item = item->right) {
    Contract(is_ast_region_list(item));
    EXTRACT_NOTNULL(region_spec, item->left);
    EXTRACT_STRING(item_name, region_spec->left);
    ast_node *region = find_region(item_name);

    // if it's linking to something unclaimed that's ok
    // if it's linking to something that is a deployable region root that's ok
    // if it's claimed and not the root that's an error
    // if the target already has errors, don't spam more errors

    if (!is_error(region) && region->sem->region && !(region->sem->sem_type & SEM_TYPE_DEPLOYABLE)) {
       CHARBUF_OPEN(msg);
       bprintf(&msg,
        "CQL0291: region links into the middle of a deployable region;"
        " you must point to the root of '%s' not into the middle:",
        region->sem->region);
       report_error(ast, msg.ptr, name);
       ast->sem->region = "(error)";
       record_error(ast);
       CHARBUF_CLOSE(msg);
       return;
    }
  }
}

// A schema region is an partitioning of the schema such that it
// only uses objects in the same partition or one of its declared
// dependencies.  One schema region may be upgraded independently
// from any others (assuming they happen such that dependents are done first).
// Here we validate:
//  * the region name is unique
//  * the dependencies (if any) are unique and exist
static void sem_declare_schema_region_stmt(ast_node *ast) {
  Contract(is_region(ast));
  EXTRACT_STRING(name, ast->left);
  EXTRACT(region_list, ast->right);

  // @DECLARE_SCHEMA_REGION name [USING region_list]

  if (!verify_schema_region_out_of_proc(ast)) {
    record_error(ast);
    return;
  }

  // Check the name list first, before we have defined the new region
  // this prevents any chance of cycles in the DAG.

  if (region_list) {
    if (!sem_verify_no_duplicate_regions(region_list)) {
      record_error(ast);
      return;
    }

    for (ast_node *item = region_list; item; item = item->right) {
      Contract(is_ast_region_list(item));
      EXTRACT_NOTNULL(region_spec, item->left);
      EXTRACT_STRING(item_name, region_spec->left);
      if (!find_region(item_name)) {
        report_error(item, "CQL0244: unknown schema region", item_name);
        record_error(ast);
        return;
      }
    }
  }

  sem_t sem_type = SEM_TYPE_REGION;

  if (is_ast_declare_deployable_region_stmt(ast)) {
    sem_type |= SEM_TYPE_DEPLOYABLE;
  }

  ast->sem = new_sem(sem_type);
  ast->sem->name = name;

  // note that regions get a slightly different treatment when in previous schema
  // validation mode.  Most entites are not added to the name tables at all
  // we check it as we visit it and then move on;   We can't do that with regions
  // because they are used by later things and the "new" regions (before the @previous_schema
  // marker) might be very different. We need the "old" regions to calculate the
  // old deployment regions and make sure they haven't changed.  So we can't just
  // check them and move on like we do with other stuff.  At the end we'll have
  // two symbol tables

  bool_t adding_current_entity = will_add_current_entity();

  // So, per the above we still do this (even if previous schema mode)

  if (!add_region(ast, name)) {
    report_error(ast, "CQL0245: schema region already defined", name);
    record_error(ast);
    return;
  }

  // But we don't do this:  So when emitting the schema we won't emit
  // the previous regions.  Other entites do neither the above add
  // or the below add. This is the difference.

  if (adding_current_entity) {
    add_item_to_list(&all_regions_list, ast);
  }

  sem_validate_region_links(ast);
}

// Recursively marks all the contained regions that are not already deployment regions
// as being deployed in this region.
static void sem_mark_deployment_subgraph(CSTR current, CSTR owner) {
  // Every name we encounter has already been validated!
  ast_node *region = find_region(current);
  Invariant(region);

  // the region field corresponds to the region this entity is in, for a region
  // that means the deployment region its in.  Note that the regions form a DAG
  // so it's possible to get to the same node two different ways.  That's not a problem.
  // By construction this will paint exactly the nodes that are under this owning
  // deployable region and we know it's safe to visit these all because if there
  // were any possible conflicts they would have been spotted when the node was added
  // or when a previous deployment region was declared.  See the relevant logic
  // in sem_declare_deployable_region where unmarked nodes are re-checked.
  if (region->sem->region) {
    // if it's already set, we're good to go
    return;
  }

  region->sem->region = owner;

  EXTRACT(region_list, region->right);
  for (ast_node *item =region_list; item; item = item->right) {
    Contract(is_ast_region_list(item));
    EXTRACT_NOTNULL(region_spec, item->left);
    EXTRACT_STRING(item_name, region_spec->left);
    sem_mark_deployment_subgraph(item_name, owner);
  }
}

// A deployable region is a regular region plus additional rules
// We first declare the region and then check for the containment rules
static void sem_declare_deployable_region_stmt(ast_node *ast) {
  Contract(is_ast_declare_deployable_region_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  sem_declare_schema_region_stmt(ast);
  if (is_error(ast)) {
    return;
  }

  // I am the new owner of the entire subgraph
  sem_mark_deployment_subgraph(ast->sem->name, ast->sem->name);

  for (list_item *item = all_regions_list; item; item = item->next) {
    ast_node *region_ast = item->ast;
    EXTRACT_STRING(target_name, region_ast->left);

    // this region is not yet part of any deployment, it might be reaching into
    // the deployment region we just made, so we have to check its linkage again

    if  (is_error(region_ast)) {
      continue;
    }

    if (!region_ast->sem->region) {

      Invariant(target_name);

      sem_validate_region_links(region_ast);
      if (is_error(region_ast)) {
        // This region is now in error also, its root isn't well defined
        record_error(ast);
        return;
      }
    }
  }

  // I am the new owner of the entire subgraph
  sem_mark_deployment_subgraph(ast->sem->name, ast->sem->name);

  // error checking will go here
}

typedef struct region_walk {
  CSTR root_name;
  symtab *regions;
  bool_t honor_private;
} region_walk;

// Recursively builds the set of all regions that are antecedents of the given region
// This will let us quickly test if any given object should be visible in the current context.
static void sem_walk_regions(region_walk *acc, CSTR name) {
  // First try to add, and see if we've already visited this region.
  // The region shape is a DAG so it's possible to get to the same place
  // two different ways.
  if (!symtab_add(acc->regions, name, NULL)) {
    return;
  }

  // Every name we encounter has already been validated!
  ast_node *region = find_region(name);
  Invariant(region);

  EXTRACT(region_list, region->right);
  for (ast_node *item = region_list; item; item = item->right) {
    Contract(is_ast_region_list(item));
    EXTRACT_NOTNULL(region_spec, item->left);
    EXTRACT_STRING(item_name, region_spec->left);
    EXTRACT_OPTION(type, region_spec->right);
    bool_t is_private = (type == PRIVATE_REGION);

    // Notes here:
    //  * Private things are not private to the one that introduced them
    //    so if we're at the root we visit privates
    //  * If we're doing schema gen or something like that visibility
    //    isn't a consideration, so private shouldn't be honored.
    //  * If you can reach a region two ways one of which isn't private, then
    //    it will be accumulated.

    if (name == acc->root_name || !acc->honor_private || !is_private) {
      sem_walk_regions(acc, item_name);
    }
  }
}

// Just use the helper above to do all regions
cql_noexport void sem_accumulate_full_region_image(symtab *r, CSTR name) {
  region_walk acc = {
    .regions = r,
    .root_name = name,
    .honor_private = 0,
  };

  sem_walk_regions(&acc, name);
}

// Just use the helper above to do only public regions
cql_noexport void sem_accumulate_public_region_image(symtab *r, CSTR name) {
  region_walk acc = {
    .regions = r,
    .root_name = name,
    .honor_private = 1,
  };

  sem_walk_regions(&acc, name);
}

// For each region list (include and exclude) we will first validate that we have
// a valid region then compute its transitive closure.  We're doing this here because
// as we encounter DDL elements we want to be able to make a quick in/out decision.
// Each element has the region string in its AST so by flatting the set here we can
// do a quick in/out test on the include an exclude list and get the right output.
// It also means that anything that can go wrong will go wrong right here;   After this
// all region names are known to be good.
static symtab *sem_accumulate_regions(uint32_t count, char **regions) {
  symtab *result = symtab_new();

  for (uint32_t i = 0; i < count; i++) {
    CSTR region = regions[i];
    if (!find_region(region)) {
      cql_error("invalid region specified '%s'\n", region);
      symtab_delete(result);
      cql_cleanup_and_exit(1);
    }

    sem_accumulate_full_region_image(result, region);
  }

  return result;
}

// To make the region filters, we have to compute the transitive closure of all the regions
// that were specified on the command line.  There are two such region lists and we process
// those lists here.
static void sem_setup_region_filters() {
  // reset these guys if they are already loaded
  SYMTAB_CLEANUP(included_regions);
  SYMTAB_CLEANUP(excluded_regions);

  if (options.include_regions_count) {
    included_regions = sem_accumulate_regions(
      options.include_regions_count,
      options.include_regions);
  }

  if (options.exclude_regions_count) {
    excluded_regions = sem_accumulate_regions(
      options.exclude_regions_count,
      options.exclude_regions);
  }
}

// Entering a schema region makes all the objects that follow part of that
// region.  It also means that all the contained objects must refer to
// only pieces of schema that are in the same region or a dependent region.
// Here we validate that region we are entering is in fact a valid region
// and that there isn't already a schema region.
static void sem_begin_schema_region_stmt(ast_node * ast) {
  Contract(is_ast_begin_schema_region_stmt(ast));
  EXTRACT_STRING(name, ast->left);

  // @BEGIN_SCHEMA_REGION name

  if (!verify_schema_region_out_of_proc(ast)) {
    record_error(ast);
    return;
  }

  if (current_region) {
    report_error(ast, "CQL0246: schema regions do not nest; end the current region before starting a new one", NULL);
    record_error(ast);
    return;
  }

  ast_node *region = find_region(name);
  if (!region) {
    report_error(ast->left, "CQL0244: unknown schema region", name);
    record_error(ast);
    return;
  }

  // Get the canonical name of the region (case adjusted)
  Contract(is_region(region));
  EXTRACT_STRING(region_name, region->left);

  // we already know we are not in a region
  Invariant(!current_region_image);
  current_region_image = symtab_new();
  sem_accumulate_public_region_image(current_region_image, region_name);

  // this is the one and only text pointer value for this region
  current_region = region_name;
  record_ok(ast);
}

// Leaving a schema region puts you back in the default region.
// Here we check that we are in a schema region.
static void sem_end_schema_region_stmt(ast_node * ast) {
  Contract(is_ast_end_schema_region_stmt(ast));

  // @END_SCHEMA_REGION

  if (!verify_schema_region_out_of_proc(ast)) {
    record_error(ast);
    return;
  }

  if (!current_region) {
    report_error(ast, "CQL0247: you must begin a schema region before you can end one", NULL);
    record_error(ast);
    return;
  }

  // We are in a region, so there is for sure a region image
  Invariant(current_region_image);
  symtab_delete(current_region_image);
  current_region_image = NULL;
  current_region = NULL;
  record_ok(ast);
}

static void sem_validate_previous_ad_hoc(ast_node *prev, CSTR name, int32_t version) {
  Contract(is_ast_schema_ad_hoc_migration_stmt(prev));

  // The ad hoc migrates are not mixed with any other kind of migrate scripts in their symbol table, so:
  // 1. some other kind of migrate script can't be used to verify that this one exists
  // 2. for sure the type of the object stored in the symbol table is schema_ad_hoc_migration_stmt
  // Hence the extracts below are absolutely safe.

  ast_node *ast = find_ad_hoc_migrate(name);
  if (!ast) {
    report_error(prev, "CQL0286: ad hoc schema migration directive was removed; this is not allowed", name);
    record_error(prev);
    return;
  }

  EXTRACT_NOTNULL(schema_ad_hoc_migration_stmt, ast);
  EXTRACT_NAMED_NOTNULL(vers_annotation, version_annotation, schema_ad_hoc_migration_stmt->left);
  EXTRACT_OPTION(vers, vers_annotation->left);

  if (vers != version) {
    report_error(ast, "CQL0285: ad hoc schema migration directive version number changed", name);
    record_error(ast);
    record_error(prev);
    return;
  }

  enqueue_pending_region_validation(prev, ast, name);

  // we've checked this migration, it isn't new and it matches
  sem_add_flags(schema_ad_hoc_migration_stmt, SEM_TYPE_VALIDATED);
}

static void sem_schema_unsub_stmt(ast_node *ast) {
  Contract(is_ast_schema_unsub_stmt(ast));
  EXTRACT_NOTNULL(version_annotation, ast->left);
  EXTRACT_STRING(name, version_annotation->right);

  if (validating_previous_schema) {
    record_ok(ast);
    return;
  }

  ast_node *target = find_usable_table_or_view_even_deleted(
    name, ast, "CQL0466: the table/view named in an @unsub directive does not exist");

  if (!target) {
    record_error(ast);
    return;
  }

  if (target->sem->delete_version > 0) {
    report_error(ast, "CQL0469: table/view is already deleted", name);
    record_error(ast);
    return;
  }

  if (target->sem->unsubscribed) {
    report_error(ast, "CQL0472: table/view is already unsubscribed", name);
    record_error(ast);
    return;
  }

  if (is_ast_create_table_stmt(target) && is_table_not_physical(target)) {
    report_error(ast, "CQL0449: unsubscribe does not make sense on non-physical tables", name);
    record_error(ast);
    return;
  }

  bytebuf *buf = symtab_ensure_bytebuf(ref_sources_for_target_table, name);
  size_t ref_count = buf->used / sizeof(ast_node *);
  ast_node **sources = (ast_node **)buf->ptr;

  // provisionally ok
  record_ok(ast);

  for (uint32_t i = 0; i < ref_count; i++) {
    ast_node *src_ast = sources[i];

    // note this checks for both @deleted and @unsub
    if (!is_deleted(src_ast)) {
      // we're not going to return; we keep generating as many errors as needed
      CSTR src_name = sem_get_name(src_ast);

      // carve out an exception for tables that refer to themselves, that FK won't break anything
      if (StrCaseCmp(name, src_name)) {
        report_error(ast, "CQL0473: @unsub is invalid because the table/view is still used by", src_name);
        record_error(ast);
      }
    }
  }

  if (is_error(ast)) {
    return;
  }

  target->sem->unsubscribed = true;
  ast->sem = new_sem(SEM_TYPE_OK);
  ast->sem->region = current_region;

  add_item_to_list(&all_subscriptions_list, ast);

  bool_t is_table = is_ast_create_table_stmt(target);
  bool_t is_recreate = target->sem->recreate;

  // recreate tables need no actions for unsubscription
  // views likewise need no actions (they are always recreate)
  if (is_table && !is_recreate) {
    record_schema_annotation(1, target, name, SCHEMA_ANNOTATION_UNSUB, NULL, version_annotation, 0);
  }
}

static void sem_schema_ad_hoc_migration_stmt_for_version(ast_node *ast) {
  Contract(is_ast_schema_ad_hoc_migration_stmt(ast));
  EXTRACT_NOTNULL(version_annotation, ast->left);

  CSTR name = NULL;
  int32_t version = -1; // sentinel indicating it's not yet set

  if (!sem_validate_version(SCHEMA_ANNOTATION_AD_HOC, ast, &version, &name)) {
    record_error(ast);
    return;
  }

  if (!name) {
    report_error(ast, "CQL0284: ad hoc schema migration directive must provide a procedure to run", NULL);
    record_error(ast);
    return;
  }

  bool_t adding_current_entity = will_add_current_entity();

  ast->sem = new_sem(SEM_TYPE_OK);
  ast->sem->region = current_region;
  ast->sem->create_version = version;

  if (validating_previous_schema) {
    sem_validate_previous_ad_hoc(ast, name, version);
  }
  else if (adding_current_entity) {
    add_item_to_list(&all_ad_hoc_list, ast);
    symtab_add(ad_hoc_migrates, name, ast);
    record_schema_annotation(version, ast, name, SCHEMA_ANNOTATION_AD_HOC, NULL, version_annotation, 0);
  }
}

// this is where you specify a procedure that should be run if you need to recreate a table or a table group
static void sem_schema_ad_hoc_migration_stmt_for_recreate(ast_node *ast) {
  Contract(is_ast_schema_ad_hoc_migration_stmt(ast));
  EXTRACT_STRING(group, ast->left);
  EXTRACT_STRING(proc, ast->right);

  bool_t adding_current_entity = will_add_current_entity();

  ast->sem = new_sem(SEM_TYPE_OK);
  ast->sem->region = current_region;

  // there is no previous schema validation for these guys, you can add and remove them as you please

  if (adding_current_entity) {
    if (!symtab_add(ad_hoc_recreate_actions, group, ast)) {
       report_error(ast, "CQL0176: indicated procedure or group already has a recreate action", group);
       record_error(ast);
       return;
    }
  }

  if (!sem_create_migration_proc_prototype(ast, proc)) {
    record_error(ast);
    return;
  }

  record_ok(ast);
}

static void sem_schema_ad_hoc_migration_stmt(ast_node *ast) {
  Contract(is_ast_schema_ad_hoc_migration_stmt(ast));
  if (ast->right) {
    sem_schema_ad_hoc_migration_stmt_for_recreate(ast);
  }
  else {
    sem_schema_ad_hoc_migration_stmt_for_version(ast);
  }
}

static void enqueue_pending_region_validation(ast_node *prev, ast_node *cur, CSTR name) {
  // we're processing the previous item when we enqueue, if that item has no region
  // then it is allowed to make any change it wants to.
  if (!current_region) {
    // no need to enqueue a check
    return;
  }

  deployable_validation *v = bytebuf_new(deployable_validations, deployable_validation);

  v->prev = prev;
  v->cur = cur;
  v->prev_region = current_region;  // recall we are processing previous items (see above)
  v->cur_region = cur->sem->region ? cur->sem->region : "(none)";
  v->name = name;
}

// Given some schema object (any kind of ast) look to see if it has a region
// if does have a deployment region then make sure it didn't change.
static void sem_validate_previous_deployable_region(ast_node *root, deployable_validation *v) {
  // if there was no previous deployment region you can acquire one
  CSTR prev_region = v->prev_region;
  ast_node *cur = v->cur;
  ast_node *prev = v->prev;
  CSTR  name = v->name;

  // sem error will be missing useful state, no need to look at this and no need to pile
  // on more errors, whatever it is already has errors reported against it
  Contract(!is_error(cur));
  Contract(!is_error(prev));

  // null previous region is not enqueued, there's nothing to validate
  Invariant(prev_region);
  ast_node *prev_reg = find_region(prev_region);

  // Importantly, the entire reason we have to enqueue these is because this
  // check right here cannot be done on the previous region at the time we find the
  // item we are checking.  The deployment region (DR) that contains this region (R) may not
  // have been declared before things were put into (R).  So the check has to happen at the end.

  if (prev_reg->sem->region) {
    // recall that regions themselves have a region tag which is the deployable region they are in
    CSTR prev_deployment_region = prev_reg->sem->region;

    // now get the current deployment region or "(none)" which can match nothing (invalid name)
    CSTR cur_deployment_region = "(none)";
    if (cur->sem->region) {
      ast_node *cur_reg = find_cur_region(cur->sem->region);
      if (cur_reg->sem->region) {
        cur_deployment_region = cur_reg->sem->region;
      }
    }

    if (strcmp(cur_deployment_region, prev_deployment_region)) {
      CHARBUF_OPEN(msg);
      bprintf(&msg,
              "CQL0311: object's deployment region changed from '%s' to '%s'",
              prev_deployment_region,
              cur_deployment_region);

      report_and_capture_error(root, cur, msg.ptr, name);
      record_error(prev);
      CHARBUF_CLOSE(msg);
    }
  }
}

// At this point everything is all queued up and ready to go, just run through the pending
// validations and do them.
static void sem_validate_all_deployable_regions(ast_node *root) {
  uint32_t count = deployable_validations->used / sizeof(deployable_validation);

  deployable_validation *validations = (deployable_validation *)deployable_validations->ptr;

  for (uint32_t i = 0; i < count; i++) {
    deployable_validation *v = &validations[i];

    // don't pile on more errors...
    if (!is_error(v->prev) && !is_error(v->cur)) {
      sem_validate_previous_deployable_region(root, v);
    }
  }
}

static void sem_emit_enums_stmt(ast_node *ast) {
  Contract(is_ast_emit_enums_stmt(ast));
  EXTRACT(name_list, ast->left);

  while (name_list) {
    EXTRACT_NAME_AST(name_ast, name_list->left);
    EXTRACT_STRING(name, name_ast);

    if (!find_enum(name)) {
      report_error(name_ast, "CQL0169: enum not found", name);
      record_error(ast);
      return;
    }

    name_list = name_list->right;
  }

  record_ok(ast);
}

static void sem_emit_constants_stmt(ast_node *ast) {
  Contract(is_ast_emit_constants_stmt(ast));
  EXTRACT_NOTNULL(name_list, ast->left);

  while (name_list) {
    EXTRACT_NAME_AST(name_ast, name_list->left);
    EXTRACT_STRING(name, name_ast);

    if (!find_constant_group(name)) {
      report_error(name_ast, "CQL0169: constant group not found", name);
      record_error(ast);
      return;
    }

    name_list = name_list->right;
  }

  record_ok(ast);
}

static void sem_keep_table_name_in_aliases_stmt(ast_node *ast) {
  Contract(is_ast_keep_table_name_in_aliases_stmt(ast));
  record_ok(ast);

  keep_table_name_in_aliases = 1;
}

// Add a special sem node to a string node to represent an "override" of the original string value.
// This is currently used only for overriding table name aliases for better explain query plan analysis.
static void insert_table_alias_string_overide(ast_node *_Nonnull ast, CSTR _Nonnull table_name) {
  Contract(keep_table_name_in_aliases);
  Contract(is_ast_str(ast));
  EXTRACT_STRING(original_alias, ast);

  // Don't do this renaming if the underlying construct isn't a table (e.g. a CTE instead).
  ast_node *table_ast = find_table_or_view_even_deleted(table_name);
  if (!table_ast) {
    return;
  }

  // attemping to alias this table just makes it not work, you can't rename this virtual table
  if (!strcmp(original_alias, "excluded")) {
    return;
  }

  if (!strcmp(table_name, original_alias)) {
    return;
  }

  bool_t qid = !!(table_ast->sem->sem_type & SEM_TYPE_QID);

  CSTR result;

  // fully decoded and ready to use in both cases
  if (qid) {
    CHARBUF_OPEN(tmp);
    bprintf(&tmp, "[TABLE ");
    cg_unquote_encoded_qstr(&tmp, table_name);
    bprintf(&tmp, " AS %s]", original_alias);
    result = Strdup(tmp.ptr);
    CHARBUF_CLOSE(tmp);
  }
  else {
    result = dup_printf("[TABLE %s AS %s]", table_name, original_alias);
  }

  // Allow existing alias to be reformatted as something like "TABLE table_name AS some_alias".
  sem_node *new_alias_sem = new_sem(SEM_TYPE_OK);
  new_alias_sem->name = result;
  ast->sem = new_alias_sem;
}

// Return value of special sem node inserted by insert_table_alias_string_overide.
cql_noexport CSTR get_inserted_table_alias_string_override(ast_node *_Nonnull ast) {
  if (!ast->left->sem) {
    return NULL;
  }

  return ast->left->sem->name;
}

// Helper for doing series of potential rewrites on column_values node for
// update and update cursor statements.
static void rewrite_column_values_for_update_stmts(ast_node *_Nonnull ast, ast_node *_Nonnull columns_values, sem_struct *sptr) {
  // Any parent ast node to attach sem_err if needed.
  Contract(ast);
  // columns_values ast node to validate and rewrite
  Contract(columns_values);
  // Underlying table or cursor struct being updated by columns_values ast.
  Contract(sptr);

  rewrite_like_column_spec_if_needed(columns_values);
  if (is_error(columns_values)) {
    record_error(ast);
    return;
  }

  EXTRACT_NOTNULL(column_spec, columns_values->left);
  EXTRACT_ANY_NOTNULL(name_list, column_spec->left);
  EXTRACT_ANY_NOTNULL(insert_list, columns_values->right);

  // if there are any FROM C(like shape) thing in the values list, expand them
  if (!rewrite_shape_forms_in_list_if_needed(insert_list)) {
    record_error(ast);
    return;
  }

  // check if length of columns to update and provided values match
  for ( ; name_list && insert_list; name_list = name_list->right, insert_list = insert_list->right) {}
  if (name_list || insert_list) {
    report_error(ast, "CQL0157: count of columns differs from count of values", NULL);
    record_error(ast);
    return;
  }
}

// This is for the macro def statments that have no meaning in this pass
// macros are already expanded
static void sem_no_op_stmt(ast_node *stmt) {
  record_ok(stmt);
}

// Most codegen types are not compatible with previous schema generation because it adds stuff to the AST
// and that stuff isn't even fully type evaluated.  So the best thing to do is punt on codegen if we
// did that sort of validation.
cql_noexport void exit_on_validating_schema() {
  if (validating_previous_schema) {
    cql_error("This code generation mode is not compatible with @previous_schema validation mode.\n");
    cql_cleanup_and_exit(1);
  }
}

#undef STMT_INIT
#define STMT_INIT(x) symtab_add(syms, k_ast_ ## x, (void *)sem_ ## x)

#undef NO_OP_STMT_INIT
#define NO_OP_STMT_INIT(x) symtab_add(syms, k_ast_ ## x, (void*)sem_no_op_stmt)

#undef FUNC_INIT
#define FUNC_INIT(x) symtab_add(builtin_funcs, #x, (void *)sem_func_ ## x)

#undef FUNC_REWRITE_INIT
#define FUNC_REWRITE_INIT(x) { \
  symtab_add(builtin_funcs, #x, (void *)sem_func_ ## x); \
  symtab_add(builtin_sql_rewrites, #x, (void *)1);  }

// A special function is one whose arguments require special treatment during
// semantic analysis, for whatever reason. The procedure that does the analysis
// (of type `sem_special_func`) must therefore be sure to analyze its argument
// list appropriately: It will not be done beforehand as it is with functions
// registered via `FUNC_INIT`. It must also indicate if it is an aggregate
// function so that `sem_expr_call` knows how to handle it.
#undef SPECIAL_FUNC_INIT
#define SPECIAL_FUNC_INIT(x) symtab_add(builtin_special_funcs, #x, (void *)sem_special_func_ ## x)

#undef AGGR_FUNC_INIT
#define AGGR_FUNC_INIT(x) symtab_add(builtin_aggregated_funcs, #x, (void *)sem_aggr_func_ ## x)

#undef EXPR_INIT
#define EXPR_INIT(x, func, str) \
  static sem_expr_dispatch expr_disp_ ## x = { func, str }; \
  symtab_add(exprs, k_ast_ ## x, (void *)&expr_disp_ ## x);

#undef MISC_ATTR_INIT
#define MISC_ATTR_INIT(x) symtab_add(misc_attributes, #x, (void *)sem_misc_attrs_ ## x)

// This method loads up the global symbol tables in either empty state or
// with the appropriate tokens ready to go.  Using our own symbol tables for
// dispatch saves us a lot of if/else string comparison verbosity.
cql_noexport void sem_main(ast_node *ast) {
  Contract(!__charbufs_in_flight);
  // restore all globals and statics we own
  sem_cleanup();
  eval_init();

  AST_REWRITE_INFO_START();

  ops = symtab_new();
  exprs = symtab_new();
  builtin_funcs = symtab_new();
  builtin_special_funcs = symtab_new();
  builtin_sql_rewrites = symtab_new();
  funcs = symtab_new();
  interfaces = symtab_new();
  unchecked_funcs = symtab_new();
  procs = symtab_new();
  unchecked_procs = symtab_new();
  proc_arg_info = symtab_new();
  enums = symtab_new();
  triggers = symtab_new();
  upgrade_procs = symtab_new();
  ad_hoc_migrates = symtab_new();
  tables = symtab_new();
  table_default_values = symtab_new();
  backing_info = symtab_new();
  indices = symtab_new();
  globals = symtab_new();
  constant_groups = symtab_new();
  variable_groups = symtab_new();
  constants = symtab_new();
  current_variables = globals;
  savepoints = symtab_new();
  schema_regions = symtab_new();
  non_sql_stmts = symtab_new();
  sql_stmts = symtab_new();
  ref_sources_for_target_table = symtab_new();
  ref_targets_for_source_table = symtab_new();
  builtin_aggregated_funcs = symtab_new();
  global_types = symtab_new();
  misc_attributes = symtab_new();
  ad_hoc_recreate_actions = symtab_new();
  recreate_group_deps = symtab_new();

  schema_annotations = _ast_pool_new(bytebuf);
  recreate_annotations = _ast_pool_new(bytebuf);
  bytebuf_open(schema_annotations);
  bytebuf_open(recreate_annotations);

  Invariant(cte_cur == NULL);

  symtab *syms = non_sql_stmts;

  STMT_INIT(assign);
  STMT_INIT(call_stmt);
  STMT_INIT(commit_return_stmt);
  STMT_INIT(const_stmt);
  STMT_INIT(continue_stmt);
  STMT_INIT(create_proc_stmt);
  STMT_INIT(declare_const_stmt);
  STMT_INIT(declare_cursor);
  STMT_INIT(declare_cursor_like_name);
  STMT_INIT(declare_cursor_like_select);
  STMT_INIT(declare_cursor_like_typed_names);
  STMT_INIT(declare_enum_stmt);
  STMT_INIT(declare_func_no_check_stmt);
  STMT_INIT(declare_func_stmt);
  STMT_INIT(declare_group_stmt);
  STMT_INIT(declare_interface_stmt);
  STMT_INIT(declare_named_type);
  STMT_INIT(declare_out_call_stmt);
  STMT_INIT(declare_proc_no_check_stmt);
  STMT_INIT(declare_proc_stmt);
  STMT_INIT(declare_select_func_no_check_stmt);
  STMT_INIT(declare_select_func_stmt);
  STMT_INIT(declare_value_cursor);
  STMT_INIT(declare_vars_type);
  STMT_INIT(echo_stmt);
  STMT_INIT(expr_stmt);
  STMT_INIT(fetch_values_stmt);
  STMT_INIT(for_stmt);
  STMT_INIT(guard_stmt);
  STMT_INIT(if_stmt);
  STMT_INIT(ifdef_stmt);
  STMT_INIT(ifndef_stmt);
  STMT_INIT(leave_stmt);
  STMT_INIT(let_stmt);
  STMT_INIT(misc_attrs);
  STMT_INIT(op_stmt);
  STMT_INIT(out_stmt);
  STMT_INIT(out_union_parent_child_stmt);
  STMT_INIT(out_union_stmt);
  STMT_INIT(previous_schema_stmt);
  STMT_INIT(return_stmt);
  STMT_INIT(rollback_return_stmt);
  STMT_INIT(schema_upgrade_script_stmt);
  STMT_INIT(schema_upgrade_version_stmt);
  STMT_INIT(set_from_cursor);
  STMT_INIT(switch_stmt);
  STMT_INIT(while_stmt);

  syms = sql_stmts;

  STMT_INIT(alter_table_add_column_stmt);
  STMT_INIT(begin_schema_region_stmt);
  STMT_INIT(begin_trans_stmt);
  STMT_INIT(close_stmt);
  STMT_INIT(commit_trans_stmt);
  STMT_INIT(create_index_stmt);
  STMT_INIT(create_table_stmt);
  STMT_INIT(create_trigger_stmt);
  STMT_INIT(create_view_stmt);
  STMT_INIT(create_virtual_table_stmt);
  STMT_INIT(declare_deployable_region_stmt);
  STMT_INIT(declare_schema_region_stmt);
  STMT_INIT(delete_returning_stmt);
  STMT_INIT(delete_stmt);
  STMT_INIT(drop_index_stmt);
  STMT_INIT(drop_table_stmt);
  STMT_INIT(drop_trigger_stmt);
  STMT_INIT(drop_view_stmt);
  STMT_INIT(emit_constants_stmt);
  STMT_INIT(emit_enums_stmt);
  STMT_INIT(emit_group_stmt);
  STMT_INIT(end_schema_region_stmt);
  STMT_INIT(enforce_normal_stmt);
  STMT_INIT(enforce_pop_stmt);
  STMT_INIT(enforce_push_stmt);
  STMT_INIT(enforce_reset_stmt);
  STMT_INIT(enforce_strict_stmt);
  STMT_INIT(explain_stmt);
  STMT_INIT(fetch_call_stmt);
  STMT_INIT(fetch_stmt);
  STMT_INIT(insert_returning_stmt);
  STMT_INIT(insert_stmt);
  STMT_INIT(keep_table_name_in_aliases_stmt);
  STMT_INIT(loop_stmt);
  STMT_INIT(proc_savepoint_stmt);
  STMT_INIT(release_savepoint_stmt);
  STMT_INIT(rollback_trans_stmt);
  STMT_INIT(savepoint_stmt);
  STMT_INIT(schema_ad_hoc_migration_stmt);
  STMT_INIT(schema_unsub_stmt);
  STMT_INIT(select_nothing_stmt);
  STMT_INIT(select_stmt);
  STMT_INIT(throw_stmt);
  STMT_INIT(trycatch_stmt);
  STMT_INIT(update_cursor_stmt);
  STMT_INIT(update_returning_stmt);
  STMT_INIT(update_stmt);
  STMT_INIT(upsert_returning_stmt);
  STMT_INIT(upsert_stmt);
  STMT_INIT(with_delete_stmt);
  STMT_INIT(with_insert_stmt);
  STMT_INIT(with_select_stmt);
  STMT_INIT(with_update_stmt);
  STMT_INIT(with_upsert_stmt);

  NO_OP_STMT_INIT(cte_tables_macro_def);
  NO_OP_STMT_INIT(expr_macro_def);
  NO_OP_STMT_INIT(query_parts_macro_def);
  NO_OP_STMT_INIT(select_core_macro_def);
  NO_OP_STMT_INIT(select_expr_macro_def);
  NO_OP_STMT_INIT(stmt_list_macro_def);

  AGGR_FUNC_INIT(avg);
  AGGR_FUNC_INIT(group_concat);
  AGGR_FUNC_INIT(json_group_array);
  AGGR_FUNC_INIT(json_group_object);
  AGGR_FUNC_INIT(jsonb_group_array);
  AGGR_FUNC_INIT(jsonb_group_object);
  AGGR_FUNC_INIT(max);
  AGGR_FUNC_INIT(min);
  AGGR_FUNC_INIT(sum);
  AGGR_FUNC_INIT(total);

  FUNC_INIT(abs);
  FUNC_INIT(changes);
  FUNC_INIT(coalesce);
  FUNC_INIT(cql_compressed);
  FUNC_INIT(cql_get_blob_size);
  FUNC_INIT(cume_dist);
  FUNC_INIT(dense_rank);
  FUNC_INIT(first_value);
  FUNC_INIT(format);
  FUNC_INIT(ifnull);
  FUNC_INIT(ifnull_crash);
  FUNC_INIT(ifnull_throw);
  FUNC_INIT(lag);
  FUNC_INIT(last_insert_rowid);
  FUNC_INIT(last_value);
  FUNC_INIT(lead);
  FUNC_INIT(likelihood);
  FUNC_INIT(likely);
  FUNC_INIT(load_extension);
  FUNC_INIT(nth_value);
  FUNC_INIT(ntile);
  FUNC_INIT(nullable);
  FUNC_INIT(nullif);
  FUNC_INIT(percent_rank);
  FUNC_INIT(printf);
  FUNC_INIT(rank);
  FUNC_INIT(row_number);
  FUNC_INIT(sensitive);
  FUNC_INIT(sign);
  FUNC_INIT(sqlite_offset);
  FUNC_INIT(typeof);
  FUNC_INIT(unlikely);

  FUNC_REWRITE_INIT(char);
  FUNC_REWRITE_INIT(concat);
  FUNC_REWRITE_INIT(concat_ws);
  FUNC_REWRITE_INIT(date);
  FUNC_REWRITE_INIT(datetime);
  FUNC_REWRITE_INIT(glob);
  FUNC_REWRITE_INIT(hex);
  FUNC_REWRITE_INIT(instr);
  FUNC_REWRITE_INIT(json);
  FUNC_REWRITE_INIT(json_array);
  FUNC_REWRITE_INIT(json_array_length);
  FUNC_REWRITE_INIT(json_error_position);
  FUNC_REWRITE_INIT(json_extract);
  FUNC_REWRITE_INIT(json_insert);
  FUNC_REWRITE_INIT(json_object);
  FUNC_REWRITE_INIT(json_patch);
  FUNC_REWRITE_INIT(json_pretty);
  FUNC_REWRITE_INIT(json_quote);
  FUNC_REWRITE_INIT(json_remove);
  FUNC_REWRITE_INIT(json_replace);
  FUNC_REWRITE_INIT(json_set);
  FUNC_REWRITE_INIT(json_type);
  FUNC_REWRITE_INIT(json_valid);
  FUNC_REWRITE_INIT(jsonb);
  FUNC_REWRITE_INIT(jsonb_array);
  FUNC_REWRITE_INIT(jsonb_extract);
  FUNC_REWRITE_INIT(jsonb_insert);
  FUNC_REWRITE_INIT(jsonb_object);
  FUNC_REWRITE_INIT(jsonb_patch);
  FUNC_REWRITE_INIT(jsonb_remove);
  FUNC_REWRITE_INIT(jsonb_replace);
  FUNC_REWRITE_INIT(jsonb_set);
  FUNC_REWRITE_INIT(julianday);
  FUNC_REWRITE_INIT(length);
  FUNC_REWRITE_INIT(like);
  FUNC_REWRITE_INIT(lower);
  FUNC_REWRITE_INIT(ltrim);
  FUNC_REWRITE_INIT(octet_length);
  FUNC_REWRITE_INIT(quote);
  FUNC_REWRITE_INIT(random);
  FUNC_REWRITE_INIT(randomblob);
  FUNC_REWRITE_INIT(replace);
  FUNC_REWRITE_INIT(round);
  FUNC_REWRITE_INIT(rtrim);
  FUNC_REWRITE_INIT(soundex);
  FUNC_REWRITE_INIT(sqlite_compileoption_get);
  FUNC_REWRITE_INIT(sqlite_compileoption_used);
  FUNC_REWRITE_INIT(sqlite_source_id);
  FUNC_REWRITE_INIT(sqlite_version);
  FUNC_REWRITE_INIT(strftime);
  FUNC_REWRITE_INIT(substr);
  FUNC_REWRITE_INIT(substring);
  FUNC_REWRITE_INIT(time);
  FUNC_REWRITE_INIT(total_changes);
  FUNC_REWRITE_INIT(trim);
  FUNC_REWRITE_INIT(unhex);
  FUNC_REWRITE_INIT(unicode);
  FUNC_REWRITE_INIT(upper);
  FUNC_REWRITE_INIT(zeroblob);

  SPECIAL_FUNC_INIT(count);
  SPECIAL_FUNC_INIT(cql_blob_create);
  SPECIAL_FUNC_INIT(cql_blob_get);
  SPECIAL_FUNC_INIT(cql_blob_get_type);
  SPECIAL_FUNC_INIT(cql_blob_update);
  SPECIAL_FUNC_INIT(cql_inferred_notnull);
  SPECIAL_FUNC_INIT(iif);
  SPECIAL_FUNC_INIT(ptr);

  EXPR_INIT(num, sem_expr_num, "NUM");
  EXPR_INIT(str, sem_expr_str, "STR");
  EXPR_INIT(blob, sem_expr_blob, "BLB");
  EXPR_INIT(null, sem_expr_null, "NULL");
  EXPR_INIT(dot, sem_expr_dot, "DOT");
  EXPR_INIT(const, sem_expr_const, "CONST");
  EXPR_INIT(lshift, sem_binary_integer_math, "<<");
  EXPR_INIT(rshift, sem_binary_integer_math, ">>");
  EXPR_INIT(bin_and, sem_binary_integer_math, "&");
  EXPR_INIT(bin_or, sem_binary_integer_math, "|");
  EXPR_INIT(collate, sem_collate, "COLLATE");
  EXPR_INIT(mul, sem_binary_math, "*");
  EXPR_INIT(div, sem_binary_math, "/");
  EXPR_INIT(mod, sem_binary_integer_math, "%");
  EXPR_INIT(add, sem_binary_math, "+");
  EXPR_INIT(sub, sem_binary_math, "-");
  EXPR_INIT(not, sem_unary_logical, "NOT");
  EXPR_INIT(is_not_true, sem_unary_is_true_or_false, "IS NOT TRUE");
  EXPR_INIT(is_not_false, sem_unary_is_true_or_false, "IS NOT FALSE");
  EXPR_INIT(is_true, sem_unary_is_true_or_false, "IS TRUE");
  EXPR_INIT(is_false, sem_unary_is_true_or_false, "IS FALSE");
  EXPR_INIT(tilde, sem_unary_integer_math, "~");
  EXPR_INIT(uminus, sem_unary_math, "-");
  EXPR_INIT(eq, sem_binary_eq_or_ne, "=");
  EXPR_INIT(lt, sem_binary_compare, "<");
  EXPR_INIT(gt, sem_binary_compare, ">");
  EXPR_INIT(ne, sem_binary_eq_or_ne, "<>");
  EXPR_INIT(ge, sem_binary_compare, ">=");
  EXPR_INIT(le, sem_binary_compare, "<=");
  EXPR_INIT(array, sem_expr_array, "get_from");
  EXPR_INIT(call, sem_expr_call, "CALL");
  EXPR_INIT(window_func_inv, sem_expr_window_func_inv, "WINDOW-FUNC-INV");
  EXPR_INIT(raise, sem_expr_raise, "RAISE");
  EXPR_INIT(exists_expr, sem_expr_exists, "EXISTS");
  EXPR_INIT(between, sem_expr_between_or_not_between, "BETWEEN");
  EXPR_INIT(not_between, sem_expr_between_or_not_between, "NOT BETWEEN");
  EXPR_INIT(between_rewrite, sem_expr_between_rewrite, "BETWEEN REWRITE");
  EXPR_INIT(and, sem_binary_logical, "AND");
  EXPR_INIT(or, sem_binary_logical, "OR");
  EXPR_INIT(select_stmt, sem_expr_select, "SELECT");
  EXPR_INIT(select_if_nothing_throw_expr, sem_expr_select_if_nothing_throw, "IF NOTHING THROW");
  EXPR_INIT(select_if_nothing_or_null_throw_expr, sem_expr_select_if_nothing_or_null_throw, "IF NOTHING OR NULL THROW");
  EXPR_INIT(select_if_nothing_expr, sem_expr_select_if_nothing, "IF NOTHING");
  EXPR_INIT(select_if_nothing_or_null_expr, sem_expr_select_if_nothing, "IF NOTHING OR NULL");
  EXPR_INIT(with_select_stmt, sem_expr_select, "WITH...SELECT");
  EXPR_INIT(is, sem_binary_is_or_is_not, "IS");
  EXPR_INIT(is_not, sem_binary_is_or_is_not, "IS NOT");
  EXPR_INIT(like, sem_binary_like, "LIKE");
  EXPR_INIT(not_like, sem_binary_like, "NOT LIKE");
  EXPR_INIT(match, sem_binary_match, "MATCH");
  EXPR_INIT(not_match, sem_binary_match, "NOT MATCH");
  EXPR_INIT(regexp, sem_binary_match, "REGEXP");
  EXPR_INIT(not_regexp, sem_binary_match, "NOT REGEXP");
  EXPR_INIT(glob, sem_binary_match, "GLOB");
  EXPR_INIT(not_glob, sem_binary_match, "NOT GLOB");
  EXPR_INIT(in_pred, sem_expr_in_pred_or_not_in, "IN");
  EXPR_INIT(not_in, sem_expr_in_pred_or_not_in, "NOT IN");
  EXPR_INIT(cast_expr, sem_expr_cast, "CAST");
  EXPR_INIT(type_check_expr, sem_expr_type_check, "TYPE_CHECK");
  EXPR_INIT(case_expr, sem_expr_case, "CASE");
  EXPR_INIT(concat, sem_concat, "||");
  EXPR_INIT(jex1, sem_jex1, "->");
  EXPR_INIT(jex2, sem_jex2, "->>");
  EXPR_INIT(reverse_apply, sem_reverse_apply, ":");
  EXPR_INIT(reverse_apply_poly_args, sem_reverse_apply, ":");
  EXPR_INIT(expr_assign, sem_expr_invalid_op, ":=");
  EXPR_INIT(add_eq, sem_expr_invalid_op, "+=");
  EXPR_INIT(sub_eq, sem_expr_invalid_op, "-=");
  EXPR_INIT(mul_eq, sem_expr_invalid_op, "*=");
  EXPR_INIT(div_eq, sem_expr_invalid_op, "/=");
  EXPR_INIT(mod_eq, sem_expr_invalid_op, "%=");
  EXPR_INIT(and_eq, sem_expr_invalid_op, "&=");
  EXPR_INIT(or_eq, sem_expr_invalid_op, "|=");
  EXPR_INIT(ls_eq, sem_expr_invalid_op, "<<=");
  EXPR_INIT(rs_eq, sem_expr_invalid_op, ">>=");
  EXPR_INIT(star, sem_expr_invalid_op, "*");
  EXPR_INIT(table_star, sem_expr_invalid_op, "T.*");

  MISC_ATTR_INIT(alias_of);
  MISC_ATTR_INIT(no_table_scan);
  MISC_ATTR_INIT(ok_table_scan);

  if (ast) {
    sem_stmt_list(ast);
  }

  Invariant(cte_cur == NULL);

  // put tables/views/etc into the natural order (the order declared)
  reverse_list(&all_tables_list);
  reverse_list(&all_functions_list);
  reverse_list(&all_views_list);
  reverse_list(&all_indices_list);
  reverse_list(&all_triggers_list);
  reverse_list(&all_regions_list);
  reverse_list(&all_ad_hoc_list);
  reverse_list(&all_enums_list);
  reverse_list(&all_select_functions_list);

  // We want the list in order when validating previous schema
  // to help us to do the validations, so we don't need to reverse it again
  // but if we never hit @previous_schmea then reverse it now.
  if (!validating_previous_schema) {
    reverse_list(&all_subscriptions_list);
  }

  // the index list in any given table needs to be reversed to get the natural order
  for (list_item *item = all_tables_list; item; item = item->next) {
    ast_node *table = item->ast;
    Invariant(ast);

    if (table->sem && table->sem->table_info && table->sem->table_info->index_list) {
      reverse_list(&table->sem->table_info->index_list);
    }
  }

  if (validating_previous_schema) {
    reverse_list(&all_prev_recreate_tables);
    sem_validate_all_tables_not_in_previous(ast);
    sem_validate_all_columns_not_in_previous(ast);
    sem_validate_all_prev_recreate_tables(ast);
    sem_validate_all_ad_hoc_not_in_previous(ast);
    sem_validate_all_deployable_regions(ast);
  }

  if (validating_previous_schema) {
    // In case there is any futher processing, the region symbol table
    // used during previous schema procesing is now useless, put it back
    // to the normal  one.
    symtab_delete(schema_regions);  // the regions during previous schema processing
    schema_regions = new_regions;   // the original regions
    new_regions = NULL;             // nobody should be looking here anymore

    symtab_delete(enums);  // the enums during previous schema processing
    enums = new_enums;     // the original enums
    new_enums = NULL;      // nobody should be looking here anymore
  }

  AST_REWRITE_INFO_END();

  // in case later passes need the regions resolved
  sem_setup_region_filters();
}

static sem_node *new_sem_std(sem_t sem_type, ast_node *arg_list) {
  sem_type = core_type_of(sem_type);
  sem_t sensitive = 0;
  sem_t notnull = SEM_TYPE_NOTNULL;

  for (ast_node *ast = arg_list; ast; ast = ast->right) {
     ast_node *arg = ast->left;
     sensitive |= (arg->sem->sem_type & SEM_TYPE_SENSITIVE);
     notnull &= (arg->sem->sem_type & SEM_TYPE_NOTNULL);
  }

  return new_sem(sem_type | sensitive | notnull);
}

#define ARG_COUNT 8

typedef struct arg_pattern {
  uint16_t data[ARG_COUNT];
  int16_t repeat_start;
  int16_t repeat_period;
} arg_pattern;

static void sem_parse_arg_pattern(CSTR _Nonnull input, arg_pattern *_Nonnull out);

static bool_t sem_validate_arg_pattern(CSTR type_string, ast_node *ast_call, uint32_t arg_count) {
  Contract(is_ast_call(ast_call));
  EXTRACT_NAME_AST(name_ast, ast_call->left);
  EXTRACT_STRING(name, name_ast);
  EXTRACT_NOTNULL(call_arg_list, ast_call->right);
  EXTRACT(arg_list, call_arg_list->right);

  arg_pattern pat;
  sem_parse_arg_pattern(type_string, &pat);
  uint16_t *types = pat.data;

  if (pat.repeat_period && arg_count >= pat.repeat_start) {
    if ((((int16_t)arg_count - pat.repeat_start) % pat.repeat_period) != 0) {
      CHARBUF_OPEN(msg);
      bprintf(&msg, "CQL0079: starting at argument %d, arguments must come in groups of %d in",
        pat.repeat_start + 1, pat.repeat_period);  // one based argument numbers
      report_error(ast_call, Strdup(msg.ptr), name);
      record_error(ast_call);
      CHARBUF_CLOSE(msg);
      return false;
    }
  }

  uint16_t iarg = 0;
  uint16_t inum = 1;
  for (ast_node *ast = arg_list; ast; ast = ast->right, iarg++, inum++) {
    Contract(is_ast_arg_list(arg_list));
    EXTRACT_ANY_NOTNULL(arg, ast->left);

    if (types[iarg] == 0 || types[iarg] == SEM_TYPE_MASK_OPT) {
      // too many args
      report_error(ast_call, "CQL0079: too many arguments in function", name);
      record_error(ast_call);
      return false;
    }

    uint16_t arg_mask = (uint16_t)(1 << core_type_of(arg->sem->sem_type));

    if (types[iarg] & SEM_TYPE_MASK_REP) {
       iarg -= pat.repeat_period;
    }

    uint16_t reqd_mask = types[iarg];
    if (!(reqd_mask & arg_mask)) {

      CHARBUF_OPEN(msg);
      if (arg_mask & SEM_TYPE_MASK_NULL) {
        bprintf(&msg, "CQL0076: argument %d is a NULL literal; useless in", inum);
        report_error(arg, Strdup(msg.ptr), name);
        record_error(arg);
        record_error(ast_call);
      }
      else {
        bprintf(&msg, "CQL0084: argument %d '", inum);
        get_sem_core(arg->sem->sem_type, &msg);
        bprintf(&msg, "' is an invalid type; valid types are: ");

        if (reqd_mask & SEM_TYPE_MASK_BOOL) bprintf(&msg, "'bool' ");
        if (reqd_mask & SEM_TYPE_MASK_INT)  bprintf(&msg, "'integer' ");
        if (reqd_mask & SEM_TYPE_MASK_LONG) bprintf(&msg, "'long' ");
        if (reqd_mask & SEM_TYPE_MASK_REAL) bprintf(&msg, "'real' ");
        if (reqd_mask & SEM_TYPE_MASK_TEXT) bprintf(&msg, "'text' ");
        if (reqd_mask & SEM_TYPE_MASK_BLOB) bprintf(&msg, "'blob' ");
        if (reqd_mask & SEM_TYPE_MASK_OBJ)  bprintf(&msg, "'object' ");
        bprintf(&msg, "in");

        report_error(arg, Strdup(msg.ptr), name);
        record_error(arg);
        record_error(ast_call);
      }
      CHARBUF_CLOSE(msg);
      return false;
    }
  }

  // if there are more arguments and they are not optional then too few
  if (types[iarg] != 0 && !(types[iarg] & SEM_TYPE_MASK_OPT)) {
    // too few args
    report_error(ast_call, "CQL0079: too few arguments in function", name);
    record_error(ast_call);
    return false;
  }

  return true;
}

static void sem_parse_arg_pattern(CSTR input, arg_pattern *out) {
   Contract(out);
   int16_t item = 0;
   memset(out, 0, sizeof(*out));
   uint16_t *data = out->data;
   int16_t last_optional = -1;

   CSTR pattern = input;

   for ( ;*pattern; pattern++) {
      bool_t handled = false;
      switch (*pattern) {
      case 'n': data[item] |= SEM_TYPE_MASK_NULL; handled = true; break;
      case 'f': data[item] |= SEM_TYPE_MASK_BOOL; handled = true; break;
      case 'i': data[item] |= SEM_TYPE_MASK_INT;  handled = true; break;
      case 'l': data[item] |= SEM_TYPE_MASK_LONG; handled = true; break;
      case 'd': data[item] |= SEM_TYPE_MASK_REAL; handled = true; break;
      case 's': data[item] |= SEM_TYPE_MASK_TEXT; handled = true; break;
      case 'b': data[item] |= SEM_TYPE_MASK_BLOB; handled = true; break;
      case 'o': data[item] |= SEM_TYPE_MASK_OBJ;  handled = true; break;
      case '[':
        for (int i = item; i < ARG_COUNT; i++) {
          Contract(data[i] == 0);
          data[i] = SEM_TYPE_MASK_OPT;
        }
        handled = true;
        last_optional = item;
        break;

      case ']':
        Contract(pattern[1] == ',' || pattern[1] == '\0');
        Contract(last_optional >= 0);
        last_optional = -1;
        handled = true;
        break;

      case '*':
        Contract(last_optional >= 0);
        Contract(item > last_optional);
        Contract(data[item] == SEM_TYPE_MASK_OPT);
        Contract(pattern[1] == ']');
        Contract(pattern[2] == '\0');
        data[item] |= SEM_TYPE_MASK_REP;
        out->repeat_start = last_optional;
        out->repeat_period = item - last_optional;
        handled = true;
        break;

      case ',':
        item++;
        Contract(item <= 7);
        handled = true;
        break;
      }

      Contract(handled);
   }
}

// This method frees all the global state of the semantic analyzer
cql_noexport void sem_cleanup() {
  eval_cleanup();

  BYTEBUF_CLEANUP(deployable_validations);
  BYTEBUF_CLEANUP(recreate_annotations);
  BYTEBUF_CLEANUP(schema_annotations);
  BYTEBUF_CLEANUP(unitary_locals);

  SYMTAB_CLEANUP(ad_hoc_migrates);
  SYMTAB_CLEANUP(ref_sources_for_target_table);
  SYMTAB_CLEANUP(ref_targets_for_source_table);
  SYMTAB_CLEANUP(builtin_funcs);
  SYMTAB_CLEANUP(builtin_special_funcs)
  SYMTAB_CLEANUP(builtin_sql_rewrites)
  SYMTAB_CLEANUP(current_region_image);
  SYMTAB_CLEANUP(exprs);
  SYMTAB_CLEANUP(funcs);
  SYMTAB_CLEANUP(unchecked_funcs);
  SYMTAB_CLEANUP(globals);
  SYMTAB_CLEANUP(indices);
  SYMTAB_CLEANUP(locals);
  SYMTAB_CLEANUP(constant_groups);
  SYMTAB_CLEANUP(variable_groups);
  SYMTAB_CLEANUP(constants);
  SYMTAB_CLEANUP(monitor_symtab );
  SYMTAB_CLEANUP(new_regions);
  SYMTAB_CLEANUP(new_enums);
  SYMTAB_CLEANUP(non_sql_stmts);
  SYMTAB_CLEANUP(ops);
  SYMTAB_CLEANUP(procs);
  SYMTAB_CLEANUP(unchecked_procs);
  SYMTAB_CLEANUP(interfaces);
  SYMTAB_CLEANUP(proc_arg_info);
  SYMTAB_CLEANUP(enums);
  SYMTAB_CLEANUP(schema_regions);
  SYMTAB_CLEANUP(savepoints);
  SYMTAB_CLEANUP(sql_stmts);
  SYMTAB_CLEANUP(table_items);
  SYMTAB_CLEANUP(tables);
  SYMTAB_CLEANUP(backing_info);
  SYMTAB_CLEANUP(triggers);
  SYMTAB_CLEANUP(upgrade_procs);
  SYMTAB_CLEANUP(builtin_aggregated_funcs);
  SYMTAB_CLEANUP(included_regions);
  SYMTAB_CLEANUP(excluded_regions);
  SYMTAB_CLEANUP(global_types);
  SYMTAB_CLEANUP(misc_attributes);
  SYMTAB_CLEANUP(ad_hoc_recreate_actions);
  SYMTAB_CLEANUP(table_default_values);
  SYMTAB_CLEANUP(recreate_group_deps);

  // these are getting zeroed so that leaksanitizer will not count those objects as reachable from a global root.

  all_ad_hoc_list = NULL;
  all_functions_list = NULL;
  all_indices_list = NULL;
  all_prev_recreate_tables = NULL;
  all_regions_list = NULL;
  all_select_functions_list = NULL;
  all_tables_list = NULL;
  all_subscriptions_list = NULL;
  next_subscription = NULL;
  found_subscription_error = false;
  all_triggers_list = NULL;
  all_views_list = NULL;
  created_columns = NULL;
  cte_cur = NULL;
  current_explain_stmt = NULL;
  current_expr_context = SEM_EXPR_CONTEXT_NONE;
  current_joinscope = NULL;
  current_region = NULL;
  current_upsert_table_ast = NULL;
  current_variables = NULL;  // this is either locals or globals, freed above
  has_dml = false;
  in_shared_fragment_call = false;
  in_trigger = false;
  in_trigger_when_expr = false;
  in_switch = false;
  in_upsert = false;
  in_upsert_rewrite = false;
  keep_table_name_in_aliases = false;
  loop_depth = 0;
  in_proc_savepoint = false;
  max_previous_schema_version = -1;
  reset_enforcements();
  enforcement_stack = NULL; // all the stack entries are in the ast pool, nothing to free
  monitor_jptr = NULL;
  recreates = 0;
  schema_upgrade_script = false;
  schema_upgrade_version = -1;
  select_level = 0;
  sem_stmt_level = -1;
  sem_ok = NULL;
  validating_previous_schema = false;
  between_count = 0;
  pending_table_validations_head = NULL;
  current_table_name = NULL;
  current_table_ast = NULL;
  local_types = NULL;
  is_analyzing_notnull_rewrite = false;
  global_notnull_improvements = NULL;
  current_loop_analysis_state = LOOP_ANALYSIS_STATE_NONE;
  current_proc_contains_try_is_proc_body = false;
  in_backing_rewrite = false;
  backed_tables_list = NULL;
}

#endif

// When validating against the previous schema we need to make sure all these items
// have been validated.  Any that are found in the old schema must match appropriately
// and any that are not found must have suitable @create markers.
cql_data_defn( list_item *all_tables_list );
cql_data_defn( list_item *all_subscriptions_list );
cql_data_defn( list_item *all_functions_list );
cql_data_defn( list_item *all_views_list );
cql_data_defn( list_item *all_indices_list );
cql_data_defn( list_item *all_triggers_list );
cql_data_defn( list_item *all_regions_list );
cql_data_defn( list_item *all_ad_hoc_list );
cql_data_defn( list_item *all_select_functions_list );
cql_data_defn( list_item *all_enums_list );
cql_data_defn( list_item *all_constant_groups_list );
cql_data_defn( cte_state *cte_cur );
cql_data_defn( symtab *ref_sources_for_target_table );
cql_data_defn( symtab *ref_targets_for_source_table );

// If creating debug/test output, we will hold errors for a given statement in this buffer.
cql_data_defn( charbuf *error_capture );

// The flags for the global proc (which has no ast node) this is what captures loose statements
cql_data_defn( sem_t global_proc_flags );

// If there is a current proc, it's root ast.
cql_data_defn(ast_node *current_proc);

cql_data_defn( symtab *schema_regions );

// These are the symbol tables with the accumulated included/excluded regions
cql_data_defn( symtab *included_regions );
cql_data_defn( symtab *excluded_regions );

// all the schema annotations
cql_data_defn( bytebuf *schema_annotations );
cql_data_defn( bytebuf *recreate_annotations );

// any table or group can have an action
cql_data_defn( symtab *ad_hoc_recreate_actions );

// If the current context is a upsert statement
cql_data_defn( bool_t in_upsert );

// We can suppress CQL0280 in a rewrite because we know the form we create is good
cql_data_defn( bool_t in_upsert_rewrite );

// hold the table ast query in the current upsert statement.
cql_data_defn ( ast_node *current_upsert_table_ast );
// This is the symbol table with recreate group dependencies
cql_data_defn( symtab *recreate_group_deps );

// Truthy when the @keep_table_name_in_aliases_stmt directive is used.
cql_data_defn( bool_t keep_table_name_in_aliases );
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// MIT license applies only to the extent that this file has been modified
// from the public domain version, which, as it happens, is barely at all.
//
// The original header with claritications from its github readme is
// included here including the public domain nature of the original code,
// and attribution to the original author.

/*********************************************************************
* Filename:   sha256.c
* Author:     Brad Conte (brad AT bradconte.com)
* Release:    This code is released into the public domain free of any
*             restrictions. The author requests acknowledgement if the
*             code is used, but does not require it.
*             This code is provided free of any liability and without
*             any quality claims by the author.
* Disclaimer: This code is presented "as is" without any guarantees.
* Details:    Implementation of the SHA-256 hashing algorithm.
              SHA-256 is one of the three algorithms in the SHA2
              specification. The others, SHA-384 and SHA-512, are not
              offered in this implementation.
              Algorithm specification can be found here:
               * http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf
              This implementation uses little endian byte order.
*********************************************************************/

/*************************** HEADER FILES ***************************/

/****************************** MACROS ******************************/
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))

#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))

/**************************** VARIABLES *****************************/
static const SHA256_WORD k[64] = {
  0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
  0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
  0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
  0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
  0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
  0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
  0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
  0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

/*********************** FUNCTION DEFINITIONS ***********************/
void sha256_transform(SHA256_CTX *ctx, const SHA256_BYTE data[])
{
  SHA256_WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

  for (i = 0, j = 0; i < 16; ++i, j += 4) {
    m[i] = (SHA256_WORD)(
                  ((uint64_t)data[j] << 24) |
                  ((uint64_t)data[j + 1] << 16) |
                  ((uint64_t)data[j + 2] << 8L) |
                   (uint64_t)data[j + 3]
                );
        }

  for ( ; i < 64; ++i)
    m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

  a = ctx->state[0];
  b = ctx->state[1];
  c = ctx->state[2];
  d = ctx->state[3];
  e = ctx->state[4];
  f = ctx->state[5];
  g = ctx->state[6];
  h = ctx->state[7];

  for (i = 0; i < 64; ++i) {
    t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
    t2 = EP0(a) + MAJ(a,b,c);
    h = g;
    g = f;
    f = e;
    e = d + t1;
    d = c;
    c = b;
    b = a;
    a = t1 + t2;
  }

  ctx->state[0] += a;
  ctx->state[1] += b;
  ctx->state[2] += c;
  ctx->state[3] += d;
  ctx->state[4] += e;
  ctx->state[5] += f;
  ctx->state[6] += g;
  ctx->state[7] += h;
}

void sha256_init(SHA256_CTX *ctx)
{
  ctx->datalen = 0;
  ctx->bitlen = 0;
  ctx->state[0] = 0x6a09e667;
  ctx->state[1] = 0xbb67ae85;
  ctx->state[2] = 0x3c6ef372;
  ctx->state[3] = 0xa54ff53a;
  ctx->state[4] = 0x510e527f;
  ctx->state[5] = 0x9b05688c;
  ctx->state[6] = 0x1f83d9ab;
  ctx->state[7] = 0x5be0cd19;
}

void sha256_update(SHA256_CTX *ctx, const SHA256_BYTE data[], size_t len)
{
  SHA256_WORD i;

  for (i = 0; i < len; ++i) {
    ctx->data[ctx->datalen] = data[i];
    ctx->datalen++;
    if (ctx->datalen == 64) {
      sha256_transform(ctx, ctx->data);
      ctx->bitlen += 512;
      ctx->datalen = 0;
    }
  }
}

void sha256_final(SHA256_CTX *ctx, SHA256_BYTE hash[])
{
  SHA256_WORD i;

  i = ctx->datalen;

  // Pad whatever data is left in the buffer.
  if (ctx->datalen < 56) {
    ctx->data[i++] = 0x80;
    while (i < 56)
      ctx->data[i++] = 0x00;
  }
  else {
    ctx->data[i++] = 0x80;
    while (i < 64)
      ctx->data[i++] = 0x00;
    sha256_transform(ctx, ctx->data);
    memset(ctx->data, 0, 56);
  }

  // Append to the padding the total message's length in bits and transform.
  ctx->bitlen += ctx->datalen * 8;
  ctx->data[63] = (SHA256_BYTE)(ctx->bitlen);
  ctx->data[62] = (SHA256_BYTE)(ctx->bitlen >> 8);
  ctx->data[61] = (SHA256_BYTE)(ctx->bitlen >> 16);
  ctx->data[60] = (SHA256_BYTE)(ctx->bitlen >> 24);
  ctx->data[59] = (SHA256_BYTE)(ctx->bitlen >> 32);
  ctx->data[58] = (SHA256_BYTE)(ctx->bitlen >> 40);
  ctx->data[57] = (SHA256_BYTE)(ctx->bitlen >> 48);
  ctx->data[56] = (SHA256_BYTE)(ctx->bitlen >> 56);
  sha256_transform(ctx, ctx->data);

  // Since this implementation uses little endian byte ordering and SHA uses big endian,
  // reverse all the bytes when copying the final state to the output hash.
  for (i = 0; i < 4; ++i) {
    hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
    hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
    hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
    hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
    hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
    hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
    hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
    hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
  }
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


static void symtab_rehash(symtab *syms);

static void set_payload(symtab *syms) {
  syms->payload = (symtab_entry *)calloc(syms->capacity, sizeof(symtab_entry));
}


// Standard hash and comparison functions for strings

static uint32_t hash_case_insens(const char *sym) {
  const unsigned char *bytes = (const unsigned char *)sym;
  uint64_t hash = 0;
  while (*bytes) {
    unsigned char byte = *bytes | 0x20;
    hash = ((hash << 5) | (hash >> 27)) ^ byte;
    bytes++;
  }
  return (uint32_t)(hash ^ (hash >>32));
}

static int32_t cmp_case_insens(const char *s1, const char *s2) {
  return (int32_t)StrCaseCmp(s1, s2);
}

static int32_t cmp_case_sens(const char *s1, const char *s2) {
  return (int32_t)strcmp(s1, s2);
}

static uint32_t hash_case_sens(const char *sym) {
  const unsigned char *bytes = (const unsigned char *)sym;
  uint64_t hash = 0;
  while (*bytes) {
    unsigned char byte = *bytes;
    hash = ((hash << 5) | (hash >> 27)) ^ byte;
    bytes++;
  }
  return (uint32_t)(hash ^ (hash >>32));
}

// The most normal confuguration of the symbol table is case insensitive
// the hash and comparison function are created for that case.  The
// normal teardown function is no-teardown as all items are borrowed.
// The most common case is that the names are strings in the AST
// and the values are AST pointer, all of which are durable from
// the perspective of the symbol table.
cql_noexport symtab *symtab_new() {
  symtab *syms = _new(symtab);
  syms->count = 0;
  syms->capacity = SYMTAB_INIT_SIZE;
  syms->hash = hash_case_insens;
  syms->cmp = cmp_case_insens;
  syms->teardown = NULL;
  set_payload(syms);
  return syms;
}

// This is the case sensitive version of the symbol table
// The default is case insensitive because nearly every
// lookup is case insensitive.
cql_noexport symtab *symtab_new_case_sens() {
  symtab *syms = symtab_new();
  syms->hash = hash_case_sens;
  syms->cmp = cmp_case_sens;
  return syms;
}

// If there is a teardown function, it is called for each payload.
// Specifically the *values* of each payload.  The strings are
// assumed to be long-lived and owned by something else.
cql_noexport void symtab_delete(symtab *syms) {
  if (syms->teardown) {
    for (uint32_t i = 0; i < syms->capacity; i++) {
      void *val = syms->payload[i].val;
      if (val) {
        syms->teardown(val);
      }
    }
  }
  free(syms->payload);
  free(syms);
}

// Adding a new symbol to the table is a simple matter of finding an empty slot
// and populating it.  If the table is too full we rehash in a bigger table.
// We a least have room to add the new symbol.  The hashing algorithm is
// the usual close hash table form with linear probing.  The comparison
// and hashing functions can be changed at the time the table is created.
// But if you change them after inserting anything you will have to rehash the table.
// Generally, this is a really bad idea.
cql_noexport bool_t symtab_add(symtab *syms, const char *sym_new, void *val_new) {
  uint32_t hash = syms->hash(sym_new);
  uint32_t offset = hash % syms->capacity;
  symtab_entry *payload = syms->payload;

  for (;;) {
    // We search until we find an empty slot or a matching symbol
    // one of the two will happen for sure because the table is never full.
    const char *sym = payload[offset].sym;
    if (!sym) {
      payload[offset].sym = sym_new;
      payload[offset].val = val_new;

      syms->count++;
      if (syms->count > syms->capacity * SYMTAB_LOAD_FACTOR) {
        symtab_rehash(syms);
      }

      // did not find the symbol, return true indicating we added it
      return true;
    }

    // found the symbol, return false indicated we did not add
    if (!syms->cmp(sym, sym_new)) {
      return false;
    }

    // wrap the offset around, we don't use modulus because it
    // isn't a power of two necessarily.  This form can compile
    // into a conditional store.
    offset++;
    if (offset >= syms->capacity) {
      offset = 0;
    }
  }
}

// The find operation is a simple matter of hashing the symbol and then
// doing a linear probe until we find the symbol or an empty slot.
// We return the payload slow which allows us to modify the stored value
// if we want to.
cql_noexport symtab_entry *symtab_find(symtab *syms, const char *sym_needed) {
  if (!syms) {
    return NULL;
  }

  uint32_t hash = syms->hash(sym_needed);
  uint32_t offset = hash % syms->capacity;
  symtab_entry *payload = syms->payload;

  for (;;) {
    const char *sym = syms->payload[offset].sym;
    if (!sym) {
      return NULL;
    }

    if (!syms->cmp(sym, sym_needed)) {
      return &payload[offset];
    }

    offset++;
    if (offset >= syms->capacity) {
      offset = 0;
    }
  }
}

// When the table is too full we rehash in a bigger table.
// To do this extract the guts of the table and then load
// it with new, bigger guts, that are empty.  Then we
// insert the values from the old guts.  This is a liner
// time operation and it's the simplest way spread the
// values to the new table.  When this is done we
// can delete the old guts.
static void symtab_rehash(symtab *syms) {
  uint32_t old_capacity = syms->capacity;
  symtab_entry *old_payload = syms->payload;

  syms->count = 0;
  syms->capacity *= 2;
  set_payload(syms);

  for (uint32_t i = 0; i < old_capacity; i++) {
    const char *sym = old_payload[i].sym;
    if (!sym) {
      continue;
    }

    symtab_add(syms, old_payload[i].sym, old_payload[i].val);
  }

  free(old_payload);
}

// patternlint-disable-next-line prefer-sized-ints-in-msys
cql_noexport int default_symtab_comparator(symtab_entry *entry1, symtab_entry *entry2) {
  return strcmp(entry1->sym, entry2->sym);
}

// This helper function makes a copy of the payload entires and
// then storts them according to the provided comparator.  Any
// null in the payload array are skipped.
cql_noexport symtab_entry *symtab_copy_sorted_payload(symtab *syms, int (*comparator)(symtab_entry *entry1, symtab_entry *entry2)) {
  uint32_t count = syms->count;
  size_t size = sizeof(symtab_entry);
  symtab_entry *sorted = calloc(count, size);
  int32_t found = 0;
  for (uint32_t i = 0; i < syms->capacity; i++) {
    // skip the null syms in our copy
    if (syms->payload[i].sym) {
      sorted[found++] = syms->payload[i];
    }
  }

  // now sort the nonnull values
  qsort(sorted, count, size, (int (*)(const void *, const void *))comparator);
  return sorted;
}

// first special case teardown
//  * a symbol table with payload of symbol tables
static void symtab_teardown(void *val) {
  symtab_delete(val);
}

// second special case teardown
//  * a symbol table with payload of bytebuffers
static void bytebuf_teardown(void *val) {
  bytebuf_close((bytebuf*)val);
  free(val);
}

// third special case teardown
//  * a symbol table with payload of character buffers
static void charbuf_teardown(void *val) {
  bclose((charbuf*)val);
  free(val);
}


// This helper is just for making a symbol table that holds symbol tables.
// It sets the cleanup function to be one that deletes symbol tables in the payload.
// This flavor create the table at the named slot for you to use.
cql_noexport symtab *_Nonnull symtab_ensure_symtab(symtab *syms, const char *name) {
  syms->teardown = symtab_teardown;
  symtab_entry *entry = symtab_find(syms, name);

  symtab *value = entry ? (symtab *)entry->val : NULL;
  if (entry == NULL) {
    value = symtab_new();
    symtab_add(syms, name, value);
  }
  return value;
}

// This helper is just for making a symbol table that holds symbol tables
// we don't have to do anything special except set the cleanup function
// to one that deletes symbol tables in the payload.
cql_noexport bool_t symtab_add_symtab(symtab *syms, CSTR name, symtab *data) {
  syms->teardown = symtab_teardown;
  return symtab_add(syms, name, (void*)data);
}

// This helper ensures that a byte buffer is present for the given symbol and
// returns it.  If the symbol value is not present it creates a new byte buffer
// for that slot. The teardown function is changed to free the byte buffers.
// Mixing different value types in the same symbol table is a bad idea.
cql_noexport bytebuf *_Nonnull symtab_ensure_bytebuf(symtab *syms, const char *sym_new) {
  syms->teardown = bytebuf_teardown;
  symtab_entry *entry = symtab_find(syms, sym_new);

  bytebuf *buf = entry ? (bytebuf *)entry->val : NULL;
  if (entry == NULL) {
    buf = _new(bytebuf);
    bytebuf_open(buf);
    symtab_add(syms, sym_new, buf);
  }
  return buf;
}

// This helper uses the above to create a byte buffer for the given symbol
// and then appends the given bytes to that  buffer.
cql_noexport void symtab_append_bytes(symtab *syms, const char *sym_new, const void *bytes, size_t count) {
  bytebuf *buf = symtab_ensure_bytebuf(syms, sym_new);
  bytebuf_append(buf, bytes, (uint32_t)count);
}

// This is similar to the byte buffer case but for character buffers.  These can
// be written to with charbuf helpers like bprintf and so forth.  Once you do this
// the teardown function is changed to free the char buffers.  Mixing different
// value types in the same symbol table is a bad idea.
cql_noexport charbuf *_Nonnull symtab_ensure_charbuf(symtab *syms, const char *sym_new) {
  syms->teardown = charbuf_teardown;
  symtab_entry *entry = symtab_find(syms, sym_new);
  charbuf *output = entry ? (charbuf *)entry->val : NULL;
  if (!output) {
    // None found, create one
    output = _new(charbuf);
    bopen(output);
    // This buffer doesn't participate in the normal stack of charbufs
    // it will be freed when the symbol table is torn down
    charbuf_open_count--;
    symtab_add(syms, sym_new, output);
  }
  return output;
}
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#if defined(CQL_AMALGAM_LEAN) && !defined(CQL_AMALGAM_UNIT_TESTS)

// stubs to avoid link errors
cql_noexport void run_unit_tests() {}

#else


// This file implement very simple unit tests for functions that are too complicated
// to test directly through invocations of the CQL tool.
//
// This test suite is extremely simple and it does not (purposefully) use common
// test infrastructure such as gtest or gmock. This is just a simple C program
// that calls test functions and asserts their results on every step.

#define TEST_ASSERT assert
#define STR_EQ(s1, s2) strcmp(s1, s2) == 0

cql_noexport void cg_c_init(void);
cql_noexport void cg_c_cleanup(void);
cql_noexport uint32_t cg_statement_pieces(CSTR in, charbuf *output);

static bool test_frag_tricky_case() {
  options.compress = 1;
  CHARBUF_OPEN(tmp);
  cg_c_init();
  // get into a state with a single trailing space
  uint32_t count = cg_statement_pieces("atest btest ", &tmp);
  cg_c_cleanup();
  CHARBUF_CLOSE(tmp);

  // two tokens, no going off the end and making extra tokens!
  return count == 2;
}

static bool test_strdup__empty_string() {
  char* str_copy = Strdup("");
  bool result = STR_EQ(str_copy, "");
  return result;
}

static bool test_strdup__one_character_string() {
  char* str_copy = Strdup("a");
  bool result = STR_EQ(str_copy, "a");
  return result;
}

static bool test_strdup__long_string() {
  char* str_copy = Strdup("abcd");
  bool result = STR_EQ(str_copy, "abcd");
  return result;
}

static bool test_strcasecmp_empty_strings() {
  return StrCaseCmp("", "") == 0;
}

static bool test_strcasecmp_one_char_strings__result_is_less_than() {
  return StrCaseCmp("a", "B") < 0;
}

static bool test_strcasecmp_one_char_strings__result_is_greater_than() {
  return StrCaseCmp("B", "a") > 0;
}

static bool test_strcasecmp_one_char_strings__result_is_equals() {
  return StrCaseCmp("Aab", "aaB") == 0;
}

static bool test_strcasecmp_long_strings__result_is_less_than() {
  return StrCaseCmp("aca", "acD") < 0;
}

static bool test_strcasecmp_long_strings__result_is_greater_than() {
  return StrCaseCmp("bab", "baA") > 0;
}

static bool test_strcasecmp_long_strings__result_is_equals() {
  return StrCaseCmp("Aab", "aaB") == 0;
}

static bool test_strcasecmp_different_length_strings__result_is_less_than() {
  return StrCaseCmp("aab", "AABc") < 0;
}

static bool test_strcasecmp_different_length_strings__result_is_greater_than() {
  return StrCaseCmp("AABc", "aab") > 0;
}

static bool test_strncasecmp__empty_strings__zero_cmp_size__result_is_equals() {
  return StrNCaseCmp("", "", 0) == 0;
}

static bool test_strncasecmp__empty_strings__past_length_cmp_size__result_is_equals() {
  return StrNCaseCmp("", "", 1) == 0;
}

static bool test_strncasecmp__one_char_strings__zero_cmp_size__result_is_equals() {
  return StrNCaseCmp("a", "b", 0) == 0;
}

static bool test_strncasecmp__one_char_strings__past_length_cmp_size__result_is_less_than() {
  return StrNCaseCmp("a", "B", 2) < 0;
}

static bool test_strncasecmp__one_char_strings__past_length_cmp_size__result_is_greater_than() {
  return StrNCaseCmp("B", "a", 2) > 0;
}

static bool test_strncasecmp__one_char_strings__past_length_cmp_size__result_is_equals() {
  return StrNCaseCmp("B", "b", 2) == 0;
}

static bool test_strncasecmp__long_strings__past_length_cmp_size__result_is_less_than() {
  return StrNCaseCmp("aca", "acD", 4) < 0;
}

static bool test_strncasecmp__long_strings__past_length_cmp_size__result_is_greater_than() {
  return StrNCaseCmp("bab", "baA", 4) > 0;
}

static bool test_strncasecmp__long_strings__past_length_cmp_size__result_is_equals() {
  return StrNCaseCmp("Aab", "aaB", 4) == 0;
}

static bool test_strncasecmp__long_strings__shorter_than_length_cmp_size__result_is_less_than() {
  return StrNCaseCmp("abd", "Aca", 2) < 0;
}

static bool test_strncasecmp__long_strings__shorter_than_length_cmp_size__result_is_greater_than() {
  return StrNCaseCmp("Bbd", "baa", 2) > 0;
}

static bool test_strncasecmp__long_strings__shorter_than_length_cmp_size__result_is_equals() {
  return StrNCaseCmp("Aac", "aaB", 2) == 0;
}

static bool test_sha256_example1() {
  CHARBUF_OPEN(temp);
  bprintf(&temp, "Foo:x:String");
  bool result = sha256_charbuf(&temp) == -5028419846961717871L;
  CHARBUF_CLOSE(temp);
  return result;
}

static bool test_sha256_example2() {
  CHARBUF_OPEN(temp);
  bprintf(&temp, "id:?Int64");
  bool result = sha256_charbuf(&temp) == -9155171551243524439L;
  CHARBUF_CLOSE(temp);
  return result;
}

static bool test_sha256_example3() {
  CHARBUF_OPEN(temp);
  bprintf(&temp, "x:String");
  bool result = sha256_charbuf(&temp) == -6620767298254076690L;
  CHARBUF_CLOSE(temp);
  return result;
}

static bool test_sha256_example4() {
  CHARBUF_OPEN(temp);
  bprintf(&temp, "fooBar:?Int64");
  bool result = sha256_charbuf(&temp) == -6345014076009057275L;
  CHARBUF_CLOSE(temp);
  return result;
}

static bool test_sha256_example5() {
  CHARBUF_OPEN(temp);
  bprintf(&temp, "XXXXXXXXX.XXXXXXXXX.XXXXXXXXX.XXXXXXXXX.XXXXXXXXX.XXXXXXXXX.XXXXXXXXX.");
  bool result = sha256_charbuf(&temp) == -8121930428982087348L;
  CHARBUF_CLOSE(temp);
  return result;
}

static bool test_sha256_example6() {
  CHARBUF_OPEN(temp);
  bprintf(&temp, "XXXXXXXXX.XXXXXXXXX.XXXXXXXXX.XXXXXXXXX.XXXXXXXXX.123456789");
  bool result = sha256_charbuf(&temp) ==  -4563262961718308998L;
  CHARBUF_CLOSE(temp);
  return result;
}

static bool test_unknown_macro() {
 ast_node *t = new_ast_unknown_macro_arg(NULL, NULL);
 if (t->type != k_ast_unknown_macro_arg) return false;

 t = new_ast_unknown_macro_def(NULL, NULL);
 if (t->type != k_ast_unknown_macro_def) return false;
 return true;
}

cql_noexport void run_unit_tests() {
  TEST_ASSERT(test_strdup__empty_string());
  TEST_ASSERT(test_strdup__one_character_string());
  TEST_ASSERT(test_strdup__long_string());
  TEST_ASSERT(test_strcasecmp_empty_strings());
  TEST_ASSERT(test_strcasecmp_one_char_strings__result_is_less_than());
  TEST_ASSERT(test_strcasecmp_one_char_strings__result_is_greater_than());
  TEST_ASSERT(test_strcasecmp_one_char_strings__result_is_equals());
  TEST_ASSERT(test_strcasecmp_long_strings__result_is_less_than());
  TEST_ASSERT(test_strcasecmp_long_strings__result_is_greater_than());
  TEST_ASSERT(test_strcasecmp_long_strings__result_is_equals());
  TEST_ASSERT(test_strcasecmp_different_length_strings__result_is_less_than());
  TEST_ASSERT(test_strcasecmp_different_length_strings__result_is_greater_than());
  TEST_ASSERT(test_strncasecmp__empty_strings__zero_cmp_size__result_is_equals());
  TEST_ASSERT(test_strncasecmp__empty_strings__past_length_cmp_size__result_is_equals());
  TEST_ASSERT(test_strncasecmp__one_char_strings__zero_cmp_size__result_is_equals());
  TEST_ASSERT(test_strncasecmp__one_char_strings__past_length_cmp_size__result_is_less_than());
  TEST_ASSERT(test_strncasecmp__one_char_strings__past_length_cmp_size__result_is_greater_than());
  TEST_ASSERT(test_strncasecmp__one_char_strings__past_length_cmp_size__result_is_equals());
  TEST_ASSERT(test_strncasecmp__long_strings__past_length_cmp_size__result_is_less_than());
  TEST_ASSERT(test_strncasecmp__long_strings__past_length_cmp_size__result_is_greater_than());
  TEST_ASSERT(test_strncasecmp__long_strings__past_length_cmp_size__result_is_equals());
  TEST_ASSERT(test_strncasecmp__long_strings__shorter_than_length_cmp_size__result_is_less_than());
  TEST_ASSERT(test_strncasecmp__long_strings__shorter_than_length_cmp_size__result_is_greater_than());
  TEST_ASSERT(test_strncasecmp__long_strings__shorter_than_length_cmp_size__result_is_equals());
  TEST_ASSERT(test_frag_tricky_case());
  TEST_ASSERT(test_sha256_example1());
  TEST_ASSERT(test_sha256_example2());
  TEST_ASSERT(test_sha256_example3());
  TEST_ASSERT(test_sha256_example4());
  TEST_ASSERT(test_sha256_example5());
  TEST_ASSERT(test_sha256_example6());
  TEST_ASSERT(test_unknown_macro());
}

#endif
// no extra .c files
#ifndef _MSC_VER
#pragma clang diagnostic ignored "-Wimplicit-int-conversion"
#pragma clang diagnostic ignored "-Wsign-conversion"
#endif
/* A Bison parser, made by GNU Bison 3.8.2.  */

/* Bison interface for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
   especially those whose name start with YY_ or yy_.  They are
   private implementation details that can be changed or removed.  */

#ifndef YY_YY_OUT_CQL_Y_H_INCLUDED
# define YY_YY_OUT_CQL_Y_H_INCLUDED
/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif
#if YYDEBUG
extern int yydebug;
#endif

/* Token kinds.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
  enum yytokentype
  {
    YYEMPTY = -2,
    YYEOF = 0,                     /* "end of file"  */
    YYerror = 256,                 /* error  */
    YYUNDEF = 257,                 /* "invalid token"  */
    ID = 258,                      /* ID  */
    QID = 259,                     /* QID  */
    TRUE_ = 260,                   /* "TRUE"  */
    FALSE_ = 261,                  /* "FALSE"  */
    STRLIT = 262,                  /* STRLIT  */
    CSTRLIT = 263,                 /* CSTRLIT  */
    BLOBLIT = 264,                 /* BLOBLIT  */
    INTLIT = 265,                  /* INTLIT  */
    BOOL_ = 266,                   /* "BOOL"  */
    AT_DUMMY_NULLABLES = 267,      /* AT_DUMMY_NULLABLES  */
    AT_DUMMY_DEFAULTS = 268,       /* AT_DUMMY_DEFAULTS  */
    LONGLIT = 269,                 /* LONGLIT  */
    REALLIT = 270,                 /* REALLIT  */
    STMT_LIST_MACRO = 271,         /* STMT_LIST_MACRO  */
    EXPR_MACRO = 272,              /* EXPR_MACRO  */
    QUERY_PARTS_MACRO = 273,       /* QUERY_PARTS_MACRO  */
    CTE_TABLES_MACRO = 274,        /* CTE_TABLES_MACRO  */
    SELECT_CORE_MACRO = 275,       /* SELECT_CORE_MACRO  */
    SELECT_EXPR_MACRO = 276,       /* SELECT_EXPR_MACRO  */
    UNION_ALL = 277,               /* UNION_ALL  */
    UNION = 278,                   /* UNION  */
    INTERSECT = 279,               /* INTERSECT  */
    EXCEPT = 280,                  /* EXCEPT  */
    ADD_EQ = 281,                  /* ADD_EQ  */
    SUB_EQ = 282,                  /* SUB_EQ  */
    MUL_EQ = 283,                  /* MUL_EQ  */
    DIV_EQ = 284,                  /* DIV_EQ  */
    MOD_EQ = 285,                  /* MOD_EQ  */
    OR_EQ = 286,                   /* OR_EQ  */
    AND_EQ = 287,                  /* AND_EQ  */
    LS_EQ = 288,                   /* LS_EQ  */
    RS_EQ = 289,                   /* RS_EQ  */
    OR = 290,                      /* OR  */
    AND = 291,                     /* AND  */
    NOT = 292,                     /* NOT  */
    BETWEEN = 293,                 /* BETWEEN  */
    NOT_BETWEEN = 294,             /* NOT_BETWEEN  */
    LIKE = 295,                    /* LIKE  */
    NOT_LIKE = 296,                /* NOT_LIKE  */
    GLOB = 297,                    /* GLOB  */
    NOT_GLOB = 298,                /* NOT_GLOB  */
    MATCH = 299,                   /* MATCH  */
    NOT_MATCH = 300,               /* NOT_MATCH  */
    REGEXP = 301,                  /* REGEXP  */
    NOT_REGEXP = 302,              /* NOT_REGEXP  */
    IN = 303,                      /* IN  */
    NOT_IN = 304,                  /* NOT_IN  */
    IS_NOT = 305,                  /* IS_NOT  */
    IS = 306,                      /* IS  */
    IS_TRUE = 307,                 /* IS_TRUE  */
    IS_FALSE = 308,                /* IS_FALSE  */
    IS_NOT_TRUE = 309,             /* IS_NOT_TRUE  */
    IS_NOT_FALSE = 310,            /* IS_NOT_FALSE  */
    ISNULL = 311,                  /* ISNULL  */
    NOTNULL = 312,                 /* NOTNULL  */
    JEX1 = 313,                    /* JEX1  */
    JEX2 = 314,                    /* JEX2  */
    COLLATE = 315,                 /* COLLATE  */
    UMINUS = 316,                  /* UMINUS  */
    ASSIGN = 317,                  /* ":="  */
    CONCAT = 318,                  /* "||"  */
    EQEQ = 319,                    /* "=="  */
    GE = 320,                      /* ">="  */
    LE = 321,                      /* "<="  */
    LS = 322,                      /* "<<"  */
    NE = 323,                      /* "<>"  */
    NE_ = 324,                     /* "!="  */
    RS = 325,                      /* ">>"  */
    EXCLUDE_GROUP = 326,           /* EXCLUDE_GROUP  */
    EXCLUDE_CURRENT_ROW = 327,     /* EXCLUDE_CURRENT_ROW  */
    EXCLUDE_TIES = 328,            /* EXCLUDE_TIES  */
    EXCLUDE_NO_OTHERS = 329,       /* EXCLUDE_NO_OTHERS  */
    CURRENT_ROW = 330,             /* CURRENT_ROW  */
    UNBOUNDED = 331,               /* UNBOUNDED  */
    PRECEDING = 332,               /* PRECEDING  */
    FOLLOWING = 333,               /* FOLLOWING  */
    CREATE = 334,                  /* CREATE  */
    DROP = 335,                    /* DROP  */
    TABLE = 336,                   /* TABLE  */
    WITHOUT = 337,                 /* WITHOUT  */
    ROWID = 338,                   /* ROWID  */
    PRIMARY = 339,                 /* PRIMARY  */
    KEY = 340,                     /* KEY  */
    NULL_ = 341,                   /* "NULL"  */
    DEFAULT = 342,                 /* DEFAULT  */
    CHECK = 343,                   /* CHECK  */
    AT_DUMMY_SEED = 344,           /* AT_DUMMY_SEED  */
    VIRTUAL = 345,                 /* VIRTUAL  */
    AT_EMIT_GROUP = 346,           /* AT_EMIT_GROUP  */
    AT_EMIT_ENUMS = 347,           /* AT_EMIT_ENUMS  */
    AT_EMIT_CONSTANTS = 348,       /* AT_EMIT_CONSTANTS  */
    OBJECT = 349,                  /* OBJECT  */
    TEXT = 350,                    /* TEXT  */
    BLOB = 351,                    /* BLOB  */
    LONG_ = 352,                   /* LONG_  */
    INT_ = 353,                    /* INT_  */
    INTEGER = 354,                 /* INTEGER  */
    LONG_INT = 355,                /* LONG_INT  */
    LONG_INTEGER = 356,            /* LONG_INTEGER  */
    REAL = 357,                    /* REAL  */
    ON = 358,                      /* ON  */
    UPDATE = 359,                  /* UPDATE  */
    CASCADE = 360,                 /* CASCADE  */
    ON_CONFLICT = 361,             /* ON_CONFLICT  */
    DO = 362,                      /* DO  */
    NOTHING = 363,                 /* NOTHING  */
    DELETE = 364,                  /* DELETE  */
    INDEX = 365,                   /* INDEX  */
    FOREIGN = 366,                 /* FOREIGN  */
    REFERENCES = 367,              /* REFERENCES  */
    CONSTRAINT = 368,              /* CONSTRAINT  */
    UPSERT = 369,                  /* UPSERT  */
    STATEMENT = 370,               /* STATEMENT  */
    CONST = 371,                   /* CONST  */
    INSERT = 372,                  /* INSERT  */
    INTO = 373,                    /* INTO  */
    VALUES = 374,                  /* VALUES  */
    VIEW = 375,                    /* VIEW  */
    SELECT = 376,                  /* SELECT  */
    QUERY_PLAN = 377,              /* QUERY_PLAN  */
    EXPLAIN = 378,                 /* EXPLAIN  */
    OVER = 379,                    /* OVER  */
    WINDOW = 380,                  /* WINDOW  */
    FILTER = 381,                  /* FILTER  */
    PARTITION = 382,               /* PARTITION  */
    RANGE = 383,                   /* RANGE  */
    ROWS = 384,                    /* ROWS  */
    GROUPS = 385,                  /* GROUPS  */
    AS = 386,                      /* AS  */
    CASE = 387,                    /* CASE  */
    WHEN = 388,                    /* WHEN  */
    FROM = 389,                    /* FROM  */
    THEN = 390,                    /* THEN  */
    ELSE = 391,                    /* ELSE  */
    END = 392,                     /* END  */
    LEFT = 393,                    /* LEFT  */
    SWITCH = 394,                  /* SWITCH  */
    OUTER = 395,                   /* OUTER  */
    JOIN = 396,                    /* JOIN  */
    WHERE = 397,                   /* WHERE  */
    GROUP = 398,                   /* GROUP  */
    BY = 399,                      /* BY  */
    ORDER = 400,                   /* ORDER  */
    ASC = 401,                     /* ASC  */
    NULLS = 402,                   /* NULLS  */
    FIRST = 403,                   /* FIRST  */
    LAST = 404,                    /* LAST  */
    DESC = 405,                    /* DESC  */
    INNER = 406,                   /* INNER  */
    AUTOINCREMENT = 407,           /* AUTOINCREMENT  */
    DISTINCT = 408,                /* DISTINCT  */
    LIMIT = 409,                   /* LIMIT  */
    OFFSET = 410,                  /* OFFSET  */
    TEMP = 411,                    /* TEMP  */
    TRIGGER = 412,                 /* TRIGGER  */
    IF = 413,                      /* IF  */
    ALL = 414,                     /* ALL  */
    CROSS = 415,                   /* CROSS  */
    USING = 416,                   /* USING  */
    RIGHT = 417,                   /* RIGHT  */
    AT_EPONYMOUS = 418,            /* AT_EPONYMOUS  */
    HIDDEN = 419,                  /* HIDDEN  */
    UNIQUE = 420,                  /* UNIQUE  */
    HAVING = 421,                  /* HAVING  */
    SET = 422,                     /* SET  */
    LET = 423,                     /* LET  */
    TO = 424,                      /* TO  */
    DISTINCTROW = 425,             /* DISTINCTROW  */
    ENUM = 426,                    /* ENUM  */
    FUNC = 427,                    /* FUNC  */
    FUNCTION = 428,                /* FUNCTION  */
    PROC = 429,                    /* PROC  */
    PROCEDURE = 430,               /* PROCEDURE  */
    INTERFACE = 431,               /* INTERFACE  */
    OUT = 432,                     /* OUT  */
    INOUT = 433,                   /* INOUT  */
    CURSOR = 434,                  /* CURSOR  */
    DECLARE = 435,                 /* DECLARE  */
    VAR = 436,                     /* VAR  */
    TYPE = 437,                    /* TYPE  */
    FETCH = 438,                   /* FETCH  */
    LOOP = 439,                    /* LOOP  */
    LEAVE = 440,                   /* LEAVE  */
    CONTINUE = 441,                /* CONTINUE  */
    ENCODE = 442,                  /* ENCODE  */
    CONTEXT_COLUMN = 443,          /* CONTEXT_COLUMN  */
    CONTEXT_TYPE = 444,            /* CONTEXT_TYPE  */
    OPEN = 445,                    /* OPEN  */
    CLOSE = 446,                   /* CLOSE  */
    ELSE_IF = 447,                 /* ELSE_IF  */
    WHILE = 448,                   /* WHILE  */
    CALL = 449,                    /* CALL  */
    TRY = 450,                     /* TRY  */
    CATCH = 451,                   /* CATCH  */
    THROW = 452,                   /* THROW  */
    RETURN = 453,                  /* RETURN  */
    SAVEPOINT = 454,               /* SAVEPOINT  */
    ROLLBACK = 455,                /* ROLLBACK  */
    COMMIT = 456,                  /* COMMIT  */
    TRANSACTION = 457,             /* TRANSACTION  */
    RELEASE = 458,                 /* RELEASE  */
    ARGUMENTS = 459,               /* ARGUMENTS  */
    TYPE_CHECK = 460,              /* TYPE_CHECK  */
    CAST = 461,                    /* CAST  */
    WITH = 462,                    /* WITH  */
    RECURSIVE = 463,               /* RECURSIVE  */
    REPLACE = 464,                 /* REPLACE  */
    IGNORE = 465,                  /* IGNORE  */
    ADD = 466,                     /* ADD  */
    COLUMN = 467,                  /* COLUMN  */
    AT_COLUMNS = 468,              /* AT_COLUMNS  */
    RENAME = 469,                  /* RENAME  */
    ALTER = 470,                   /* ALTER  */
    AT_ECHO = 471,                 /* AT_ECHO  */
    AT_CREATE = 472,               /* AT_CREATE  */
    AT_RECREATE = 473,             /* AT_RECREATE  */
    AT_DELETE = 474,               /* AT_DELETE  */
    AT_SCHEMA_UPGRADE_VERSION = 475, /* AT_SCHEMA_UPGRADE_VERSION  */
    AT_PREVIOUS_SCHEMA = 476,      /* AT_PREVIOUS_SCHEMA  */
    AT_SCHEMA_UPGRADE_SCRIPT = 477, /* AT_SCHEMA_UPGRADE_SCRIPT  */
    AT_ID = 478,                   /* AT_ID  */
    AT_RC = 479,                   /* AT_RC  */
    AT_PROC = 480,                 /* AT_PROC  */
    AT_FILE = 481,                 /* AT_FILE  */
    AT_LINE = 482,                 /* AT_LINE  */
    AT_MACRO_LINE = 483,           /* AT_MACRO_LINE  */
    AT_MACRO_FILE = 484,           /* AT_MACRO_FILE  */
    AT_TEXT = 485,                 /* AT_TEXT  */
    AT_ATTRIBUTE = 486,            /* AT_ATTRIBUTE  */
    AT_SENSITIVE = 487,            /* AT_SENSITIVE  */
    DEFERRED = 488,                /* DEFERRED  */
    AT_TMP = 489,                  /* AT_TMP  */
    NOT_DEFERRABLE = 490,          /* NOT_DEFERRABLE  */
    DEFERRABLE = 491,              /* DEFERRABLE  */
    IMMEDIATE = 492,               /* IMMEDIATE  */
    EXCLUSIVE = 493,               /* EXCLUSIVE  */
    RESTRICT = 494,                /* RESTRICT  */
    ACTION = 495,                  /* ACTION  */
    INITIALLY = 496,               /* INITIALLY  */
    NO = 497,                      /* NO  */
    BEFORE = 498,                  /* BEFORE  */
    AFTER = 499,                   /* AFTER  */
    INSTEAD = 500,                 /* INSTEAD  */
    OF = 501,                      /* OF  */
    FOR_EACH_ROW = 502,            /* FOR_EACH_ROW  */
    EXISTS = 503,                  /* EXISTS  */
    RAISE = 504,                   /* RAISE  */
    FAIL = 505,                    /* FAIL  */
    ABORT = 506,                   /* ABORT  */
    AT_ENFORCE_STRICT = 507,       /* AT_ENFORCE_STRICT  */
    AT_ENFORCE_NORMAL = 508,       /* AT_ENFORCE_NORMAL  */
    AT_ENFORCE_RESET = 509,        /* AT_ENFORCE_RESET  */
    AT_ENFORCE_PUSH = 510,         /* AT_ENFORCE_PUSH  */
    AT_ENFORCE_POP = 511,          /* AT_ENFORCE_POP  */
    AT_BEGIN_SCHEMA_REGION = 512,  /* AT_BEGIN_SCHEMA_REGION  */
    AT_END_SCHEMA_REGION = 513,    /* AT_END_SCHEMA_REGION  */
    AT_OP = 514,                   /* AT_OP  */
    AT_DECLARE_SCHEMA_REGION = 515, /* AT_DECLARE_SCHEMA_REGION  */
    AT_DECLARE_DEPLOYABLE_REGION = 516, /* AT_DECLARE_DEPLOYABLE_REGION  */
    AT_SCHEMA_AD_HOC_MIGRATION = 517, /* AT_SCHEMA_AD_HOC_MIGRATION  */
    PRIVATE = 518,                 /* PRIVATE  */
    AT_KEEP_TABLE_NAME_IN_ALIASES = 519, /* AT_KEEP_TABLE_NAME_IN_ALIASES  */
    AT_MACRO = 520,                /* AT_MACRO  */
    EXPR = 521,                    /* EXPR  */
    STMT_LIST = 522,               /* STMT_LIST  */
    QUERY_PARTS = 523,             /* QUERY_PARTS  */
    CTE_TABLES = 524,              /* CTE_TABLES  */
    SELECT_CORE = 525,             /* SELECT_CORE  */
    SELECT_EXPR = 526,             /* SELECT_EXPR  */
    SIGN_FUNCTION = 527,           /* SIGN_FUNCTION  */
    CURSOR_HAS_ROW = 528,          /* CURSOR_HAS_ROW  */
    AT_UNSUB = 529,                /* AT_UNSUB  */
    BEGIN_INCLUDE = 530,           /* BEGIN_INCLUDE  */
    END_INCLUDE = 531,             /* END_INCLUDE  */
    AT_IFDEF = 532,                /* AT_IFDEF  */
    AT_IFNDEF = 533,               /* AT_IFNDEF  */
    AT_ELSE = 534,                 /* AT_ELSE  */
    AT_ENDIF = 535,                /* AT_ENDIF  */
    RETURNING = 536,               /* RETURNING  */
    BEGIN_ = 537,                  /* BEGIN_  */
    FOR = 538                      /* FOR  */
  };
  typedef enum yytokentype yytoken_kind_t;
#endif

/* Value type.  */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
union YYSTYPE
{

  struct ast_node *aval;
  int ival;
  char *sval;


};
typedef union YYSTYPE YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define YYSTYPE_IS_DECLARED 1
#endif


extern YYSTYPE yylval;


int yyparse (void);


#endif /* !YY_YY_OUT_CQL_Y_H_INCLUDED  */
/* A Bison parser, made by GNU Bison 3.8.2.  */

/* Bison implementation for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
   especially those whose name start with YY_ or yy_.  They are
   private implementation details that can be changed or removed.  */

/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */

/* Identify Bison output, and Bison version.  */
#define YYBISON 30802

/* Bison version string.  */
#define YYBISON_VERSION "3.8.2"

/* Skeleton name.  */
#define YYSKELETON_NAME "yacc.c"

/* Pure parsers.  */
#define YYPURE 0

/* Push parsers.  */
#define YYPUSH 0

/* Pull parsers.  */
#define YYPULL 1




/* First part of user prologue.  */




// In order for leak sanitizer to run, main must exit normally
// and yet there are cases we need to bail out like we would in exit
// to do that we use cql_cleanup_and_exit below which triggers this longjmp
// here in main.  CQL aspires to be a library in the future and so
// it cannot exit in those cases either it has to clean up, clean.

static jmp_buf cql_for_exit;
static int32_t cql_exit_code;

// this is the state we need to pre-process @ifdef and @ifndef
typedef struct cql_ifdef_state_t {
  bool_t process_else;
  bool_t processing;
  struct cql_ifdef_state_t *prev;
} cql_ifdef_state_t;

static cql_ifdef_state_t *cql_ifdef_state;

static ast_node *do_ifdef(ast_node *ast);
static ast_node *do_ifndef(ast_node *ast);
static void do_endif(void);
static void do_else(void);
static bool_t is_processing(void);

// The stack needed is modest (32k) and this prevents leaks in error cases because
// it's just a stack alloc.
#define YYSTACK_USE_ALLOCA 1

// Bison defines this only if __GNUC__ is defined, but Clang defines _MSC_VER
// and not __GNUC__ on Windows.
#ifdef __clang__
  #define YY_ATTRIBUTE_UNUSED __attribute__((unused))
#endif

static void parse_cmd(int argc, char **argv);
static void print_dot(struct ast_node* node);
static ast_node *file_literal(ast_node *);
static void cql_exit_on_parse_errors();
static void parse_cleanup();
static void cql_usage();
static ast_node *make_statement_node(ast_node *misc_attrs, ast_node *any_stmt);
static ast_node *make_coldef_node(ast_node *col_def_tye_attrs, ast_node *misc_attrs);
static ast_node *reduce_str_chain(ast_node *str_chain);
static ast_node *new_simple_call_from_name(ast_node *name);

// Set to true upon a call to `yyerror`.
static bool_t parse_error_occurred;
static CSTR table_comment_saved;

static void cql_setup_defines(void);
static void cql_cleanup_defines(void);
static void cql_add_define(CSTR name);

int yylex();
void yyerror(const char *s, ...);
void yyset_in(FILE *);
void yyset_lineno(int);
void yyrestart(FILE *);

#ifndef _MSC_VER
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wsign-conversion"
#pragma clang diagnostic ignored "-Wimplicit-int-conversion"
#pragma clang diagnostic ignored "-Wconversion"
#endif

// In two places in the grammar we have to include an optional name list
// even though the name list isn't actually allowed.  We do this to avoid
// a shift reduce conflict.  We can't avoid the conflict case without a lot
// of very ugly grammar duplication. So this is the lesser of two evils
// and definitely more maintainable.
#define YY_ERROR_ON_COLUMNS(x) \
  if (x) yyerror("Cursor columns not allowed in this form.")

// In window_func_inv the 'distinct' keyword may not be part of the call
// e.g. count(distinct x) is not a valid form for window functions.  We
// unify these trees to avoid shift reduce conflicts and to clean up the grammar.
// so there is one call form.  However it means an explicit error check
#define YY_ERROR_ON_DISTINCT(x) \
  if (x) yyerror("DISTINCT not valid in this context.")

// if macro arg found that's an error, it should be a macro
#define YY_ERROR_ON_MACRO_ARG(x) \
  if (get_macro_arg_info(x) && !get_macro_info(x)) yyerror("expected a defined macro not a macro formal.");

// if macro arg not found that's an error, it shouldn't be a macro, it should be an arg
#define YY_ERROR_ON_MACRO(x) \
  if (!get_macro_arg_info(x) && get_macro_info(x)) yyerror("expected a defined macro formal not a macro.");

#define YY_ERROR_ON_FAILED_ADD_MACRO(success, name) \
  if (!success) { yyerror(dup_printf("macro already exists '%s'.", name)); }

#define YY_ERROR_ON_FAILED_MACRO_ARG(name) \
  if (name) { yyerror(dup_printf("macro argument already exists '%s'.", name)); }

// We insert calls to `cql_inferred_notnull` as part of a rewrite so we expect
// to see it during semantic analysis, but it cannot be allowed to appear in a
// program. It would be unsafe if it could: It coerces a value from a nullable
// type to a nonnull type without any runtime check.
#define YY_ERROR_ON_CQL_INFERRED_NOTNULL(x) \
  if (is_ast_str(x)) { \
    EXTRACT_STRING(proc_name, x); \
    if (!strcmp(proc_name, "cql_inferred_notnull")) { \
      yyerror("Call to internal function is not allowed 'cql_inferred_notnull'"); \
    } \
  }

// If a column alias is present for * or T.* that's an error
// We now parse ast_star as an expression to avoid ambiguities in the grammar
// but that means we have to manually filter out some of this bad syntax
#define YY_ERROR_ON_ALIAS_PRESENT(x) \
   if (x) yyerror("* and T.* cannot have a column alias");

#ifdef CQL_AMALGAM
static void cql_reset_globals(void);
#endif

#define AST_STR(node) (((str_ast_node *)node)->value)



# ifndef YY_CAST
#  ifdef __cplusplus
#   define YY_CAST(Type, Val) static_cast<Type> (Val)
#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
#  else
#   define YY_CAST(Type, Val) ((Type) (Val))
#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
#  endif
# endif
# ifndef YY_NULLPTR
#  if defined __cplusplus
#   if 201103L <= __cplusplus
#    define YY_NULLPTR nullptr
#   else
#    define YY_NULLPTR 0
#   endif
#  else
#   define YY_NULLPTR ((void*)0)
#  endif
# endif

/* Symbol kind.  */
enum yysymbol_kind_t
{
  YYSYMBOL_YYEMPTY = -2,
  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
  YYSYMBOL_YYerror = 1,                    /* error  */
  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
  YYSYMBOL_ID = 3,                         /* ID  */
  YYSYMBOL_QID = 4,                        /* QID  */
  YYSYMBOL_TRUE_ = 5,                      /* "TRUE"  */
  YYSYMBOL_FALSE_ = 6,                     /* "FALSE"  */
  YYSYMBOL_STRLIT = 7,                     /* STRLIT  */
  YYSYMBOL_CSTRLIT = 8,                    /* CSTRLIT  */
  YYSYMBOL_BLOBLIT = 9,                    /* BLOBLIT  */
  YYSYMBOL_INTLIT = 10,                    /* INTLIT  */
  YYSYMBOL_BOOL_ = 11,                     /* "BOOL"  */
  YYSYMBOL_AT_DUMMY_NULLABLES = 12,        /* AT_DUMMY_NULLABLES  */
  YYSYMBOL_AT_DUMMY_DEFAULTS = 13,         /* AT_DUMMY_DEFAULTS  */
  YYSYMBOL_LONGLIT = 14,                   /* LONGLIT  */
  YYSYMBOL_REALLIT = 15,                   /* REALLIT  */
  YYSYMBOL_STMT_LIST_MACRO = 16,           /* STMT_LIST_MACRO  */
  YYSYMBOL_EXPR_MACRO = 17,                /* EXPR_MACRO  */
  YYSYMBOL_QUERY_PARTS_MACRO = 18,         /* QUERY_PARTS_MACRO  */
  YYSYMBOL_CTE_TABLES_MACRO = 19,          /* CTE_TABLES_MACRO  */
  YYSYMBOL_SELECT_CORE_MACRO = 20,         /* SELECT_CORE_MACRO  */
  YYSYMBOL_SELECT_EXPR_MACRO = 21,         /* SELECT_EXPR_MACRO  */
  YYSYMBOL_UNION_ALL = 22,                 /* UNION_ALL  */
  YYSYMBOL_UNION = 23,                     /* UNION  */
  YYSYMBOL_INTERSECT = 24,                 /* INTERSECT  */
  YYSYMBOL_EXCEPT = 25,                    /* EXCEPT  */
  YYSYMBOL_ADD_EQ = 26,                    /* ADD_EQ  */
  YYSYMBOL_SUB_EQ = 27,                    /* SUB_EQ  */
  YYSYMBOL_MUL_EQ = 28,                    /* MUL_EQ  */
  YYSYMBOL_DIV_EQ = 29,                    /* DIV_EQ  */
  YYSYMBOL_MOD_EQ = 30,                    /* MOD_EQ  */
  YYSYMBOL_OR_EQ = 31,                     /* OR_EQ  */
  YYSYMBOL_AND_EQ = 32,                    /* AND_EQ  */
  YYSYMBOL_LS_EQ = 33,                     /* LS_EQ  */
  YYSYMBOL_RS_EQ = 34,                     /* RS_EQ  */
  YYSYMBOL_OR = 35,                        /* OR  */
  YYSYMBOL_AND = 36,                       /* AND  */
  YYSYMBOL_NOT = 37,                       /* NOT  */
  YYSYMBOL_BETWEEN = 38,                   /* BETWEEN  */
  YYSYMBOL_NOT_BETWEEN = 39,               /* NOT_BETWEEN  */
  YYSYMBOL_40_ = 40,                       /* '='  */
  YYSYMBOL_LIKE = 41,                      /* LIKE  */
  YYSYMBOL_NOT_LIKE = 42,                  /* NOT_LIKE  */
  YYSYMBOL_GLOB = 43,                      /* GLOB  */
  YYSYMBOL_NOT_GLOB = 44,                  /* NOT_GLOB  */
  YYSYMBOL_MATCH = 45,                     /* MATCH  */
  YYSYMBOL_NOT_MATCH = 46,                 /* NOT_MATCH  */
  YYSYMBOL_REGEXP = 47,                    /* REGEXP  */
  YYSYMBOL_NOT_REGEXP = 48,                /* NOT_REGEXP  */
  YYSYMBOL_IN = 49,                        /* IN  */
  YYSYMBOL_NOT_IN = 50,                    /* NOT_IN  */
  YYSYMBOL_IS_NOT = 51,                    /* IS_NOT  */
  YYSYMBOL_IS = 52,                        /* IS  */
  YYSYMBOL_IS_TRUE = 53,                   /* IS_TRUE  */
  YYSYMBOL_IS_FALSE = 54,                  /* IS_FALSE  */
  YYSYMBOL_IS_NOT_TRUE = 55,               /* IS_NOT_TRUE  */
  YYSYMBOL_IS_NOT_FALSE = 56,              /* IS_NOT_FALSE  */
  YYSYMBOL_ISNULL = 57,                    /* ISNULL  */
  YYSYMBOL_NOTNULL = 58,                   /* NOTNULL  */
  YYSYMBOL_59_ = 59,                       /* '<'  */
  YYSYMBOL_60_ = 60,                       /* '>'  */
  YYSYMBOL_61_ = 61,                       /* '&'  */
  YYSYMBOL_62_ = 62,                       /* '|'  */
  YYSYMBOL_63_ = 63,                       /* '+'  */
  YYSYMBOL_64_ = 64,                       /* '-'  */
  YYSYMBOL_65_ = 65,                       /* '*'  */
  YYSYMBOL_66_ = 66,                       /* '/'  */
  YYSYMBOL_67_ = 67,                       /* '%'  */
  YYSYMBOL_JEX1 = 68,                      /* JEX1  */
  YYSYMBOL_JEX2 = 69,                      /* JEX2  */
  YYSYMBOL_70_ = 70,                       /* ':'  */
  YYSYMBOL_71_ = 71,                       /* '.'  */
  YYSYMBOL_72_ = 72,                       /* '['  */
  YYSYMBOL_73_ = 73,                       /* '~'  */
  YYSYMBOL_COLLATE = 74,                   /* COLLATE  */
  YYSYMBOL_UMINUS = 75,                    /* UMINUS  */
  YYSYMBOL_ASSIGN = 76,                    /* ":="  */
  YYSYMBOL_CONCAT = 77,                    /* "||"  */
  YYSYMBOL_EQEQ = 78,                      /* "=="  */
  YYSYMBOL_GE = 79,                        /* ">="  */
  YYSYMBOL_LE = 80,                        /* "<="  */
  YYSYMBOL_LS = 81,                        /* "<<"  */
  YYSYMBOL_NE = 82,                        /* "<>"  */
  YYSYMBOL_NE_ = 83,                       /* "!="  */
  YYSYMBOL_RS = 84,                        /* ">>"  */
  YYSYMBOL_EXCLUDE_GROUP = 85,             /* EXCLUDE_GROUP  */
  YYSYMBOL_EXCLUDE_CURRENT_ROW = 86,       /* EXCLUDE_CURRENT_ROW  */
  YYSYMBOL_EXCLUDE_TIES = 87,              /* EXCLUDE_TIES  */
  YYSYMBOL_EXCLUDE_NO_OTHERS = 88,         /* EXCLUDE_NO_OTHERS  */
  YYSYMBOL_CURRENT_ROW = 89,               /* CURRENT_ROW  */
  YYSYMBOL_UNBOUNDED = 90,                 /* UNBOUNDED  */
  YYSYMBOL_PRECEDING = 91,                 /* PRECEDING  */
  YYSYMBOL_FOLLOWING = 92,                 /* FOLLOWING  */
  YYSYMBOL_CREATE = 93,                    /* CREATE  */
  YYSYMBOL_DROP = 94,                      /* DROP  */
  YYSYMBOL_TABLE = 95,                     /* TABLE  */
  YYSYMBOL_WITHOUT = 96,                   /* WITHOUT  */
  YYSYMBOL_ROWID = 97,                     /* ROWID  */
  YYSYMBOL_PRIMARY = 98,                   /* PRIMARY  */
  YYSYMBOL_KEY = 99,                       /* KEY  */
  YYSYMBOL_NULL_ = 100,                    /* "NULL"  */
  YYSYMBOL_DEFAULT = 101,                  /* DEFAULT  */
  YYSYMBOL_CHECK = 102,                    /* CHECK  */
  YYSYMBOL_AT_DUMMY_SEED = 103,            /* AT_DUMMY_SEED  */
  YYSYMBOL_VIRTUAL = 104,                  /* VIRTUAL  */
  YYSYMBOL_AT_EMIT_GROUP = 105,            /* AT_EMIT_GROUP  */
  YYSYMBOL_AT_EMIT_ENUMS = 106,            /* AT_EMIT_ENUMS  */
  YYSYMBOL_AT_EMIT_CONSTANTS = 107,        /* AT_EMIT_CONSTANTS  */
  YYSYMBOL_OBJECT = 108,                   /* OBJECT  */
  YYSYMBOL_TEXT = 109,                     /* TEXT  */
  YYSYMBOL_BLOB = 110,                     /* BLOB  */
  YYSYMBOL_LONG_ = 111,                    /* LONG_  */
  YYSYMBOL_INT_ = 112,                     /* INT_  */
  YYSYMBOL_INTEGER = 113,                  /* INTEGER  */
  YYSYMBOL_LONG_INT = 114,                 /* LONG_INT  */
  YYSYMBOL_LONG_INTEGER = 115,             /* LONG_INTEGER  */
  YYSYMBOL_REAL = 116,                     /* REAL  */
  YYSYMBOL_ON = 117,                       /* ON  */
  YYSYMBOL_UPDATE = 118,                   /* UPDATE  */
  YYSYMBOL_CASCADE = 119,                  /* CASCADE  */
  YYSYMBOL_ON_CONFLICT = 120,              /* ON_CONFLICT  */
  YYSYMBOL_DO = 121,                       /* DO  */
  YYSYMBOL_NOTHING = 122,                  /* NOTHING  */
  YYSYMBOL_DELETE = 123,                   /* DELETE  */
  YYSYMBOL_INDEX = 124,                    /* INDEX  */
  YYSYMBOL_FOREIGN = 125,                  /* FOREIGN  */
  YYSYMBOL_REFERENCES = 126,               /* REFERENCES  */
  YYSYMBOL_CONSTRAINT = 127,               /* CONSTRAINT  */
  YYSYMBOL_UPSERT = 128,                   /* UPSERT  */
  YYSYMBOL_STATEMENT = 129,                /* STATEMENT  */
  YYSYMBOL_CONST = 130,                    /* CONST  */
  YYSYMBOL_INSERT = 131,                   /* INSERT  */
  YYSYMBOL_INTO = 132,                     /* INTO  */
  YYSYMBOL_VALUES = 133,                   /* VALUES  */
  YYSYMBOL_VIEW = 134,                     /* VIEW  */
  YYSYMBOL_SELECT = 135,                   /* SELECT  */
  YYSYMBOL_QUERY_PLAN = 136,               /* QUERY_PLAN  */
  YYSYMBOL_EXPLAIN = 137,                  /* EXPLAIN  */
  YYSYMBOL_OVER = 138,                     /* OVER  */
  YYSYMBOL_WINDOW = 139,                   /* WINDOW  */
  YYSYMBOL_FILTER = 140,                   /* FILTER  */
  YYSYMBOL_PARTITION = 141,                /* PARTITION  */
  YYSYMBOL_RANGE = 142,                    /* RANGE  */
  YYSYMBOL_ROWS = 143,                     /* ROWS  */
  YYSYMBOL_GROUPS = 144,                   /* GROUPS  */
  YYSYMBOL_AS = 145,                       /* AS  */
  YYSYMBOL_CASE = 146,                     /* CASE  */
  YYSYMBOL_WHEN = 147,                     /* WHEN  */
  YYSYMBOL_FROM = 148,                     /* FROM  */
  YYSYMBOL_THEN = 149,                     /* THEN  */
  YYSYMBOL_ELSE = 150,                     /* ELSE  */
  YYSYMBOL_END = 151,                      /* END  */
  YYSYMBOL_LEFT = 152,                     /* LEFT  */
  YYSYMBOL_SWITCH = 153,                   /* SWITCH  */
  YYSYMBOL_OUTER = 154,                    /* OUTER  */
  YYSYMBOL_JOIN = 155,                     /* JOIN  */
  YYSYMBOL_WHERE = 156,                    /* WHERE  */
  YYSYMBOL_GROUP = 157,                    /* GROUP  */
  YYSYMBOL_BY = 158,                       /* BY  */
  YYSYMBOL_ORDER = 159,                    /* ORDER  */
  YYSYMBOL_ASC = 160,                      /* ASC  */
  YYSYMBOL_NULLS = 161,                    /* NULLS  */
  YYSYMBOL_FIRST = 162,                    /* FIRST  */
  YYSYMBOL_LAST = 163,                     /* LAST  */
  YYSYMBOL_DESC = 164,                     /* DESC  */
  YYSYMBOL_INNER = 165,                    /* INNER  */
  YYSYMBOL_AUTOINCREMENT = 166,            /* AUTOINCREMENT  */
  YYSYMBOL_DISTINCT = 167,                 /* DISTINCT  */
  YYSYMBOL_LIMIT = 168,                    /* LIMIT  */
  YYSYMBOL_OFFSET = 169,                   /* OFFSET  */
  YYSYMBOL_TEMP = 170,                     /* TEMP  */
  YYSYMBOL_TRIGGER = 171,                  /* TRIGGER  */
  YYSYMBOL_IF = 172,                       /* IF  */
  YYSYMBOL_ALL = 173,                      /* ALL  */
  YYSYMBOL_CROSS = 174,                    /* CROSS  */
  YYSYMBOL_USING = 175,                    /* USING  */
  YYSYMBOL_RIGHT = 176,                    /* RIGHT  */
  YYSYMBOL_AT_EPONYMOUS = 177,             /* AT_EPONYMOUS  */
  YYSYMBOL_HIDDEN = 178,                   /* HIDDEN  */
  YYSYMBOL_UNIQUE = 179,                   /* UNIQUE  */
  YYSYMBOL_HAVING = 180,                   /* HAVING  */
  YYSYMBOL_SET = 181,                      /* SET  */
  YYSYMBOL_LET = 182,                      /* LET  */
  YYSYMBOL_TO = 183,                       /* TO  */
  YYSYMBOL_DISTINCTROW = 184,              /* DISTINCTROW  */
  YYSYMBOL_ENUM = 185,                     /* ENUM  */
  YYSYMBOL_FUNC = 186,                     /* FUNC  */
  YYSYMBOL_FUNCTION = 187,                 /* FUNCTION  */
  YYSYMBOL_PROC = 188,                     /* PROC  */
  YYSYMBOL_PROCEDURE = 189,                /* PROCEDURE  */
  YYSYMBOL_INTERFACE = 190,                /* INTERFACE  */
  YYSYMBOL_OUT = 191,                      /* OUT  */
  YYSYMBOL_INOUT = 192,                    /* INOUT  */
  YYSYMBOL_CURSOR = 193,                   /* CURSOR  */
  YYSYMBOL_DECLARE = 194,                  /* DECLARE  */
  YYSYMBOL_VAR = 195,                      /* VAR  */
  YYSYMBOL_TYPE = 196,                     /* TYPE  */
  YYSYMBOL_FETCH = 197,                    /* FETCH  */
  YYSYMBOL_LOOP = 198,                     /* LOOP  */
  YYSYMBOL_LEAVE = 199,                    /* LEAVE  */
  YYSYMBOL_CONTINUE = 200,                 /* CONTINUE  */
  YYSYMBOL_ENCODE = 201,                   /* ENCODE  */
  YYSYMBOL_CONTEXT_COLUMN = 202,           /* CONTEXT_COLUMN  */
  YYSYMBOL_CONTEXT_TYPE = 203,             /* CONTEXT_TYPE  */
  YYSYMBOL_OPEN = 204,                     /* OPEN  */
  YYSYMBOL_CLOSE = 205,                    /* CLOSE  */
  YYSYMBOL_ELSE_IF = 206,                  /* ELSE_IF  */
  YYSYMBOL_WHILE = 207,                    /* WHILE  */
  YYSYMBOL_CALL = 208,                     /* CALL  */
  YYSYMBOL_TRY = 209,                      /* TRY  */
  YYSYMBOL_CATCH = 210,                    /* CATCH  */
  YYSYMBOL_THROW = 211,                    /* THROW  */
  YYSYMBOL_RETURN = 212,                   /* RETURN  */
  YYSYMBOL_SAVEPOINT = 213,                /* SAVEPOINT  */
  YYSYMBOL_ROLLBACK = 214,                 /* ROLLBACK  */
  YYSYMBOL_COMMIT = 215,                   /* COMMIT  */
  YYSYMBOL_TRANSACTION = 216,              /* TRANSACTION  */
  YYSYMBOL_RELEASE = 217,                  /* RELEASE  */
  YYSYMBOL_ARGUMENTS = 218,                /* ARGUMENTS  */
  YYSYMBOL_TYPE_CHECK = 219,               /* TYPE_CHECK  */
  YYSYMBOL_CAST = 220,                     /* CAST  */
  YYSYMBOL_WITH = 221,                     /* WITH  */
  YYSYMBOL_RECURSIVE = 222,                /* RECURSIVE  */
  YYSYMBOL_REPLACE = 223,                  /* REPLACE  */
  YYSYMBOL_IGNORE = 224,                   /* IGNORE  */
  YYSYMBOL_ADD = 225,                      /* ADD  */
  YYSYMBOL_COLUMN = 226,                   /* COLUMN  */
  YYSYMBOL_AT_COLUMNS = 227,               /* AT_COLUMNS  */
  YYSYMBOL_RENAME = 228,                   /* RENAME  */
  YYSYMBOL_ALTER = 229,                    /* ALTER  */
  YYSYMBOL_AT_ECHO = 230,                  /* AT_ECHO  */
  YYSYMBOL_AT_CREATE = 231,                /* AT_CREATE  */
  YYSYMBOL_AT_RECREATE = 232,              /* AT_RECREATE  */
  YYSYMBOL_AT_DELETE = 233,                /* AT_DELETE  */
  YYSYMBOL_AT_SCHEMA_UPGRADE_VERSION = 234, /* AT_SCHEMA_UPGRADE_VERSION  */
  YYSYMBOL_AT_PREVIOUS_SCHEMA = 235,       /* AT_PREVIOUS_SCHEMA  */
  YYSYMBOL_AT_SCHEMA_UPGRADE_SCRIPT = 236, /* AT_SCHEMA_UPGRADE_SCRIPT  */
  YYSYMBOL_AT_ID = 237,                    /* AT_ID  */
  YYSYMBOL_AT_RC = 238,                    /* AT_RC  */
  YYSYMBOL_AT_PROC = 239,                  /* AT_PROC  */
  YYSYMBOL_AT_FILE = 240,                  /* AT_FILE  */
  YYSYMBOL_AT_LINE = 241,                  /* AT_LINE  */
  YYSYMBOL_AT_MACRO_LINE = 242,            /* AT_MACRO_LINE  */
  YYSYMBOL_AT_MACRO_FILE = 243,            /* AT_MACRO_FILE  */
  YYSYMBOL_AT_TEXT = 244,                  /* AT_TEXT  */
  YYSYMBOL_AT_ATTRIBUTE = 245,             /* AT_ATTRIBUTE  */
  YYSYMBOL_AT_SENSITIVE = 246,             /* AT_SENSITIVE  */
  YYSYMBOL_DEFERRED = 247,                 /* DEFERRED  */
  YYSYMBOL_AT_TMP = 248,                   /* AT_TMP  */
  YYSYMBOL_NOT_DEFERRABLE = 249,           /* NOT_DEFERRABLE  */
  YYSYMBOL_DEFERRABLE = 250,               /* DEFERRABLE  */
  YYSYMBOL_IMMEDIATE = 251,                /* IMMEDIATE  */
  YYSYMBOL_EXCLUSIVE = 252,                /* EXCLUSIVE  */
  YYSYMBOL_RESTRICT = 253,                 /* RESTRICT  */
  YYSYMBOL_ACTION = 254,                   /* ACTION  */
  YYSYMBOL_INITIALLY = 255,                /* INITIALLY  */
  YYSYMBOL_NO = 256,                       /* NO  */
  YYSYMBOL_BEFORE = 257,                   /* BEFORE  */
  YYSYMBOL_AFTER = 258,                    /* AFTER  */
  YYSYMBOL_INSTEAD = 259,                  /* INSTEAD  */
  YYSYMBOL_OF = 260,                       /* OF  */
  YYSYMBOL_FOR_EACH_ROW = 261,             /* FOR_EACH_ROW  */
  YYSYMBOL_EXISTS = 262,                   /* EXISTS  */
  YYSYMBOL_RAISE = 263,                    /* RAISE  */
  YYSYMBOL_FAIL = 264,                     /* FAIL  */
  YYSYMBOL_ABORT = 265,                    /* ABORT  */
  YYSYMBOL_AT_ENFORCE_STRICT = 266,        /* AT_ENFORCE_STRICT  */
  YYSYMBOL_AT_ENFORCE_NORMAL = 267,        /* AT_ENFORCE_NORMAL  */
  YYSYMBOL_AT_ENFORCE_RESET = 268,         /* AT_ENFORCE_RESET  */
  YYSYMBOL_AT_ENFORCE_PUSH = 269,          /* AT_ENFORCE_PUSH  */
  YYSYMBOL_AT_ENFORCE_POP = 270,           /* AT_ENFORCE_POP  */
  YYSYMBOL_AT_BEGIN_SCHEMA_REGION = 271,   /* AT_BEGIN_SCHEMA_REGION  */
  YYSYMBOL_AT_END_SCHEMA_REGION = 272,     /* AT_END_SCHEMA_REGION  */
  YYSYMBOL_AT_OP = 273,                    /* AT_OP  */
  YYSYMBOL_AT_DECLARE_SCHEMA_REGION = 274, /* AT_DECLARE_SCHEMA_REGION  */
  YYSYMBOL_AT_DECLARE_DEPLOYABLE_REGION = 275, /* AT_DECLARE_DEPLOYABLE_REGION  */
  YYSYMBOL_AT_SCHEMA_AD_HOC_MIGRATION = 276, /* AT_SCHEMA_AD_HOC_MIGRATION  */
  YYSYMBOL_PRIVATE = 277,                  /* PRIVATE  */
  YYSYMBOL_AT_KEEP_TABLE_NAME_IN_ALIASES = 278, /* AT_KEEP_TABLE_NAME_IN_ALIASES  */
  YYSYMBOL_AT_MACRO = 279,                 /* AT_MACRO  */
  YYSYMBOL_EXPR = 280,                     /* EXPR  */
  YYSYMBOL_STMT_LIST = 281,                /* STMT_LIST  */
  YYSYMBOL_QUERY_PARTS = 282,              /* QUERY_PARTS  */
  YYSYMBOL_CTE_TABLES = 283,               /* CTE_TABLES  */
  YYSYMBOL_SELECT_CORE = 284,              /* SELECT_CORE  */
  YYSYMBOL_SELECT_EXPR = 285,              /* SELECT_EXPR  */
  YYSYMBOL_SIGN_FUNCTION = 286,            /* SIGN_FUNCTION  */
  YYSYMBOL_CURSOR_HAS_ROW = 287,           /* CURSOR_HAS_ROW  */
  YYSYMBOL_AT_UNSUB = 288,                 /* AT_UNSUB  */
  YYSYMBOL_BEGIN_INCLUDE = 289,            /* BEGIN_INCLUDE  */
  YYSYMBOL_END_INCLUDE = 290,              /* END_INCLUDE  */
  YYSYMBOL_AT_IFDEF = 291,                 /* AT_IFDEF  */
  YYSYMBOL_AT_IFNDEF = 292,                /* AT_IFNDEF  */
  YYSYMBOL_AT_ELSE = 293,                  /* AT_ELSE  */
  YYSYMBOL_AT_ENDIF = 294,                 /* AT_ENDIF  */
  YYSYMBOL_RETURNING = 295,                /* RETURNING  */
  YYSYMBOL_BEGIN_ = 296,                   /* BEGIN_  */
  YYSYMBOL_FOR = 297,                      /* FOR  */
  YYSYMBOL_298_ = 298,                     /* '!'  */
  YYSYMBOL_299_ = 299,                     /* '('  */
  YYSYMBOL_300_ = 300,                     /* ')'  */
  YYSYMBOL_301_ = 301,                     /* ';'  */
  YYSYMBOL_302_ = 302,                     /* ']'  */
  YYSYMBOL_303_ = 303,                     /* ','  */
  YYSYMBOL_YYACCEPT = 304,                 /* $accept  */
  YYSYMBOL_program = 305,                  /* program  */
  YYSYMBOL_top_level_stmts = 306,          /* top_level_stmts  */
  YYSYMBOL_include_section = 307,          /* include_section  */
  YYSYMBOL_include_stmts = 308,            /* include_stmts  */
  YYSYMBOL_opt_stmt_list = 309,            /* opt_stmt_list  */
  YYSYMBOL_macro_ref = 310,                /* macro_ref  */
  YYSYMBOL_stmt_list = 311,                /* stmt_list  */
  YYSYMBOL_stmt = 312,                     /* stmt  */
  YYSYMBOL_expr_stmt = 313,                /* expr_stmt  */
  YYSYMBOL_any_stmt = 314,                 /* any_stmt  */
  YYSYMBOL_explain_stmt = 315,             /* explain_stmt  */
  YYSYMBOL_opt_query_plan = 316,           /* opt_query_plan  */
  YYSYMBOL_explain_target = 317,           /* explain_target  */
  YYSYMBOL_previous_schema_stmt = 318,     /* previous_schema_stmt  */
  YYSYMBOL_schema_upgrade_script_stmt = 319, /* schema_upgrade_script_stmt  */
  YYSYMBOL_schema_upgrade_version_stmt = 320, /* schema_upgrade_version_stmt  */
  YYSYMBOL_set_stmt = 321,                 /* set_stmt  */
  YYSYMBOL_let_stmt = 322,                 /* let_stmt  */
  YYSYMBOL_const_stmt = 323,               /* const_stmt  */
  YYSYMBOL_version_attrs_opt_recreate = 324, /* version_attrs_opt_recreate  */
  YYSYMBOL_opt_delete_plain_attr = 325,    /* opt_delete_plain_attr  */
  YYSYMBOL_opt_version_attrs = 326,        /* opt_version_attrs  */
  YYSYMBOL_version_attrs = 327,            /* version_attrs  */
  YYSYMBOL_opt_delete_version_attr = 328,  /* opt_delete_version_attr  */
  YYSYMBOL_drop_table_stmt = 329,          /* drop_table_stmt  */
  YYSYMBOL_drop_view_stmt = 330,           /* drop_view_stmt  */
  YYSYMBOL_drop_index_stmt = 331,          /* drop_index_stmt  */
  YYSYMBOL_drop_trigger_stmt = 332,        /* drop_trigger_stmt  */
  YYSYMBOL_create_virtual_table_stmt = 333, /* create_virtual_table_stmt  */
  YYSYMBOL_opt_module_args = 334,          /* opt_module_args  */
  YYSYMBOL_create_table_prefix_opt_temp = 335, /* create_table_prefix_opt_temp  */
  YYSYMBOL_create_table_stmt = 336,        /* create_table_stmt  */
  YYSYMBOL_opt_temp = 337,                 /* opt_temp  */
  YYSYMBOL_opt_if_not_exists = 338,        /* opt_if_not_exists  */
  YYSYMBOL_opt_no_rowid = 339,             /* opt_no_rowid  */
  YYSYMBOL_opt_vtab_flags = 340,           /* opt_vtab_flags  */
  YYSYMBOL_col_key_list = 341,             /* col_key_list  */
  YYSYMBOL_col_key_def = 342,              /* col_key_def  */
  YYSYMBOL_check_def = 343,                /* check_def  */
  YYSYMBOL_shape_exprs = 344,              /* shape_exprs  */
  YYSYMBOL_shape_expr = 345,               /* shape_expr  */
  YYSYMBOL_shape_def = 346,                /* shape_def  */
  YYSYMBOL_shape_def_base = 347,           /* shape_def_base  */
  YYSYMBOL_sql_name = 348,                 /* sql_name  */
  YYSYMBOL_misc_attr_key = 349,            /* misc_attr_key  */
  YYSYMBOL_cql_attr_key = 350,             /* cql_attr_key  */
  YYSYMBOL_misc_attr_value_list = 351,     /* misc_attr_value_list  */
  YYSYMBOL_misc_attr_value = 352,          /* misc_attr_value  */
  YYSYMBOL_misc_attr = 353,                /* misc_attr  */
  YYSYMBOL_misc_attrs = 354,               /* misc_attrs  */
  YYSYMBOL_col_def = 355,                  /* col_def  */
  YYSYMBOL_pk_def = 356,                   /* pk_def  */
  YYSYMBOL_opt_conflict_clause = 357,      /* opt_conflict_clause  */
  YYSYMBOL_conflict_clause = 358,          /* conflict_clause  */
  YYSYMBOL_opt_fk_options = 359,           /* opt_fk_options  */
  YYSYMBOL_fk_options = 360,               /* fk_options  */
  YYSYMBOL_fk_on_options = 361,            /* fk_on_options  */
  YYSYMBOL_fk_action = 362,                /* fk_action  */
  YYSYMBOL_fk_deferred_options = 363,      /* fk_deferred_options  */
  YYSYMBOL_fk_initial_state = 364,         /* fk_initial_state  */
  YYSYMBOL_fk_def = 365,                   /* fk_def  */
  YYSYMBOL_fk_target_options = 366,        /* fk_target_options  */
  YYSYMBOL_unq_def = 367,                  /* unq_def  */
  YYSYMBOL_opt_unique = 368,               /* opt_unique  */
  YYSYMBOL_indexed_column = 369,           /* indexed_column  */
  YYSYMBOL_indexed_columns = 370,          /* indexed_columns  */
  YYSYMBOL_create_index_stmt = 371,        /* create_index_stmt  */
  YYSYMBOL_name = 372,                     /* name  */
  YYSYMBOL_loose_name = 373,               /* loose_name  */
  YYSYMBOL_loose_name_or_type = 374,       /* loose_name_or_type  */
  YYSYMBOL_opt_sql_name = 375,             /* opt_sql_name  */
  YYSYMBOL_name_list = 376,                /* name_list  */
  YYSYMBOL_sql_name_list = 377,            /* sql_name_list  */
  YYSYMBOL_opt_name_list = 378,            /* opt_name_list  */
  YYSYMBOL_opt_sql_name_list = 379,        /* opt_sql_name_list  */
  YYSYMBOL_cte_binding_list = 380,         /* cte_binding_list  */
  YYSYMBOL_cte_binding = 381,              /* cte_binding  */
  YYSYMBOL_col_attrs = 382,                /* col_attrs  */
  YYSYMBOL_version_annotation = 383,       /* version_annotation  */
  YYSYMBOL_opt_kind = 384,                 /* opt_kind  */
  YYSYMBOL_data_type_numeric = 385,        /* data_type_numeric  */
  YYSYMBOL_data_type_any = 386,            /* data_type_any  */
  YYSYMBOL_not_null = 387,                 /* not_null  */
  YYSYMBOL_data_type_with_options = 388,   /* data_type_with_options  */
  YYSYMBOL_str_literal = 389,              /* str_literal  */
  YYSYMBOL_str_chain = 390,                /* str_chain  */
  YYSYMBOL_str_leaf = 391,                 /* str_leaf  */
  YYSYMBOL_num_literal = 392,              /* num_literal  */
  YYSYMBOL_const_expr = 393,               /* const_expr  */
  YYSYMBOL_any_literal = 394,              /* any_literal  */
  YYSYMBOL_text_args = 395,                /* text_args  */
  YYSYMBOL_text_arg = 396,                 /* text_arg  */
  YYSYMBOL_raise_expr = 397,               /* raise_expr  */
  YYSYMBOL_opt_distinct = 398,             /* opt_distinct  */
  YYSYMBOL_simple_call = 399,              /* simple_call  */
  YYSYMBOL_call = 400,                     /* call  */
  YYSYMBOL_basic_expr = 401,               /* basic_expr  */
  YYSYMBOL_math_expr = 402,                /* math_expr  */
  YYSYMBOL_expr = 403,                     /* expr  */
  YYSYMBOL_case_list = 404,                /* case_list  */
  YYSYMBOL_arg_expr = 405,                 /* arg_expr  */
  YYSYMBOL_arg_exprs = 406,                /* arg_exprs  */
  YYSYMBOL_arg_list = 407,                 /* arg_list  */
  YYSYMBOL_opt_expr_list = 408,            /* opt_expr_list  */
  YYSYMBOL_expr_list = 409,                /* expr_list  */
  YYSYMBOL_shape_arguments = 410,          /* shape_arguments  */
  YYSYMBOL_column_calculation = 411,       /* column_calculation  */
  YYSYMBOL_col_calcs = 412,                /* col_calcs  */
  YYSYMBOL_col_calc = 413,                 /* col_calc  */
  YYSYMBOL_cte_tables = 414,               /* cte_tables  */
  YYSYMBOL_cte_decl = 415,                 /* cte_decl  */
  YYSYMBOL_shared_cte = 416,               /* shared_cte  */
  YYSYMBOL_cte_table = 417,                /* cte_table  */
  YYSYMBOL_with_prefix = 418,              /* with_prefix  */
  YYSYMBOL_with_select_stmt = 419,         /* with_select_stmt  */
  YYSYMBOL_select_nothing_stmt = 420,      /* select_nothing_stmt  */
  YYSYMBOL_select_stmt = 421,              /* select_stmt  */
  YYSYMBOL_select_stmt_no_with = 422,      /* select_stmt_no_with  */
  YYSYMBOL_select_core_list = 423,         /* select_core_list  */
  YYSYMBOL_values = 424,                   /* values  */
  YYSYMBOL_select_core = 425,              /* select_core  */
  YYSYMBOL_compound_operator = 426,        /* compound_operator  */
  YYSYMBOL_window_func_inv = 427,          /* window_func_inv  */
  YYSYMBOL_opt_filter_clause = 428,        /* opt_filter_clause  */
  YYSYMBOL_window_name_or_defn = 429,      /* window_name_or_defn  */
  YYSYMBOL_window_defn = 430,              /* window_defn  */
  YYSYMBOL_opt_frame_spec = 431,           /* opt_frame_spec  */
  YYSYMBOL_frame_type = 432,               /* frame_type  */
  YYSYMBOL_frame_exclude = 433,            /* frame_exclude  */
  YYSYMBOL_frame_boundary_opts = 434,      /* frame_boundary_opts  */
  YYSYMBOL_frame_boundary_start = 435,     /* frame_boundary_start  */
  YYSYMBOL_frame_boundary_end = 436,       /* frame_boundary_end  */
  YYSYMBOL_frame_boundary = 437,           /* frame_boundary  */
  YYSYMBOL_opt_partition_by = 438,         /* opt_partition_by  */
  YYSYMBOL_opt_select_window = 439,        /* opt_select_window  */
  YYSYMBOL_window_clause = 440,            /* window_clause  */
  YYSYMBOL_window_name_defn_list = 441,    /* window_name_defn_list  */
  YYSYMBOL_window_name_defn = 442,         /* window_name_defn  */
  YYSYMBOL_region_spec = 443,              /* region_spec  */
  YYSYMBOL_region_list = 444,              /* region_list  */
  YYSYMBOL_declare_schema_region_stmt = 445, /* declare_schema_region_stmt  */
  YYSYMBOL_declare_deployable_region_stmt = 446, /* declare_deployable_region_stmt  */
  YYSYMBOL_begin_schema_region_stmt = 447, /* begin_schema_region_stmt  */
  YYSYMBOL_end_schema_region_stmt = 448,   /* end_schema_region_stmt  */
  YYSYMBOL_schema_unsub_stmt = 449,        /* schema_unsub_stmt  */
  YYSYMBOL_schema_ad_hoc_migration_stmt = 450, /* schema_ad_hoc_migration_stmt  */
  YYSYMBOL_emit_enums_stmt = 451,          /* emit_enums_stmt  */
  YYSYMBOL_emit_group_stmt = 452,          /* emit_group_stmt  */
  YYSYMBOL_emit_constants_stmt = 453,      /* emit_constants_stmt  */
  YYSYMBOL_opt_from_query_parts = 454,     /* opt_from_query_parts  */
  YYSYMBOL_opt_where = 455,                /* opt_where  */
  YYSYMBOL_opt_groupby = 456,              /* opt_groupby  */
  YYSYMBOL_groupby_list = 457,             /* groupby_list  */
  YYSYMBOL_groupby_item = 458,             /* groupby_item  */
  YYSYMBOL_opt_asc_desc = 459,             /* opt_asc_desc  */
  YYSYMBOL_opt_nullsfirst_nullslast = 460, /* opt_nullsfirst_nullslast  */
  YYSYMBOL_opt_having = 461,               /* opt_having  */
  YYSYMBOL_opt_orderby = 462,              /* opt_orderby  */
  YYSYMBOL_orderby_list = 463,             /* orderby_list  */
  YYSYMBOL_orderby_item = 464,             /* orderby_item  */
  YYSYMBOL_opt_limit = 465,                /* opt_limit  */
  YYSYMBOL_opt_offset = 466,               /* opt_offset  */
  YYSYMBOL_select_opts = 467,              /* select_opts  */
  YYSYMBOL_select_expr_list = 468,         /* select_expr_list  */
  YYSYMBOL_select_expr = 469,              /* select_expr  */
  YYSYMBOL_opt_as_alias = 470,             /* opt_as_alias  */
  YYSYMBOL_as_alias = 471,                 /* as_alias  */
  YYSYMBOL_query_parts = 472,              /* query_parts  */
  YYSYMBOL_table_or_subquery_list = 473,   /* table_or_subquery_list  */
  YYSYMBOL_join_clause = 474,              /* join_clause  */
  YYSYMBOL_join_target_list = 475,         /* join_target_list  */
  YYSYMBOL_table_or_subquery = 476,        /* table_or_subquery  */
  YYSYMBOL_join_type = 477,                /* join_type  */
  YYSYMBOL_join_target = 478,              /* join_target  */
  YYSYMBOL_opt_join_cond = 479,            /* opt_join_cond  */
  YYSYMBOL_join_cond = 480,                /* join_cond  */
  YYSYMBOL_table_function = 481,           /* table_function  */
  YYSYMBOL_create_view_stmt = 482,         /* create_view_stmt  */
  YYSYMBOL_delete_stmt = 483,              /* delete_stmt  */
  YYSYMBOL_delete_stmt_plain = 484,        /* delete_stmt_plain  */
  YYSYMBOL_opt_insert_dummy_spec = 485,    /* opt_insert_dummy_spec  */
  YYSYMBOL_dummy_modifier = 486,           /* dummy_modifier  */
  YYSYMBOL_insert_stmt_type = 487,         /* insert_stmt_type  */
  YYSYMBOL_opt_column_spec = 488,          /* opt_column_spec  */
  YYSYMBOL_column_spec = 489,              /* column_spec  */
  YYSYMBOL_from_shape = 490,               /* from_shape  */
  YYSYMBOL_insert_stmt_plain = 491,        /* insert_stmt_plain  */
  YYSYMBOL_returning_suffix = 492,         /* returning_suffix  */
  YYSYMBOL_insert_stmt = 493,              /* insert_stmt  */
  YYSYMBOL_insert_list_item = 494,         /* insert_list_item  */
  YYSYMBOL_insert_list = 495,              /* insert_list  */
  YYSYMBOL_basic_update_stmt = 496,        /* basic_update_stmt  */
  YYSYMBOL_update_stmt = 497,              /* update_stmt  */
  YYSYMBOL_update_stmt_plain = 498,        /* update_stmt_plain  */
  YYSYMBOL_update_entry = 499,             /* update_entry  */
  YYSYMBOL_update_list = 500,              /* update_list  */
  YYSYMBOL_upsert_stmt = 501,              /* upsert_stmt  */
  YYSYMBOL_upsert_stmt_plain = 502,        /* upsert_stmt_plain  */
  YYSYMBOL_update_cursor_stmt = 503,       /* update_cursor_stmt  */
  YYSYMBOL_conflict_target = 504,          /* conflict_target  */
  YYSYMBOL_function = 505,                 /* function  */
  YYSYMBOL_declare_out_call_stmt = 506,    /* declare_out_call_stmt  */
  YYSYMBOL_declare_enum_stmt = 507,        /* declare_enum_stmt  */
  YYSYMBOL_enum_values = 508,              /* enum_values  */
  YYSYMBOL_enum_value = 509,               /* enum_value  */
  YYSYMBOL_declare_const_stmt = 510,       /* declare_const_stmt  */
  YYSYMBOL_declare_group_stmt = 511,       /* declare_group_stmt  */
  YYSYMBOL_simple_variable_decls = 512,    /* simple_variable_decls  */
  YYSYMBOL_const_values = 513,             /* const_values  */
  YYSYMBOL_const_value = 514,              /* const_value  */
  YYSYMBOL_declare_select_func_stmt = 515, /* declare_select_func_stmt  */
  YYSYMBOL_declare_func_stmt = 516,        /* declare_func_stmt  */
  YYSYMBOL_procedure = 517,                /* procedure  */
  YYSYMBOL_declare_proc_no_check_stmt = 518, /* declare_proc_no_check_stmt  */
  YYSYMBOL_declare_proc_stmt = 519,        /* declare_proc_stmt  */
  YYSYMBOL_declare_interface_stmt = 520,   /* declare_interface_stmt  */
  YYSYMBOL_create_proc_stmt = 521,         /* create_proc_stmt  */
  YYSYMBOL_inout = 522,                    /* inout  */
  YYSYMBOL_typed_name = 523,               /* typed_name  */
  YYSYMBOL_typed_names = 524,              /* typed_names  */
  YYSYMBOL_func_param = 525,               /* func_param  */
  YYSYMBOL_func_params = 526,              /* func_params  */
  YYSYMBOL_param = 527,                    /* param  */
  YYSYMBOL_params = 528,                   /* params  */
  YYSYMBOL_declare_value_cursor = 529,     /* declare_value_cursor  */
  YYSYMBOL_row_source = 530,               /* row_source  */
  YYSYMBOL_declare_forward_read_cursor_stmt = 531, /* declare_forward_read_cursor_stmt  */
  YYSYMBOL_declare_fetched_value_cursor_stmt = 532, /* declare_fetched_value_cursor_stmt  */
  YYSYMBOL_declare_type_stmt = 533,        /* declare_type_stmt  */
  YYSYMBOL_declare_vars_stmt = 534,        /* declare_vars_stmt  */
  YYSYMBOL_call_stmt = 535,                /* call_stmt  */
  YYSYMBOL_for_stmt = 536,                 /* for_stmt  */
  YYSYMBOL_while_stmt = 537,               /* while_stmt  */
  YYSYMBOL_switch_stmt = 538,              /* switch_stmt  */
  YYSYMBOL_switch_case = 539,              /* switch_case  */
  YYSYMBOL_switch_cases = 540,             /* switch_cases  */
  YYSYMBOL_loop_stmt = 541,                /* loop_stmt  */
  YYSYMBOL_leave_stmt = 542,               /* leave_stmt  */
  YYSYMBOL_return_stmt = 543,              /* return_stmt  */
  YYSYMBOL_rollback_return_stmt = 544,     /* rollback_return_stmt  */
  YYSYMBOL_commit_return_stmt = 545,       /* commit_return_stmt  */
  YYSYMBOL_throw_stmt = 546,               /* throw_stmt  */
  YYSYMBOL_trycatch_stmt = 547,            /* trycatch_stmt  */
  YYSYMBOL_continue_stmt = 548,            /* continue_stmt  */
  YYSYMBOL_fetch_stmt = 549,               /* fetch_stmt  */
  YYSYMBOL_fetch_values_stmt = 550,        /* fetch_values_stmt  */
  YYSYMBOL_expr_names = 551,               /* expr_names  */
  YYSYMBOL_expr_name = 552,                /* expr_name  */
  YYSYMBOL_fetch_call_stmt = 553,          /* fetch_call_stmt  */
  YYSYMBOL_close_stmt = 554,               /* close_stmt  */
  YYSYMBOL_out_stmt = 555,                 /* out_stmt  */
  YYSYMBOL_out_union_stmt = 556,           /* out_union_stmt  */
  YYSYMBOL_out_union_parent_child_stmt = 557, /* out_union_parent_child_stmt  */
  YYSYMBOL_child_results = 558,            /* child_results  */
  YYSYMBOL_child_result = 559,             /* child_result  */
  YYSYMBOL_if_ending = 560,                /* if_ending  */
  YYSYMBOL_if_stmt = 561,                  /* if_stmt  */
  YYSYMBOL_opt_else = 562,                 /* opt_else  */
  YYSYMBOL_elseif_item = 563,              /* elseif_item  */
  YYSYMBOL_elseif_list = 564,              /* elseif_list  */
  YYSYMBOL_opt_elseif_list = 565,          /* opt_elseif_list  */
  YYSYMBOL_control_stmt = 566,             /* control_stmt  */
  YYSYMBOL_guard_stmt = 567,               /* guard_stmt  */
  YYSYMBOL_transaction_mode = 568,         /* transaction_mode  */
  YYSYMBOL_begin_trans_stmt = 569,         /* begin_trans_stmt  */
  YYSYMBOL_rollback_trans_stmt = 570,      /* rollback_trans_stmt  */
  YYSYMBOL_commit_trans_stmt = 571,        /* commit_trans_stmt  */
  YYSYMBOL_proc_savepoint_stmt = 572,      /* proc_savepoint_stmt  */
  YYSYMBOL_savepoint_name = 573,           /* savepoint_name  */
  YYSYMBOL_savepoint_stmt = 574,           /* savepoint_stmt  */
  YYSYMBOL_release_savepoint_stmt = 575,   /* release_savepoint_stmt  */
  YYSYMBOL_echo_stmt = 576,                /* echo_stmt  */
  YYSYMBOL_alter_table_add_column_stmt = 577, /* alter_table_add_column_stmt  */
  YYSYMBOL_create_trigger_stmt = 578,      /* create_trigger_stmt  */
  YYSYMBOL_trigger_def = 579,              /* trigger_def  */
  YYSYMBOL_trigger_condition = 580,        /* trigger_condition  */
  YYSYMBOL_trigger_operation = 581,        /* trigger_operation  */
  YYSYMBOL_opt_of = 582,                   /* opt_of  */
  YYSYMBOL_trigger_action = 583,           /* trigger_action  */
  YYSYMBOL_opt_foreachrow = 584,           /* opt_foreachrow  */
  YYSYMBOL_opt_when_expr = 585,            /* opt_when_expr  */
  YYSYMBOL_trigger_stmts = 586,            /* trigger_stmts  */
  YYSYMBOL_trigger_stmt = 587,             /* trigger_stmt  */
  YYSYMBOL_trigger_select_stmt = 588,      /* trigger_select_stmt  */
  YYSYMBOL_trigger_insert_stmt = 589,      /* trigger_insert_stmt  */
  YYSYMBOL_trigger_delete_stmt = 590,      /* trigger_delete_stmt  */
  YYSYMBOL_trigger_update_stmt = 591,      /* trigger_update_stmt  */
  YYSYMBOL_enforcement_options = 592,      /* enforcement_options  */
  YYSYMBOL_enforce_strict_stmt = 593,      /* enforce_strict_stmt  */
  YYSYMBOL_enforce_normal_stmt = 594,      /* enforce_normal_stmt  */
  YYSYMBOL_enforce_reset_stmt = 595,       /* enforce_reset_stmt  */
  YYSYMBOL_enforce_push_stmt = 596,        /* enforce_push_stmt  */
  YYSYMBOL_enforce_pop_stmt = 597,         /* enforce_pop_stmt  */
  YYSYMBOL_keep_table_name_in_aliases_stmt = 598, /* keep_table_name_in_aliases_stmt  */
  YYSYMBOL_expr_macro_def = 599,           /* expr_macro_def  */
  YYSYMBOL_stmt_list_macro_def = 600,      /* stmt_list_macro_def  */
  YYSYMBOL_query_parts_macro_def = 601,    /* query_parts_macro_def  */
  YYSYMBOL_cte_tables_macro_def = 602,     /* cte_tables_macro_def  */
  YYSYMBOL_select_core_macro_def = 603,    /* select_core_macro_def  */
  YYSYMBOL_select_expr_macro_def = 604,    /* select_expr_macro_def  */
  YYSYMBOL_op_stmt = 605,                  /* op_stmt  */
  YYSYMBOL_ifdef = 606,                    /* ifdef  */
  YYSYMBOL_ifndef = 607,                   /* ifndef  */
  YYSYMBOL_elsedef = 608,                  /* elsedef  */
  YYSYMBOL_endif = 609,                    /* endif  */
  YYSYMBOL_ifdef_stmt = 610,               /* ifdef_stmt  */
  YYSYMBOL_ifndef_stmt = 611,              /* ifndef_stmt  */
  YYSYMBOL_macro_def_stmt = 612,           /* macro_def_stmt  */
  YYSYMBOL_opt_macro_args = 613,           /* opt_macro_args  */
  YYSYMBOL_macro_arg = 614,                /* macro_arg  */
  YYSYMBOL_macro_args = 615,               /* macro_args  */
  YYSYMBOL_opt_macro_formals = 616,        /* opt_macro_formals  */
  YYSYMBOL_macro_formals = 617,            /* macro_formals  */
  YYSYMBOL_macro_formal = 618,             /* macro_formal  */
  YYSYMBOL_macro_type = 619                /* macro_type  */
};
typedef enum yysymbol_kind_t yysymbol_kind_t;




#ifdef short
# undef short
#endif

/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
   <limits.h> and (if available) <stdint.h> are included
   so that the code can choose integer types of a good width.  */

#ifndef __PTRDIFF_MAX__
# include <limits.h> /* INFRINGES ON USER NAME SPACE */
# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
#  define YY_STDINT_H
# endif
#endif

/* Narrow types that promote to a signed type and that can represent a
   signed or unsigned integer of at least N bits.  In tables they can
   save space and decrease cache pressure.  Promoting to a signed type
   helps avoid bugs in integer arithmetic.  */

#ifdef __INT_LEAST8_MAX__
typedef __INT_LEAST8_TYPE__ yytype_int8;
#elif defined YY_STDINT_H
typedef int_least8_t yytype_int8;
#else
typedef signed char yytype_int8;
#endif

#ifdef __INT_LEAST16_MAX__
typedef __INT_LEAST16_TYPE__ yytype_int16;
#elif defined YY_STDINT_H
typedef int_least16_t yytype_int16;
#else
typedef short yytype_int16;
#endif

/* Work around bug in HP-UX 11.23, which defines these macros
   incorrectly for preprocessor constants.  This workaround can likely
   be removed in 2023, as HPE has promised support for HP-UX 11.23
   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
#ifdef __hpux
# undef UINT_LEAST8_MAX
# undef UINT_LEAST16_MAX
# define UINT_LEAST8_MAX 255
# define UINT_LEAST16_MAX 65535
#endif

#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
typedef __UINT_LEAST8_TYPE__ yytype_uint8;
#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
       && UINT_LEAST8_MAX <= INT_MAX)
typedef uint_least8_t yytype_uint8;
#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
typedef unsigned char yytype_uint8;
#else
typedef short yytype_uint8;
#endif

#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
typedef __UINT_LEAST16_TYPE__ yytype_uint16;
#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
       && UINT_LEAST16_MAX <= INT_MAX)
typedef uint_least16_t yytype_uint16;
#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
typedef unsigned short yytype_uint16;
#else
typedef int yytype_uint16;
#endif

#ifndef YYPTRDIFF_T
# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
#  define YYPTRDIFF_T __PTRDIFF_TYPE__
#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
# elif defined PTRDIFF_MAX
#  ifndef ptrdiff_t
#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  endif
#  define YYPTRDIFF_T ptrdiff_t
#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
# else
#  define YYPTRDIFF_T long
#  define YYPTRDIFF_MAXIMUM LONG_MAX
# endif
#endif

#ifndef YYSIZE_T
# ifdef __SIZE_TYPE__
#  define YYSIZE_T __SIZE_TYPE__
# elif defined size_t
#  define YYSIZE_T size_t
# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  define YYSIZE_T size_t
# else
#  define YYSIZE_T unsigned
# endif
#endif

#define YYSIZE_MAXIMUM                                  \
  YY_CAST (YYPTRDIFF_T,                                 \
           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
            ? YYPTRDIFF_MAXIMUM                         \
            : YY_CAST (YYSIZE_T, -1)))

#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))


/* Stored state numbers (used for stacks). */
typedef yytype_int16 yy_state_t;

/* State numbers in computations.  */
typedef int yy_state_fast_t;

#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(Msgid) Msgid
# endif
#endif


#ifndef YY_ATTRIBUTE_PURE
# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
# else
#  define YY_ATTRIBUTE_PURE
# endif
#endif

#ifndef YY_ATTRIBUTE_UNUSED
# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
# else
#  define YY_ATTRIBUTE_UNUSED
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YY_USE(E) ((void) (E))
#else
# define YY_USE(E) /* empty */
#endif

/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
# else
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
# endif
# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
    _Pragma ("GCC diagnostic pop")
#else
# define YY_INITIAL_VALUE(Value) Value
#endif
#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_END
#endif
#ifndef YY_INITIAL_VALUE
# define YY_INITIAL_VALUE(Value) /* Nothing. */
#endif

#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
# define YY_IGNORE_USELESS_CAST_BEGIN                          \
    _Pragma ("GCC diagnostic push")                            \
    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
# define YY_IGNORE_USELESS_CAST_END            \
    _Pragma ("GCC diagnostic pop")
#endif
#ifndef YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_END
#endif


#define YY_ASSERT(E) ((void) (0 && (E)))

#if 1

/* The parser invokes alloca or malloc; define the necessary symbols.  */

# ifdef YYSTACK_USE_ALLOCA
#  if YYSTACK_USE_ALLOCA
#   ifdef __GNUC__
#    define YYSTACK_ALLOC __builtin_alloca
#   elif defined __BUILTIN_VA_ARG_INCR
#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
#   elif defined _AIX
#    define YYSTACK_ALLOC __alloca
#   elif defined _MSC_VER
#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
#    define alloca _alloca
#   else
#    define YYSTACK_ALLOC alloca
#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
#     ifndef EXIT_SUCCESS
#      define EXIT_SUCCESS 0
#     endif
#    endif
#   endif
#  endif
# endif

# ifdef YYSTACK_ALLOC
   /* Pacify GCC's 'empty if-body' warning.  */
#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
#  ifndef YYSTACK_ALLOC_MAXIMUM
    /* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */
#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
#  endif
# else
#  define YYSTACK_ALLOC YYMALLOC
#  define YYSTACK_FREE YYFREE
#  ifndef YYSTACK_ALLOC_MAXIMUM
#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
#  endif
#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
       && ! ((defined YYMALLOC || defined malloc) \
             && (defined YYFREE || defined free)))
#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#   ifndef EXIT_SUCCESS
#    define EXIT_SUCCESS 0
#   endif
#  endif
#  ifndef YYMALLOC
#   define YYMALLOC malloc
#   if ! defined malloc && ! defined EXIT_SUCCESS
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined EXIT_SUCCESS
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* 1 */

#if (! defined yyoverflow \
     && (! defined __cplusplus \
         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
  yy_state_t yyss_alloc;
  YYSTYPE yyvs_alloc;
};

/* The size of the maximum gap between one aligned stack and the next.  */
# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)

/* The size of an array large to enough to hold all stacks, each with
   N elements.  */
# define YYSTACK_BYTES(N) \
     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
      + YYSTACK_GAP_MAXIMUM)

# define YYCOPY_NEEDED 1

/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */
# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
    do                                                                  \
      {                                                                 \
        YYPTRDIFF_T yynewbytes;                                         \
        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        Stack = &yyptr->Stack_alloc;                                    \
        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
      }                                                                 \
    while (0)

#endif

#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
/* Copy COUNT objects from SRC to DST.  The source and destination do
   not overlap.  */
# ifndef YYCOPY
#  if defined __GNUC__ && 1 < __GNUC__
#   define YYCOPY(Dst, Src, Count) \
      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
#  else
#   define YYCOPY(Dst, Src, Count)              \
      do                                        \
        {                                       \
          YYPTRDIFF_T yyi;                      \
          for (yyi = 0; yyi < (Count); yyi++)   \
            (Dst)[yyi] = (Src)[yyi];            \
        }                                       \
      while (0)
#  endif
# endif
#endif /* !YYCOPY_NEEDED */

/* YYFINAL -- State number of the termination state.  */
#define YYFINAL  89
/* YYLAST -- Last index in YYTABLE.  */
#define YYLAST   15922

/* YYNTOKENS -- Number of terminals.  */
#define YYNTOKENS  304
/* YYNNTS -- Number of nonterminals.  */
#define YYNNTS  316
/* YYNRULES -- Number of rules.  */
#define YYNRULES  998
/* YYNSTATES -- Number of states.  */
#define YYNSTATES  1926

/* YYMAXUTOK -- Last valid token kind.  */
#define YYMAXUTOK   538


/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex, with out-of-bounds checking.  */
#define YYTRANSLATE(YYX)                                \
  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
   : YYSYMBOL_YYUNDEF)

/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex.  */
static const yytype_int16 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,   298,     2,     2,     2,    67,    61,     2,
     299,   300,    65,    63,   303,    64,    71,    66,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,    70,   301,
      59,    40,    60,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,    72,     2,   302,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,    62,     2,    73,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    41,    42,    43,    44,    45,
      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
      56,    57,    58,    68,    69,    74,    75,    76,    77,    78,
      79,    80,    81,    82,    83,    84,    85,    86,    87,    88,
      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
      99,   100,   101,   102,   103,   104,   105,   106,   107,   108,
     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
     119,   120,   121,   122,   123,   124,   125,   126,   127,   128,
     129,   130,   131,   132,   133,   134,   135,   136,   137,   138,
     139,   140,   141,   142,   143,   144,   145,   146,   147,   148,
     149,   150,   151,   152,   153,   154,   155,   156,   157,   158,
     159,   160,   161,   162,   163,   164,   165,   166,   167,   168,
     169,   170,   171,   172,   173,   174,   175,   176,   177,   178,
     179,   180,   181,   182,   183,   184,   185,   186,   187,   188,
     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,
     199,   200,   201,   202,   203,   204,   205,   206,   207,   208,
     209,   210,   211,   212,   213,   214,   215,   216,   217,   218,
     219,   220,   221,   222,   223,   224,   225,   226,   227,   228,
     229,   230,   231,   232,   233,   234,   235,   236,   237,   238,
     239,   240,   241,   242,   243,   244,   245,   246,   247,   248,
     249,   250,   251,   252,   253,   254,   255,   256,   257,   258,
     259,   260,   261,   262,   263,   264,   265,   266,   267,   268,
     269,   270,   271,   272,   273,   274,   275,   276,   277,   278,
     279,   280,   281,   282,   283,   284,   285,   286,   287,   288,
     289,   290,   291,   292,   293,   294,   295,   296,   297
};

#if YYDEBUG
/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
static const yytype_int16 yyrline[] =
{
       0,   397,   397,   432,   433,   434,   435,   448,   452,   453,
     471,   472,   476,   479,   485,   506,   521,   522,   523,   526,
     537,   538,   539,   540,   541,   542,   543,   544,   545,   546,
     547,   548,   549,   550,   551,   552,   553,   554,   555,   556,
     557,   558,   559,   560,   561,   562,   563,   564,   565,   566,
     567,   568,   569,   570,   571,   572,   573,   574,   575,   576,
     577,   578,   579,   580,   581,   582,   583,   584,   585,   586,
     587,   588,   589,   590,   591,   592,   593,   594,   595,   596,
     597,   598,   599,   600,   601,   602,   603,   604,   605,   606,
     607,   608,   609,   610,   611,   612,   613,   614,   615,   616,
     617,   618,   619,   620,   624,   628,   629,   632,   633,   634,
     635,   636,   637,   638,   639,   640,   641,   642,   646,   650,
     654,   659,   660,   661,   665,   669,   673,   674,   675,   676,
     680,   681,   685,   686,   690,   691,   695,   696,   700,   701,
     705,   706,   710,   711,   715,   716,   719,   734,   735,   736,
     740,   746,   758,   759,   763,   764,   768,   769,   773,   774,
     775,   776,   777,   781,   782,   786,   787,   788,   789,   790,
     791,   795,   796,   800,   801,   805,   806,   810,   811,   815,
     816,   820,   821,   825,   826,   830,   831,   835,   836,   840,
     841,   842,   843,   844,   845,   849,   850,   851,   852,   856,
     857,   861,   869,   873,   880,   881,   885,   886,   887,   888,
     889,   893,   894,   898,   899,   900,   904,   905,   906,   907,
     911,   912,   913,   914,   915,   919,   920,   924,   925,   926,
     930,   933,   939,   944,   948,   955,   956,   960,   965,   966,
     970,   984,   985,   986,   987,   988,   989,   990,   991,   992,
     993,   994,   995,   996,   997,   998,   999,  1000,  1001,  1002,
    1003,  1004,  1005,  1006,  1007,  1008,  1009,  1010,  1011,  1012,
    1013,  1014,  1015,  1016,  1017,  1018,  1019,  1020,  1021,  1022,
    1023,  1024,  1025,  1026,  1027,  1028,  1029,  1030,  1031,  1032,
    1033,  1034,  1035,  1036,  1037,  1038,  1039,  1040,  1041,  1042,
    1043,  1044,  1045,  1046,  1047,  1048,  1049,  1053,  1054,  1055,
    1056,  1057,  1058,  1059,  1060,  1061,  1062,  1063,  1067,  1068,
    1069,  1077,  1078,  1082,  1083,  1087,  1088,  1092,  1093,  1097,
    1098,  1102,  1103,  1106,  1107,  1111,  1112,  1113,  1117,  1121,
    1122,  1123,  1124,  1125,  1126,  1127,  1128,  1129,  1130,  1131,
    1132,  1133,  1137,  1139,  1142,  1147,  1148,  1152,  1153,  1154,
    1155,  1156,  1157,  1158,  1159,  1160,  1164,  1165,  1166,  1167,
    1168,  1171,  1174,  1175,  1178,  1178,  1182,  1183,  1184,  1185,
    1186,  1190,  1194,  1195,  1199,  1200,  1204,  1205,  1206,  1207,
    1208,  1212,  1216,  1217,  1218,  1219,  1220,  1221,  1222,  1223,
    1224,  1225,  1229,  1230,  1233,  1236,  1237,  1238,  1239,  1243,
    1244,  1248,  1253,  1258,  1266,  1267,  1268,  1269,  1270,  1273,
    1279,  1280,  1281,  1282,  1283,  1284,  1285,  1286,  1287,  1288,
    1289,  1290,  1291,  1292,  1293,  1294,  1295,  1296,  1297,  1298,
    1299,  1300,  1301,  1302,  1303,  1304,  1305,  1306,  1307,  1308,
    1309,  1310,  1311,  1315,  1316,  1317,  1318,  1319,  1320,  1321,
    1322,  1323,  1324,  1325,  1326,  1327,  1328,  1329,  1330,  1331,
    1332,  1333,  1334,  1335,  1336,  1337,  1338,  1339,  1340,  1341,
    1342,  1343,  1344,  1345,  1346,  1347,  1348,  1349,  1350,  1351,
    1352,  1353,  1354,  1355,  1356,  1357,  1358,  1359,  1360,  1364,
    1365,  1366,  1367,  1368,  1369,  1370,  1371,  1372,  1373,  1374,
    1375,  1376,  1380,  1381,  1384,  1385,  1389,  1390,  1394,  1395,
    1399,  1400,  1404,  1405,  1409,  1410,  1411,  1412,  1416,  1418,
    1423,  1424,  1428,  1429,  1430,  1431,  1435,  1436,  1440,  1441,
    1442,  1446,  1447,  1451,  1452,  1453,  1458,  1463,  1465,  1467,
    1471,  1472,  1476,  1480,  1484,  1485,  1489,  1498,  1499,  1505,
    1508,  1514,  1522,  1523,  1529,  1530,  1531,  1532,  1536,  1547,
    1548,  1551,  1552,  1556,  1563,  1564,  1573,  1574,  1575,  1579,
    1580,  1581,  1582,  1583,  1587,  1592,  1600,  1601,  1602,  1603,
    1607,  1608,  1609,  1610,  1614,  1615,  1616,  1620,  1621,  1625,
    1626,  1630,  1634,  1635,  1639,  1643,  1644,  1648,  1649,  1653,
    1654,  1658,  1659,  1663,  1667,  1671,  1675,  1677,  1682,  1686,
    1690,  1694,  1695,  1699,  1700,  1704,  1705,  1709,  1710,  1714,
    1718,  1719,  1720,  1724,  1725,  1726,  1730,  1731,  1735,  1736,
    1740,  1741,  1745,  1749,  1750,  1754,  1755,  1759,  1760,  1761,
    1762,  1766,  1767,  1771,  1783,  1787,  1788,  1792,  1793,  1797,
    1798,  1802,  1803,  1807,  1811,  1812,  1816,  1817,  1818,  1819,
    1820,  1821,  1825,  1826,  1827,  1828,  1829,  1830,  1831,  1834,
    1841,  1842,  1846,  1847,  1851,  1855,  1861,  1870,  1871,  1873,
    1875,  1881,  1886,  1887,  1892,  1893,  1894,  1895,  1896,  1900,
    1901,  1902,  1903,  1904,  1905,  1906,  1910,  1911,  1912,  1916,
    1917,  1921,  1922,  1923,  1927,  1932,  1937,  1941,  1945,  1951,
    1954,  1955,  1957,  1959,  1965,  1966,  1970,  1971,  1972,  1976,
    1985,  1986,  1988,  1990,  1996,  2003,  2014,  2018,  2019,  2023,
    2024,  2026,  2028,  2033,  2036,  2042,  2045,  2048,  2053,  2054,
    2059,  2059,  2063,  2067,  2073,  2074,  2078,  2079,  2083,  2088,
    2093,  2094,  2098,  2099,  2102,  2106,  2108,  2110,  2112,  2117,
    2119,  2122,  2124,  2129,  2129,  2133,  2138,  2141,  2144,  2147,
    2150,  2153,  2156,  2162,  2164,  2169,  2171,  2176,  2177,  2178,
    2182,  2183,  2184,  2188,  2189,  2193,  2194,  2198,  2199,  2200,
    2204,  2205,  2206,  2207,  2211,  2212,  2213,  2217,  2218,  2219,
    2220,  2221,  2222,  2225,  2225,  2225,  2225,  2225,  2225,  2225,
    2229,  2230,  2231,  2232,  2236,  2237,  2241,  2242,  2246,  2247,
    2248,  2251,  2256,  2261,  2265,  2269,  2276,  2277,  2281,  2283,
    2286,  2290,  2294,  2298,  2302,  2306,  2310,  2314,  2315,  2319,
    2323,  2324,  2328,  2332,  2336,  2342,  2343,  2346,  2350,  2356,
    2360,  2364,  2368,  2372,  2373,  2377,  2378,  2381,  2381,  2384,
    2391,  2392,  2396,  2402,  2403,  2407,  2408,  2412,  2413,  2414,
    2415,  2416,  2417,  2420,  2424,  2425,  2426,  2427,  2431,  2432,
    2436,  2438,  2440,  2442,  2444,  2446,  2451,  2452,  2455,  2461,
    2462,  2466,  2471,  2473,  2478,  2479,  2483,  2488,  2496,  2509,
    2510,  2511,  2512,  2516,  2517,  2518,  2522,  2523,  2527,  2534,
    2535,  2539,  2540,  2544,  2545,  2549,  2550,  2551,  2552,  2556,
    2560,  2564,  2568,  2572,  2573,  2574,  2575,  2576,  2577,  2578,
    2579,  2580,  2581,  2582,  2583,  2584,  2585,  2586,  2587,  2591,
    2595,  2599,  2603,  2607,  2611,  2614,  2625,  2637,  2649,  2661,
    2673,  2684,  2686,  2688,  2692,  2695,  2698,  2701,  2705,  2707,
    2712,  2714,  2719,  2723,  2727,  2731,  2735,  2739,  2746,  2747,
    2751,  2752,  2753,  2754,  2755,  2756,  2760,  2761,  2765,  2766,
    2770,  2771,  2774,  2778,  2779,  2780,  2781,  2782,  2783
};
#endif

/** Accessing symbol of state STATE.  */
#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])

#if 1
/* The user-facing name of the symbol whose (internal) number is
   YYSYMBOL.  No bounds checking.  */
static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;

/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
static const char *const yytname[] =
{
  "\"end of file\"", "error", "\"invalid token\"", "ID", "QID",
  "\"TRUE\"", "\"FALSE\"", "STRLIT", "CSTRLIT", "BLOBLIT", "INTLIT",
  "\"BOOL\"", "AT_DUMMY_NULLABLES", "AT_DUMMY_DEFAULTS", "LONGLIT",
  "REALLIT", "STMT_LIST_MACRO", "EXPR_MACRO", "QUERY_PARTS_MACRO",
  "CTE_TABLES_MACRO", "SELECT_CORE_MACRO", "SELECT_EXPR_MACRO",
  "UNION_ALL", "UNION", "INTERSECT", "EXCEPT", "ADD_EQ", "SUB_EQ",
  "MUL_EQ", "DIV_EQ", "MOD_EQ", "OR_EQ", "AND_EQ", "LS_EQ", "RS_EQ", "OR",
  "AND", "NOT", "BETWEEN", "NOT_BETWEEN", "'='", "LIKE", "NOT_LIKE",
  "GLOB", "NOT_GLOB", "MATCH", "NOT_MATCH", "REGEXP", "NOT_REGEXP", "IN",
  "NOT_IN", "IS_NOT", "IS", "IS_TRUE", "IS_FALSE", "IS_NOT_TRUE",
  "IS_NOT_FALSE", "ISNULL", "NOTNULL", "'<'", "'>'", "'&'", "'|'", "'+'",
  "'-'", "'*'", "'/'", "'%'", "JEX1", "JEX2", "':'", "'.'", "'['", "'~'",
  "COLLATE", "UMINUS", "\":=\"", "\"||\"", "\"==\"", "\">=\"", "\"<=\"",
  "\"<<\"", "\"<>\"", "\"!=\"", "\">>\"", "EXCLUDE_GROUP",
  "EXCLUDE_CURRENT_ROW", "EXCLUDE_TIES", "EXCLUDE_NO_OTHERS",
  "CURRENT_ROW", "UNBOUNDED", "PRECEDING", "FOLLOWING", "CREATE", "DROP",
  "TABLE", "WITHOUT", "ROWID", "PRIMARY", "KEY", "\"NULL\"", "DEFAULT",
  "CHECK", "AT_DUMMY_SEED", "VIRTUAL", "AT_EMIT_GROUP", "AT_EMIT_ENUMS",
  "AT_EMIT_CONSTANTS", "OBJECT", "TEXT", "BLOB", "LONG_", "INT_",
  "INTEGER", "LONG_INT", "LONG_INTEGER", "REAL", "ON", "UPDATE", "CASCADE",
  "ON_CONFLICT", "DO", "NOTHING", "DELETE", "INDEX", "FOREIGN",
  "REFERENCES", "CONSTRAINT", "UPSERT", "STATEMENT", "CONST", "INSERT",
  "INTO", "VALUES", "VIEW", "SELECT", "QUERY_PLAN", "EXPLAIN", "OVER",
  "WINDOW", "FILTER", "PARTITION", "RANGE", "ROWS", "GROUPS", "AS", "CASE",
  "WHEN", "FROM", "THEN", "ELSE", "END", "LEFT", "SWITCH", "OUTER", "JOIN",
  "WHERE", "GROUP", "BY", "ORDER", "ASC", "NULLS", "FIRST", "LAST", "DESC",
  "INNER", "AUTOINCREMENT", "DISTINCT", "LIMIT", "OFFSET", "TEMP",
  "TRIGGER", "IF", "ALL", "CROSS", "USING", "RIGHT", "AT_EPONYMOUS",
  "HIDDEN", "UNIQUE", "HAVING", "SET", "LET", "TO", "DISTINCTROW", "ENUM",
  "FUNC", "FUNCTION", "PROC", "PROCEDURE", "INTERFACE", "OUT", "INOUT",
  "CURSOR", "DECLARE", "VAR", "TYPE", "FETCH", "LOOP", "LEAVE", "CONTINUE",
  "ENCODE", "CONTEXT_COLUMN", "CONTEXT_TYPE", "OPEN", "CLOSE", "ELSE_IF",
  "WHILE", "CALL", "TRY", "CATCH", "THROW", "RETURN", "SAVEPOINT",
  "ROLLBACK", "COMMIT", "TRANSACTION", "RELEASE", "ARGUMENTS",
  "TYPE_CHECK", "CAST", "WITH", "RECURSIVE", "REPLACE", "IGNORE", "ADD",
  "COLUMN", "AT_COLUMNS", "RENAME", "ALTER", "AT_ECHO", "AT_CREATE",
  "AT_RECREATE", "AT_DELETE", "AT_SCHEMA_UPGRADE_VERSION",
  "AT_PREVIOUS_SCHEMA", "AT_SCHEMA_UPGRADE_SCRIPT", "AT_ID", "AT_RC",
  "AT_PROC", "AT_FILE", "AT_LINE", "AT_MACRO_LINE", "AT_MACRO_FILE",
  "AT_TEXT", "AT_ATTRIBUTE", "AT_SENSITIVE", "DEFERRED", "AT_TMP",
  "NOT_DEFERRABLE", "DEFERRABLE", "IMMEDIATE", "EXCLUSIVE", "RESTRICT",
  "ACTION", "INITIALLY", "NO", "BEFORE", "AFTER", "INSTEAD", "OF",
  "FOR_EACH_ROW", "EXISTS", "RAISE", "FAIL", "ABORT", "AT_ENFORCE_STRICT",
  "AT_ENFORCE_NORMAL", "AT_ENFORCE_RESET", "AT_ENFORCE_PUSH",
  "AT_ENFORCE_POP", "AT_BEGIN_SCHEMA_REGION", "AT_END_SCHEMA_REGION",
  "AT_OP", "AT_DECLARE_SCHEMA_REGION", "AT_DECLARE_DEPLOYABLE_REGION",
  "AT_SCHEMA_AD_HOC_MIGRATION", "PRIVATE", "AT_KEEP_TABLE_NAME_IN_ALIASES",
  "AT_MACRO", "EXPR", "STMT_LIST", "QUERY_PARTS", "CTE_TABLES",
  "SELECT_CORE", "SELECT_EXPR", "SIGN_FUNCTION", "CURSOR_HAS_ROW",
  "AT_UNSUB", "BEGIN_INCLUDE", "END_INCLUDE", "AT_IFDEF", "AT_IFNDEF",
  "AT_ELSE", "AT_ENDIF", "RETURNING", "BEGIN_", "FOR", "'!'", "'('", "')'",
  "';'", "']'", "','", "$accept", "program", "top_level_stmts",
  "include_section", "include_stmts", "opt_stmt_list", "macro_ref",
  "stmt_list", "stmt", "expr_stmt", "any_stmt", "explain_stmt",
  "opt_query_plan", "explain_target", "previous_schema_stmt",
  "schema_upgrade_script_stmt", "schema_upgrade_version_stmt", "set_stmt",
  "let_stmt", "const_stmt", "version_attrs_opt_recreate",
  "opt_delete_plain_attr", "opt_version_attrs", "version_attrs",
  "opt_delete_version_attr", "drop_table_stmt", "drop_view_stmt",
  "drop_index_stmt", "drop_trigger_stmt", "create_virtual_table_stmt",
  "opt_module_args", "create_table_prefix_opt_temp", "create_table_stmt",
  "opt_temp", "opt_if_not_exists", "opt_no_rowid", "opt_vtab_flags",
  "col_key_list", "col_key_def", "check_def", "shape_exprs", "shape_expr",
  "shape_def", "shape_def_base", "sql_name", "misc_attr_key",
  "cql_attr_key", "misc_attr_value_list", "misc_attr_value", "misc_attr",
  "misc_attrs", "col_def", "pk_def", "opt_conflict_clause",
  "conflict_clause", "opt_fk_options", "fk_options", "fk_on_options",
  "fk_action", "fk_deferred_options", "fk_initial_state", "fk_def",
  "fk_target_options", "unq_def", "opt_unique", "indexed_column",
  "indexed_columns", "create_index_stmt", "name", "loose_name",
  "loose_name_or_type", "opt_sql_name", "name_list", "sql_name_list",
  "opt_name_list", "opt_sql_name_list", "cte_binding_list", "cte_binding",
  "col_attrs", "version_annotation", "opt_kind", "data_type_numeric",
  "data_type_any", "not_null", "data_type_with_options", "str_literal",
  "str_chain", "str_leaf", "num_literal", "const_expr", "any_literal",
  "text_args", "text_arg", "raise_expr", "opt_distinct", "simple_call",
  "call", "basic_expr", "math_expr", "expr", "case_list", "arg_expr",
  "arg_exprs", "arg_list", "opt_expr_list", "expr_list", "shape_arguments",
  "column_calculation", "col_calcs", "col_calc", "cte_tables", "cte_decl",
  "shared_cte", "cte_table", "with_prefix", "with_select_stmt",
  "select_nothing_stmt", "select_stmt", "select_stmt_no_with",
  "select_core_list", "values", "select_core", "compound_operator",
  "window_func_inv", "opt_filter_clause", "window_name_or_defn",
  "window_defn", "opt_frame_spec", "frame_type", "frame_exclude",
  "frame_boundary_opts", "frame_boundary_start", "frame_boundary_end",
  "frame_boundary", "opt_partition_by", "opt_select_window",
  "window_clause", "window_name_defn_list", "window_name_defn",
  "region_spec", "region_list", "declare_schema_region_stmt",
  "declare_deployable_region_stmt", "begin_schema_region_stmt",
  "end_schema_region_stmt", "schema_unsub_stmt",
  "schema_ad_hoc_migration_stmt", "emit_enums_stmt", "emit_group_stmt",
  "emit_constants_stmt", "opt_from_query_parts", "opt_where",
  "opt_groupby", "groupby_list", "groupby_item", "opt_asc_desc",
  "opt_nullsfirst_nullslast", "opt_having", "opt_orderby", "orderby_list",
  "orderby_item", "opt_limit", "opt_offset", "select_opts",
  "select_expr_list", "select_expr", "opt_as_alias", "as_alias",
  "query_parts", "table_or_subquery_list", "join_clause",
  "join_target_list", "table_or_subquery", "join_type", "join_target",
  "opt_join_cond", "join_cond", "table_function", "create_view_stmt",
  "delete_stmt", "delete_stmt_plain", "opt_insert_dummy_spec",
  "dummy_modifier", "insert_stmt_type", "opt_column_spec", "column_spec",
  "from_shape", "insert_stmt_plain", "returning_suffix", "insert_stmt",
  "insert_list_item", "insert_list", "basic_update_stmt", "update_stmt",
  "update_stmt_plain", "update_entry", "update_list", "upsert_stmt",
  "upsert_stmt_plain", "update_cursor_stmt", "conflict_target", "function",
  "declare_out_call_stmt", "declare_enum_stmt", "enum_values",
  "enum_value", "declare_const_stmt", "declare_group_stmt",
  "simple_variable_decls", "const_values", "const_value",
  "declare_select_func_stmt", "declare_func_stmt", "procedure",
  "declare_proc_no_check_stmt", "declare_proc_stmt",
  "declare_interface_stmt", "create_proc_stmt", "inout", "typed_name",
  "typed_names", "func_param", "func_params", "param", "params",
  "declare_value_cursor", "row_source", "declare_forward_read_cursor_stmt",
  "declare_fetched_value_cursor_stmt", "declare_type_stmt",
  "declare_vars_stmt", "call_stmt", "for_stmt", "while_stmt",
  "switch_stmt", "switch_case", "switch_cases", "loop_stmt", "leave_stmt",
  "return_stmt", "rollback_return_stmt", "commit_return_stmt",
  "throw_stmt", "trycatch_stmt", "continue_stmt", "fetch_stmt",
  "fetch_values_stmt", "expr_names", "expr_name", "fetch_call_stmt",
  "close_stmt", "out_stmt", "out_union_stmt",
  "out_union_parent_child_stmt", "child_results", "child_result",
  "if_ending", "if_stmt", "opt_else", "elseif_item", "elseif_list",
  "opt_elseif_list", "control_stmt", "guard_stmt", "transaction_mode",
  "begin_trans_stmt", "rollback_trans_stmt", "commit_trans_stmt",
  "proc_savepoint_stmt", "savepoint_name", "savepoint_stmt",
  "release_savepoint_stmt", "echo_stmt", "alter_table_add_column_stmt",
  "create_trigger_stmt", "trigger_def", "trigger_condition",
  "trigger_operation", "opt_of", "trigger_action", "opt_foreachrow",
  "opt_when_expr", "trigger_stmts", "trigger_stmt", "trigger_select_stmt",
  "trigger_insert_stmt", "trigger_delete_stmt", "trigger_update_stmt",
  "enforcement_options", "enforce_strict_stmt", "enforce_normal_stmt",
  "enforce_reset_stmt", "enforce_push_stmt", "enforce_pop_stmt",
  "keep_table_name_in_aliases_stmt", "expr_macro_def",
  "stmt_list_macro_def", "query_parts_macro_def", "cte_tables_macro_def",
  "select_core_macro_def", "select_expr_macro_def", "op_stmt", "ifdef",
  "ifndef", "elsedef", "endif", "ifdef_stmt", "ifndef_stmt",
  "macro_def_stmt", "opt_macro_args", "macro_arg", "macro_args",
  "opt_macro_formals", "macro_formals", "macro_formal", "macro_type", YY_NULLPTR
};

static const char *
yysymbol_name (yysymbol_kind_t yysymbol)
{
  return yytname[yysymbol];
}
#endif

#define YYPACT_NINF (-1757)

#define yypact_value_is_default(Yyn) \
  ((Yyn) == YYPACT_NINF)

#define YYTABLE_NINF (-852)

#define yytable_value_is_error(Yyn) \
  0

/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */
static const yytype_int16 yypact[] =
{
      79,    60,  -157,   308, 15541, 15541,   150, -1757,  -129,   107,
     155, -1757,    30,  3144,   204,   204, -1757, -1757, 15541, 15541,
    -117, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757,   -92, -1757,   -87, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757,   226, -1757, -1757,   -40, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757,  6893,   -65,   -31,  6893,  6893,
   -1757,  6893,   848,   387, -1757, 15541, 15541, 15541, -1757, -1757,
   -1757, -1757, -1757, 11640,   133,  8469,   122,    13,   608,  1068,
      23,  5573, -1757,  6893,  6893, -1757, 13786, 13786, -1757, -1757,
   15541, 13981, 15541, 10080, 15541, 15541, 15541,   144, -1757, -1757,
   15541,  6893, 10470,   265, -1757, -1757, 14176,   276,    83, 14371,
      70,    93,  8665,   270,   319, 15541,   149, -1757, -1757, -1757,
   -1757,   200, -1757, -1757, -1757,   202,   224,   237,  1760,  1760,
   -1757, -1757, -1757, 15541, -1757,  1028, 15541, 15541,   184, -1757,
     253,   260,   135,  6893,  3970, -1757, -1757,   243, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
     399, -1757, -1757,   281,   285, -1757, -1757,   414, -1757, -1757,
   -1757, -1757,   453, -1757,   538, 15838,  2724,     6, -1757, -1757,
   -1757, -1757,   455,   454, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757,   327, 13786,   -21, -1757,
   -1757,   327, -1757,   327, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, 10665, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757,   320,   363,   390,
     429,   444,   461, -1757, -1757,   197,   800,   197,    41,   581,
      42,   613, -1757,  6893,  6893,   473,   485, -1757, -1757, 15838,
     528,   528, -1757, -1757, -1757,   641, -1757, -1757,   379,   636,
   10470, 11835, 12030, 12225, 12420,   490, -1757, -1757, -1757, -1757,
   -1757, 15541,   631, -1757, 13786,  6893,   737,   355, -1757,  5837,
   -1757, -1757, -1757, -1757, -1757,  6101, -1757,  1153,   824,  6893,
    2372,   484,  2134,  2074,   134,   754,   533, 14566, -1757,    43,
     678,   328, 15541, 15541, -1757, -1757, 15541,   629,   537,   -28,
    1813, 10470, 10470,  1813,  1813,   -22, 15541,   546, -1757,  1374,
   -1757,   544,   635, -1757, -1757, -1757, 14761, -1757,   667, -1757,
   -1757, 14176, -1757,  6893,  6893,  9449,   629, -1757,   552, -1757,
      99,   551, -1757, 13786,   553,   852,   414,  6893,    48,   372,
     823, -1757,   680,   773,   723,   775,   759,   755,   720,   328,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,   835,
     828,   840,   835,   835,   481,   835,   835,   835,   835,   835,
     839,   611, -1757,   846,   742,   744,   699,   922, -1757,   409,
   13786,   321, -1757, -1757, -1757,   718,   683,   165,   735,   171,
     -58, -1757,   898, 13786,   528, -1757,  9645,  7157,   871,  2840,
   12615,  5837,  1813,  6893,  6893,  6893,  6893,  6893,  6893,  6893,
    6893,  6893,  6893,  6893,   647,   649,  6893,  6893, -1757, -1757,
   -1757, -1757, -1757, -1757,  6893,  6893,  6893,  6893,  6893,  6893,
    6893,  6893,  6893, 15541,  6893,  6893,  6893,  6893,  6893,  6893,
    6893,  6893,  6893,  6893,  6893,  6893,  6893,  6893,  6893,  6893,
    6893,  6893,  6893,  6893, 13786,   133,   270, -1757,   327,   -21,
     327,   327,   795,   790, -1757, -1757, -1757, -1757,   171,  6101,
   -1757,     3,   665, -1757, -1757, -1757,   669,   670,  6893,   412,
    8861,  9449,   171,  6101, -1757, -1757,   228, -1757,   228, -1757,
    7685,   664, 15541,  7685, -1757, 15541,   673,   682,  2724,   689,
    3706, -1757,  5837,  5837,    17, -1757,   399,   399,   399,   684,
     728, -1757,   730, -1757,   731, -1757,   732, -1757, 15541,   -47,
    9057,   845,   789,  6893,   865,   870,   872,   876,   877, 14956,
    2724, -1757,   700,   711,   717,  9885, -1757,   869,   719,   387,
     804,   374, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757,   -40,   721,  2309,   493,  6893, -1757,
    6893,   890,   498,   336,   813,   814, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757,  5837,  6893,   836,  6893, 12810, 10470, -1757,
     875,  8077,   884,  3442, -1757,   734, 15541, 15541,   738,   262,
     739, -1757, 13786,    56,  1813,    50, -1757,  -111,  -104, -1757,
   -1757, 15541,  6893, 12810,   892,   909,   321,   321,  5837,   321,
   14176, -1757, 15151, -1757,  2449,  2468, -1757,   -55, 13005,  9253,
     743,  9449,   819,    86,   746,   749,   750,   752,   753,   757,
     758,   762,  1016, -1757, -1757, -1757,   941, -1757, -1757,   938,
   -1757, 15541, -1757, 10470, 15541, -1757, -1757, -1757,   835,   835,
   -1757, -1757, -1757, -1757, -1757, -1757, 10470,  6893, 10470, 15541,
   15541,   763,   245,   768,   769,   783,   784,   785,   786,   787,
     937, -1757,   412, -1757,   968, -1757,   833,   810,  5837,   971,
   -1757, -1757, -1757, -1757,  1813,   815,  5837,   285, -1757, -1757,
   -1757,  2724,   811, -1757,   820, -1757,  1042,  2846, 15791,  3671,
    3671,  3671,  3671,  3671,  3671,  3671,  3671,  3671,  3970,  3970,
    3671,  3671,   914,   914,   841,   841,   587,   587,   589,   589,
     589, -1757,  1043,  3671,   914,   914,   841,  3671,  3671,   841,
    2724,  2724,  2724,  2724,  2724,  2724,  2724,  2724,  2724,  1080,
   -1757,  2724, -1757, -1757, -1757, -1757,  6893,  6893,   952, -1757,
   -1757,   990,  3970,   268,  6893,  1005,   321, 10860,  1939,   432,
    7881, 13200, 13200,   830,   976, -1757, -1757,   633, 13200,   979,
     980,   981,   853,   853,   881,   881,  7685, -1757,   831, -1757,
   -1757, -1757, -1757,   834, -1757, -1757,  6893, -1757,   847,   862,
     864,   868,   412,  2724,   873,   861, -1757,   874,   878,  1131,
     997, 13786, 13786, 13786, 13786, 10860, 13786, 13786, 13786, 13786,
   -1757,  6893,  1022, 12810,  1132,  1135,   879,   869,  6893, -1757,
   -1757,  2724, -1757, -1757, -1757, -1757, -1757,  1136,  1136,  5837,
     880, 11250, 13786, -1757, -1757, -1757,  8861,   845,  6101, -1757,
    6893,  6893, -1757,  2160,   258,  1030,  1033,   412, -1757,   498,
   -1757,   982,   883,  2724, 15541,  2724, 13786, -1757,  1813,  1136,
     886,   894,   629, 12810, -1757,   972, -1757,   629, -1757,  2724,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, 13396,   893,   -86,
     527,   899, 12810, -1757,  8273,  1049,  3442, -1757, -1757,  1102,
      52, -1757,   959,  1104, 10860,  1108, 10860, -1757,  9885,  1110,
     911,   916, -1757,   919, 11055,  1110,  1069,  1071,   923,  1073,
   -1757, 14176, -1757,  1813,  1813, 15541, -1757,   925,   926,    48,
   -1757,    49, -1757,  1001,   931, -1757, -1757, -1757, -1757, -1757,
    6893, -1757,  6893,  6893,  1139,   286, -1757,  1171, 10275,    55,
   -1757, -1757, 10275,   940, 10275,   964,   943, -1757, -1757, 15541,
   -1757, 15541, 15541, 15541, 15541, 15541, 15541, 15541, -1757,  1040,
     121,  4253, -1757,   139,   950,  1094,   455,  1180,   956,   958,
    5837, -1757, -1757,  6893,  6893,   960, -1757,   962,   963,   966,
    1715, -1757,   961,  2724,  6893, -1757, -1757, -1757,  1110, 13591,
    1110,  1110,   965,   967,  1715,   213,  1118, -1757, -1757, -1757,
   -1757,  1813,  1136, 13786,   970,   974, -1757, -1757,   977,   985,
     992,  1084, -1757, -1757,  5837, -1757,  1116, -1757, -1757,  1126,
    8861, -1757,  1127,   582, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757,   994,   978,   993, -1757, -1757,  6101,   171,  8861,
    9449,   437, -1757,  3706,  1157,  1157,  1036,  1262,  1128,   -37,
     495,  1074,  1184,  1002, -1757, -1757, -1757, -1757, -1757, 11445,
   -1757,  1004,  1006,  6893,  1009, 13786,   845,  2724, -1757, -1757,
   -1757,    13, 12810, -1757,   192,  1013,  1011, -1757, -1757,  1152,
   -1757,  2372,  2229, -1757,  6893,   440,   498,   482, -1757,  6893,
     982, -1757,  1190,  1265, -1757, -1757, -1757, 12810, -1757,  1167,
   -1757,  1307,  1045, -1757, -1757, 13786,  1046,  1047, -1757, 15541,
    1245, 10860, 15541, 13786,  1197,  1048, 15541,  1051, 12810, -1757,
     629,  2724, -1757, -1757, -1757, -1757,  1519,    72,  1052,  1054,
   -1757, -1757,  1056, -1757,  1058, -1757,  6893, -1757, -1757,  1059,
   15541,  1060,  1060, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
    1061,  1063, 15346,  1065,  1057, -1757, -1757,  1066,  1070,  1075,
      30,  6893,   849,  1044,  1072,  1267, -1757, -1757, -1757, -1757,
    1312,  1228,  1317,  1319,  1235, -1757,  1236, -1757, 15541,  1079,
      21,  1085,  1087,  1088,  1089,  1090,  1093,  1091,   321,  1290,
    6365,  1095,  1124,  1294,  1097,  1295, 13786,  1099,  1111,  1109,
   -1757, -1757, 13786, -1757, -1757, -1757, -1757,  1157,  6893,   770,
    7157,  3706, -1757, -1757,  3671,  3671, -1757, -1757, -1757, -1757,
    1253,  1253, -1757,  6893,  2724, -1757, -1757, -1757,  6893,   845,
   -1757, 13786, -1757, -1757, -1757, -1757, -1757,  1813, 10860,  1120,
   13200, 13200, -1757, 15541,  1117, -1757, -1757, -1757,  1115,  8861,
   -1757, -1757,  7685, -1757,  1119,  1121,  1122,  1125, -1757, -1757,
    1129, -1757, -1757,  1243,  1164, 15541,    48, 15541, -1757, -1757,
    1169,    40,  1138, -1757, 13786,  1134,  1140, -1757, -1757,  2724,
    5837, -1757,   455, -1757,  1141, 13786, -1757, -1757, 12810,  1269,
    1258, -1757, -1757, -1757, -1757,   396, -1757, -1757,  2360, -1757,
     321,  1289,  6893, -1757,  1143,   629, -1757, -1757, -1757, 13396,
    1405,  1147,  1145,    89,  1151,  1412,  1261, -1757,   527,  1415,
    1156,  1154, -1757,  1159, -1757,  1813, -1757, -1757, 10860,  1794,
     -44,  6893, -1757,  5837,  1060, -1757, -1757, -1757, -1757, 15541,
   -1757, -1757, 15541, -1757, -1757, -1757, -1757,  1160, -1757, -1757,
   -1757, -1757, 10470, 10470, -1757, -1757, 10470, 10470, -1757, 15541,
   15541, -1757,  1162,  1165,  1166,  1172,  1174,  1177,  1170,  1326,
    4781,  1163,  1291, -1757, -1757,  1181,  6893,  1183,    29,  1366,
    6893,  1383,   139,  1813, -1757, -1757, -1757, -1757, -1757,  1185,
    4517, -1757,  1186,   539, -1757, -1757, -1757, -1757, -1757, -1757,
    1306, -1757, -1757,   321, -1757, -1757, -1757, -1757,     0, -1757,
   -1757, -1757, -1757, -1757,   845, -1757, -1757,  1191,  1074,  1189,
   -1757,  1210, -1757, -1757,  1375, -1757,  1192,   321,  5837,  1193,
     790, -1757, -1757, -1757,  6893,  6893,  1355,   336, -1757,  1323,
   -1757,  2724, 15541, -1757, -1757,  6893, -1757, 15541, 12810, -1757,
     108,  1455, -1757,  6893, -1757, 15541, -1757, -1757, -1757,  1813,
   -1757,  1281,    65, 12810,  1302,  1199, -1757, -1757, -1757, -1757,
    1440, -1757, -1757, -1757,  1201,  1204, 15541, 15541, 15541, 15541,
   15541, 15541,  1296, -1757,  6629,  1212,  1511, -1757, -1757,  6893,
    1522, 13786,  1414,  1419,  1215,  1220,  1221,  1423,   697, -1757,
    1636, -1757,  5045, -1757,  1432,  2648,   692, -1757, -1757, -1757,
   -1757, 13786,  1373,  6893,  1226, -1757, -1757,  1229,  7421,  1386,
   -1757,  1387, 15541, -1757, 13786,  6893,  1377,  1234,   869, -1757,
    2724, -1757,  1256,  2724, 15541, -1757, -1757, -1757, -1757,  1260,
    2724, -1757,  1263, 12810, -1757,  2724, -1757, -1757, -1757,  1266,
   12810,  1264,   774,  1110, -1757, -1757, -1757,  1270,  1272, -1757,
    1271,  1276,  1277,  1279,  1280,  1283,   321,  1288,  1590, -1757,
   -1757,  1292, -1757,  1293,  1268,  1297,  6893,  6893,  1441, -1757,
    1138,   -69,  1138, -1757, -1757, 15541,  1470,   736,  1298, 13786,
    1636,  1441,  1138,  1138,  1636,  1636, -1757,  1441, -1757,  1479,
    2551,  1553, -1757, -1757, -1757, -1757, -1757, -1757, -1757,   869,
   -1757,  2724, 15541, -1757,  1498,  1299,  1301,    48, -1757,  1333,
    1303, -1757, -1757,   845,  6893,  1459, -1757,  1305,  1460, -1757,
    1309, 12810,  1310, -1757,  1593,  1599, -1757, -1757,   657, -1757,
   15541, -1757, -1757, -1757, -1757, -1757,  1462, -1757, -1757,  1441,
    1488,  6893, 13786,  1337,  1652,   415, -1757, -1757,   275, -1757,
   15541, -1757,   275,  1636,  1441,   881,   881,  1636,  1636,  1636,
    6893,  1340, -1757,  1636,  1636,  1636, -1757, -1757,  1636, -1757,
   -1757, -1757,  5309,   845,  1342,  1343, -1757,   139,  1074, -1757,
   -1757,  1497,   845,   455, -1757,  1347, 15541, 15541, -1757,  1348,
    1472, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757,  1439, -1757, -1757,  1350,  1351,  1441, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757,  1354, -1757, -1757,  1407,  1636,
    1636, -1757, -1757, -1757,  1663, 13786, -1757, -1757, -1757, -1757,
   -1757,  1563,  2573, -1757, -1757, -1757, -1757,  1361, -1757,  6893,
    1371,  1074,   790, -1757, -1757, -1757,  1493,  1453, -1757,  1441,
    1488, -1757,  1438,  1636, -1757, -1757, -1757,  1636,  1376, -1757,
   -1757, -1757,  1074,  2724,   726, -1757, -1757,  1485, -1757, -1757,
   -1757, -1757, -1757, -1757,     1, -1757,    15, -1757, -1757,   327,
   -1757, -1757,  1556,   726,  1403,  1408,  1411,  1413, -1757,   297,
    1458,  1458, -1757, -1757,   499, -1757,   327, -1757, -1757, -1757,
   -1757, -1757, -1757,    -7,    -7,   143, -1757, -1757, -1757, -1757,
     696, -1757,  1454,  1598,  1601, -1757, -1757, -1757, -1757, -1757,
    1596,  1602,    -7,    -7, -1757, -1757
};

/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
   Performed when YYTABLE does not specify something else to do.  Zero
   means the default is an error.  */
static const yytype_int16 yydefact[] =
{
     199,     0,     0,   199,     0,     0,     0,     2,     8,   199,
     199,    14,   199,     0,   199,   199,    17,    18,     0,     0,
       0,   241,   283,   269,   254,   261,   298,   306,   292,   278,
     256,   305,   300,   252,   259,   274,   287,   296,   277,   304,
     264,   282,   286,   270,   281,   247,   280,   268,   279,   260,
     250,   299,   302,   271,   303,   267,   262,   293,   301,   288,
     290,   272,   244,   253,   289,   246,     0,   258,     0,   257,
     273,   263,   291,   243,   275,   251,   245,   276,   266,   242,
     284,   265,   297,   285,   255,   294,   295,   964,   965,     1,
       9,   199,    15,   200,   241,   421,   389,   390,   384,   385,
     401,   386,   310,   387,   388,     0,     0,     0,     0,     0,
     423,     0,   254,   261,   394,   327,   327,     0,   315,   314,
     312,   311,   313,     0,   259,     0,     0,     0,   647,   264,
       0,     0,   317,     0,     0,   316,   309,     0,   773,   774,
       0,     0,     0,     0,     0,   303,   267,     0,   842,   849,
       0,     0,   308,   199,   846,   843,   293,   890,   897,   288,
       0,     0,     0,   290,   246,     0,     0,   118,   119,   424,
     399,     0,   396,   397,   398,     0,     0,     0,     0,     0,
     951,   952,   953,     0,   614,     0,     0,     0,     0,   954,
       0,     0,   884,     0,     0,   422,    21,     0,    66,    82,
      92,    93,    94,    75,    28,    53,    55,    52,    54,    35,
     154,    32,    30,   420,     0,   392,   381,   382,   393,   428,
     427,   432,   414,   430,   453,   499,    19,     0,   554,    67,
      89,   555,   638,   557,   431,    46,    36,    22,    60,    91,
      90,    57,    58,    59,    34,    51,   687,     0,   720,    73,
      99,   730,   100,   739,    98,    42,    37,    38,    39,    41,
      40,     0,    43,    44,    45,    31,   830,    48,    49,    50,
      47,    24,   102,   101,    95,    76,    74,    85,    86,    26,
      96,    97,    29,    69,    70,    68,    25,    79,    80,    81,
      72,    71,    23,    87,    27,    83,    88,    84,    56,    20,
      33,    65,    61,    64,    63,    62,   103,     0,     0,     0,
       0,     0,     0,    78,    77,     0,   199,     0,     0,   185,
       0,   183,     7,     0,     0,    12,     0,   309,   308,   472,
     409,   409,   470,   469,   471,     0,   153,   236,     0,     0,
       0,     0,     0,     0,     0,   323,   328,   619,   618,   620,
     182,     0,     0,   181,     0,     0,     0,     0,   699,   726,
     563,   553,   649,   648,   650,     0,   106,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   860,     0,
       0,     0,     0,     0,   750,   751,     0,     0,   325,   181,
       0,     0,     0,     0,     0,   706,     0,     0,   859,     0,
     307,     0,     0,   899,   900,   901,     0,   844,   891,   845,
     896,   293,   902,     0,     0,     0,     0,   549,   540,   550,
       0,   536,   705,     0,     0,     0,     0,     0,     0,     0,
       0,   943,     0,     0,     0,     0,     0,     0,     0,     0,
     935,   939,   944,   945,   946,   949,   950,   613,   372,   355,
       0,   355,   355,   355,   355,   355,   355,   355,   355,   355,
       0,     0,   366,     0,   609,   611,     0,     0,   616,     0,
       0,   199,   885,   886,   887,   889,     0,   647,     0,     0,
       0,    16,     0,     0,   409,   383,     0,     0,     0,     0,
       0,   518,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   467,   468,
     463,   464,   465,   466,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,   552,   689,   722,
     732,   741,     0,   643,   565,   564,   566,   567,     0,     0,
     688,   706,   748,   721,   731,   740,   293,     0,     0,   199,
       0,     0,     0,     0,   966,   967,   199,   969,   199,   971,
       0,     0,     0,     0,   195,     0,     0,   402,   404,     0,
     978,   410,   518,   518,   158,   150,   154,   154,   154,     0,
       0,   139,     0,   143,     0,   141,     0,   145,     0,   706,
       0,   623,     0,     0,     0,     0,     0,     0,     0,     0,
     724,   725,   727,     0,     0,   655,   654,   621,   651,     0,
     897,   884,   104,   112,   114,   111,   113,   107,   110,   115,
     116,   117,   108,   109,     0,     0,     0,     0,     0,   445,
       0,     0,     0,   199,     0,     0,   879,   880,   881,   877,
     882,   878,   883,   518,     0,     0,     0,     0,     0,   861,
       0,     0,     0,     0,   808,   177,     0,     0,     0,     0,
       0,   752,     0,     0,     0,   376,   828,     0,     0,   829,
     827,     0,     0,   329,     0,   851,   199,   199,   518,   199,
     293,   892,     0,   903,     0,     0,   551,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,   942,   938,   947,     0,   936,   941,     0,
     937,     0,   361,     0,     0,   369,   367,   368,   355,   355,
     360,   357,   358,   364,   365,   359,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,   888,   199,   429,     0,   433,     0,     0,   518,   597,
     572,   568,   571,   451,     0,   241,   518,   416,   415,   426,
     425,   514,   516,   519,     0,   515,     0,     0,     0,   473,
     485,   486,   491,   492,   487,   488,   489,   490,   520,   520,
     495,   496,   475,   476,   454,   455,   458,   459,   460,   461,
     462,   498,   497,   474,   479,   480,   456,   477,   478,   457,
     503,   504,   506,   505,   507,   509,   508,   510,   511,   501,
     500,   502,   690,   723,   733,   742,     0,     0,   645,   558,
     719,     0,     0,     0,     0,     0,   199,   804,     0,   199,
       0,   655,   655,   181,     0,   659,   660,   661,   655,     0,
       0,     0,     0,     0,     0,     0,     0,   189,     0,   191,
     190,   197,   186,     0,   184,   248,     0,   249,     0,     0,
       0,     0,   199,   980,     0,   986,   979,     0,     0,     0,
     160,     0,     0,     0,     0,   804,     0,     0,     0,     0,
     324,     0,     0,     0,     0,     0,   737,   621,     0,   691,
     391,   125,   702,   700,   701,   704,   703,   526,   524,   726,
     559,     0,     0,   658,   653,   656,     0,   623,     0,   562,
       0,     0,   443,     0,   522,     0,     0,   199,   840,     0,
     834,   875,     0,   121,     0,   124,     0,   791,     0,   181,
     793,     0,     0,     0,   179,   181,   810,     0,   814,   823,
     813,   816,   815,   817,   818,   821,   819,     0,     0,     0,
       0,     0,     0,   326,     0,     0,     0,   807,   826,     0,
     378,   375,   377,     0,   797,     0,   797,   850,     0,   692,
     855,     0,   330,     0,     0,   692,     0,     0,     0,     0,
     894,   293,   893,     0,     0,     0,   545,     0,     0,     0,
     548,     0,   537,     0,     0,   904,   120,   395,   400,   442,
       0,   405,     0,     0,     0,     0,   940,     0,     0,     0,
     363,   362,     0,     0,     0,   605,   608,   610,   612,     0,
     354,     0,     0,     0,     0,     0,     0,     0,   615,     0,
     199,     0,   155,   199,     0,     0,   638,     0,   418,     0,
       0,   449,   450,     0,     0,     0,   521,     0,     0,     0,
     630,   639,   640,   644,     0,   556,   716,   717,   692,     0,
     692,   692,   238,     0,   630,     0,     0,   787,   788,   789,
     802,     0,   181,     0,   805,     0,   972,   973,     0,     0,
       0,   541,   671,   666,   518,   974,   673,   677,   678,   674,
       0,   663,     0,   664,   669,   975,   976,   977,   968,   970,
     194,   193,     0,   187,     0,   196,   403,     0,     0,     0,
       0,   199,    13,     0,   569,   569,     0,     0,     0,     0,
     909,   136,     0,     0,   138,   142,   140,   144,   747,     0,
     746,     0,     0,     0,     0,     0,   623,   624,   527,   525,
     728,     0,     0,   533,   532,     0,   530,   657,   622,   625,
     652,   512,     0,   446,     0,   199,     0,   199,   838,     0,
     873,   876,   870,     0,   122,   790,   792,     0,   784,     0,
     862,   863,     0,   180,   825,     0,     0,   174,   175,     0,
       0,   804,     0,     0,     0,     0,     0,     0,     0,   809,
       0,   822,   820,   374,   379,   380,     0,   181,   798,     0,
     795,   775,     0,   857,     0,   854,     0,   708,   707,     0,
       0,   706,   706,   858,   853,   841,   833,   831,   848,   895,
       0,     0,     0,     0,   331,   539,   538,     0,     0,     0,
     199,     0,     0,     0,     0,     0,   933,   934,   356,   319,
     318,     0,     0,     0,     0,   373,     0,   606,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   199,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   163,
     169,   170,     0,   165,   166,   167,   168,   569,     0,   574,
       0,   978,   417,   517,   493,   494,   483,   484,   481,   482,
     633,   633,   642,     0,   646,   718,   714,   715,     0,   623,
     237,   321,   743,   744,   898,   800,   803,     0,   804,     0,
     655,   655,   670,     0,     0,   675,   676,   662,   661,     0,
     665,   192,     0,   198,     0,     0,     0,     0,   981,   987,
       0,   413,   412,   159,     0,     0,     0,     0,   910,   911,
       0,     0,     0,   907,     0,     0,     0,   710,   709,   736,
     726,   738,   638,   560,     0,     0,   534,   528,     0,     0,
     636,   513,   444,   523,   837,   199,   835,   839,     0,   874,
     199,     0,     0,   794,     0,     0,   812,   176,   178,     0,
       0,     0,   762,     0,     0,     0,   181,   759,   760,   756,
       0,   754,   783,     0,   824,     0,   771,   796,   797,     0,
     776,     0,   856,   726,   706,   713,   712,   448,   447,     0,
     333,   546,     0,   547,   544,   543,   906,     0,   406,   408,
     407,   948,     0,     0,   371,   370,     0,     0,   607,     0,
       0,   352,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,   441,   434,     0,     0,     0,     0,   181,
       0,   156,   199,     0,   411,   598,   576,   577,   578,     0,
       0,   452,     0,     0,   631,   632,   641,   239,   749,   322,
       0,   801,   806,   199,   668,   667,   542,   684,   680,   188,
     985,   984,   982,   983,   623,   162,   161,   147,   136,     0,
     912,   916,   913,   914,     0,   137,     0,   199,   726,     0,
     643,   529,   535,   531,     0,     0,   599,   199,   871,   868,
     869,   123,     0,   864,   173,     0,   758,     0,     0,   767,
       0,     0,   761,     0,   753,     0,   811,   772,   799,     0,
     769,     0,     0,     0,     0,     0,   711,   334,   332,   905,
       0,   963,   962,   961,     0,     0,   988,   988,   988,   988,
     988,   988,     0,   832,     0,     0,     0,   440,   439,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   126,   164,
     335,   573,     0,   596,     0,     0,   579,   584,   419,   634,
     635,     0,     0,     0,     0,   679,   681,     0,     0,     0,
     685,     0,     0,   915,     0,     0,     0,     0,   621,   734,
     629,   626,   627,   637,     0,   561,   600,   872,   867,     0,
     764,   763,     0,     0,   765,   757,   755,   770,   778,     0,
       0,     0,   694,   692,   320,   617,   353,     0,     0,   989,
     990,     0,     0,     0,     0,     0,   199,     0,     0,   438,
     435,     0,   172,     0,     0,     0,     0,     0,   204,   157,
       0,   130,     0,   151,   129,     0,     0,     0,     0,     0,
     335,   204,     0,     0,   335,   335,   201,   204,   588,     0,
       0,     0,   594,   595,   582,   581,   583,   580,   575,   621,
     786,   682,     0,   570,     0,     0,     0,     0,   917,   919,
       0,   785,   745,   623,     0,     0,   601,   602,   865,   768,
       0,     0,     0,   777,   695,   696,   693,   852,     0,   955,
       0,   956,   957,   958,   959,   960,     0,   437,   436,   204,
       0,     0,     0,     0,     0,     0,   234,   205,   132,   131,
       0,   127,   132,   335,   204,     0,     0,   335,   335,   335,
       0,     0,   347,   335,   335,   335,   348,   351,   335,   586,
     587,   589,     0,   623,     0,     0,   148,   199,   136,   920,
     908,   921,   623,   638,   628,     0,     0,     0,   766,     0,
     779,   697,   698,   993,   994,   995,   996,   997,   998,   992,
     991,     0,   203,   231,     0,     0,   204,   171,   206,   210,
     209,   208,   207,   134,   133,     0,   135,   344,   335,   335,
     335,   343,   341,   342,     0,     0,   346,   349,   350,   336,
     591,     0,     0,   585,   729,   683,   149,     0,   686,     0,
       0,   136,   643,   604,   603,   866,   781,     0,   847,   204,
       0,   233,   130,   335,   337,   340,   339,   335,     0,   593,
     590,   592,   136,   922,     0,   240,   735,     0,   780,   202,
     230,   128,   338,   345,   211,   146,     0,   929,   931,   720,
     930,   932,     0,   923,     0,     0,     0,     0,   782,     0,
     227,   227,   232,   212,   213,   214,   722,   918,   924,   928,
     926,   927,   925,     0,     0,     0,   226,   225,   215,   222,
       0,   223,     0,   217,   216,   228,   229,   220,   221,   224,
       0,     0,     0,     0,   218,   219
};

/* YYPGOTO[NTERM-NUM].  */
static const yytype_int16 yypgoto[] =
{
   -1757, -1757,  1713, -1757,  1714,     9,  -143,    20,     4, -1757,
   -1757,  1708, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757,  -127,   -29,   136, -1418,  1359,  1360,  1362,  1363, -1757,
   -1757, -1757, -1757, -1757,   364, -1757, -1757, -1396, -1757, -1757,
     332, -1757,  -354, -1757,  1883, -1757, -1757, -1262,    98, -1757,
      -5,   486, -1757, -1578, -1757, -1757, -1757, -1757, -1756,  -162,
    -156, -1757, -1618, -1757, -1757, -1757, -1256, -1757,  1092,  -131,
    -729, -1757,  -101,  -660,  1624, -1757, -1217, -1757,   389, -1287,
     217,  1076,  -173,  -608,  -356,  -416,  1536, -1757,  -829,  -553,
    -541,  -306, -1757, -1757,  -225,  1278, -1757,  -459,   -64,    -8,
    -338, -1757,   694,  -529,   983,  -598,  -342, -1757, -1061, -1757,
    -375, -1757,   747, -1757,   -13, -1757, -1757,    -4,  -223,  -505,
     596, -1757, -1757, -1757, -1030, -1757,   -24, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757,   -20, -1757, -1757,
    -695, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
    -873,  -849, -1757,    51, -1757,   686,   460, -1757, -1007,   462,
   -1757, -1451, -1757, -1757,  -503, -1757,  -792,   788,  -767,   663,
   -1757,   666, -1012, -1757, -1757, -1757, -1757, -1757, -1757,   -12,
    -224,  -945, -1757, -1757,  -535, -1757,  -671,  -219,  -240,   -11,
   -1757,  -868,   693,    59,  1550, -1757, -1098,    73,  1554, -1757,
   -1757,  -204, -1757, -1757,   235, -1757, -1757, -1757,   376,   249,
   -1757, -1757, -1757,    44, -1757, -1757, -1757, -1757, -1757, -1757,
    -907, -1757,  -918,  -913,  -834, -1757,   812, -1757, -1757, -1757,
    1774,     2, -1757, -1757, -1757,  -318,  -843, -1757,  1416,  1417,
    1420,  1422,  1425, -1757,  1426,  1655, -1757,  -757, -1757, -1757,
   -1757, -1757, -1757, -1757,   411, -1757, -1757, -1757, -1757, -1757,
     624, -1757, -1757, -1757, -1757,  1442, -1757,  1443, -1757,  -128,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757,   -76, -1757, -1757, -1757, -1757, -1757,  1629, -1757,
   -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757, -1757,
   -1757, -1757, -1757, -1757,  1495,  -259, -1757, -1757, -1757,   516,
   -1757,   685,  -765,    90, -1757, -1757
};

/* YYDEFGOTO[NTERM-NUM].  */
static const yytype_int16 yydefgoto[] =
{
       0,     6,     7,     8,     9,   315,   195,   316,    11,   196,
     197,   958,   367,   632,   199,   200,   201,   202,   203,   204,
    1673,  1751,  1813,  1814,  1363,   205,   206,   207,   208,   209,
    1609,   210,   211,   338,   483,  1588,   891,  1288,  1289,  1290,
    1196,  1197,   947,   675,   948,   320,   318,  1122,  1123,    12,
      13,  1293,  1294,  1746,  1747,  1892,  1893,  1894,  1913,  1895,
    1906,  1295,  1685,  1296,   339,  1082,  1083,   212,   213,   214,
    1261,  1490,   346,   390,   347,   993,  1243,  1244,  1686,   468,
     732,   462,   685,  1687,   686,   215,   216,   217,   218,   219,
     220,   586,   587,   221,   592,   222,   223,   224,   225,   781,
     371,   782,   783,   784,  1065,  1066,   785,   626,  1165,  1166,
     419,   420,  1098,   421,   479,   228,   229,   960,   231,   232,
     360,   233,   558,   234,  1351,   771,   772,  1479,  1480,  1698,
    1596,  1691,  1833,  1597,  1056,  1625,  1626,  1716,  1717,  1036,
    1037,   235,   236,   237,   238,   239,   240,   241,   242,   243,
     927,   909,  1380,  1621,  1622,  1312,  1484,  1526,   553,  1071,
    1072,   838,  1075,   365,   627,   628,   924,   925,   854,   855,
     856,  1111,   857,  1112,  1113,  1605,  1606,   858,   244,   961,
     246,  1225,  1726,   247,   694,   905,   995,   248,   563,   962,
     622,   623,  1881,   963,   251,   906,   907,   964,   253,   254,
     845,   391,   255,   256,  1410,  1411,   257,   258,  1204,  1401,
    1402,   259,   260,   261,   262,   263,   264,   265,  1093,   950,
     951,  1218,  1219,  1094,  1095,   266,   965,   267,   268,   269,
    1205,   966,   272,   273,   274,   939,   940,   275,   276,   277,
     278,   279,   280,   281,   282,   283,   284,   989,   990,   285,
     286,   287,   288,   289,  1190,  1191,  1530,   290,  1391,  1180,
    1181,  1182,   662,   291,   475,   292,   293,   294,   295,   405,
     296,   297,   298,   299,   300,  1141,  1361,  1514,  1613,  1780,
    1781,  1840,  1882,  1883,  1884,  1885,  1886,  1887,   445,   301,
     302,   303,   304,   305,   306,   307,   308,   309,   310,   311,
     312,   313,    14,    15,   576,   577,    16,    17,   314,   884,
     885,   886,  1648,  1649,  1650,  1799
};

/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule whose
   number is the opposite.  If YYTABLE_NINF, syntax error.  */
static const yytype_int16 yytable[] =
{
     227,   245,   249,   548,   547,   226,   560,    93,   549,   230,
     715,   564,   463,   565,    92,   271,   349,   621,   589,   417,
      10,   401,   973,    10,   317,   674,   843,   869,   773,    91,
     869,   412,   647,   992,  1156,  1120,  1121,   689,   690,   870,
     706,   329,   870,   393,   332,   333,  1192,   334,  1008,  1299,
    1234,  1160,   935,   839,   652,  1038,   840,  1371,   579,  1102,
    1103,  1143,  1487,   887,   888,  1207,  1114,   860,  1222,  1619,
     861,  1220,   250,  1220,   902,  1515,  1589,   982,  1169,    -3,
    1499,   580,   583,  1100,   671,  1078,   252,   979,  1639,   979,
    1610,  1450,   448,    98,    99,    92,  1178,   974,  1338,   562,
     449,  1374,     1,  1763,   841,  1352,   593,    -4,  1356,  1768,
     691,   448,  1909,   946,   764,  1258,  1496,  1603,  1889,   449,
    1005,   716,  1803,   370,   544,   372,   373,  1582,   901,   545,
     567,  1551,    18,  1315,   942,  1316,  1317,   126,   545,   127,
     709,   477,    19,   399,  1148,   983,   126,  1552,  1914,   130,
      89,     1,   985,   692,  1583,    -5,   340,   357,  1511,  1168,
       3,  1802,   402,  1512,  1749,   683,  1924,  1925,   684,   998,
    1200,  1513,  1081,   322,  1910,  1604,  1818,   677,   842,     1,
     946,   127,   127,   477,   477,   476,   478,   392,   984,   889,
     480,   130,   130,     1,   890,   986,   859,   451,   452,   453,
     454,   455,   456,   457,   458,   459,   663,   323,  1584,   599,
     664,     1,   324,  1201,  1586,  1558,   451,   452,   453,   454,
     455,   456,   457,   458,   459,   645,    -6,     1,  1851,   546,
    1750,  1150,  1870,   946,   330,   730,  1262,  1283,   546,  1054,
     672,  1284,   765,  1152,   710,  1006,  1911,  1059,  1263,  1912,
    1890,  1891,   693,   975,   358,  1553,   547,   668,   325,   768,
     687,   688,  1357,  1375,  1285,  1417,  1286,  1474,   331,   162,
     162,  1869,   417,   449,   559,     2,     1,   693,   701,  -851,
    1393,   354,   665,   703,   532,   533,   534,   535,   536,   537,
     538,   539,   540,   541,   542,   409,   980,  1015,     1,   410,
       1,  1413,   693,  1264,   127,  1266,   477,  1372,   832,   833,
     834,   835,   359,   869,   130,   588,   588,  1523,  1287,   786,
      92,  1451,   368,  1661,     2,   870,   461,  1498,   978,   977,
    1014,  1321,   362,  1386,   543,  1322,  1012,     1,   363,   991,
     673,   396,   584,   581,   471,   461,  1705,   612,   981,   364,
     981,   620,     2,   976,   227,   638,   639,   625,   777,  1710,
    1838,   646,  1346,   637,  1640,  1520,     2,  1404,     3,   413,
       4,     5,  1214,   454,   455,   456,   457,   458,   459,   670,
       1,  1837,   472,  1748,     2,  1752,   473,   474,  1538,   681,
    1915,  1866,   414,     1,  1916,  1764,  1765,    -4,     4,     5,
       2,   127,   422,   477,  1256,   704,   705,  1633,     1,  1257,
    1743,   130,     4,     5,   423,  1903,  1079,  1278,   707,   588,
    1904,    98,    99,  1865,   717,  1170,   640,   851,   417,   787,
     788,   789,   790,   791,   792,   793,   794,   795,   796,   797,
     641,  1033,   800,   801,  1875,    -5,     4,     5,   425,     2,
     802,   803,   804,   805,   806,   807,   808,   809,   810,   406,
     812,   813,   814,   815,   816,   817,   818,   819,     1,  1422,
    1488,     2,   -10,     2,   595,   -10,   554,   555,   556,   557,
     760,   466,   341,   467,     1,  1804,   -10,   -10,   407,   162,
     574,   575,   408,  1090,  1492,     4,     5,   -10,   -10,   426,
    1548,   427,  1519,  1699,     1,  1220,  1670,   900,  1672,     1,
       2,   342,     1,   596,   384,   385,    -6,     4,     5,     4,
       5,   343,   -10,   428,   820,   821,   822,   823,   824,   825,
     826,   827,   828,   829,   830,   831,   429,   401,  1494,  1495,
     731,  1090,   -10,  -836,   481,  1040,  -836,  -836,  1041,  1151,
     597,   625,   469,     2,     1,  1555,     4,     5,   344,   470,
     848,  1174,  1384,  1158,  1159,   625,     2,  1163,   417,   614,
    1126,   482,  1000,  1448,  1002,  1334,  1383,   621,   615,   616,
    -307,     2,   883,  1097,   484,   862,   718,   863,  1348,   849,
     987,   486,  1185,   738,   739,  1186,   719,     3,    -3,     4,
       5,  1057,  1028,  1118,  1119,   911,   487,   488,   489,   490,
     491,   492,     4,     5,   552,  1032,   568,  1034,  1176,   617,
     618,   472,   559,  1345,  1344,   473,   474,     4,     5,  1808,
    1090,  1632,  1090,  1387,   648,   649,   720,   721,  1809,  1810,
     933,     2,   934,   931,   932,   650,  1641,  1240,   937,   938,
    1617,   582,   520,   521,   522,  1607,   943,     2,   945,   569,
     227,   523,   941,   523,   524,   959,   524,   956,   735,   736,
     737,   740,   741,   742,   743,   744,   745,     2,   868,  1811,
    1812,   873,     2,   585,   988,     2,   570,     4,     5,   753,
     754,   755,   756,   757,   758,   591,  1425,  1426,  1727,  1291,
    1475,  1599,  1600,     4,     5,   996,   997,   851,   999,   532,
     533,   534,   535,   536,   537,   538,   539,   540,   541,   542,
    1202,  1203,   144,     4,     5,   571,  1720,     2,     4,     5,
     361,     4,     5,  1722,  1106,  1325,   594,  -672,  1326,   588,
     572,    96,    97,    98,    99,  1713,   101,  1107,  1890,  1891,
     103,   104,  1358,  1359,  1360,  1347,  1108,   573,  1109,   543,
     598,   532,   533,   534,   535,   536,   537,   538,   539,   540,
     541,   542,   590,     4,     5,   362,  1842,  1694,  1695,  1696,
    1697,   363,  1050,   851,   355,  1106,  1724,  1725,  -672,   869,
     934,   934,   364,   608,  1067,  1069,  1917,  1918,  1107,  1755,
    1756,   870,  1651,  1652,  1653,  1654,  1655,  1108,  1163,  1109,
    1376,   543,   610,   613,  1789,   532,   533,   534,   535,   536,
     537,   538,   539,   540,   541,   542,  1773,   644,  1070,  1073,
     666,  1241,   667,  1381,   988,   676,  1084,   668,  1077,  1080,
     682,  1481,   696,   698,  1321,   699,  1099,  1090,  1758,   545,
     702,   708,  1101,    92,   711,  1086,   713,   126,   722,   127,
    1416,   477,   714,  1326,  1783,   543,   326,   723,   588,   130,
     724,   725,     1,  1239,   726,   532,   533,   534,   535,   536,
     537,   538,   539,   540,   541,   542,    96,    97,   727,  1556,
     728,   101,   729,   988,   731,   103,   104,  1260,   733,   734,
    1157,  1260,  1131,  1260,   518,   519,   520,   521,   522,   746,
     747,   620,  1476,  1477,  1478,   523,   748,   749,   524,   750,
     625,  1663,  1171,  1172,  1834,   543,  1819,  1820,  1670,  1671,
    1672,   751,   752,  1841,   761,   766,  1110,  1793,  1794,  1795,
    1796,  1797,  1798,  -152,   774,  1437,   798,   162,   799,   546,
     -11,   -11,   335,   836,  1189,  1030,  1031,  1177,   837,  1194,
     892,   893,   894,   227,   844,   846,   871,   851,  1211,   847,
    1209,  1491,  -235,   875,  1090,   516,   517,   518,   519,   520,
     521,   522,  -152,   895,   762,   876,   851,   417,   523,   877,
     896,   524,   897,   898,   899,   528,  1233,   912,   531,  1304,
    1305,   908,   913,   919,   914,  1247,   -11,  1249,   915,   916,
     -11,   920,  1252,  1101,  1253,  1254,   921,   926,   336,  -152,
     410,   929,   928,   936,  1163,   407,   409,   337,   621,   944,
     952,   448,   957,   967,   970,   763,   138,   139,   972,   449,
     994,   691,  1011,  1282,  1013,     2,  1016,  1539,  1292,  1017,
    1018,   674,  1019,  1024,    92,   869,  1020,  1021,  1025,  1547,
    1026,  1022,  1039,  1550,  1090,  1023,  1314,   870,  1042,  1043,
     532,   533,   534,   535,   536,   537,   538,   539,   540,   541,
     542,   621,  1805,  1044,  1045,  1046,  1047,  1048,  1049,   910,
    1051,     4,     5,   -11,   -11,  1052,    87,    88,   532,   533,
     534,   535,   536,   537,   538,   539,   540,   541,   542,  1053,
     319,   321,  1055,  1058,  1060,  1062,   542,   523,  1291,   625,
     543,  1074,  1061,  1076,  1759,   883,  1085,  1105,   450,  1104,
    1115,  1116,  1117,  1124,  1125,    92,   451,   452,   453,   454,
     455,   456,   457,   458,   459,  1369,  1127,   575,   543,  1438,
     532,   533,   534,   535,   536,   537,   538,   539,   540,   541,
     542,  1128,  -105,  1129,  1133,  1858,   934,  1130,  1136,  1137,
    1149,  1388,  1153,  1132,  1134,  1154,   621,   946,  1135,  1175,
     650,    92,  1155,  1161,  1634,  1183,  -105,   977,  1179,  1187,
    1193,  -105,  1199,  1637,  1188,  1385,   851,  1210,  1206,  -105,
     543,  -105,  1213,  -105,   366,  1215,  1216,   345,   345,   345,
    1221,  -105,  1414,  1224,  1226,   353,  1227,   353,   988,  1228,
    1235,   460,  1236,  1237,  1238,  1245,  1246,  1250,   353,   353,
    1251,  1258,   376,   378,   379,   389,   345,   394,   395,  1255,
    1265,  1267,   398,   588,   400,  1292,  1268,   629,   404,  1277,
    1297,   404,  1298,  1300,   418,  1301,  1509,   424,  1302,  1333,
    1306,  1757,  1307,  1308,  1313,   461,  1309,  1319,  1318,  1324,
    1335,   544,  1462,  1328,  1329,   447,   545,  1330,   464,   465,
    1336,  1342,  1339,  -105,   126,  1331,   127,  1459,   477,  -105,
     934,  -105,  1332,   883,  1341,  1343,   130,  1350,  1353,  1354,
    1590,  1364,  1365,  1355,  1367,  1070,  1368,  1362,  1370,  1379,
    1084,  1560,  1561,  1377,  1378,  1562,  1563,   532,   533,   534,
     535,   536,   537,   538,   539,   540,   541,   542,   532,   533,
     534,   535,   536,   537,   538,   539,   540,   541,   542,   353,
    1390,  1392,  1394,  1395,  1439,  1396,  1398,  1403,  1407,  1408,
    1399,  1412,  1508,   400,  1419,  1418,  1420,  1421,  1423,   693,
    1432,  1427,   620,  1428,  -105,  1431,  1433,   543,   630,  1441,
    1434,  1442,  1440,  1443,   162,  1435,   546,  1444,   543,  1445,
    1446,  1447,  1449,  1452,  1531,  1453,  1454,  1455,  1456,    92,
    1460,  1457,  1458,  1465,  1467,  1463,  1466,  1189,  1470,  1528,
     532,   533,   534,   535,   536,   537,   538,   539,   540,   541,
     542,  1471,  1472,  1554,  1483,   620,  1493,  1497,  1110,  1500,
    1505,  1501,  1502,  1291,  1464,  1503,  1506,  1524,  1504,  1510,
    1517,  1629,   400,   353,   353,   353,   353,   467,  1525,  1518,
    1529,  1521,  1532,   609,   979,  1535,   353,  1536,  1537,   631,
     543,  1540,  1576,   671,  1541,  1543,  1544,  1545,  1580,  1546,
    1559,  1566,  1084,  1577,  1567,  1568,  1572,  1292,  1585,   669,
    1612,  1569,  1595,  1570,   678,   679,  1571,  1573,   680,  1587,
    1579,  1675,  1581,   400,   400,  1591,  1598,  1601,   695,  1611,
    1608,  1615,  1614,  1618,  1624,  1628,   974,  1638,   404,  1643,
    1644,  1645,  1602,   404,  1646,  1676,  1656,   418,  1677,  1678,
     620,  1708,  1659,  1664,  1666,   353,  1620,  1623,  1665,  1667,
    1669,  1668,   448,  1692,  1700,  1702,  1616,  1630,  1711,  1703,
     449,  1706,  1707,  1679,  1712,  1635,  1627,   532,   533,   534,
     535,   536,   537,   538,   539,   540,   541,   542,   532,   533,
     534,   535,   536,   537,   538,   539,   540,   541,   542,  1714,
    1718,  1745,   353,  1719,  1723,  1721,  1658,  1741,  1728,  1754,
    1769,  1084,  1729,  1853,  1730,   353,  1731,  1732,   770,  1733,
    1734,   400,   353,  1735,  1690,  1680,  1681,   543,  1737,  1772,
    1775,  1578,  1739,  1740,  1779,  1701,  1742,  1760,   543,  1776,
    1777,  1774,  1642,  1782,  1785,  1787,  1791,  1084,  1786,  1788,
    1790,  1792,  1415,  1801,  1679,   811,   532,   533,   534,   535,
     536,   537,   538,   539,   540,   541,   542,   451,   452,   453,
     454,   455,   456,   457,   458,   459,   353,  1806,  1682,  1825,
    1683,  1877,  1835,  1836,  1839,  1879,   769,  1847,  1846,  1848,
    1849,  1850,   548,  1684,  1852,  1859,   833,  1896,  1084,  1744,
    1877,  1862,   853,   418,  1879,  1736,   543,  1864,  1867,  1868,
     697,  1749,   353,   979,   872,   353,  1874,   874,   532,   533,
     534,   535,   536,   537,   538,   539,   540,   541,   542,   532,
     533,   534,   535,   536,   537,   538,   539,   540,   541,   542,
     345,  1888,   353,  1778,  1899,   981,  1620,  1897,  1919,  1900,
    1675,   918,  1901,  1905,  1902,  1920,    20,   353,  1921,  1922,
    1923,   198,    90,  1816,  1674,  1871,   633,   634,   543,   635,
     636,  1534,  1908,  1084,  1676,  1907,  1436,  1677,  1678,   543,
     348,   532,   533,   534,   535,   536,   537,   538,   539,   540,
     541,   542,  1824,   485,  1303,   971,   461,  1373,  1248,   949,
     400,  1843,  1679,   955,  1832,  1784,  1844,   778,   968,   969,
    1320,  1485,  1292,  1337,   353,  1486,  1223,   550,  1323,  1340,
    1636,   551,  1068,   345,  1542,   353,  1631,   270,  1212,   656,
     657,   543,   404,   658,   404,   659,   430,   448,   660,   661,
     353,   353,   397,   418,  1389,   449,  1533,  1898,   446,   642,
     643,  1660,   578,   431,  1680,  1681,   448,  1482,  1349,     0,
    1800,     0,  1662,  1027,   449,   400,  1029,     0,     0,     0,
       0,  1863,     0,     0,     0,     0,     0,     0,   400,     0,
     400,  1035,  1035,     0,     0,     0,     0,     0,     0,     0,
       0,  1876,  1878,  1880,     0,   432,   433,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,  1682,     0,  1683,
    1876,  1878,  1880,     0,     0,  1310,     0,     0,   434,  1311,
       0,     0,  1684,     0,     0,   435,     0,  1549,   436,     0,
    1738,   437,     0,     0,     0,   438,     0,     0,     0,   439,
       0,     0,   451,   452,   453,   454,   455,   456,   457,   458,
     459,     0,     0,     0,     0,   440,     0,     0,     0,     0,
       0,   451,   452,   453,   454,   455,   456,   457,   458,   459,
       0,     0,     0,     0,   981,     0,     0,     0,     0,  1092,
       0,     0,   853,   353,   353,     0,     0,     0,     0,     0,
     353,     0,  1807,     0,     0,     0,     0,     0,   353,     0,
       0,     0,     0,  1857,     0,   532,   533,   534,   535,   536,
     537,   538,   539,   540,   541,   542,   441,     0,     0,     0,
     442,     0,     0,   353,   353,   353,   353,  1092,   353,   353,
     353,   353,     0,     0,     0,   353,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   352,     0,   356,     0,
       0,     0,     0,   353,   353,   543,     0,     0,   853,   374,
     375,     0,     0,     0,     0,     0,   388,     0,     0,     0,
       0,   461,     0,     0,     0,     0,  1184,     0,   955,     0,
       0,     0,     0,     0,     0,   949,   443,   444,     0,     0,
     461,     0,     0,     0,     0,     0,     0,     0,     0,   353,
       0,     0,     0,     0,   949,     0,   955,     0,     0,  1762,
       0,     0,     0,  1766,  1767,     0,  1217,     0,  1217,     0,
     353,     0,     0,     0,     0,     0,  1232,     0,     0,     0,
    1096,     0,     0,   404,     0,     0,     0,  1242,     0,     0,
     532,   533,   534,   535,   536,   537,   538,   539,   540,   541,
     542,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     400,     0,     0,     0,   400,     0,   400,     0,     0,     0,
     561,  1269,     0,  1270,  1271,  1272,  1273,  1274,  1275,  1276,
       0,     0,  1817,     0,     0,     0,  1821,  1822,  1823,     0,
     543,     0,  1826,  1827,  1828,     0,     0,  1829,     0,     0,
     532,   533,   534,   535,   536,   537,   538,   539,   540,   541,
     542,  1232,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,   353,   532,   533,   534,   535,
     536,   537,   538,   539,   540,   541,   542,     0,     0,     0,
       0,     0,   853,     0,     0,     0,     0,  1854,  1855,  1856,
     543,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,   853,   418,   653,   601,   603,   605,   607,     0,     0,
       0,     0,     0,     0,     0,     0,   543,   611,     0,     0,
       0,  1232,  1872,     0,     0,     0,  1873,   353,     0,     0,
       0,     0,     0,     0,   353,   532,   533,   534,   535,   536,
     537,   538,   539,   540,   541,   542,     0,     0,     0,     0,
       0,     0,     0,   148,   149,     0,     0,     0,     0,   949,
       0,   650,     0,     0,     0,   154,   155,   353,   654,   655,
       0,  1400,     0,  1092,  1405,  1406,     0,     0,  1409,     0,
     949,     0,     0,     0,     0,   543,   712,   651,     0,     0,
       0,  1173,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,  1424,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,  1430,   532,   533,   534,   535,   536,
     537,   538,   539,   540,   541,   542,     0,     0,     0,     0,
       0,     0,     0,   759,     0,     0,     0,     0,     0,     0,
    1035,     0,     0,     0,     0,     0,   767,     0,     0,     0,
       0,     0,     0,   780,     0,     0,     0,     0,  1469,     0,
    1382,     0,     0,     0,   353,   543,   532,   533,   534,   535,
     536,   537,   538,   539,   540,   541,   542,     0,   532,   533,
     534,   535,   536,   537,   538,   539,   540,   541,   542,     0,
       0,     0,     0,   353,     0,     0,     0,     0,     0,     0,
    1092,     0,   353,   353,     0,  1242,     0,   352,     0,     0,
       0,   853,     0,     0,   353,     0,   543,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,  1507,   543,   345,
       0,     0,     0,   852,     0,     0,   353,     0,   930,     0,
       0,     0,     0,   867,     0,     0,   867,   353,     0,     0,
     353,     0,     0,     0,     0,   532,   533,   534,   535,   536,
     537,   538,   539,   540,   541,   542,     0,     0,     0,     0,
       0,   353,     0,   904,   532,   533,   534,   535,   536,   537,
     538,   539,   540,   541,   542,     0,     0,     0,   923,  1527,
    1217,     0,     0,     0,     0,     0,     0,     0,     0,   369,
       0,  1557,     0,     0,  1242,   543,     0,     0,     0,     0,
       0,     0,     0,     0,   400,   400,     0,     0,   400,   400,
       0,  1564,  1565,     0,   543,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   954,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,   388,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   388,   532,   533,   534,
     535,   536,   537,   538,   539,   540,   541,   542,     0,     0,
       0,   388,  1010,     0,  1003,     0,     0,     0,     0,   532,
     533,   534,   535,   536,   537,   538,   539,   540,   541,   542,
       0,     0,     0,  1004,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   345,     0,     0,   543,     0,  1400,
     949,     0,     0,     0,     0,     0,     0,  1409,     0,     0,
       0,     0,  1770,  1771,     0,   949,     0,     0,     0,   543,
       0,     0,     0,     0,     0,     0,     0,     0,  1647,  1647,
    1647,  1647,  1647,  1647,  1860,  1861,     0,     0,     0,     0,
       0,     0,     0,   353,   532,   533,   534,   535,   536,   537,
     538,   539,   540,   541,   542,     0,     0,     0,     0,     0,
       0,     0,     0,   353,     0,     0,     0,     0,     0,     0,
     353,     0,     0,     0,   345,     0,   353,     0,     0,     0,
       0,     0,     0,     0,     0,     0,  1715,     0,     0,     0,
       0,     0,     0,     0,   543,   949,     0,     0,     0,     0,
    1091,     0,   949,   852,   923,   923,     0,     0,     0,  1693,
       0,   923,     0,     0,     0,     0,     0,     0,     0,   867,
     532,   533,   534,   535,   536,   537,   538,   539,   540,   541,
     542,     0,     0,     0,     0,     0,     0,  1753,     0,     0,
       0,   353,     0,     0,  1138,  1139,  1140,  1142,  1091,  1144,
    1145,  1146,  1147,     0,     0,     0,   388,     0,     0,     0,
       0,     0,     0,     0,   345,     0,     0,     0,     0,     0,
     543,     0,     0,     0,  1164,  1167,     0,     0,     0,   852,
       0,     0,     0,   949,     0,     0,     0,     0,     0,     0,
       0,     0,  1647,     0,     0,     0,     0,     0,     0,   954,
       0,     0,     0,     0,   353,     0,     0,     0,     0,     0,
       0,     0,  1815,   775,     0,     0,     0,     0,     0,     0,
    1198,   102,     0,     0,     0,     0,     0,   954,     0,     0,
       0,     0,     0,     0,     0,     0,     0,  1091,     0,  1091,
       0,   923,     0,     0,     0,     0,     0,     0,  1715,  1845,
       0,   106,  1063,   107,   493,   494,   495,   496,   497,   498,
     499,   500,   501,   502,   503,   504,   505,   506,   507,   508,
     509,   510,   511,   512,   513,   514,   515,   516,   517,   518,
     519,   520,   521,   522,     0,     0,     0,   353,     0,     0,
     523,     0,     0,   524,   525,   526,   527,   528,   529,   530,
     531,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,   118,    32,
     119,   120,   121,     0,     0,     0,   122,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,  1327,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,   132,   852,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,   852,     0,     0,     0,   135,     0,    53,     0,
       0,   327,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    54,    55,   904,     0,
       0,    56,     0,     0,     0,  1164,     0,     0,   328,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,  1397,     0,
       0,     0,     0,     0,  1091,     0,   388,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
       0,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   776,
       0,     0,     0,     0,     0,     0,     0,    94,    95,    96,
      97,    98,    99,   100,   101,   102,     0,     0,   103,   104,
       0,     0,     0,     0,     0,     0,     0,     0,     0,  1468,
       0,     0,     0,     0,     0,  1473,     0,     0,     0,     0,
       0,   105,     0,     0,     0,   106,     0,   107,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,  1489,     0,     0,   108,   109,   110,
       0,  1091,     0,   923,   923,     0,     0,   111,     0,     0,
       0,     0,   852,     0,     0,   867,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    22,    23,   112,   113,    26,
      27,    28,     0,    29,   114,    30,     0,  1516,    31,   115,
     116,   117,   118,    32,   119,   120,   121,     0,  1522,     0,
     122,  1164,   123,    33,     0,     0,     0,   124,    35,     0,
      36,     0,     0,    37,   125,   126,    38,   127,    39,   128,
       0,   129,  1198,     0,     0,    41,    42,   130,    43,     0,
     131,     0,     0,     0,     0,     0,   132,   133,    44,     0,
       0,  1091,     0,     0,    45,    46,    47,    48,    49,     0,
      50,     0,     0,     0,    51,    52,   134,     0,     0,     0,
     135,     0,    53,     0,     0,   136,   137,     0,     0,     0,
       0,     0,   138,   139,   140,   141,     0,   142,   143,   144,
     145,   146,   147,   148,   149,    56,     0,     0,     0,   150,
       0,   151,   152,   153,     0,   154,   155,   156,   157,   158,
      58,   159,     0,   160,   161,   162,     0,   163,    61,    62,
      63,     0,    64,   164,   165,     0,     0,     0,   166,   167,
     168,    66,   169,   170,   171,   172,   173,   174,   175,     0,
       0,    67,    68,     0,    69,    70,    71,    72,    73,    74,
       0,    75,    76,    77,     0,     0,   176,   177,    78,    79,
     178,   179,   180,   181,   182,   183,   184,   185,   186,   187,
     188,    80,   189,   190,    81,    82,    83,    84,    85,    86,
       0,     0,   191,     0,     0,     0,     0,     0,     0,     0,
     192,   193,     0,   194,     0,    94,    95,    96,    97,    98,
      99,   100,   101,   102,     0,     0,   103,   104,     0,     0,
       0,     0,     0,     0,   388,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   105,
       0,     0,     0,   106,   904,   107,     0,     0,     0,     0,
       0,   867,     0,     0,     0,     0,     0,  1709,     0,     0,
       0,     0,     0,     0,     0,   108,   109,   110,     0,     0,
       0,     0,     0,     0,     0,   111,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    22,    23,    24,    25,    26,    27,    28,
       0,    29,   114,    30,     0,     0,    31,     0,     0,     0,
     118,    32,   119,   120,   121,     0,     0,     0,   122,     0,
     544,    33,  1761,     0,     0,   124,    35,     0,    36,     0,
       0,    37,   326,   126,    38,   127,    39,   477,     0,   129,
       0,     0,     0,    41,    42,   130,    43,     0,   131,     0,
       0,     0,     0,     0,   132,     0,    44,     0,     0,     0,
       0,     0,    45,    46,    47,    48,    49,     0,    50,     0,
       0,     0,    51,    52,     0,     0,     0,     0,   135,     0,
      53,     0,     0,   327,     0,   388,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    54,    55,
       0,     0,     0,    56,     0,     0,     0,     0,     0,     0,
     152,     0,     0,     0,     0,    57,     0,     0,    58,    59,
       0,   160,   161,   162,     0,   163,    61,    62,    63,     0,
      64,    65,     0,     0,     0,     0,     0,     0,     0,    66,
     169,   170,   171,   172,   173,   174,   175,     0,     0,    67,
      68,     0,    69,    70,    71,    72,    73,    74,     0,    75,
      76,    77,     0,     0,   176,   177,    78,    79,   388,    94,
      95,    96,    97,    98,    99,   100,   101,   102,     0,    80,
     103,   104,    81,    82,    83,    84,    85,    86,   512,   513,
     514,   515,   516,   517,   518,   519,   520,   521,   522,     0,
       0,   194,     0,   105,     0,   523,     0,   106,   524,   107,
     526,   527,   528,     0,     0,   531,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   108,
     109,   110,     0,     0,     0,     0,     0,     0,     0,   111,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    22,    23,    24,
      25,    26,    27,    28,     0,    29,   114,    30,     0,     0,
      31,     0,     0,     0,   118,    32,   119,   120,   121,     0,
       0,     0,   122,     0,     0,    33,     0,     0,     0,    34,
      35,     0,    36,     0,     0,    37,   326,     0,    38,     0,
      39,   878,     0,    40,     0,     0,     0,    41,    42,   879,
      43,     0,   131,     0,   880,     0,     0,     0,   132,     0,
      44,     0,     0,     0,     0,     0,    45,    46,    47,    48,
      49,     0,    50,     0,     0,     0,    51,    52,     0,     0,
       0,     0,   135,     0,    53,     0,     0,   327,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    54,    55,     0,     0,     0,    56,     0,     0,
       0,     0,     0,     0,   328,     0,     0,     0,     0,    57,
       0,     0,    58,    59,     0,   160,   161,   881,     0,    60,
      61,    62,    63,     0,    64,    65,     0,     0,     0,     0,
       0,     0,     0,    66,   169,   170,   171,   172,   173,   174,
     175,     0,     0,    67,    68,     0,    69,    70,    71,    72,
      73,    74,     0,    75,    76,    77,     0,     0,   176,   177,
      78,    79,     0,    94,    95,    96,    97,    98,    99,   100,
     101,   102,     0,    80,   103,   104,    81,    82,    83,    84,
      85,    86,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   882,     0,     0,   194,     0,   105,     0,     0,
       0,   106,     0,   107,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,   108,   109,   110,     0,     0,     0,     0,
       0,     0,     0,   111,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    22,    23,    24,    25,    26,    27,    28,     0,    29,
     114,    30,     0,     0,    31,     0,     0,     0,   118,    32,
     119,   120,   121,     0,     0,     0,   122,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
     326,     0,    38,   127,    39,   477,     0,    40,     0,     0,
       0,    41,    42,   130,    43,     0,   131,     0,     0,     0,
       0,     0,   132,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,     0,     0,     0,     0,   135,     0,    53,     0,
       0,   327,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    54,    55,     0,     0,
       0,    56,     0,     0,     0,     0,     0,     0,   328,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,   160,
     161,   162,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,   169,   170,
     171,   172,   173,   174,   175,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
       0,     0,   176,   177,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    94,    95,    96,    97,
      98,    99,   100,   101,   102,     0,     0,   103,   104,   194,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,  1279,     0,
     105,     0,     0,     0,   106,     0,   107,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   108,   109,   110,     0,
       0,     0,     0,     0,     0,     0,   111,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    22,    23,    24,    25,    26,    27,
      28,     0,    29,   114,    30,     0,     0,    31,     0,     0,
       0,   118,    32,   119,   120,   121,     0,     0,     0,   122,
       0,     0,    33,     0,     0,     0,    34,    35,     0,    36,
       0,     0,    37,   326,     0,    38,     0,    39,     0,     0,
      40,     0,     0,     0,    41,    42,     0,    43,     0,   131,
       0,     0,  1280,     0,     0,   132,     0,    44,     0,     0,
       0,     0,     0,    45,    46,    47,    48,    49,     0,    50,
       0,     0,     0,    51,    52,     0,     0,     0,     0,   135,
       0,    53,     0,     0,   327,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    54,
      55,     0,     0,     0,    56,     0,     0,     0,     0,     0,
       0,   328,     0,     0,  1281,     0,    57,     0,     0,    58,
      59,     0,   160,   161,     0,     0,    60,    61,    62,    63,
       0,    64,    65,     0,     0,     0,     0,     0,     0,     0,
      66,   169,   170,   171,   172,   173,   174,   175,     0,     0,
      67,    68,     0,    69,    70,    71,    72,    73,    74,     0,
      75,    76,    77,     0,     0,   176,   177,    78,    79,     0,
      94,    95,    96,    97,    98,    99,   100,   101,   102,     0,
      80,   103,   104,    81,    82,    83,    84,    85,    86,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   194,     0,   105,  1592,     0,     0,   106,     0,
     107,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     108,   109,   110,     0,     0,     0,     0,     0,     0,     0,
     111,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,  1593,  1594,    22,    23,
      24,    25,    26,    27,    28,     0,    29,   114,    30,     0,
       0,    31,     0,     0,     0,   118,    32,   119,   120,   121,
       0,     0,     0,   122,     0,     0,    33,     0,     0,     0,
      34,    35,     0,    36,     0,     0,    37,   326,     0,    38,
       0,    39,     0,     0,    40,     0,     0,     0,    41,    42,
       0,    43,     0,   131,     0,     0,     0,     0,     0,   132,
       0,    44,     0,     0,     0,     0,     0,    45,    46,    47,
      48,    49,     0,    50,     0,     0,     0,    51,    52,     0,
       0,     0,     0,   135,     0,    53,     0,     0,   327,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    54,    55,     0,     0,     0,    56,     0,
       0,     0,     0,     0,     0,   328,     0,     0,     0,     0,
      57,     0,     0,    58,    59,     0,   160,   161,     0,     0,
      60,    61,    62,    63,     0,    64,    65,     0,     0,     0,
       0,     0,     0,     0,    66,   169,   170,   171,   172,   173,
     174,   175,     0,     0,    67,    68,     0,    69,    70,    71,
      72,    73,    74,     0,    75,    76,    77,     0,     0,   176,
     177,    78,    79,     0,    94,    95,    96,    97,    98,    99,
     100,   101,   102,     0,    80,   103,   104,    81,    82,    83,
      84,    85,    86,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   194,     0,   105,     0,
       0,     0,   106,     0,   107,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   108,   109,   110,     0,     0,     0,
       0,     0,     0,     0,   111,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    22,    23,    24,    25,    26,    27,    28,     0,
      29,   114,    30,     0,     0,    31,     0,     0,     0,   118,
      32,   119,   120,   121,     0,     0,     0,   122,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,   326,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,   131,     0,     0,
    1574,     0,     0,   132,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,   135,     0,    53,
       0,     0,   327,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,     0,
       0,     0,    56,     0,     0,     0,     0,     0,     0,   328,
       0,     0,  1575,     0,    57,     0,     0,    58,    59,     0,
     160,   161,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,   169,
     170,   171,   172,   173,   174,   175,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,   176,   177,    78,    79,     0,    94,    95,
      96,    97,    98,    99,   100,   101,   102,     0,    80,   103,
     104,    81,    82,    83,    84,    85,    86,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     194,     0,   105,     0,     0,     0,   106,     0,   107,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   108,   109,
     110,     0,     0,     0,     0,     0,     0,     0,   111,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,  1688,  1689,    22,    23,    24,    25,
      26,    27,    28,     0,    29,   114,    30,     0,     0,    31,
       0,     0,     0,   118,    32,   119,   120,   121,     0,     0,
       0,   122,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,   326,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,   131,     0,     0,     0,     0,     0,   132,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,   135,     0,    53,     0,     0,   327,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,     0,     0,     0,    56,     0,     0,     0,
       0,     0,     0,   328,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,   160,   161,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,   169,   170,   171,   172,   173,   174,   175,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,   176,   177,    78,
      79,     0,    94,    95,    96,    97,    98,    99,   100,   101,
     102,     0,    80,   103,   104,    81,    82,    83,    84,    85,
      86,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   194,     0,   105,     0,     0,     0,
     106,     0,   107,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   108,   109,   110,     0,     0,     0,     0,     0,
       0,     0,   111,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,  1830,  1831,
      22,    23,    24,    25,    26,    27,    28,     0,    29,   114,
      30,     0,     0,    31,     0,     0,     0,   118,    32,   119,
     120,   121,     0,     0,     0,   122,     0,     0,    33,     0,
       0,     0,    34,    35,     0,    36,     0,     0,    37,   326,
       0,    38,     0,    39,     0,     0,    40,     0,     0,     0,
      41,    42,     0,    43,     0,   131,     0,     0,     0,     0,
       0,   132,     0,    44,     0,     0,     0,     0,     0,    45,
      46,    47,    48,    49,     0,    50,     0,     0,     0,    51,
      52,     0,     0,     0,     0,   135,     0,    53,     0,     0,
     327,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    54,    55,     0,     0,     0,
      56,     0,     0,     0,     0,     0,     0,   328,     0,     0,
       0,     0,    57,     0,     0,    58,    59,     0,   160,   161,
       0,     0,    60,    61,    62,    63,     0,    64,    65,     0,
       0,     0,     0,     0,     0,     0,    66,   169,   170,   171,
     172,   173,   174,   175,     0,     0,    67,    68,     0,    69,
      70,    71,    72,    73,    74,     0,    75,    76,    77,     0,
       0,   176,   177,    78,    79,     0,    94,    95,    96,    97,
      98,    99,   100,   101,   102,     0,    80,   103,   104,    81,
      82,    83,    84,    85,    86,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   194,     0,
     105,     0,     0,     0,   106,     0,   107,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   108,   109,   110,     0,
       0,     0,     0,     0,     0,     0,   111,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    22,    23,    24,    25,    26,    27,
      28,     0,    29,   114,    30,     0,     0,    31,     0,     0,
       0,   118,    32,   119,   120,   121,     0,     0,     0,   122,
       0,     0,    33,     0,     0,     0,    34,    35,     0,    36,
       0,     0,    37,   326,     0,    38,     0,    39,     0,     0,
      40,     0,     0,     0,    41,    42,     0,    43,     0,   131,
     369,     0,     0,     0,     0,   132,     0,    44,     0,     0,
       0,     0,     0,    45,    46,    47,    48,    49,     0,    50,
       0,     0,     0,    51,    52,     0,     0,     0,     0,   135,
       0,    53,     0,     0,   327,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    54,
      55,     0,     0,     0,    56,     0,     0,     0,     0,     0,
       0,   328,     0,     0,     0,     0,    57,     0,     0,    58,
      59,     0,   160,   161,     0,     0,    60,    61,    62,    63,
       0,    64,    65,     0,     0,     0,     0,     0,     0,     0,
      66,   169,   170,   171,   172,   173,   174,   175,     0,     0,
      67,    68,     0,    69,    70,    71,    72,    73,    74,     0,
      75,    76,    77,     0,     0,   176,   177,    78,    79,     0,
      94,    95,    96,    97,    98,    99,   100,   101,   102,     0,
      80,   103,   104,    81,    82,    83,    84,    85,    86,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   194,     0,   105,     0,     0,     0,   106,     0,
     107,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     108,   109,   110,     0,     0,     0,     0,     0,     0,     0,
     111,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    22,    23,
      24,    25,    26,    27,    28,     0,    29,   114,    30,     0,
       0,    31,     0,     0,     0,   118,    32,   119,   120,   121,
       0,     0,     0,   122,     0,     0,    33,     0,     0,     0,
      34,    35,     0,    36,     0,     0,    37,   326,     0,    38,
       0,    39,     0,     0,    40,     0,     0,     0,    41,    42,
       0,    43,     0,   131,     0,   619,     0,     0,     0,   132,
       0,    44,     0,     0,     0,     0,     0,    45,    46,    47,
      48,    49,     0,    50,     0,     0,     0,    51,    52,     0,
       0,     0,     0,   135,     0,    53,     0,     0,   327,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    54,    55,     0,     0,     0,    56,     0,
       0,     0,     0,     0,     0,   328,     0,     0,     0,     0,
      57,     0,     0,    58,    59,     0,   160,   161,     0,     0,
      60,    61,    62,    63,     0,    64,    65,     0,     0,     0,
       0,     0,     0,     0,    66,   169,   170,   171,   172,   173,
     174,   175,     0,     0,    67,    68,     0,    69,    70,    71,
      72,    73,    74,     0,    75,    76,    77,     0,     0,   176,
     177,    78,    79,     0,    94,    95,    96,    97,    98,    99,
     100,   101,   102,     0,    80,   103,   104,    81,    82,    83,
      84,    85,    86,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   194,     0,   105,     0,
       0,     0,   106,     0,   107,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   108,   109,   110,     0,     0,     0,
       0,     0,     0,     0,   111,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    22,    23,    24,    25,    26,    27,    28,     0,
      29,   114,    30,     0,     0,    31,     0,     0,     0,   118,
      32,   119,   120,   121,     0,     0,     0,   122,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,   326,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,   131,     0,     0,
       0,     0,     0,   132,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,   135,     0,    53,
       0,     0,   327,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,     0,
       0,     0,    56,     0,     0,     0,     0,     0,     0,   328,
       0,     0,     0,     0,    57,     0,     0,    58,    59,     0,
     160,   161,     0,     0,    60,    61,    62,    63,   624,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,   169,
     170,   171,   172,   173,   174,   175,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,   176,   177,    78,    79,     0,    94,    95,
      96,    97,    98,    99,   100,   101,   102,     0,    80,   103,
     104,    81,    82,    83,    84,    85,    86,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     194,     0,   105,     0,     0,     0,   106,     0,   107,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   108,   109,
     110,     0,     0,     0,     0,     0,     0,     0,   111,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    22,    23,    24,    25,
      26,    27,    28,     0,    29,   114,    30,     0,     0,    31,
       0,     0,     0,   118,    32,   119,   120,   121,     0,     0,
       0,   122,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,   326,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,   131,     0,     0,     0,     0,     0,   132,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,   135,     0,    53,     0,     0,   327,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,     0,     0,     0,    56,     0,     0,     0,
       0,     0,     0,   328,     0,     0,  1461,     0,    57,     0,
       0,    58,    59,     0,   160,   161,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,   169,   170,   171,   172,   173,   174,   175,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,   176,   177,    78,
      79,     0,    94,    95,    96,    97,    98,    99,   100,   101,
     102,     0,    80,   103,   104,    81,    82,    83,    84,    85,
      86,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   194,     0,   105,     0,     0,     0,
     106,     0,   107,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   108,   109,   110,     0,     0,     0,     0,     0,
       0,     0,   111,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      22,    23,    24,    25,    26,    27,    28,     0,    29,   114,
      30,     0,     0,    31,     0,     0,     0,   118,    32,   119,
     120,   121,     0,     0,     0,   122,     0,     0,    33,     0,
       0,     0,    34,    35,     0,    36,     0,     0,    37,   326,
       0,    38,     0,    39,     0,     0,    40,     0,     0,     0,
      41,    42,     0,    43,     0,   131,     0,     0,     0,     0,
       0,   132,     0,    44,     0,     0,     0,     0,     0,    45,
      46,    47,    48,    49,     0,    50,     0,     0,     0,    51,
      52,     0,     0,     0,     0,   135,     0,    53,     0,     0,
     327,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    54,    55,     0,     0,     0,
      56,     0,     0,     0,     0,     0,     0,   328,     0,     0,
    1657,     0,    57,     0,     0,    58,    59,     0,   160,   161,
       0,     0,    60,    61,    62,    63,     0,    64,    65,     0,
       0,     0,     0,     0,     0,     0,    66,   169,   170,   171,
     172,   173,   174,   175,     0,     0,    67,    68,     0,    69,
      70,    71,    72,    73,    74,     0,    75,    76,    77,     0,
       0,   176,   177,    78,    79,     0,    94,    95,    96,    97,
      98,    99,   100,   101,   102,     0,    80,   103,   104,    81,
      82,    83,    84,    85,    86,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   194,     0,
     105,     0,     0,     0,   106,     0,   107,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   108,   109,   110,     0,
       0,     0,     0,     0,     0,     0,   111,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    22,    23,    24,    25,    26,    27,
      28,     0,    29,   114,    30,     0,     0,    31,     0,     0,
       0,   118,    32,   119,   120,   121,     0,     0,     0,   122,
       0,     0,    33,     0,     0,     0,    34,    35,     0,    36,
       0,     0,    37,   326,     0,    38,     0,    39,     0,     0,
      40,     0,     0,     0,    41,    42,     0,    43,     0,   131,
       0,     0,     0,     0,     0,   132,     0,    44,     0,     0,
       0,     0,     0,    45,    46,    47,    48,    49,     0,    50,
       0,     0,     0,    51,    52,     0,     0,     0,     0,   135,
       0,    53,     0,     0,   327,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    54,
      55,     0,     0,     0,    56,     0,     0,     0,     0,     0,
       0,   328,     0,     0,     0,     0,    57,     0,     0,    58,
      59,     0,   160,   161,     0,     0,    60,    61,    62,    63,
       0,    64,    65,     0,     0,     0,     0,     0,     0,     0,
      66,   169,   170,   171,   172,   173,   174,   175,     0,     0,
      67,    68,     0,    69,    70,    71,    72,    73,    74,     0,
      75,    76,    77,     0,     0,   176,   177,    78,    79,     0,
      94,    95,    96,    97,    98,    99,   100,   101,   102,     0,
      80,   103,   104,    81,    82,    83,    84,    85,    86,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   194,     0,     0,     0,     0,     0,   106,     0,
     107,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   110,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    22,    23,
      24,    25,    26,    27,    28,     0,    29,   114,    30,     0,
       0,    31,     0,     0,     0,   118,    32,   119,   120,   121,
       0,     0,     0,   122,     0,     0,    33,     0,     0,     0,
      34,    35,     0,    36,     0,     0,    37,   326,     0,    38,
       0,    39,     0,     0,    40,     0,     0,     0,    41,    42,
       0,    43,     0,   131,     0,     0,     0,     0,     0,   132,
       0,    44,     0,     0,     0,     0,     0,    45,    46,    47,
      48,    49,     0,    50,     0,     0,     0,    51,    52,     0,
       0,     0,     0,   135,     0,    53,     0,     0,   327,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    54,    55,     0,     0,     0,    56,     0,
       0,     0,     0,     0,     0,   328,     0,     0,     0,     0,
      57,     0,     0,    58,    59,     0,   160,   161,     0,     0,
      60,    61,    62,    63,     0,    64,    65,     0,     0,     0,
       0,     0,     0,     0,    66,   169,   170,   171,   172,   173,
     174,   175,     0,     0,    67,    68,     0,    69,    70,    71,
      72,    73,    74,     0,    75,    76,    77,     0,     0,   176,
     177,    78,    79,     0,    21,   350,    96,    97,    98,    99,
     100,   101,     0,     0,    80,   103,   104,    81,    82,    83,
      84,    85,    86,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   194,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   864,   865,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    22,    23,    24,    25,    26,    27,    28,     0,
      29,   114,    30,     0,     0,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,   326,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,     0,
       0,     0,    56,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    57,     0,     0,    58,    59,  1704,
       0,     0,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
     170,   171,   172,   173,   174,   175,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,    21,   350,
      96,    97,    98,    99,   100,   101,     0,     0,    80,   103,
     104,    81,    82,    83,    84,    85,    86,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     866,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,   864,   865,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    22,    23,    24,    25,
      26,    27,    28,     0,    29,   114,    30,     0,     0,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,   326,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,     0,    94,   350,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,   170,   171,   172,   173,   174,   175,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,     0,    22,    23,    24,    25,    26,    27,    28,     0,
      29,     0,    30,     0,   866,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,     0,     0,    38,   127,    39,   477,     0,    40,     0,
       0,     0,    41,    42,   130,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,     0,
      21,   350,    56,     0,     0,     0,     0,     0,     0,   668,
       0,     0,     0,     0,    57,     0,     0,    58,    59,     0,
       0,     0,   162,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    80,     0,
       0,    81,    82,    83,    84,    85,    86,     0,    22,    23,
      24,    25,    26,    27,    28,     0,    29,     0,    30,     0,
     850,    31,     0,     0,     0,     0,    32,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    33,     0,     0,     0,
      34,    35,     0,    36,     0,     0,    37,     0,     0,    38,
     127,    39,   477,     0,    40,     0,     0,     0,    41,    42,
     130,    43,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    44,     0,     0,     0,     0,     0,    45,    46,    47,
      48,    49,     0,    50,     0,     0,     0,    51,    52,     0,
       0,     0,     0,     0,     0,    53,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    54,    55,     0,    21,   350,    56,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      57,     0,     0,    58,    59,     0,     0,     0,   162,     0,
      60,    61,    62,    63,     0,    64,    65,     0,     0,     0,
       0,     0,     0,     0,    66,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    67,    68,     0,    69,    70,    71,
      72,    73,    74,     0,    75,    76,    77,     0,     0,     0,
       0,    78,    79,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    80,     0,     0,    81,    82,    83,
      84,    85,    86,     0,    22,    23,    24,    25,    26,    27,
      28,     0,    29,     0,    30,     0,   953,    31,     0,     0,
       0,     0,    32,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    33,     0,     0,     0,    34,    35,     0,    36,
       0,     0,    37,     0,     0,    38,   127,    39,   477,     0,
      40,     0,     0,     0,    41,    42,   130,    43,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    44,     0,     0,
       0,     0,     0,    45,    46,    47,    48,    49,     0,    50,
       0,     0,     0,    51,    52,     0,     0,     0,     0,     0,
       0,    53,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    54,
      55,     0,    21,   350,    56,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    57,     0,     0,    58,
      59,     0,     0,     0,   162,     0,    60,    61,    62,    63,
       0,    64,    65,     0,     0,     0,     0,     0,     0,     0,
      66,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      67,    68,     0,    69,    70,    71,    72,    73,    74,     0,
      75,    76,    77,     0,     0,     0,     0,    78,    79,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      80,     0,     0,    81,    82,    83,    84,    85,    86,     0,
      22,    23,    24,    25,    26,    27,    28,     0,    29,     0,
      30,     0,  1208,    31,     0,     0,     0,     0,    32,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    33,     0,
       0,     0,    34,    35,     0,    36,     0,     0,    37,     0,
       0,    38,     0,    39,     0,     0,    40,     0,     0,     0,
      41,    42,     0,    43,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    44,     0,     0,     0,     0,     0,    45,
      46,    47,    48,    49,     0,    50,     0,     0,     0,    51,
      52,     0,     0,     0,     0,     0,     0,    53,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    54,    55,     0,    94,     0,
      56,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    57,     0,     0,    58,    59,     0,     0,     0,
       0,     0,    60,    61,    62,    63,     0,    64,    65,     0,
       0,     0,     0,     0,     0,     0,    66,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    67,    68,     0,    69,
      70,    71,    72,    73,    74,     0,    75,    76,    77,     0,
       0,     0,     0,    78,    79,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    80,     0,     0,    81,
      82,    83,    84,    85,    86,     0,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,   355,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,     0,    94,   350,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,   415,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,     0,    22,    23,    24,    25,    26,    27,    28,     0,
      29,     0,    30,     0,   416,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,     0,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,     0,
      21,   350,    56,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    57,     0,     0,    58,    59,     0,
       0,     0,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    80,     0,
       0,    81,    82,    83,    84,    85,    86,     0,    22,    23,
      24,    25,    26,    27,    28,     0,    29,     0,    30,     0,
     850,    31,     0,     0,     0,     0,    32,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    33,     0,     0,     0,
      34,    35,     0,    36,     0,     0,    37,     0,     0,    38,
       0,    39,     0,     0,    40,     0,     0,     0,    41,    42,
       0,    43,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    44,     0,     0,     0,     0,     0,    45,    46,    47,
      48,    49,     0,    50,     0,     0,     0,    51,    52,     0,
       0,     0,     0,     0,     0,    53,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    54,    55,     0,    21,   350,    56,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      57,     0,     0,    58,    59,     0,     0,     0,     0,     0,
      60,    61,    62,    63,     0,    64,    65,     0,     0,     0,
       0,     0,     0,     0,    66,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    67,    68,     0,    69,    70,    71,
      72,    73,    74,     0,    75,    76,    77,     0,     0,     0,
       0,    78,    79,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    80,     0,     0,    81,    82,    83,
      84,    85,    86,     0,    22,    23,    24,    25,    26,    27,
      28,     0,    29,     0,    30,     0,   903,    31,     0,     0,
       0,     0,    32,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    33,     0,     0,     0,    34,    35,     0,    36,
       0,     0,    37,     0,     0,    38,     0,    39,     0,     0,
      40,     0,     0,     0,    41,    42,     0,    43,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    44,     0,     0,
       0,     0,     0,    45,    46,    47,    48,    49,     0,    50,
       0,     0,     0,    51,    52,     0,     0,     0,     0,     0,
       0,    53,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    54,
      55,     0,    94,     0,    56,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    57,     0,     0,    58,
      59,     0,     0,     0,     0,     0,    60,    61,    62,    63,
       0,    64,    65,     0,     0,     0,     0,     0,     0,     0,
      66,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      67,    68,     0,    69,    70,    71,    72,    73,    74,     0,
      75,    76,    77,     0,     0,     0,     0,    78,    79,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      80,     0,     0,    81,    82,    83,    84,    85,    86,     0,
      22,    23,    24,    25,    26,    27,    28,     0,    29,     0,
      30,     0,  1009,    31,     0,     0,     0,     0,    32,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    33,     0,
       0,     0,    34,    35,     0,    36,     0,     0,    37,     0,
       0,    38,     0,    39,     0,     0,    40,     0,     0,     0,
      41,    42,     0,    43,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    44,     0,     0,     0,     0,     0,    45,
      46,    47,    48,    49,     0,    50,     0,     0,     0,    51,
      52,     0,     0,     0,     0,     0,     0,    53,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    54,    55,     0,    21,     0,
      56,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    57,     0,     0,    58,    59,     0,     0,     0,
       0,     0,    60,    61,    62,    63,     0,    64,    65,     0,
       0,     0,     0,     0,     0,     0,    66,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    67,    68,     0,    69,
      70,    71,    72,    73,    74,     0,    75,    76,    77,     0,
       0,     0,     0,    78,    79,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    80,     0,     0,    81,
      82,    83,    84,    85,    86,     0,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,   416,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,     0,     0,     0,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,     0,     0,     0,     0,    21,   350,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,   532,   533,   534,   535,   536,   537,   538,   539,   540,
     541,   542,    80,     0,     0,    81,    82,    83,    84,    85,
      86,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   769,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,   543,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
     922,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,    21,   350,     0,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,     0,    32,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
     380,     0,    38,     0,    39,   381,     0,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    44,     0,     0,   382,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,     0,     0,     0,     0,     0,     0,    53,     0,
       0,     0,     0,     0,     0,   383,   384,   385,   138,   139,
     386,   387,     0,     0,     0,     0,    54,    55,    21,     0,
       0,    56,     0,     0,     0,     0,   102,     0,     0,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
       0,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,   118,    32,   119,   120,   121,     0,     0,
       0,   122,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,   132,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,  1259,     0,
       0,   135,     0,    53,     0,     0,   327,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,    21,     0,     0,    56,     0,     0,     0,
       0,   102,     0,   328,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,   118,    32,
     119,   120,   121,     0,     0,     0,   122,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,     0,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,   132,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,     0,     0,     0,     0,   135,     0,    53,     0,
       0,   327,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    54,    55,    21,     0,
       0,    56,     0,     0,     0,     0,   102,     0,   328,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
       0,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,   118,    32,   119,   120,   121,     0,     0,
       0,   122,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,   132,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,   135,     0,    53,     0,     0,   327,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,    21,   350,     0,    56,     0,     0,     0,
       0,     0,     0,   328,     0,     0,     0,     0,   566,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,   946,    66,     0,     0,     0,     0,     0,     0,  1087,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,     0,    32,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,     0,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,     0,     0,     0,     0,     0,     0,    53,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,  1088,  1089,     0,     0,     0,    54,    55,    21,     0,
       0,    56,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
       0,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,  1229,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,  1230,     0,
       0,    54,    55,    21,   350,     0,    56,     0,     0,     0,
       0,     0,     0,   668,     0,     0,     0,     0,    57,     0,
       0,    58,    59,  1231,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,   946,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,     0,    32,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,     0,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,  1162,     0,     0,
      51,    52,     0,     0,     0,     0,     0,     0,    53,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    54,    55,    21,     0,
       0,    56,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
       0,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,  1366,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,  1230,     0,
       0,    54,    55,    21,   350,     0,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,  1231,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,     0,    32,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,     0,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,     0,     0,     0,     0,     0,     0,    53,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,   351,     0,     0,    54,    55,    21,   350,
       0,    56,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
       0,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,   600,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,    21,   350,     0,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,     0,    32,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,     0,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,   602,     0,     0,     0,     0,     0,    53,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    54,    55,    21,   350,
       0,    56,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
       0,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,   604,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,    21,   350,     0,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,     0,    32,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,     0,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,   606,     0,     0,     0,     0,     0,    53,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    54,    55,    21,   350,
       0,    56,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
     779,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,    21,   350,     0,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,   946,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,     0,    32,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,     0,    40,     0,     0,
       0,    41,    42,     0,    43,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,     0,     0,     0,     0,     0,     0,    53,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    54,    55,    21,   350,
       0,    56,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
    1007,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,    22,    23,    24,    25,
      26,    27,    28,     0,    29,     0,    30,     0,     0,    31,
       0,     0,     0,     0,    32,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    33,     0,     0,     0,    34,    35,
       0,    36,     0,     0,    37,     0,     0,    38,     0,    39,
       0,     0,    40,     0,     0,     0,    41,    42,     0,    43,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    44,
       0,     0,     0,     0,     0,    45,    46,    47,    48,    49,
       0,    50,     0,     0,     0,    51,    52,     0,     0,     0,
       0,     0,     0,    53,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,    54,    55,    21,   350,     0,    56,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    57,     0,
       0,    58,    59,     0,     0,     0,     0,     0,    60,    61,
      62,    63,     0,    64,    65,     0,     0,     0,     0,     0,
       0,     0,    66,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    67,    68,     0,    69,    70,    71,    72,    73,
      74,     0,    75,    76,    77,     0,     0,     0,     0,    78,
      79,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    80,     0,     0,    81,    82,    83,    84,    85,
      86,    22,    23,    24,    25,    26,    27,    28,     0,    29,
       0,    30,     0,     0,    31,     0,     0,     0,     0,    32,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    33,
       0,     0,     0,    34,    35,     0,    36,     0,     0,    37,
       0,     0,    38,     0,    39,     0,     0,    40,     0,     0,
       0,    41,    42,     0,    43,   922,     0,     0,     0,     0,
       0,     0,     0,     0,    44,     0,     0,     0,     0,     0,
      45,    46,    47,    48,    49,     0,    50,     0,     0,     0,
      51,    52,     0,     0,     0,     0,     0,     0,    53,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    54,    55,     0,    21,
     350,    56,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    57,     0,     0,    58,    59,     0,     0,
       0,     0,     0,    60,    61,    62,    63,     0,    64,    65,
       0,     0,     0,     0,     0,     0,     0,    66,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    67,    68,     0,
      69,    70,    71,    72,    73,    74,     0,    75,    76,    77,
    1195,     0,     0,     0,    78,    79,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    80,     0,     0,
      81,    82,    83,    84,    85,    86,     0,    22,    23,    24,
      25,    26,    27,    28,     0,    29,     0,    30,     0,     0,
      31,     0,     0,     0,     0,    32,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    33,     0,     0,     0,    34,
      35,     0,    36,     0,     0,    37,     0,     0,    38,     0,
      39,     0,     0,    40,     0,     0,     0,    41,    42,     0,
      43,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      44,     0,     0,     0,     0,     0,    45,    46,    47,    48,
      49,     0,    50,     0,     0,     0,    51,    52,     0,     0,
       0,     0,     0,     0,    53,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    54,    55,    21,     0,     0,    56,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    57,
       0,     0,    58,    59,     0,     0,     0,     0,     0,    60,
      61,    62,    63,     0,    64,    65,     0,     0,     0,     0,
       0,     0,     0,    66,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    67,    68,     0,    69,    70,    71,    72,
      73,    74,     0,    75,    76,    77,     0,     0,     0,     0,
      78,    79,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    80,     0,     0,    81,    82,    83,    84,
      85,    86,    22,    23,    24,    25,    26,    27,    28,     0,
      29,     0,    30,     0,     0,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,     0,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,  1230,     0,     0,    54,    55,    21,
     350,     0,    56,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    57,     0,     0,    58,    59,  1231,
       0,     0,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    80,     0,
       0,    81,    82,    83,    84,    85,    86,    22,    23,    24,
      25,    26,    27,    28,     0,    29,     0,    30,     0,     0,
      31,     0,     0,     0,     0,    32,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    33,     0,     0,     0,    34,
      35,     0,    36,     0,     0,    37,     0,     0,    38,     0,
      39,     0,     0,    40,     0,     0,     0,    41,    42,     0,
      43,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      44,     0,     0,     0,     0,     0,    45,    46,    47,    48,
      49,     0,    50,     0,     0,     0,    51,    52,     0,     0,
       0,     0,     0,     0,    53,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    54,    55,    21,     0,     0,    56,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    57,
       0,     0,    58,    59,   377,     0,     0,     0,     0,    60,
      61,    62,    63,     0,    64,    65,     0,     0,     0,     0,
       0,     0,     0,    66,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    67,    68,     0,    69,    70,    71,    72,
      73,    74,     0,    75,    76,    77,     0,     0,     0,     0,
      78,    79,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    80,     0,     0,    81,    82,    83,    84,
      85,    86,    22,    23,    24,    25,    26,    27,    28,     0,
      29,     0,    30,     0,     0,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,     0,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,    21,
       0,     0,    56,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    57,     0,     0,    58,    59,     0,
       0,     0,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    80,     0,
       0,    81,    82,    83,    84,    85,    86,    22,    23,    24,
      25,    26,    27,    28,     0,    29,     0,    30,     0,     0,
      31,     0,     0,     0,     0,    32,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    33,     0,     0,     0,    34,
      35,     0,    36,     0,     0,    37,     0,     0,    38,     0,
      39,     0,     0,    40,     0,     0,     0,    41,    42,     0,
      43,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      44,     0,     0,     0,     0,     0,    45,    46,    47,    48,
      49,     0,    50,     0,     0,     0,    51,    52,     0,     0,
       0,     0,     0,     0,    53,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    54,    55,    21,     0,     0,    56,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    57,
       0,     0,    58,    59,     0,     0,     0,     0,     0,    60,
      61,    62,    63,     0,    64,    65,     0,     0,     0,     0,
       0,     0,     0,    66,     0,   403,     0,     0,     0,     0,
       0,     0,     0,    67,    68,     0,    69,    70,    71,    72,
      73,    74,     0,    75,    76,    77,     0,     0,     0,     0,
      78,    79,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    80,     0,     0,    81,    82,    83,    84,
      85,    86,    22,    23,    24,    25,    26,    27,    28,     0,
      29,     0,    30,     0,     0,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,     0,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,    21,
       0,     0,    56,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   411,     0,     0,    58,    59,     0,
       0,     0,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
     403,     0,     0,     0,     0,     0,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    80,     0,
       0,    81,    82,    83,    84,    85,    86,    22,    23,    24,
      25,    26,    27,    28,     0,    29,     0,    30,     0,     0,
      31,     0,     0,     0,     0,    32,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    33,     0,     0,     0,    34,
      35,     0,    36,     0,     0,    37,     0,     0,    38,     0,
      39,     0,     0,    40,     0,     0,     0,    41,    42,     0,
      43,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      44,     0,     0,     0,     0,     0,    45,    46,    47,    48,
      49,     0,    50,     0,     0,     0,    51,    52,     0,     0,
       0,     0,     0,     0,    53,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    54,    55,    21,     0,     0,    56,     0,     0,
       0,     0,     0,     0,   668,     0,     0,     0,     0,    57,
       0,     0,    58,    59,     0,     0,     0,     0,     0,    60,
      61,    62,    63,     0,    64,    65,     0,     0,     0,     0,
       0,     0,     0,    66,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    67,    68,     0,    69,    70,    71,    72,
      73,    74,     0,    75,    76,    77,     0,     0,     0,     0,
      78,    79,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    80,     0,     0,    81,    82,    83,    84,
      85,    86,    22,    23,    24,    25,    26,    27,    28,     0,
      29,     0,    30,     0,     0,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,     0,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,    21,
       0,     0,    56,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,   700,     0,     0,    58,    59,     0,
       0,     0,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
     403,     0,     0,     0,     0,     0,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    80,     0,
       0,    81,    82,    83,    84,    85,    86,    22,    23,    24,
      25,    26,    27,    28,     0,    29,     0,    30,     0,     0,
      31,     0,     0,     0,     0,    32,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    33,     0,     0,     0,    34,
      35,     0,    36,     0,     0,    37,     0,     0,    38,     0,
      39,     0,     0,    40,     0,     0,     0,    41,    42,     0,
      43,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      44,     0,     0,     0,     0,     0,    45,    46,    47,    48,
      49,     0,    50,     0,     0,     0,    51,    52,     0,     0,
       0,     0,     0,     0,    53,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    54,    55,    21,     0,     0,    56,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    57,
       0,     0,    58,    59,   917,     0,     0,     0,     0,    60,
      61,    62,    63,     0,    64,    65,     0,     0,     0,     0,
       0,     0,     0,    66,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    67,    68,     0,    69,    70,    71,    72,
      73,    74,     0,    75,    76,    77,     0,     0,     0,     0,
      78,    79,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    80,     0,     0,    81,    82,    83,    84,
      85,    86,    22,    23,    24,    25,    26,    27,    28,     0,
      29,     0,    30,     0,     0,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,     0,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,    21,
       0,     0,    56,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,  1001,     0,     0,    58,    59,     0,
       0,     0,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
     403,     0,     0,     0,     0,     0,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    80,     0,
       0,    81,    82,    83,    84,    85,    86,    22,    23,    24,
      25,    26,    27,    28,     0,    29,     0,    30,     0,     0,
      31,     0,     0,     0,     0,    32,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    33,     0,     0,     0,    34,
      35,     0,    36,     0,     0,    37,     0,     0,    38,     0,
      39,     0,     0,    40,     0,     0,     0,    41,    42,     0,
      43,  1429,     0,     0,     0,     0,     0,     0,     0,     0,
      44,     0,     0,     0,     0,     0,    45,    46,    47,    48,
      49,     0,    50,     0,     0,     0,    51,    52,     0,     0,
       0,     0,     0,     0,    53,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    54,    55,    21,     0,     0,    56,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,    57,
       0,     0,    58,    59,     0,     0,     0,     0,     0,    60,
      61,    62,    63,     0,    64,    65,     0,     0,     0,     0,
       0,     0,     0,    66,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    67,    68,     0,    69,    70,    71,    72,
      73,    74,     0,    75,    76,    77,     0,     0,     0,     0,
      78,    79,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    80,     0,     0,    81,    82,    83,    84,
      85,    86,    22,    23,    24,    25,    26,    27,    28,     0,
      29,     0,    30,     0,     0,    31,     0,     0,     0,     0,
      32,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      33,     0,     0,     0,    34,    35,     0,    36,     0,     0,
      37,     0,     0,    38,     0,    39,     0,     0,    40,     0,
       0,     0,    41,    42,     0,    43,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    44,     0,     0,     0,     0,
       0,    45,    46,    47,    48,    49,     0,    50,     0,     0,
       0,    51,    52,     0,     0,     0,     0,     0,     0,    53,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    54,    55,     0,
       0,     0,    56,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    57,     0,     0,    58,    59,     0,
       0,     0,     0,     0,    60,    61,    62,    63,     0,    64,
      65,     0,     0,     0,     0,     0,     0,     0,    66,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    67,    68,
       0,    69,    70,    71,    72,    73,    74,     0,    75,    76,
      77,     0,     0,     0,     0,    78,    79,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    80,     0,
       0,    81,    82,    83,    84,    85,    86,  1064,     0,   493,
     494,   495,   496,   497,   498,   499,   500,   501,   502,   503,
     504,   505,   506,   507,   508,   509,   510,   511,   512,   513,
     514,   515,   516,   517,   518,   519,   520,   521,   522,     0,
       0,     0,     0,     0,     0,   523,     0,     0,   524,   525,
     526,   527,   528,   529,   530,   531,   493,   494,   495,   496,
     497,   498,   499,   500,   501,   502,   503,   504,   505,   506,
     507,   508,   509,   510,   511,   512,   513,   514,   515,   516,
     517,   518,   519,   520,   521,   522,     0,     0,     0,     0,
       0,     0,   523,     0,     0,   524,   525,   526,   527,   528,
     529,   530,   531
};

static const yytype_int16 yycheck[] =
{
      13,    13,    13,   227,   227,    13,   246,    12,   227,    13,
     426,   251,   185,   253,    10,    13,   117,   359,   324,   162,
       0,   152,   682,     3,    15,   379,   561,   580,   487,     9,
     583,   159,   370,   693,   907,   864,   865,   393,   394,   580,
     415,   105,   583,   144,   108,   109,   953,   111,   708,  1056,
     995,   919,   650,   558,   372,   750,   559,  1155,   317,   851,
     852,   895,  1318,   592,   593,   972,   858,   572,   986,  1520,
     573,   984,    13,   986,   609,  1362,  1472,   685,   927,     0,
    1342,    40,    40,   850,    41,   842,    13,    37,    23,    37,
    1508,    70,     3,     7,     8,    91,   939,    41,  1110,   120,
      11,  1162,    72,  1681,   101,  1135,   331,     0,   145,  1687,
     132,     3,   119,    41,   172,    60,  1333,   117,   117,    11,
     175,   427,  1740,   131,   118,   133,   134,    98,   175,   123,
     261,   175,    72,  1078,   663,  1080,  1081,   131,   123,   133,
      41,   135,   299,   151,   901,   256,   131,   191,  1904,   143,
       0,    72,   256,   175,   125,     0,   112,    35,   118,   926,
     289,  1739,   153,   123,   233,   193,  1922,  1923,   196,   698,
     256,   131,   843,   290,   181,   175,  1754,   381,   175,    72,
      41,   133,   133,   135,   135,   193,   194,   143,   299,   172,
     194,   143,   143,    72,   177,   299,   571,   108,   109,   110,
     111,   112,   113,   114,   115,   116,    72,   299,   179,   340,
      76,    72,   299,   299,  1470,  1432,   108,   109,   110,   111,
     112,   113,   114,   115,   116,   368,     0,    72,  1806,   223,
     299,   902,  1850,    41,   299,   439,   181,    98,   223,   768,
     197,   102,   300,   903,   145,   300,   253,   776,   193,   256,
     249,   250,   299,   197,   132,   299,   479,   208,   298,   484,
     391,   392,   299,    71,   125,   193,   127,  1297,   299,   221,
     221,  1849,   415,    11,   295,   245,    72,   299,   406,   301,
    1187,   148,   148,   411,    26,    27,    28,    29,    30,    31,
      32,    33,    34,    35,    36,   212,   246,   713,    72,   216,
      72,  1208,   299,  1032,   133,  1034,   135,  1156,   548,   549,
     550,   551,   299,   866,   143,   323,   324,  1378,   179,   492,
     316,   300,   299,  1579,   245,   866,   237,  1339,   684,   683,
     244,   118,   167,  1176,    76,   122,   711,    72,   173,   693,
     297,   197,   300,   302,   209,   237,  1608,   355,   298,   184,
     298,   359,   245,   297,   367,   367,   367,   365,   489,  1615,
    1778,   369,  1129,   367,   299,  1372,   245,  1201,   289,   299,
     291,   292,   980,   111,   112,   113,   114,   115,   116,   377,
      72,  1777,   247,  1670,   245,  1672,   251,   252,   299,   387,
     247,  1842,   299,    72,   251,  1682,  1683,   290,   291,   292,
     245,   133,   132,   135,   118,   413,   414,   299,    72,   123,
    1666,   143,   291,   292,    95,   118,   148,   296,   416,   427,
     123,     7,     8,  1841,   428,   928,   367,   570,   571,   493,
     494,   495,   496,   497,   498,   499,   500,   501,   502,   503,
     367,   747,   506,   507,  1862,   290,   291,   292,   299,   245,
     514,   515,   516,   517,   518,   519,   520,   521,   522,   183,
     524,   525,   526,   527,   528,   529,   530,   531,    72,  1226,
    1319,   245,   151,   245,    95,   210,    22,    23,    24,    25,
     471,   297,    95,   299,    72,  1741,   150,   151,   212,   221,
     293,   294,   216,   847,  1328,   291,   292,   293,   294,   299,
    1418,   299,  1370,  1601,    72,  1418,   231,   608,   233,    72,
     245,   124,    72,   134,   186,   187,   290,   291,   292,   291,
     292,   134,   294,   299,   532,   533,   534,   535,   536,   537,
     538,   539,   540,   541,   542,   543,   299,   668,  1330,  1331,
      59,   895,   206,   147,   301,   300,   150,   151,   303,   903,
     171,   559,   299,   245,    72,  1423,   291,   292,   171,   299,
     568,   303,   122,   917,   918,   573,   245,   921,   711,   214,
     876,   172,   700,  1268,   702,  1104,  1174,   919,   223,   224,
     299,   245,   590,   151,   299,   576,   214,   578,   151,   569,
     691,   138,   948,   112,   113,   949,   224,   289,   290,   291,
     292,   774,   733,   862,   863,   613,    68,    69,    70,    71,
      72,    73,   291,   292,   159,   746,   296,   748,   936,   264,
     265,   247,   295,  1128,  1127,   251,   252,   291,   292,   214,
     984,  1538,   986,   151,   150,   151,   264,   265,   223,   224,
     648,   245,   650,   150,   151,   147,  1553,  1003,   150,   151,
    1518,    70,    65,    66,    67,  1504,   664,   245,   666,   296,
     673,    74,   653,    74,    77,   673,    77,   671,   451,   452,
     453,   454,   455,   456,   457,   458,   459,   245,   580,   264,
     265,   583,   245,    70,   692,   245,   296,   291,   292,   280,
     281,   282,   283,   284,   285,   167,  1231,  1232,  1643,  1053,
    1298,   162,   163,   291,   292,   696,   697,   850,   699,    26,
      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
     193,   194,   195,   291,   292,   296,  1633,   245,   291,   292,
     122,   291,   292,  1640,   152,  1091,    95,   155,  1092,   747,
     296,     5,     6,     7,     8,  1618,    10,   165,   249,   250,
      14,    15,   257,   258,   259,  1130,   174,   296,   176,    76,
     124,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,   299,   291,   292,   167,  1783,    85,    86,    87,
      88,   173,   762,   926,   299,   152,    12,    13,   155,  1342,
     798,   799,   184,   303,   798,   799,   100,   101,   165,    63,
      64,  1342,  1567,  1568,  1569,  1570,  1571,   174,  1162,   176,
    1164,    76,   181,    76,  1721,    26,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    36,  1699,     3,   836,   837,
      76,  1004,   299,  1171,   842,   157,   844,   208,   842,   843,
     303,  1300,   296,   299,   118,   210,   850,  1201,  1677,   123,
     183,   299,   850,   849,   303,   846,   303,   131,    35,   133,
    1216,   135,    10,  1217,  1713,    76,   130,   187,   876,   143,
      97,   148,    72,  1001,    99,    26,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    36,     5,     6,   129,  1424,
     135,    10,   172,   901,    59,    14,    15,  1028,    70,    59,
     908,  1032,   882,  1034,    63,    64,    65,    66,    67,    70,
     299,   919,   142,   143,   144,    74,    70,   175,    77,   175,
     928,  1581,   930,   931,  1773,    76,  1755,  1756,   231,   232,
     233,   232,    10,  1782,   216,    37,   303,   280,   281,   282,
     283,   284,   285,    95,    73,  1251,   299,   221,   299,   223,
     150,   151,   104,   158,   952,   738,   739,   937,   168,   957,
     596,   597,   598,   976,   299,   296,   302,  1110,   976,   299,
     974,  1327,   124,   300,  1328,    61,    62,    63,    64,    65,
      66,    67,   134,   299,   301,   303,  1129,  1130,    74,   300,
     262,    77,   262,   262,   262,    81,   994,   132,    84,  1063,
    1064,   156,   132,   303,   132,  1009,   206,  1011,   132,   132,
     210,   300,  1020,  1011,  1022,  1023,   299,   148,   170,   171,
     216,   300,   303,   133,  1378,   212,   212,   179,  1370,   193,
     155,     3,   148,   299,   296,   300,   188,   189,   299,    11,
     148,   132,   299,  1051,   225,   245,   300,  1403,  1053,   300,
     300,  1405,   300,    37,  1050,  1608,   303,   300,   117,  1415,
     122,   303,   299,  1419,  1418,   303,  1074,  1608,   300,   300,
      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
      36,  1423,  1742,   300,   300,   300,   300,   300,   151,   300,
     122,   291,   292,   293,   294,   262,     4,     5,    26,    27,
      28,    29,    30,    31,    32,    33,    34,    35,    36,   299,
      18,    19,   141,   298,   303,    73,    36,    74,  1472,  1127,
      76,   169,   302,   133,  1677,  1133,   121,   151,   100,   299,
     151,   151,   151,   302,   300,  1131,   108,   109,   110,   111,
     112,   113,   114,   115,   116,  1153,   299,   294,    76,   300,
      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
      36,   299,    94,   299,   303,  1825,  1174,   299,    37,   172,
     148,  1179,    40,   300,   300,    40,  1518,    41,   300,   149,
     147,  1177,   303,   303,  1540,   302,   118,  1541,   206,   303,
     218,   123,   299,  1549,   300,  1175,  1339,   148,   299,   131,
      76,   133,   100,   135,   136,   246,   102,   115,   116,   117,
     102,   143,  1210,   103,   303,   123,   300,   125,  1226,   300,
     151,   193,   151,   300,   151,   300,   300,   226,   136,   137,
     299,    60,   140,   141,   142,   143,   144,   145,   146,   100,
     300,   277,   150,  1251,   152,  1250,   303,    94,   156,   209,
     300,   159,   158,    73,   162,   299,  1357,   165,   300,   175,
     300,  1677,   300,   300,   303,   237,   300,   300,   303,   151,
     154,   118,  1280,   303,   300,   183,   123,   300,   186,   187,
     154,   303,   155,   215,   131,   300,   133,  1278,   135,   221,
    1298,   223,   300,  1301,   300,   302,   143,   140,   262,    37,
    1473,   117,   300,   175,   300,  1313,   300,   233,   299,   157,
    1318,  1442,  1443,   300,   303,  1446,  1447,    26,    27,    28,
      29,    30,    31,    32,    33,    34,    35,    36,    26,    27,
      28,    29,    30,    31,    32,    33,    34,    35,    36,   247,
     150,    76,   175,    36,   300,   300,   300,   102,   151,   301,
     303,   300,  1356,   261,   300,   303,   300,   299,   299,   299,
     303,   300,  1370,   300,   296,   300,   300,    76,   215,   102,
     300,    59,   300,   145,   221,   300,   223,    60,    76,    60,
     145,   145,   303,   298,  1392,   298,   298,   298,   298,  1385,
     100,   298,   301,    99,    99,   300,   299,  1395,   299,  1390,
      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
      36,   300,   303,  1421,   161,  1423,   296,   300,   303,   300,
     177,   300,   300,  1777,   300,   300,   262,   158,   299,   260,
     296,  1532,   340,   341,   342,   343,   344,   299,   180,   299,
     151,   300,   299,   351,    37,    40,   354,   300,   303,   296,
      76,   300,  1460,    41,   193,    40,   300,   303,  1466,   300,
     300,   299,  1470,   300,   299,   299,   296,  1472,   102,   377,
     260,   299,  1480,   299,   382,   383,   299,   151,   386,    96,
     299,    74,   299,   391,   392,   300,   300,   181,   396,   300,
     299,   299,   117,   300,   139,   172,    41,   216,   406,   300,
      60,   300,  1493,   411,   300,    98,   210,   415,   101,   102,
    1518,  1612,   300,    99,   299,   423,  1524,  1525,    99,   299,
      97,   300,     3,    91,   151,   299,  1517,  1535,   151,   300,
      11,   145,   145,   126,   300,  1543,  1527,    26,    27,    28,
      29,    30,    31,    32,    33,    34,    35,    36,    26,    27,
      28,    29,    30,    31,    32,    33,    34,    35,    36,   303,
     300,   120,   470,   300,   300,   299,  1574,   299,   298,    99,
      91,  1579,   300,   166,   303,   483,   300,   300,   486,   300,
     300,   489,   490,   300,  1592,   178,   179,    76,   300,    36,
      92,   300,   300,   300,   261,  1603,   299,   299,    76,   300,
     299,  1702,   300,   300,   145,   145,    13,  1615,   303,   300,
     300,    12,    93,   151,   126,   523,    26,    27,    28,    29,
      30,    31,    32,    33,    34,    35,    36,   108,   109,   110,
     111,   112,   113,   114,   115,   116,   544,   300,   231,   299,
     233,  1864,   300,   300,   147,  1864,   299,   175,   300,   210,
     300,   300,  1876,   246,   300,    92,  1896,  1876,  1666,  1667,
    1883,   300,   570,   571,  1883,  1656,    76,   296,   175,   216,
     296,   233,   580,    37,   582,   583,   300,   585,    26,    27,
      28,    29,    30,    31,    32,    33,    34,    35,    36,    26,
      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
     608,   216,   610,  1707,   301,   298,  1714,   151,   254,   301,
      74,   619,   301,   255,   301,   117,     3,   625,   117,   123,
     118,    13,     8,  1752,  1588,  1852,   367,   367,    76,   367,
     367,  1399,  1894,  1741,    98,  1891,  1250,   101,   102,    76,
     116,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,  1760,   217,  1060,   679,   237,  1161,  1011,   667,
     668,  1785,   126,   671,  1772,  1714,  1786,   489,   676,   677,
    1084,  1311,  1777,  1110,   682,  1313,   988,   227,  1085,  1113,
    1545,   227,   799,   691,  1408,   693,  1537,    13,   976,   373,
     373,    76,   700,   373,   702,   373,    36,     3,   373,   373,
     708,   709,   147,   711,  1180,    11,  1395,  1883,   179,   367,
     367,   300,   317,    53,   178,   179,     3,  1301,  1133,    -1,
    1730,    -1,   300,   731,    11,   733,   734,    -1,    -1,    -1,
      -1,  1839,    -1,    -1,    -1,    -1,    -1,    -1,   746,    -1,
     748,   749,   750,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,  1864,  1864,  1864,    -1,    95,    96,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   231,    -1,   233,
    1883,  1883,  1883,    -1,    -1,   160,    -1,    -1,   118,   164,
      -1,    -1,   246,    -1,    -1,   125,    -1,    93,   128,    -1,
     300,   131,    -1,    -1,    -1,   135,    -1,    -1,    -1,   139,
      -1,    -1,   108,   109,   110,   111,   112,   113,   114,   115,
     116,    -1,    -1,    -1,    -1,   155,    -1,    -1,    -1,    -1,
      -1,   108,   109,   110,   111,   112,   113,   114,   115,   116,
      -1,    -1,    -1,    -1,   298,    -1,    -1,    -1,    -1,   847,
      -1,    -1,   850,   851,   852,    -1,    -1,    -1,    -1,    -1,
     858,    -1,   300,    -1,    -1,    -1,    -1,    -1,   866,    -1,
      -1,    -1,    -1,   300,    -1,    26,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    36,   216,    -1,    -1,    -1,
     220,    -1,    -1,   891,   892,   893,   894,   895,   896,   897,
     898,   899,    -1,    -1,    -1,   903,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   123,    -1,   125,    -1,
      -1,    -1,    -1,   921,   922,    76,    -1,    -1,   926,   136,
     137,    -1,    -1,    -1,    -1,    -1,   143,    -1,    -1,    -1,
      -1,   237,    -1,    -1,    -1,    -1,   944,    -1,   946,    -1,
      -1,    -1,    -1,    -1,    -1,   953,   286,   287,    -1,    -1,
     237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   967,
      -1,    -1,    -1,    -1,   972,    -1,   974,    -1,    -1,  1680,
      -1,    -1,    -1,  1684,  1685,    -1,   984,    -1,   986,    -1,
     988,    -1,    -1,    -1,    -1,    -1,   994,    -1,    -1,    -1,
     151,    -1,    -1,  1001,    -1,    -1,    -1,  1005,    -1,    -1,
      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
      36,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    1028,    -1,    -1,    -1,  1032,    -1,  1034,    -1,    -1,    -1,
     247,  1039,    -1,  1041,  1042,  1043,  1044,  1045,  1046,  1047,
      -1,    -1,  1753,    -1,    -1,    -1,  1757,  1758,  1759,    -1,
      76,    -1,  1763,  1764,  1765,    -1,    -1,  1768,    -1,    -1,
      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
      36,  1079,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,  1093,    26,    27,    28,    29,
      30,    31,    32,    33,    34,    35,    36,    -1,    -1,    -1,
      -1,    -1,  1110,    -1,    -1,    -1,    -1,  1818,  1819,  1820,
      76,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,  1129,  1130,   149,   341,   342,   343,   344,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    76,   354,    -1,    -1,
      -1,  1149,  1853,    -1,    -1,    -1,  1857,  1155,    -1,    -1,
      -1,    -1,    -1,    -1,  1162,    26,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    36,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   199,   200,    -1,    -1,    -1,    -1,  1187,
      -1,   147,    -1,    -1,    -1,   211,   212,  1195,   214,   215,
      -1,  1199,    -1,  1201,  1202,  1203,    -1,    -1,  1206,    -1,
    1208,    -1,    -1,    -1,    -1,    76,   423,   173,    -1,    -1,
      -1,   151,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,  1230,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,  1242,    26,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    36,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   470,    -1,    -1,    -1,    -1,    -1,    -1,
    1268,    -1,    -1,    -1,    -1,    -1,   483,    -1,    -1,    -1,
      -1,    -1,    -1,   490,    -1,    -1,    -1,    -1,  1286,    -1,
     151,    -1,    -1,    -1,  1292,    76,    26,    27,    28,    29,
      30,    31,    32,    33,    34,    35,    36,    -1,    26,    27,
      28,    29,    30,    31,    32,    33,    34,    35,    36,    -1,
      -1,    -1,    -1,  1321,    -1,    -1,    -1,    -1,    -1,    -1,
    1328,    -1,  1330,  1331,    -1,  1333,    -1,   544,    -1,    -1,
      -1,  1339,    -1,    -1,  1342,    -1,    76,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,  1355,    76,  1357,
      -1,    -1,    -1,   570,    -1,    -1,  1364,    -1,   149,    -1,
      -1,    -1,    -1,   580,    -1,    -1,   583,  1375,    -1,    -1,
    1378,    -1,    -1,    -1,    -1,    26,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    36,    -1,    -1,    -1,    -1,
      -1,  1399,    -1,   610,    26,    27,    28,    29,    30,    31,
      32,    33,    34,    35,    36,    -1,    -1,    -1,   625,   149,
    1418,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   147,
      -1,  1429,    -1,    -1,  1432,    76,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,  1442,  1443,    -1,    -1,  1446,  1447,
      -1,  1449,  1450,    -1,    76,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   671,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   682,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   693,    26,    27,    28,
      29,    30,    31,    32,    33,    34,    35,    36,    -1,    -1,
      -1,   708,   709,    -1,   145,    -1,    -1,    -1,    -1,    26,
      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
      -1,    -1,    -1,   145,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,  1532,    -1,    -1,    76,    -1,  1537,
    1538,    -1,    -1,    -1,    -1,    -1,    -1,  1545,    -1,    -1,
      -1,    -1,    91,    92,    -1,  1553,    -1,    -1,    -1,    76,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,  1566,  1567,
    1568,  1569,  1570,  1571,    91,    92,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,  1581,    26,    27,    28,    29,    30,    31,
      32,    33,    34,    35,    36,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,  1601,    -1,    -1,    -1,    -1,    -1,    -1,
    1608,    -1,    -1,    -1,  1612,    -1,  1614,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,  1624,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    76,  1633,    -1,    -1,    -1,    -1,
     847,    -1,  1640,   850,   851,   852,    -1,    -1,    -1,    91,
      -1,   858,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   866,
      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
      36,    -1,    -1,    -1,    -1,    -1,    -1,  1675,    -1,    -1,
      -1,  1679,    -1,    -1,   891,   892,   893,   894,   895,   896,
     897,   898,   899,    -1,    -1,    -1,   903,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,  1702,    -1,    -1,    -1,    -1,    -1,
      76,    -1,    -1,    -1,   921,   922,    -1,    -1,    -1,   926,
      -1,    -1,    -1,  1721,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,  1730,    -1,    -1,    -1,    -1,    -1,    -1,   946,
      -1,    -1,    -1,    -1,  1742,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,  1750,     3,    -1,    -1,    -1,    -1,    -1,    -1,
     967,    11,    -1,    -1,    -1,    -1,    -1,   974,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   984,    -1,   986,
      -1,   988,    -1,    -1,    -1,    -1,    -1,    -1,  1786,  1787,
      -1,    41,    36,    43,    38,    39,    40,    41,    42,    43,
      44,    45,    46,    47,    48,    49,    50,    51,    52,    53,
      54,    55,    56,    57,    58,    59,    60,    61,    62,    63,
      64,    65,    66,    67,    -1,    -1,    -1,  1825,    -1,    -1,
      74,    -1,    -1,    77,    78,    79,    80,    81,    82,    83,
      84,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,   108,   109,
     110,   111,   112,    -1,    -1,    -1,   116,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,  1093,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   152,  1110,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,  1129,    -1,    -1,    -1,   176,    -1,   178,    -1,
      -1,   181,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   196,   197,  1155,    -1,
      -1,   201,    -1,    -1,    -1,  1162,    -1,    -1,   208,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,  1195,    -1,
      -1,    -1,    -1,    -1,  1201,    -1,  1203,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   299,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,     5,
       6,     7,     8,     9,    10,    11,    -1,    -1,    14,    15,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,  1286,
      -1,    -1,    -1,    -1,    -1,  1292,    -1,    -1,    -1,    -1,
      -1,    37,    -1,    -1,    -1,    41,    -1,    43,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,  1321,    -1,    -1,    63,    64,    65,
      -1,  1328,    -1,  1330,  1331,    -1,    -1,    73,    -1,    -1,
      -1,    -1,  1339,    -1,    -1,  1342,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    91,    92,    93,    94,    95,
      96,    97,    -1,    99,   100,   101,    -1,  1364,   104,   105,
     106,   107,   108,   109,   110,   111,   112,    -1,  1375,    -1,
     116,  1378,   118,   119,    -1,    -1,    -1,   123,   124,    -1,
     126,    -1,    -1,   129,   130,   131,   132,   133,   134,   135,
      -1,   137,  1399,    -1,    -1,   141,   142,   143,   144,    -1,
     146,    -1,    -1,    -1,    -1,    -1,   152,   153,   154,    -1,
      -1,  1418,    -1,    -1,   160,   161,   162,   163,   164,    -1,
     166,    -1,    -1,    -1,   170,   171,   172,    -1,    -1,    -1,
     176,    -1,   178,    -1,    -1,   181,   182,    -1,    -1,    -1,
      -1,    -1,   188,   189,   190,   191,    -1,   193,   194,   195,
     196,   197,   198,   199,   200,   201,    -1,    -1,    -1,   205,
      -1,   207,   208,   209,    -1,   211,   212,   213,   214,   215,
     216,   217,    -1,   219,   220,   221,    -1,   223,   224,   225,
     226,    -1,   228,   229,   230,    -1,    -1,    -1,   234,   235,
     236,   237,   238,   239,   240,   241,   242,   243,   244,    -1,
      -1,   247,   248,    -1,   250,   251,   252,   253,   254,   255,
      -1,   257,   258,   259,    -1,    -1,   262,   263,   264,   265,
     266,   267,   268,   269,   270,   271,   272,   273,   274,   275,
     276,   277,   278,   279,   280,   281,   282,   283,   284,   285,
      -1,    -1,   288,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     296,   297,    -1,   299,    -1,     3,     4,     5,     6,     7,
       8,     9,    10,    11,    -1,    -1,    14,    15,    -1,    -1,
      -1,    -1,    -1,    -1,  1581,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    37,
      -1,    -1,    -1,    41,  1601,    43,    -1,    -1,    -1,    -1,
      -1,  1608,    -1,    -1,    -1,    -1,    -1,  1614,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    63,    64,    65,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    73,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    91,    92,    93,    94,    95,    96,    97,
      -1,    99,   100,   101,    -1,    -1,   104,    -1,    -1,    -1,
     108,   109,   110,   111,   112,    -1,    -1,    -1,   116,    -1,
     118,   119,  1679,    -1,    -1,   123,   124,    -1,   126,    -1,
      -1,   129,   130,   131,   132,   133,   134,   135,    -1,   137,
      -1,    -1,    -1,   141,   142,   143,   144,    -1,   146,    -1,
      -1,    -1,    -1,    -1,   152,    -1,   154,    -1,    -1,    -1,
      -1,    -1,   160,   161,   162,   163,   164,    -1,   166,    -1,
      -1,    -1,   170,   171,    -1,    -1,    -1,    -1,   176,    -1,
     178,    -1,    -1,   181,    -1,  1742,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,
      -1,    -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,
     208,    -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,
      -1,   219,   220,   221,    -1,   223,   224,   225,   226,    -1,
     228,   229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,
     238,   239,   240,   241,   242,   243,   244,    -1,    -1,   247,
     248,    -1,   250,   251,   252,   253,   254,   255,    -1,   257,
     258,   259,    -1,    -1,   262,   263,   264,   265,  1825,     3,
       4,     5,     6,     7,     8,     9,    10,    11,    -1,   277,
      14,    15,   280,   281,   282,   283,   284,   285,    57,    58,
      59,    60,    61,    62,    63,    64,    65,    66,    67,    -1,
      -1,   299,    -1,    37,    -1,    74,    -1,    41,    77,    43,
      79,    80,    81,    -1,    -1,    84,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    63,
      64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    73,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    91,    92,    93,
      94,    95,    96,    97,    -1,    99,   100,   101,    -1,    -1,
     104,    -1,    -1,    -1,   108,   109,   110,   111,   112,    -1,
      -1,    -1,   116,    -1,    -1,   119,    -1,    -1,    -1,   123,
     124,    -1,   126,    -1,    -1,   129,   130,    -1,   132,    -1,
     134,   135,    -1,   137,    -1,    -1,    -1,   141,   142,   143,
     144,    -1,   146,    -1,   148,    -1,    -1,    -1,   152,    -1,
     154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,
     164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,
      -1,    -1,   176,    -1,   178,    -1,    -1,   181,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   196,   197,    -1,    -1,    -1,   201,    -1,    -1,
      -1,    -1,    -1,    -1,   208,    -1,    -1,    -1,    -1,   213,
      -1,    -1,   216,   217,    -1,   219,   220,   221,    -1,   223,
     224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   237,   238,   239,   240,   241,   242,   243,
     244,    -1,    -1,   247,   248,    -1,   250,   251,   252,   253,
     254,   255,    -1,   257,   258,   259,    -1,    -1,   262,   263,
     264,   265,    -1,     3,     4,     5,     6,     7,     8,     9,
      10,    11,    -1,   277,    14,    15,   280,   281,   282,   283,
     284,   285,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   296,    -1,    -1,   299,    -1,    37,    -1,    -1,
      -1,    41,    -1,    43,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    73,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
     100,   101,    -1,    -1,   104,    -1,    -1,    -1,   108,   109,
     110,   111,   112,    -1,    -1,    -1,   116,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
     130,    -1,   132,   133,   134,   135,    -1,   137,    -1,    -1,
      -1,   141,   142,   143,   144,    -1,   146,    -1,    -1,    -1,
      -1,    -1,   152,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,    -1,    -1,    -1,    -1,   176,    -1,   178,    -1,
      -1,   181,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   196,   197,    -1,    -1,
      -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,   208,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,   219,
     220,   221,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,   238,   239,
     240,   241,   242,   243,   244,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      -1,    -1,   262,   263,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,     3,     4,     5,     6,
       7,     8,     9,    10,    11,    -1,    -1,    14,    15,   299,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    35,    -1,
      37,    -1,    -1,    -1,    41,    -1,    43,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    63,    64,    65,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    73,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    91,    92,    93,    94,    95,    96,
      97,    -1,    99,   100,   101,    -1,    -1,   104,    -1,    -1,
      -1,   108,   109,   110,   111,   112,    -1,    -1,    -1,   116,
      -1,    -1,   119,    -1,    -1,    -1,   123,   124,    -1,   126,
      -1,    -1,   129,   130,    -1,   132,    -1,   134,    -1,    -1,
     137,    -1,    -1,    -1,   141,   142,    -1,   144,    -1,   146,
      -1,    -1,   149,    -1,    -1,   152,    -1,   154,    -1,    -1,
      -1,    -1,    -1,   160,   161,   162,   163,   164,    -1,   166,
      -1,    -1,    -1,   170,   171,    -1,    -1,    -1,    -1,   176,
      -1,   178,    -1,    -1,   181,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,
     197,    -1,    -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,
      -1,   208,    -1,    -1,   211,    -1,   213,    -1,    -1,   216,
     217,    -1,   219,   220,    -1,    -1,   223,   224,   225,   226,
      -1,   228,   229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     237,   238,   239,   240,   241,   242,   243,   244,    -1,    -1,
     247,   248,    -1,   250,   251,   252,   253,   254,   255,    -1,
     257,   258,   259,    -1,    -1,   262,   263,   264,   265,    -1,
       3,     4,     5,     6,     7,     8,     9,    10,    11,    -1,
     277,    14,    15,   280,   281,   282,   283,   284,   285,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   299,    -1,    37,    38,    -1,    -1,    41,    -1,
      43,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    89,    90,    91,    92,
      93,    94,    95,    96,    97,    -1,    99,   100,   101,    -1,
      -1,   104,    -1,    -1,    -1,   108,   109,   110,   111,   112,
      -1,    -1,    -1,   116,    -1,    -1,   119,    -1,    -1,    -1,
     123,   124,    -1,   126,    -1,    -1,   129,   130,    -1,   132,
      -1,   134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,
      -1,   144,    -1,   146,    -1,    -1,    -1,    -1,    -1,   152,
      -1,   154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,
     163,   164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,
      -1,    -1,    -1,   176,    -1,   178,    -1,    -1,   181,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   196,   197,    -1,    -1,    -1,   201,    -1,
      -1,    -1,    -1,    -1,    -1,   208,    -1,    -1,    -1,    -1,
     213,    -1,    -1,   216,   217,    -1,   219,   220,    -1,    -1,
     223,   224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   237,   238,   239,   240,   241,   242,
     243,   244,    -1,    -1,   247,   248,    -1,   250,   251,   252,
     253,   254,   255,    -1,   257,   258,   259,    -1,    -1,   262,
     263,   264,   265,    -1,     3,     4,     5,     6,     7,     8,
       9,    10,    11,    -1,   277,    14,    15,   280,   281,   282,
     283,   284,   285,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   299,    -1,    37,    -1,
      -1,    -1,    41,    -1,    43,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    63,    64,    65,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    73,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,   100,   101,    -1,    -1,   104,    -1,    -1,    -1,   108,
     109,   110,   111,   112,    -1,    -1,    -1,   116,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,   130,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,   146,    -1,    -1,
     149,    -1,    -1,   152,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,   176,    -1,   178,
      -1,    -1,   181,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,    -1,
      -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,   208,
      -1,    -1,   211,    -1,   213,    -1,    -1,   216,   217,    -1,
     219,   220,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,   238,
     239,   240,   241,   242,   243,   244,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,   262,   263,   264,   265,    -1,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    -1,   277,    14,
      15,   280,   281,   282,   283,   284,   285,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     299,    -1,    37,    -1,    -1,    -1,    41,    -1,    43,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    63,    64,
      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    73,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    89,    90,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,   100,   101,    -1,    -1,   104,
      -1,    -1,    -1,   108,   109,   110,   111,   112,    -1,    -1,
      -1,   116,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,   130,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,   146,    -1,    -1,    -1,    -1,    -1,   152,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,   176,    -1,   178,    -1,    -1,   181,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,    -1,    -1,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,   208,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,   219,   220,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,   238,   239,   240,   241,   242,   243,   244,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,   262,   263,   264,
     265,    -1,     3,     4,     5,     6,     7,     8,     9,    10,
      11,    -1,   277,    14,    15,   280,   281,   282,   283,   284,
     285,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   299,    -1,    37,    -1,    -1,    -1,
      41,    -1,    43,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    89,    90,
      91,    92,    93,    94,    95,    96,    97,    -1,    99,   100,
     101,    -1,    -1,   104,    -1,    -1,    -1,   108,   109,   110,
     111,   112,    -1,    -1,    -1,   116,    -1,    -1,   119,    -1,
      -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,   130,
      -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,    -1,
     141,   142,    -1,   144,    -1,   146,    -1,    -1,    -1,    -1,
      -1,   152,    -1,   154,    -1,    -1,    -1,    -1,    -1,   160,
     161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,   170,
     171,    -1,    -1,    -1,    -1,   176,    -1,   178,    -1,    -1,
     181,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   196,   197,    -1,    -1,    -1,
     201,    -1,    -1,    -1,    -1,    -1,    -1,   208,    -1,    -1,
      -1,    -1,   213,    -1,    -1,   216,   217,    -1,   219,   220,
      -1,    -1,   223,   224,   225,   226,    -1,   228,   229,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   237,   238,   239,   240,
     241,   242,   243,   244,    -1,    -1,   247,   248,    -1,   250,
     251,   252,   253,   254,   255,    -1,   257,   258,   259,    -1,
      -1,   262,   263,   264,   265,    -1,     3,     4,     5,     6,
       7,     8,     9,    10,    11,    -1,   277,    14,    15,   280,
     281,   282,   283,   284,   285,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   299,    -1,
      37,    -1,    -1,    -1,    41,    -1,    43,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    63,    64,    65,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    73,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    91,    92,    93,    94,    95,    96,
      97,    -1,    99,   100,   101,    -1,    -1,   104,    -1,    -1,
      -1,   108,   109,   110,   111,   112,    -1,    -1,    -1,   116,
      -1,    -1,   119,    -1,    -1,    -1,   123,   124,    -1,   126,
      -1,    -1,   129,   130,    -1,   132,    -1,   134,    -1,    -1,
     137,    -1,    -1,    -1,   141,   142,    -1,   144,    -1,   146,
     147,    -1,    -1,    -1,    -1,   152,    -1,   154,    -1,    -1,
      -1,    -1,    -1,   160,   161,   162,   163,   164,    -1,   166,
      -1,    -1,    -1,   170,   171,    -1,    -1,    -1,    -1,   176,
      -1,   178,    -1,    -1,   181,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,
     197,    -1,    -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,
      -1,   208,    -1,    -1,    -1,    -1,   213,    -1,    -1,   216,
     217,    -1,   219,   220,    -1,    -1,   223,   224,   225,   226,
      -1,   228,   229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     237,   238,   239,   240,   241,   242,   243,   244,    -1,    -1,
     247,   248,    -1,   250,   251,   252,   253,   254,   255,    -1,
     257,   258,   259,    -1,    -1,   262,   263,   264,   265,    -1,
       3,     4,     5,     6,     7,     8,     9,    10,    11,    -1,
     277,    14,    15,   280,   281,   282,   283,   284,   285,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   299,    -1,    37,    -1,    -1,    -1,    41,    -1,
      43,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      63,    64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    91,    92,
      93,    94,    95,    96,    97,    -1,    99,   100,   101,    -1,
      -1,   104,    -1,    -1,    -1,   108,   109,   110,   111,   112,
      -1,    -1,    -1,   116,    -1,    -1,   119,    -1,    -1,    -1,
     123,   124,    -1,   126,    -1,    -1,   129,   130,    -1,   132,
      -1,   134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,
      -1,   144,    -1,   146,    -1,   148,    -1,    -1,    -1,   152,
      -1,   154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,
     163,   164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,
      -1,    -1,    -1,   176,    -1,   178,    -1,    -1,   181,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   196,   197,    -1,    -1,    -1,   201,    -1,
      -1,    -1,    -1,    -1,    -1,   208,    -1,    -1,    -1,    -1,
     213,    -1,    -1,   216,   217,    -1,   219,   220,    -1,    -1,
     223,   224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   237,   238,   239,   240,   241,   242,
     243,   244,    -1,    -1,   247,   248,    -1,   250,   251,   252,
     253,   254,   255,    -1,   257,   258,   259,    -1,    -1,   262,
     263,   264,   265,    -1,     3,     4,     5,     6,     7,     8,
       9,    10,    11,    -1,   277,    14,    15,   280,   281,   282,
     283,   284,   285,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   299,    -1,    37,    -1,
      -1,    -1,    41,    -1,    43,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    63,    64,    65,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    73,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,   100,   101,    -1,    -1,   104,    -1,    -1,    -1,   108,
     109,   110,   111,   112,    -1,    -1,    -1,   116,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,   130,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,   146,    -1,    -1,
      -1,    -1,    -1,   152,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,   176,    -1,   178,
      -1,    -1,   181,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,    -1,
      -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,   208,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,
     219,   220,    -1,    -1,   223,   224,   225,   226,   227,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,   238,
     239,   240,   241,   242,   243,   244,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,   262,   263,   264,   265,    -1,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    -1,   277,    14,
      15,   280,   281,   282,   283,   284,   285,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     299,    -1,    37,    -1,    -1,    -1,    41,    -1,    43,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    63,    64,
      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    73,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,   100,   101,    -1,    -1,   104,
      -1,    -1,    -1,   108,   109,   110,   111,   112,    -1,    -1,
      -1,   116,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,   130,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,   146,    -1,    -1,    -1,    -1,    -1,   152,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,   176,    -1,   178,    -1,    -1,   181,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,    -1,    -1,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,   208,    -1,    -1,   211,    -1,   213,    -1,
      -1,   216,   217,    -1,   219,   220,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,   238,   239,   240,   241,   242,   243,   244,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,   262,   263,   264,
     265,    -1,     3,     4,     5,     6,     7,     8,     9,    10,
      11,    -1,   277,    14,    15,   280,   281,   282,   283,   284,
     285,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   299,    -1,    37,    -1,    -1,    -1,
      41,    -1,    43,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    73,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      91,    92,    93,    94,    95,    96,    97,    -1,    99,   100,
     101,    -1,    -1,   104,    -1,    -1,    -1,   108,   109,   110,
     111,   112,    -1,    -1,    -1,   116,    -1,    -1,   119,    -1,
      -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,   130,
      -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,    -1,
     141,   142,    -1,   144,    -1,   146,    -1,    -1,    -1,    -1,
      -1,   152,    -1,   154,    -1,    -1,    -1,    -1,    -1,   160,
     161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,   170,
     171,    -1,    -1,    -1,    -1,   176,    -1,   178,    -1,    -1,
     181,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   196,   197,    -1,    -1,    -1,
     201,    -1,    -1,    -1,    -1,    -1,    -1,   208,    -1,    -1,
     211,    -1,   213,    -1,    -1,   216,   217,    -1,   219,   220,
      -1,    -1,   223,   224,   225,   226,    -1,   228,   229,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   237,   238,   239,   240,
     241,   242,   243,   244,    -1,    -1,   247,   248,    -1,   250,
     251,   252,   253,   254,   255,    -1,   257,   258,   259,    -1,
      -1,   262,   263,   264,   265,    -1,     3,     4,     5,     6,
       7,     8,     9,    10,    11,    -1,   277,    14,    15,   280,
     281,   282,   283,   284,   285,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   299,    -1,
      37,    -1,    -1,    -1,    41,    -1,    43,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    63,    64,    65,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    73,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    91,    92,    93,    94,    95,    96,
      97,    -1,    99,   100,   101,    -1,    -1,   104,    -1,    -1,
      -1,   108,   109,   110,   111,   112,    -1,    -1,    -1,   116,
      -1,    -1,   119,    -1,    -1,    -1,   123,   124,    -1,   126,
      -1,    -1,   129,   130,    -1,   132,    -1,   134,    -1,    -1,
     137,    -1,    -1,    -1,   141,   142,    -1,   144,    -1,   146,
      -1,    -1,    -1,    -1,    -1,   152,    -1,   154,    -1,    -1,
      -1,    -1,    -1,   160,   161,   162,   163,   164,    -1,   166,
      -1,    -1,    -1,   170,   171,    -1,    -1,    -1,    -1,   176,
      -1,   178,    -1,    -1,   181,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,
     197,    -1,    -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,
      -1,   208,    -1,    -1,    -1,    -1,   213,    -1,    -1,   216,
     217,    -1,   219,   220,    -1,    -1,   223,   224,   225,   226,
      -1,   228,   229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     237,   238,   239,   240,   241,   242,   243,   244,    -1,    -1,
     247,   248,    -1,   250,   251,   252,   253,   254,   255,    -1,
     257,   258,   259,    -1,    -1,   262,   263,   264,   265,    -1,
       3,     4,     5,     6,     7,     8,     9,    10,    11,    -1,
     277,    14,    15,   280,   281,   282,   283,   284,   285,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   299,    -1,    -1,    -1,    -1,    -1,    41,    -1,
      43,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    91,    92,
      93,    94,    95,    96,    97,    -1,    99,   100,   101,    -1,
      -1,   104,    -1,    -1,    -1,   108,   109,   110,   111,   112,
      -1,    -1,    -1,   116,    -1,    -1,   119,    -1,    -1,    -1,
     123,   124,    -1,   126,    -1,    -1,   129,   130,    -1,   132,
      -1,   134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,
      -1,   144,    -1,   146,    -1,    -1,    -1,    -1,    -1,   152,
      -1,   154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,
     163,   164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,
      -1,    -1,    -1,   176,    -1,   178,    -1,    -1,   181,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   196,   197,    -1,    -1,    -1,   201,    -1,
      -1,    -1,    -1,    -1,    -1,   208,    -1,    -1,    -1,    -1,
     213,    -1,    -1,   216,   217,    -1,   219,   220,    -1,    -1,
     223,   224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   237,   238,   239,   240,   241,   242,
     243,   244,    -1,    -1,   247,   248,    -1,   250,   251,   252,
     253,   254,   255,    -1,   257,   258,   259,    -1,    -1,   262,
     263,   264,   265,    -1,     3,     4,     5,     6,     7,     8,
       9,    10,    -1,    -1,   277,    14,    15,   280,   281,   282,
     283,   284,   285,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   299,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    63,    64,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,   100,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,   130,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,    -1,
      -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,   218,
      -1,    -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
     239,   240,   241,   242,   243,   244,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,     3,     4,
       5,     6,     7,     8,     9,    10,    -1,    -1,   277,    14,
      15,   280,   281,   282,   283,   284,   285,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     299,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    63,    64,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,   100,   101,    -1,    -1,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,   130,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,    -1,     3,     4,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,   239,   240,   241,   242,   243,   244,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    -1,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,    -1,   101,    -1,   299,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,    -1,    -1,   132,   133,   134,   135,    -1,   137,    -1,
      -1,    -1,   141,   142,   143,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,    -1,
       3,     4,   201,    -1,    -1,    -1,    -1,    -1,    -1,   208,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,
      -1,    -1,   221,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,
      -1,   280,   281,   282,   283,   284,   285,    -1,    91,    92,
      93,    94,    95,    96,    97,    -1,    99,    -1,   101,    -1,
     299,   104,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,
     123,   124,    -1,   126,    -1,    -1,   129,    -1,    -1,   132,
     133,   134,   135,    -1,   137,    -1,    -1,    -1,   141,   142,
     143,   144,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,
     163,   164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,
      -1,    -1,    -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   196,   197,    -1,     3,     4,   201,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     213,    -1,    -1,   216,   217,    -1,    -1,    -1,   221,    -1,
     223,   224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   247,   248,    -1,   250,   251,   252,
     253,   254,   255,    -1,   257,   258,   259,    -1,    -1,    -1,
      -1,   264,   265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   277,    -1,    -1,   280,   281,   282,
     283,   284,   285,    -1,    91,    92,    93,    94,    95,    96,
      97,    -1,    99,    -1,   101,    -1,   299,   104,    -1,    -1,
      -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   119,    -1,    -1,    -1,   123,   124,    -1,   126,
      -1,    -1,   129,    -1,    -1,   132,   133,   134,   135,    -1,
     137,    -1,    -1,    -1,   141,   142,   143,   144,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,
      -1,    -1,    -1,   160,   161,   162,   163,   164,    -1,   166,
      -1,    -1,    -1,   170,   171,    -1,    -1,    -1,    -1,    -1,
      -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,
     197,    -1,     3,     4,   201,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,    -1,   216,
     217,    -1,    -1,    -1,   221,    -1,   223,   224,   225,   226,
      -1,   228,   229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     247,   248,    -1,   250,   251,   252,   253,   254,   255,    -1,
     257,   258,   259,    -1,    -1,    -1,    -1,   264,   265,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     277,    -1,    -1,   280,   281,   282,   283,   284,   285,    -1,
      91,    92,    93,    94,    95,    96,    97,    -1,    99,    -1,
     101,    -1,   299,   104,    -1,    -1,    -1,    -1,   109,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,    -1,
      -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,    -1,
      -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,    -1,
     141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,   160,
     161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,   170,
     171,    -1,    -1,    -1,    -1,    -1,    -1,   178,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   196,   197,    -1,     3,    -1,
     201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,    -1,
      -1,    -1,   223,   224,   225,   226,    -1,   228,   229,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,   250,
     251,   252,   253,   254,   255,    -1,   257,   258,   259,    -1,
      -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,   280,
     281,   282,   283,   284,   285,    -1,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,   299,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,    -1,     3,     4,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,   222,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    -1,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,    -1,   101,    -1,   299,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,    -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,    -1,
       3,     4,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,
      -1,    -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,
      -1,   280,   281,   282,   283,   284,   285,    -1,    91,    92,
      93,    94,    95,    96,    97,    -1,    99,    -1,   101,    -1,
     299,   104,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,
     123,   124,    -1,   126,    -1,    -1,   129,    -1,    -1,   132,
      -1,   134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,
      -1,   144,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,
     163,   164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,
      -1,    -1,    -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   196,   197,    -1,     3,     4,   201,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     213,    -1,    -1,   216,   217,    -1,    -1,    -1,    -1,    -1,
     223,   224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   247,   248,    -1,   250,   251,   252,
     253,   254,   255,    -1,   257,   258,   259,    -1,    -1,    -1,
      -1,   264,   265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   277,    -1,    -1,   280,   281,   282,
     283,   284,   285,    -1,    91,    92,    93,    94,    95,    96,
      97,    -1,    99,    -1,   101,    -1,   299,   104,    -1,    -1,
      -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   119,    -1,    -1,    -1,   123,   124,    -1,   126,
      -1,    -1,   129,    -1,    -1,   132,    -1,   134,    -1,    -1,
     137,    -1,    -1,    -1,   141,   142,    -1,   144,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,
      -1,    -1,    -1,   160,   161,   162,   163,   164,    -1,   166,
      -1,    -1,    -1,   170,   171,    -1,    -1,    -1,    -1,    -1,
      -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,
     197,    -1,     3,    -1,   201,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,    -1,   216,
     217,    -1,    -1,    -1,    -1,    -1,   223,   224,   225,   226,
      -1,   228,   229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     247,   248,    -1,   250,   251,   252,   253,   254,   255,    -1,
     257,   258,   259,    -1,    -1,    -1,    -1,   264,   265,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     277,    -1,    -1,   280,   281,   282,   283,   284,   285,    -1,
      91,    92,    93,    94,    95,    96,    97,    -1,    99,    -1,
     101,    -1,   299,   104,    -1,    -1,    -1,    -1,   109,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,    -1,
      -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,    -1,
      -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,    -1,
     141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,   160,
     161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,   170,
     171,    -1,    -1,    -1,    -1,    -1,    -1,   178,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   196,   197,    -1,     3,    -1,
     201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,    -1,
      -1,    -1,   223,   224,   225,   226,    -1,   228,   229,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,   250,
     251,   252,   253,   254,   255,    -1,   257,   258,   259,    -1,
      -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,   280,
     281,   282,   283,   284,   285,    -1,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,   299,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,    -1,    -1,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,     3,     4,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   299,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    76,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
     145,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,     3,     4,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,   109,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
     130,    -1,   132,    -1,   134,   135,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   154,    -1,    -1,   157,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,    -1,
      -1,    -1,    -1,    -1,    -1,   185,   186,   187,   188,   189,
     190,   191,    -1,    -1,    -1,    -1,   196,   197,     3,    -1,
      -1,   201,    -1,    -1,    -1,    -1,    11,    -1,    -1,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,   108,   109,   110,   111,   112,    -1,    -1,
      -1,   116,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   152,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,   173,    -1,
      -1,   176,    -1,   178,    -1,    -1,   181,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,     3,    -1,    -1,   201,    -1,    -1,    -1,
      -1,    11,    -1,   208,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,   108,   109,
     110,   111,   112,    -1,    -1,    -1,   116,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   152,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,    -1,    -1,    -1,    -1,   176,    -1,   178,    -1,
      -1,   181,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,    -1,
      -1,   201,    -1,    -1,    -1,    -1,    11,    -1,   208,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,   108,   109,   110,   111,   112,    -1,    -1,
      -1,   116,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   152,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,   176,    -1,   178,    -1,    -1,   181,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,     3,     4,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,   208,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    41,   237,    -1,    -1,    -1,    -1,    -1,    -1,    49,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,   109,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   191,   192,    -1,    -1,    -1,   196,   197,     3,    -1,
      -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,   133,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   193,    -1,
      -1,   196,   197,     3,     4,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,   208,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,   218,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    41,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,   109,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,   167,    -1,    -1,
     170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,    -1,
      -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,   133,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   193,    -1,
      -1,   196,   197,     3,     4,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,   218,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,   109,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   193,    -1,    -1,   196,   197,     3,     4,
      -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,   172,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,     3,     4,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,   109,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,   172,    -1,    -1,    -1,    -1,    -1,   178,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,     4,
      -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,   172,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,     3,     4,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,   109,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,   172,    -1,    -1,    -1,    -1,    -1,   178,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,     4,
      -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      65,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,     3,     4,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    41,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,   109,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,     4,
      -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      65,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    91,    92,    93,    94,
      95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,   104,
      -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,   124,
      -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,   134,
      -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,   144,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   154,
      -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,   164,
      -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,
      -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,   196,   197,     3,     4,    -1,   201,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,    -1,
      -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,   224,
     225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   247,   248,    -1,   250,   251,   252,   253,   254,
     255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,   264,
     265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,   284,
     285,    91,    92,    93,    94,    95,    96,    97,    -1,    99,
      -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,   109,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   119,
      -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,   129,
      -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,    -1,
      -1,   141,   142,    -1,   144,   145,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,    -1,
     160,   161,   162,   163,   164,    -1,   166,    -1,    -1,    -1,
     170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   196,   197,    -1,     3,
       4,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,    -1,
      -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,   229,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,    -1,
     250,   251,   252,   253,   254,   255,    -1,   257,   258,   259,
      64,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,    -1,
     280,   281,   282,   283,   284,   285,    -1,    91,    92,    93,
      94,    95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,
     104,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,
     124,    -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,
     134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,
     144,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,
     164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,
      -1,    -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   196,   197,     3,    -1,    -1,   201,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,
      -1,    -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,
     224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   247,   248,    -1,   250,   251,   252,   253,
     254,   255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,
     264,   265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,
     284,   285,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,    -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,    -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   193,    -1,    -1,   196,   197,     3,
       4,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,   218,
      -1,    -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,
      -1,   280,   281,   282,   283,   284,   285,    91,    92,    93,
      94,    95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,
     104,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,
     124,    -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,
     134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,
     144,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,
     164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,
      -1,    -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   196,   197,     3,    -1,    -1,   201,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,
      -1,    -1,   216,   217,    23,    -1,    -1,    -1,    -1,   223,
     224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   247,   248,    -1,   250,   251,   252,   253,
     254,   255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,
     264,   265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,
     284,   285,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,    -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,    -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,
      -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,
      -1,    -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,
      -1,   280,   281,   282,   283,   284,   285,    91,    92,    93,
      94,    95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,
     104,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,
     124,    -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,
     134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,
     144,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,
     164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,
      -1,    -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   196,   197,     3,    -1,    -1,   201,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,
      -1,    -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,
     224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   237,    -1,   239,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   247,   248,    -1,   250,   251,   252,   253,
     254,   255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,
     264,   265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,
     284,   285,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,    -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,    -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,
      -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,
      -1,    -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
     239,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,
      -1,   280,   281,   282,   283,   284,   285,    91,    92,    93,
      94,    95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,
     104,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,
     124,    -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,
     134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,
     144,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,
     164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,
      -1,    -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   196,   197,     3,    -1,    -1,   201,    -1,    -1,
      -1,    -1,    -1,    -1,   208,    -1,    -1,    -1,    -1,   213,
      -1,    -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,
     224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   247,   248,    -1,   250,   251,   252,   253,
     254,   255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,
     264,   265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,
     284,   285,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,    -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,    -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,
      -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,
      -1,    -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
     239,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,
      -1,   280,   281,   282,   283,   284,   285,    91,    92,    93,
      94,    95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,
     104,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,
     124,    -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,
     134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,
     144,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,
     164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,
      -1,    -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   196,   197,     3,    -1,    -1,   201,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,
      -1,    -1,   216,   217,   218,    -1,    -1,    -1,    -1,   223,
     224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   247,   248,    -1,   250,   251,   252,   253,
     254,   255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,
     264,   265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,
     284,   285,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,    -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,    -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,     3,
      -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,
      -1,    -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
     239,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,
      -1,   280,   281,   282,   283,   284,   285,    91,    92,    93,
      94,    95,    96,    97,    -1,    99,    -1,   101,    -1,    -1,
     104,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   119,    -1,    -1,    -1,   123,
     124,    -1,   126,    -1,    -1,   129,    -1,    -1,   132,    -1,
     134,    -1,    -1,   137,    -1,    -1,    -1,   141,   142,    -1,
     144,   145,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     154,    -1,    -1,    -1,    -1,    -1,   160,   161,   162,   163,
     164,    -1,   166,    -1,    -1,    -1,   170,   171,    -1,    -1,
      -1,    -1,    -1,    -1,   178,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   196,   197,     3,    -1,    -1,   201,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   213,
      -1,    -1,   216,   217,    -1,    -1,    -1,    -1,    -1,   223,
     224,   225,   226,    -1,   228,   229,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   237,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   247,   248,    -1,   250,   251,   252,   253,
     254,   255,    -1,   257,   258,   259,    -1,    -1,    -1,    -1,
     264,   265,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,   277,    -1,    -1,   280,   281,   282,   283,
     284,   285,    91,    92,    93,    94,    95,    96,    97,    -1,
      99,    -1,   101,    -1,    -1,   104,    -1,    -1,    -1,    -1,
     109,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
     119,    -1,    -1,    -1,   123,   124,    -1,   126,    -1,    -1,
     129,    -1,    -1,   132,    -1,   134,    -1,    -1,   137,    -1,
      -1,    -1,   141,   142,    -1,   144,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,   154,    -1,    -1,    -1,    -1,
      -1,   160,   161,   162,   163,   164,    -1,   166,    -1,    -1,
      -1,   170,   171,    -1,    -1,    -1,    -1,    -1,    -1,   178,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,   196,   197,    -1,
      -1,    -1,   201,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   213,    -1,    -1,   216,   217,    -1,
      -1,    -1,    -1,    -1,   223,   224,   225,   226,    -1,   228,
     229,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   237,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   247,   248,
      -1,   250,   251,   252,   253,   254,   255,    -1,   257,   258,
     259,    -1,    -1,    -1,    -1,   264,   265,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   277,    -1,
      -1,   280,   281,   282,   283,   284,   285,    36,    -1,    38,
      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
      49,    50,    51,    52,    53,    54,    55,    56,    57,    58,
      59,    60,    61,    62,    63,    64,    65,    66,    67,    -1,
      -1,    -1,    -1,    -1,    -1,    74,    -1,    -1,    77,    78,
      79,    80,    81,    82,    83,    84,    38,    39,    40,    41,
      42,    43,    44,    45,    46,    47,    48,    49,    50,    51,
      52,    53,    54,    55,    56,    57,    58,    59,    60,    61,
      62,    63,    64,    65,    66,    67,    -1,    -1,    -1,    -1,
      -1,    -1,    74,    -1,    -1,    77,    78,    79,    80,    81,
      82,    83,    84
};

/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
   state STATE-NUM.  */
static const yytype_int16 yystos[] =
{
       0,    72,   245,   289,   291,   292,   305,   306,   307,   308,
     311,   312,   353,   354,   606,   607,   610,   611,    72,   299,
     306,     3,    91,    92,    93,    94,    95,    96,    97,    99,
     101,   104,   109,   119,   123,   124,   126,   129,   132,   134,
     137,   141,   142,   144,   154,   160,   161,   162,   163,   164,
     166,   170,   171,   178,   196,   197,   201,   213,   216,   217,
     223,   224,   225,   226,   228,   229,   237,   247,   248,   250,
     251,   252,   253,   254,   255,   257,   258,   259,   264,   265,
     277,   280,   281,   282,   283,   284,   285,   372,   372,     0,
     308,   311,   312,   354,     3,     4,     5,     6,     7,     8,
       9,    10,    11,    14,    15,    37,    41,    43,    63,    64,
      65,    73,    93,    94,   100,   105,   106,   107,   108,   110,
     111,   112,   116,   118,   123,   130,   131,   133,   135,   137,
     143,   146,   152,   153,   172,   176,   181,   182,   188,   189,
     190,   191,   193,   194,   195,   196,   197,   198,   199,   200,
     205,   207,   208,   209,   211,   212,   213,   214,   215,   217,
     219,   220,   221,   223,   229,   230,   234,   235,   236,   238,
     239,   240,   241,   242,   243,   244,   262,   263,   266,   267,
     268,   269,   270,   271,   272,   273,   274,   275,   276,   278,
     279,   288,   296,   297,   299,   310,   313,   314,   315,   318,
     319,   320,   321,   322,   323,   329,   330,   331,   332,   333,
     335,   336,   371,   372,   373,   389,   390,   391,   392,   393,
     394,   397,   399,   400,   401,   402,   403,   418,   419,   420,
     421,   422,   423,   425,   427,   445,   446,   447,   448,   449,
     450,   451,   452,   453,   482,   483,   484,   487,   491,   493,
     497,   498,   501,   502,   503,   506,   507,   510,   511,   515,
     516,   517,   518,   519,   520,   521,   529,   531,   532,   533,
     534,   535,   536,   537,   538,   541,   542,   543,   544,   545,
     546,   547,   548,   549,   550,   553,   554,   555,   556,   557,
     561,   567,   569,   570,   571,   572,   574,   575,   576,   577,
     578,   593,   594,   595,   596,   597,   598,   599,   600,   601,
     602,   603,   604,   605,   612,   309,   311,   309,   350,   372,
     349,   372,   290,   299,   299,   298,   130,   181,   208,   402,
     299,   299,   402,   402,   402,   104,   170,   179,   337,   368,
     517,    95,   124,   134,   171,   372,   376,   378,   378,   376,
       4,   193,   348,   372,   148,   299,   348,    35,   132,   299,
     424,   122,   167,   173,   184,   467,   136,   316,   299,   147,
     403,   404,   403,   403,   348,   348,   372,    23,   372,   372,
     130,   135,   157,   185,   186,   187,   190,   191,   348,   372,
     377,   505,   517,   376,   372,   372,   197,   549,   372,   403,
     372,   373,   309,   239,   372,   573,   183,   212,   216,   212,
     216,   213,   573,   299,   299,   222,   299,   310,   372,   414,
     415,   417,   132,    95,   372,   299,   299,   299,   299,   299,
      36,    53,    95,    96,   118,   125,   128,   131,   135,   139,
     155,   216,   220,   286,   287,   592,   592,   372,     3,    11,
     100,   108,   109,   110,   111,   112,   113,   114,   115,   116,
     193,   237,   385,   386,   372,   372,   297,   299,   383,   299,
     299,   209,   247,   251,   252,   568,   403,   135,   403,   418,
     421,   301,   172,   338,   299,   390,   138,    68,    69,    70,
      71,    72,    73,    38,    39,    40,    41,    42,    43,    44,
      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
      65,    66,    67,    74,    77,    78,    79,    80,    81,    82,
      83,    84,    26,    27,    28,    29,    30,    31,    32,    33,
      34,    35,    36,    76,   118,   123,   223,   422,   484,   491,
     498,   502,   159,   462,    22,    23,    24,    25,   426,   295,
     492,   348,   120,   492,   492,   492,   213,   373,   296,   296,
     296,   296,   296,   296,   293,   294,   608,   609,   608,   609,
      40,   302,    70,    40,   300,    70,   395,   396,   403,   395,
     299,   167,   398,   398,    95,    95,   134,   171,   124,   373,
     172,   348,   172,   348,   172,   348,   172,   348,   303,   372,
     181,   348,   403,    76,   214,   223,   224,   264,   265,   148,
     403,   410,   494,   495,   227,   403,   411,   468,   469,    94,
     215,   296,   317,   329,   330,   331,   332,   421,   483,   493,
     497,   501,   569,   571,     3,   310,   403,   404,   150,   151,
     147,   173,   539,   149,   214,   215,   542,   543,   544,   545,
     546,   548,   566,    72,    76,   148,    76,   299,   208,   372,
     535,    41,   197,   297,   346,   347,   157,   505,   372,   372,
     372,   535,   303,   193,   196,   386,   388,   373,   373,   388,
     388,   132,   175,   299,   488,   372,   296,   296,   299,   210,
     213,   573,   183,   573,   403,   403,   414,   535,   299,    41,
     145,   303,   348,   303,    10,   389,   395,   421,   214,   224,
     264,   265,    35,   187,    97,   148,    99,   129,   135,   172,
     505,    59,   384,    70,    59,   384,   384,   384,   112,   113,
     384,   384,   384,   384,   384,   384,    70,   299,    70,   175,
     175,   232,    10,   280,   281,   282,   283,   284,   285,   348,
     309,   216,   301,   300,   172,   300,    37,   348,   398,   299,
     372,   429,   430,   401,    73,     3,   299,   373,   399,    65,
     348,   403,   405,   406,   407,   410,   386,   402,   402,   402,
     402,   402,   402,   402,   402,   402,   402,   402,   299,   299,
     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,
     402,   372,   402,   402,   402,   402,   402,   402,   402,   402,
     403,   403,   403,   403,   403,   403,   403,   403,   403,   403,
     403,   403,   492,   492,   492,   492,   158,   168,   465,   423,
     468,   101,   175,   488,   299,   504,   296,   299,   403,   311,
     299,   310,   348,   372,   472,   473,   474,   476,   481,   414,
     423,   468,   309,   309,    63,    64,   299,   348,   352,   393,
     394,   302,   372,   352,   372,   300,   303,   300,   135,   143,
     148,   221,   296,   403,   613,   614,   615,   407,   407,   172,
     177,   340,   338,   338,   338,   299,   262,   262,   262,   262,
     376,   175,   488,   299,   348,   489,   499,   500,   156,   455,
     300,   403,   132,   132,   132,   132,   132,   218,   372,   303,
     300,   299,   145,   348,   470,   471,   148,   454,   303,   300,
     149,   150,   151,   403,   403,   409,   133,   150,   151,   539,
     540,   309,   407,   403,   193,   403,    41,   346,   348,   372,
     523,   524,   155,   299,   348,   372,   421,   148,   315,   403,
     421,   483,   493,   497,   501,   530,   535,   299,   372,   372,
     296,   385,   299,   377,    41,   197,   297,   346,   388,    37,
     246,   298,   387,   256,   299,   256,   299,   376,   403,   551,
     552,   346,   377,   379,   148,   490,   309,   309,   407,   309,
     573,   213,   573,   145,   145,   175,   300,    65,   377,   299,
     348,   299,   414,   225,   244,   389,   300,   300,   300,   300,
     303,   300,   303,   303,    37,   117,   122,   372,   373,   372,
     384,   384,   373,   395,   373,   372,   443,   444,   444,   299,
     300,   303,   300,   300,   300,   300,   300,   300,   300,   151,
     311,   122,   262,   299,   407,   141,   438,   386,   298,   407,
     303,   302,    73,    36,    36,   408,   409,   421,   408,   421,
     403,   463,   464,   403,   169,   466,   133,   421,   551,   148,
     421,   490,   369,   370,   403,   121,   309,    49,   191,   192,
     346,   348,   372,   522,   527,   528,   151,   151,   416,   421,
     472,   535,   470,   470,   299,   151,   152,   165,   174,   176,
     303,   475,   477,   478,   470,   151,   151,   151,   609,   609,
     392,   392,   351,   352,   302,   300,   395,   299,   299,   299,
     299,   311,   300,   303,   300,   300,    37,   172,   348,   348,
     348,   579,   348,   528,   348,   348,   348,   348,   551,   148,
     490,   346,   377,    40,    40,   303,   454,   403,   346,   346,
     495,   303,   167,   346,   348,   412,   413,   348,   472,   455,
     468,   403,   403,   151,   303,   149,   539,   311,   540,   206,
     563,   564,   565,   302,   372,   388,   346,   303,   300,   535,
     558,   559,   524,   218,   535,    64,   344,   345,   348,   299,
     256,   299,   193,   194,   512,   534,   299,   524,   299,   421,
     148,   403,   530,   100,   387,   246,   102,   372,   525,   526,
     527,   102,   526,   471,   103,   485,   303,   300,   300,   133,
     193,   218,   372,   535,   485,   151,   151,   300,   151,   573,
     388,   386,   372,   380,   381,   300,   300,   421,   416,   421,
     226,   299,   403,   403,   403,   100,   118,   123,    60,   173,
     373,   374,   181,   193,   374,   300,   374,   277,   303,   372,
     372,   372,   372,   372,   372,   372,   372,   209,   296,    35,
     149,   211,   403,    98,   102,   125,   127,   179,   341,   342,
     343,   346,   354,   355,   356,   365,   367,   300,   158,   462,
      73,   299,   300,   406,   402,   402,   300,   300,   300,   300,
     160,   164,   459,   303,   403,   485,   485,   485,   303,   300,
     459,   118,   122,   496,   151,   388,   346,   348,   303,   300,
     300,   300,   300,   175,   407,   154,   154,   473,   476,   155,
     475,   300,   303,   302,   468,   423,   472,   414,   151,   615,
     140,   428,   428,   262,    37,   175,   145,   299,   257,   258,
     259,   580,   233,   328,   117,   300,   133,   300,   300,   403,
     299,   500,   455,   424,   412,    71,   346,   300,   303,   157,
     456,   404,   151,   409,   122,   311,   540,   151,   403,   564,
     150,   562,    76,   524,   175,    36,   300,   348,   300,   303,
     372,   513,   514,   102,   528,   372,   372,   151,   301,   372,
     508,   509,   300,   524,   535,    93,   388,   193,   303,   300,
     300,   299,   551,   299,   372,   488,   488,   300,   300,   145,
     372,   300,   303,   300,   300,   300,   355,   395,   300,   300,
     300,   102,    59,   145,    60,    60,   145,   145,   444,   303,
      70,   300,   298,   298,   298,   298,   298,   298,   301,   309,
     100,   211,   403,   300,   300,    99,   299,    99,   348,   372,
     299,   300,   303,   348,   428,   409,   142,   143,   144,   431,
     432,   401,   613,   161,   460,   460,   463,   370,   455,   348,
     375,   388,   528,   296,   470,   470,   380,   300,   476,   351,
     300,   300,   300,   300,   299,   177,   262,   372,   421,   376,
     260,   118,   123,   131,   581,   383,   348,   296,   299,   495,
     462,   300,   348,   412,   158,   180,   461,   149,   309,   151,
     560,   403,   299,   558,   344,    40,   300,   303,   299,   388,
     300,   193,   512,    40,   300,   303,   300,   388,   526,    93,
     388,   175,   191,   299,   403,   495,   488,   372,   380,   300,
     373,   373,   373,   373,   372,   372,   299,   299,   299,   299,
     299,   299,   296,   151,   149,   211,   403,   300,   300,   299,
     403,   299,    98,   125,   179,   102,   370,    96,   339,   341,
     386,   300,    38,    89,    90,   403,   434,   437,   300,   162,
     163,   181,   309,   117,   175,   479,   480,   455,   299,   334,
     328,   300,   260,   582,   117,   299,   309,   495,   300,   465,
     403,   457,   458,   403,   139,   439,   440,   309,   172,   376,
     403,   513,   524,   299,   388,   403,   508,   388,   216,    23,
     299,   524,   300,   300,    60,   300,   300,   372,   616,   617,
     618,   616,   616,   616,   616,   616,   210,   211,   403,   300,
     300,   370,   300,   377,    99,    99,   299,   299,   300,    97,
     231,   232,   233,   324,   327,    74,    98,   101,   102,   126,
     178,   179,   231,   233,   246,   366,   382,   387,    89,    90,
     403,   435,    91,    91,    85,    86,    87,    88,   433,   500,
     151,   403,   299,   300,   218,   351,   145,   145,   376,   348,
     370,   151,   300,   454,   303,   372,   441,   442,   300,   300,
     524,   299,   524,   300,    12,    13,   486,   485,   298,   300,
     303,   300,   300,   300,   300,   300,   309,   300,   300,   300,
     300,   299,   299,   370,   403,   120,   357,   358,   383,   233,
     299,   325,   383,   372,    99,    63,    64,   389,   392,   393,
     299,   348,   382,   357,   383,   383,   382,   382,   357,    91,
      91,    92,    36,   454,   376,    92,   300,   299,   421,   261,
     583,   584,   300,   455,   457,   145,   303,   145,   300,   524,
     300,    13,    12,   280,   281,   282,   283,   284,   285,   619,
     617,   151,   357,   366,   370,   377,   300,   300,   214,   223,
     224,   264,   265,   326,   327,   372,   326,   382,   357,   392,
     392,   382,   382,   382,   403,   299,   382,   382,   382,   382,
      89,    90,   403,   436,   455,   300,   300,   341,   328,   147,
     585,   455,   462,   430,   441,   372,   300,   175,   210,   300,
     300,   357,   300,   166,   382,   382,   382,   300,   377,    92,
      91,    92,   300,   403,   296,   328,   465,   175,   216,   357,
     366,   325,   382,   382,   300,   328,   418,   422,   483,   491,
     493,   496,   586,   587,   588,   589,   590,   591,   216,   117,
     249,   250,   359,   360,   361,   363,   491,   151,   586,   301,
     301,   301,   301,   118,   123,   255,   364,   364,   363,   119,
     181,   253,   256,   362,   362,   247,   251,   100,   101,   254,
     117,   117,   123,   118,   362,   362
};

/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
static const yytype_int16 yyr1[] =
{
       0,   304,   305,   306,   306,   306,   306,   307,   308,   308,
     309,   309,   310,   310,   311,   311,   312,   312,   312,   313,
     314,   314,   314,   314,   314,   314,   314,   314,   314,   314,
     314,   314,   314,   314,   314,   314,   314,   314,   314,   314,
     314,   314,   314,   314,   314,   314,   314,   314,   314,   314,
     314,   314,   314,   314,   314,   314,   314,   314,   314,   314,
     314,   314,   314,   314,   314,   314,   314,   314,   314,   314,
     314,   314,   314,   314,   314,   314,   314,   314,   314,   314,
     314,   314,   314,   314,   314,   314,   314,   314,   314,   314,
     314,   314,   314,   314,   314,   314,   314,   314,   314,   314,
     314,   314,   314,   314,   315,   316,   316,   317,   317,   317,
     317,   317,   317,   317,   317,   317,   317,   317,   318,   319,
     320,   321,   321,   321,   322,   323,   324,   324,   324,   324,
     325,   325,   326,   326,   327,   327,   328,   328,   329,   329,
     330,   330,   331,   331,   332,   332,   333,   334,   334,   334,
     335,   336,   337,   337,   338,   338,   339,   339,   340,   340,
     340,   340,   340,   341,   341,   342,   342,   342,   342,   342,
     342,   343,   343,   344,   344,   345,   345,   346,   346,   347,
     347,   348,   348,   349,   349,   350,   350,   351,   351,   352,
     352,   352,   352,   352,   352,   353,   353,   353,   353,   354,
     354,   355,   356,   356,   357,   357,   358,   358,   358,   358,
     358,   359,   359,   360,   360,   360,   361,   361,   361,   361,
     362,   362,   362,   362,   362,   363,   363,   364,   364,   364,
     365,   365,   366,   367,   367,   368,   368,   369,   370,   370,
     371,   372,   372,   372,   372,   372,   372,   372,   372,   372,
     372,   372,   372,   372,   372,   372,   372,   372,   372,   372,
     372,   372,   372,   372,   372,   372,   372,   372,   372,   372,
     372,   372,   372,   372,   372,   372,   372,   372,   372,   372,
     372,   372,   372,   372,   372,   372,   372,   372,   372,   372,
     372,   372,   372,   372,   372,   372,   372,   372,   372,   372,
     372,   372,   372,   372,   372,   372,   372,   373,   373,   373,
     373,   373,   373,   373,   373,   373,   373,   373,   374,   374,
     374,   375,   375,   376,   376,   377,   377,   378,   378,   379,
     379,   380,   380,   381,   381,   382,   382,   382,   382,   382,
     382,   382,   382,   382,   382,   382,   382,   382,   382,   382,
     382,   382,   383,   383,   383,   384,   384,   385,   385,   385,
     385,   385,   385,   385,   385,   385,   386,   386,   386,   386,
     386,   386,   386,   386,   387,   387,   388,   388,   388,   388,
     388,   389,   390,   390,   391,   391,   392,   392,   392,   392,
     392,   393,   394,   394,   394,   394,   394,   394,   394,   394,
     394,   394,   395,   395,   396,   397,   397,   397,   397,   398,
     398,   399,   399,   399,   400,   400,   400,   400,   400,   400,
     401,   401,   401,   401,   401,   401,   401,   401,   401,   401,
     401,   401,   401,   401,   401,   401,   401,   401,   401,   401,
     401,   401,   401,   401,   401,   401,   401,   401,   401,   401,
     401,   401,   401,   402,   402,   402,   402,   402,   402,   402,
     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,
     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,
     402,   402,   402,   402,   402,   402,   402,   402,   402,   402,
     402,   402,   402,   402,   402,   402,   402,   402,   402,   403,
     403,   403,   403,   403,   403,   403,   403,   403,   403,   403,
     403,   403,   404,   404,   405,   405,   406,   406,   407,   407,
     408,   408,   409,   409,   410,   410,   410,   410,   411,   411,
     412,   412,   413,   413,   413,   413,   414,   414,   415,   415,
     415,   416,   416,   417,   417,   417,   417,   417,   417,   417,
     418,   418,   419,   420,   421,   421,   422,   423,   423,   424,
     424,   425,   425,   425,   426,   426,   426,   426,   427,   428,
     428,   429,   429,   430,   431,   431,   432,   432,   432,   433,
     433,   433,   433,   433,   434,   434,   435,   435,   435,   435,
     436,   436,   436,   436,   437,   437,   437,   438,   438,   439,
     439,   440,   441,   441,   442,   443,   443,   444,   444,   445,
     445,   446,   446,   447,   448,   449,   450,   450,   451,   452,
     453,   454,   454,   455,   455,   456,   456,   457,   457,   458,
     459,   459,   459,   460,   460,   460,   461,   461,   462,   462,
     463,   463,   464,   465,   465,   466,   466,   467,   467,   467,
     467,   468,   468,   469,   469,   470,   470,   471,   471,   472,
     472,   473,   473,   474,   475,   475,   476,   476,   476,   476,
     476,   476,   477,   477,   477,   477,   477,   477,   477,   478,
     479,   479,   480,   480,   481,   482,   482,   483,   483,   483,
     483,   484,   485,   485,   486,   486,   486,   486,   486,   487,
     487,   487,   487,   487,   487,   487,   488,   488,   488,   489,
     489,   490,   490,   490,   491,   491,   491,   491,   491,   492,
     493,   493,   493,   493,   494,   494,   495,   495,   495,   496,
     497,   497,   497,   497,   498,   498,   499,   500,   500,   501,
     501,   501,   501,   502,   502,   503,   503,   503,   504,   504,
     505,   505,   506,   507,   508,   508,   509,   509,   510,   511,
     512,   512,   513,   513,   514,   515,   515,   515,   515,   516,
     516,   516,   516,   517,   517,   518,   519,   519,   519,   519,
     519,   519,   519,   520,   520,   521,   521,   522,   522,   522,
     523,   523,   523,   524,   524,   525,   525,   526,   526,   526,
     527,   527,   527,   527,   528,   528,   528,   529,   529,   529,
     529,   529,   529,   530,   530,   530,   530,   530,   530,   530,
     531,   531,   531,   531,   532,   532,   533,   533,   534,   534,
     534,   535,   536,   537,   538,   538,   539,   539,   540,   540,
     540,   541,   542,   543,   544,   545,   546,   547,   547,   548,
     549,   549,   550,   550,   550,   551,   551,   552,   553,   554,
     555,   556,   557,   558,   558,   559,   559,   560,   560,   561,
     562,   562,   563,   564,   564,   565,   565,   566,   566,   566,
     566,   566,   566,   567,   568,   568,   568,   568,   569,   569,
     570,   570,   570,   570,   570,   570,   571,   571,   572,   573,
     573,   574,   575,   575,   576,   576,   577,   578,   579,   580,
     580,   580,   580,   581,   581,   581,   582,   582,   583,   584,
     584,   585,   585,   586,   586,   587,   587,   587,   587,   588,
     589,   590,   591,   592,   592,   592,   592,   592,   592,   592,
     592,   592,   592,   592,   592,   592,   592,   592,   592,   593,
     594,   595,   596,   597,   598,   599,   600,   601,   602,   603,
     604,   605,   605,   605,   606,   607,   608,   609,   610,   610,
     611,   611,   612,   612,   612,   612,   612,   612,   613,   613,
     614,   614,   614,   614,   614,   614,   615,   615,   616,   616,
     617,   617,   618,   619,   619,   619,   619,   619,   619
};

/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
static const yytype_int8 yyr2[] =
{
       0,     2,     1,     0,     1,     1,     2,     3,     1,     2,
       0,     1,     2,     5,     1,     2,     3,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     3,     0,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       4,     4,     5,     7,     4,     4,     0,     2,     5,     1,
       0,     1,     0,     1,     3,     3,     0,     2,     5,     3,
       5,     3,     5,     3,     5,     3,    13,     0,     3,     4,
       3,     8,     0,     1,     0,     3,     0,     2,     0,     3,
       1,     4,     4,     1,     3,     1,     1,     1,     1,     1,
       1,     6,     4,     3,     1,     1,     2,     1,     4,     2,
       3,     1,     1,     1,     3,     1,     3,     1,     3,     1,
       1,     1,     3,     2,     2,     4,     6,     5,     7,     0,
       2,     4,     8,     6,     0,     1,     2,     2,     2,     2,
       2,     0,     1,     1,     1,     2,     3,     3,     6,     6,
       2,     2,     1,     1,     2,     2,     2,     0,     2,     2,
       8,     6,     6,     7,     5,     0,     1,     2,     1,     3,
      12,     1,     1,     1,     1,     1,     1,     1,     4,     4,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       4,     0,     1,     1,     3,     1,     3,     0,     1,     0,
       1,     1,     3,     2,     3,     0,     3,     4,     5,     4,
       4,     3,     3,     3,     3,     5,     3,     2,     2,     3,
       3,     2,     5,     7,     3,     0,     3,     2,     2,     2,
       2,     2,     3,     3,     2,     2,     1,     2,     2,     2,
       5,     5,     1,     4,     2,     1,     1,     2,     2,     3,
       3,     1,     1,     2,     1,     1,     1,     1,     1,     1,
       1,     4,     1,     1,     1,     4,     1,     1,     1,     1,
       4,     1,     1,     3,     1,     4,     6,     6,     6,     0,
       1,     6,     6,     6,     1,     3,     3,     5,     4,     7,
       1,     1,     1,     1,     1,     3,     3,     1,     1,     3,
       1,     1,     1,     3,     6,     8,     9,     9,     8,     7,
       7,     6,     4,     4,     6,     3,     5,     6,     6,     4,
       4,     3,     6,     1,     3,     3,     3,     3,     3,     3,
       3,     3,     3,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     3,     3,     3,     3,     3,     3,     3,
       3,     5,     5,     5,     5,     3,     3,     3,     3,     3,
       3,     3,     3,     5,     5,     3,     3,     3,     3,     1,
       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
       3,     3,     4,     5,     1,     1,     1,     3,     0,     1,
       0,     1,     1,     3,     2,     3,     2,     3,     4,     5,
       1,     3,     1,     1,     2,     3,     1,     3,     4,     4,
       1,     1,     3,     5,     5,     3,     5,     5,     3,     1,
       2,     3,     2,     2,     1,     1,     4,     1,     3,     3,
       5,     8,     4,     2,     1,     1,     1,     1,     3,     0,
       4,     1,     1,     5,     0,     3,     1,     1,     1,     0,
       1,     1,     1,     1,     1,     4,     2,     2,     1,     2,
       2,     1,     2,     2,     2,     2,     1,     0,     3,     0,
       1,     2,     1,     3,     3,     1,     2,     3,     1,     2,
       4,     2,     4,     2,     1,     4,     2,     8,     2,     2,
       2,     0,     2,     0,     2,     0,     3,     1,     3,     1,
       0,     2,     2,     0,     2,     2,     0,     2,     0,     3,
       1,     3,     2,     0,     2,     0,     2,     0,     1,     1,
       1,     1,     3,     2,     1,     0,     1,     2,     1,     1,
       1,     1,     3,     2,     1,     2,     2,     4,     4,     2,
       3,     2,     0,     1,     1,     2,     2,     1,     1,     4,
       0,     1,     2,     4,     4,     8,    11,     1,     2,     2,
       3,     4,     0,     5,     0,     1,     1,     2,     2,     2,
       4,     4,     4,     4,     4,     2,     0,     3,     3,     3,
       3,     4,     3,     3,     5,     5,     4,     4,     5,     2,
       1,     2,     2,     3,     1,     1,     0,     1,     3,     6,
       1,     2,     2,     3,     8,    12,     3,     1,     3,     1,
       2,     2,     3,     5,     5,     9,     5,     5,     0,     4,
       1,     1,     3,     7,     1,     3,     1,     3,     7,     6,
       2,     3,     1,     3,     3,     8,    10,     7,     9,     7,
       8,     6,     7,     1,     1,     5,     6,     9,     8,    10,
      12,    11,    13,     6,     5,     9,     8,     1,     1,     1,
       2,     1,     2,     1,     3,     1,     2,     0,     1,     3,
       2,     3,     1,     2,     0,     1,     3,     4,     3,     5,
       4,     7,     6,     1,     1,     1,     1,     1,     1,     1,
       5,     4,     5,     4,     6,     5,     4,     3,     3,     3,
       1,     5,     7,     5,     4,     6,     4,     4,     2,     3,
       1,     5,     1,     1,     2,     2,     1,    11,     5,     1,
       4,     2,     9,     5,     5,     1,     3,     2,     5,     2,
       2,     3,     5,     1,     3,     5,     7,     2,     1,     7,
       0,     2,     4,     1,     2,     0,     1,     1,     1,     1,
       1,     1,     1,     3,     0,     1,     1,     1,     3,     2,
       1,     2,     3,     4,     4,     5,     2,     1,     5,     1,
       1,     2,     2,     3,     4,     7,     6,     6,     6,     0,
       1,     1,     2,     1,     1,     2,     0,     2,     5,     0,
       1,     0,     2,     1,     2,     2,     2,     2,     2,     1,
       1,     1,     1,     4,     4,     1,     2,     2,     2,     1,
       3,     2,     2,     1,     1,     1,     1,     2,     5,     2,
       2,     1,     1,     1,     1,     9,     9,     9,     9,     9,
       9,     7,     7,     7,     2,     2,     1,     1,     5,     3,
       5,     3,     4,     4,     4,     4,     4,     4,     0,     1,
       1,     3,     4,     4,     4,     4,     1,     3,     0,     1,
       1,     3,     3,     1,     1,     1,     1,     1,     1
};


enum { YYENOMEM = -2 };

#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (yychar = YYEMPTY)

#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrorlab
#define YYNOMEM         goto yyexhaustedlab


#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)                                    \
  do                                                              \
    if (yychar == YYEMPTY)                                        \
      {                                                           \
        yychar = (Token);                                         \
        yylval = (Value);                                         \
        YYPOPSTACK (yylen);                                       \
        yystate = *yyssp;                                         \
        goto yybackup;                                            \
      }                                                           \
    else                                                          \
      {                                                           \
        yyerror (YY_("syntax error: cannot back up")); \
        YYERROR;                                                  \
      }                                                           \
  while (0)

/* Backward compatibility with an undocumented macro.
   Use YYerror or YYUNDEF. */
#define YYERRCODE YYUNDEF


/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)                        \
do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)




# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, "%s ", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Kind, Value); \
      YYFPRINTF (stderr, "\n");                                           \
    }                                                                     \
} while (0)


/*-----------------------------------.
| Print this symbol's value on YYO.  |
`-----------------------------------*/

static void
yy_symbol_value_print (FILE *yyo,
                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
{
  FILE *yyoutput = yyo;
  YY_USE (yyoutput);
  if (!yyvaluep)
    return;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  YY_USE (yykind);
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}


/*---------------------------.
| Print this symbol on YYO.  |
`---------------------------*/

static void
yy_symbol_print (FILE *yyo,
                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
{
  YYFPRINTF (yyo, "%s %s (",
             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));

  yy_symbol_value_print (yyo, yykind, yyvaluep);
  YYFPRINTF (yyo, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

static void
yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
{
  YYFPRINTF (stderr, "Stack now");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, " %d", yybot);
    }
  YYFPRINTF (stderr, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)                            \
do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

static void
yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
                 int yyrule)
{
  int yylno = yyrline[yyrule];
  int yynrhs = yyr2[yyrule];
  int yyi;
  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
             yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
      yy_symbol_print (stderr,
                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
                       &yyvsp[(yyi + 1) - (yynrhs)]);
      YYFPRINTF (stderr, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)          \
do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, Rule); \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args) ((void) 0)
# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif


/* Context of a parse error.  */
typedef struct
{
  yy_state_t *yyssp;
  yysymbol_kind_t yytoken;
} yypcontext_t;

/* Put in YYARG at most YYARGN of the expected tokens given the
   current YYCTX, and return the number of tokens stored in YYARG.  If
   YYARG is null, return the number of expected tokens (guaranteed to
   be less than YYNTOKENS).  Return YYENOMEM on memory exhaustion.
   Return 0 if there are more than YYARGN expected tokens, yet fill
   YYARG up to YYARGN. */
static int
yypcontext_expected_tokens (const yypcontext_t *yyctx,
                            yysymbol_kind_t yyarg[], int yyargn)
{
  /* Actual size of YYARG. */
  int yycount = 0;
  int yyn = yypact[+*yyctx->yyssp];
  if (!yypact_value_is_default (yyn))
    {
      /* Start YYX at -YYN if negative to avoid negative indexes in
         YYCHECK.  In other words, skip the first -YYN actions for
         this state because they are default actions.  */
      int yyxbegin = yyn < 0 ? -yyn : 0;
      /* Stay within bounds of both yycheck and yytname.  */
      int yychecklim = YYLAST - yyn + 1;
      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
      int yyx;
      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
        if (yycheck[yyx + yyn] == yyx && yyx != YYSYMBOL_YYerror
            && !yytable_value_is_error (yytable[yyx + yyn]))
          {
            if (!yyarg)
              ++yycount;
            else if (yycount == yyargn)
              return 0;
            else
              yyarg[yycount++] = YY_CAST (yysymbol_kind_t, yyx);
          }
    }
  if (yyarg && yycount == 0 && 0 < yyargn)
    yyarg[0] = YYSYMBOL_YYEMPTY;
  return yycount;
}




#ifndef yystrlen
# if defined __GLIBC__ && defined _STRING_H
#  define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
# else
/* Return the length of YYSTR.  */
static YYPTRDIFF_T
yystrlen (const char *yystr)
{
  YYPTRDIFF_T yylen;
  for (yylen = 0; yystr[yylen]; yylen++)
    continue;
  return yylen;
}
# endif
#endif

#ifndef yystpcpy
# if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#  define yystpcpy stpcpy
# else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
static char *
yystpcpy (char *yydest, const char *yysrc)
{
  char *yyd = yydest;
  const char *yys = yysrc;

  while ((*yyd++ = *yys++) != '\0')
    continue;

  return yyd - 1;
}
# endif
#endif

#ifndef yytnamerr
/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
   quotes and backslashes, so that it's suitable for yyerror.  The
   heuristic is that double-quoting is unnecessary unless the string
   contains an apostrophe, a comma, or backslash (other than
   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
   null, do not copy; instead, return the length of what the result
   would have been.  */
static YYPTRDIFF_T
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == '"')
    {
      YYPTRDIFF_T yyn = 0;
      char const *yyp = yystr;
      for (;;)
        switch (*++yyp)
          {
          case '\'':
          case ',':
            goto do_not_strip_quotes;

          case '\\':
            if (*++yyp != '\\')
              goto do_not_strip_quotes;
            else
              goto append;

          append:
          default:
            if (yyres)
              yyres[yyn] = *yyp;
            yyn++;
            break;

          case '"':
            if (yyres)
              yyres[yyn] = '\0';
            return yyn;
          }
    do_not_strip_quotes: ;
    }

  if (yyres)
    return yystpcpy (yyres, yystr) - yyres;
  else
    return yystrlen (yystr);
}
#endif


static int
yy_syntax_error_arguments (const yypcontext_t *yyctx,
                           yysymbol_kind_t yyarg[], int yyargn)
{
  /* Actual size of YYARG. */
  int yycount = 0;
  /* There are many possibilities here to consider:
     - If this state is a consistent state with a default action, then
       the only way this function was invoked is if the default action
       is an error action.  In that case, don't check for expected
       tokens because there are none.
     - The only way there can be no lookahead present (in yychar) is if
       this state is a consistent state with a default action.  Thus,
       detecting the absence of a lookahead is sufficient to determine
       that there is no unexpected or expected token to report.  In that
       case, just report a simple "syntax error".
     - Don't assume there isn't a lookahead just because this state is a
       consistent state with a default action.  There might have been a
       previous inconsistent state, consistent state with a non-default
       action, or user semantic action that manipulated yychar.
     - Of course, the expected token list depends on states to have
       correct lookahead information, and it depends on the parser not
       to perform extra reductions after fetching a lookahead from the
       scanner and before detecting a syntax error.  Thus, state merging
       (from LALR or IELR) and default reductions corrupt the expected
       token list.  However, the list is correct for canonical LR with
       one exception: it will still contain any token that will not be
       accepted due to an error action in a later state.
  */
  if (yyctx->yytoken != YYSYMBOL_YYEMPTY)
    {
      int yyn;
      if (yyarg)
        yyarg[yycount] = yyctx->yytoken;
      ++yycount;
      yyn = yypcontext_expected_tokens (yyctx,
                                        yyarg ? yyarg + 1 : yyarg, yyargn - 1);
      if (yyn == YYENOMEM)
        return YYENOMEM;
      else
        yycount += yyn;
    }
  return yycount;
}

/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
   about the unexpected token YYTOKEN for the state stack whose top is
   YYSSP.

   Return 0 if *YYMSG was successfully written.  Return -1 if *YYMSG is
   not large enough to hold the message.  In that case, also set
   *YYMSG_ALLOC to the required number of bytes.  Return YYENOMEM if the
   required number of bytes is too large to store.  */
static int
yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
                const yypcontext_t *yyctx)
{
  enum { YYARGS_MAX = 5 };
  /* Internationalized format string. */
  const char *yyformat = YY_NULLPTR;
  /* Arguments of yyformat: reported tokens (one for the "unexpected",
     one per "expected"). */
  yysymbol_kind_t yyarg[YYARGS_MAX];
  /* Cumulated lengths of YYARG.  */
  YYPTRDIFF_T yysize = 0;

  /* Actual size of YYARG. */
  int yycount = yy_syntax_error_arguments (yyctx, yyarg, YYARGS_MAX);
  if (yycount == YYENOMEM)
    return YYENOMEM;

  switch (yycount)
    {
#define YYCASE_(N, S)                       \
      case N:                               \
        yyformat = S;                       \
        break
    default: /* Avoid compiler warnings. */
      YYCASE_(0, YY_("syntax error"));
      YYCASE_(1, YY_("syntax error, unexpected %s"));
      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
#undef YYCASE_
    }

  /* Compute error message size.  Don't count the "%s"s, but reserve
     room for the terminator.  */
  yysize = yystrlen (yyformat) - 2 * yycount + 1;
  {
    int yyi;
    for (yyi = 0; yyi < yycount; ++yyi)
      {
        YYPTRDIFF_T yysize1
          = yysize + yytnamerr (YY_NULLPTR, yytname[yyarg[yyi]]);
        if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
          yysize = yysize1;
        else
          return YYENOMEM;
      }
  }

  if (*yymsg_alloc < yysize)
    {
      *yymsg_alloc = 2 * yysize;
      if (! (yysize <= *yymsg_alloc
             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
      return -1;
    }

  /* Avoid sprintf, as that infringes on the user's name space.
     Don't have undefined behavior even if the translation
     produced a string with the wrong number of "%s"s.  */
  {
    char *yyp = *yymsg;
    int yyi = 0;
    while ((*yyp = *yyformat) != '\0')
      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        {
          yyp += yytnamerr (yyp, yytname[yyarg[yyi++]]);
          yyformat += 2;
        }
      else
        {
          ++yyp;
          ++yyformat;
        }
  }
  return 0;
}


/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

static void
yydestruct (const char *yymsg,
            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
{
  YY_USE (yyvaluep);
  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  YY_USE (yykind);
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}


/* Lookahead token kind.  */
int yychar;

/* The semantic value of the lookahead symbol.  */
YYSTYPE yylval;
/* Number of syntax errors so far.  */
int yynerrs;




/*----------.
| yyparse.  |
`----------*/

int
yyparse (void)
{
    yy_state_fast_t yystate = 0;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus = 0;

    /* Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* Their size.  */
    YYPTRDIFF_T yystacksize = YYINITDEPTH;

    /* The state stack: array, bottom, top.  */
    yy_state_t yyssa[YYINITDEPTH];
    yy_state_t *yyss = yyssa;
    yy_state_t *yyssp = yyss;

    /* The semantic value stack: array, bottom, top.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs = yyvsa;
    YYSTYPE *yyvsp = yyvs;

  int yyn;
  /* The return value of yyparse.  */
  int yyresult;
  /* Lookahead symbol kind.  */
  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  YYDPRINTF ((stderr, "Starting parse\n"));

  yychar = YYEMPTY; /* Cause a token to be read.  */

  goto yysetstate;


/*------------------------------------------------------------.
| yynewstate -- push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;


/*--------------------------------------------------------------------.
| yysetstate -- set current state (the top of the stack) to yystate.  |
`--------------------------------------------------------------------*/
yysetstate:
  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
  YY_IGNORE_USELESS_CAST_BEGIN
  *yyssp = YY_CAST (yy_state_t, yystate);
  YY_IGNORE_USELESS_CAST_END
  YY_STACK_PRINT (yyss, yyssp);

  if (yyss + yystacksize - 1 <= yyssp)
#if !defined yyoverflow && !defined YYSTACK_RELOCATE
    YYNOMEM;
#else
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYPTRDIFF_T yysize = yyssp - yyss + 1;

# if defined yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        yy_state_t *yyss1 = yyss;
        YYSTYPE *yyvs1 = yyvs;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_("memory exhausted"),
                    &yyss1, yysize * YYSIZEOF (*yyssp),
                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
                    &yystacksize);
        yyss = yyss1;
        yyvs = yyvs1;
      }
# else /* defined YYSTACK_RELOCATE */
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        YYNOMEM;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yy_state_t *yyss1 = yyss;
        union yyalloc *yyptr =
          YY_CAST (union yyalloc *,
                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
        if (! yyptr)
          YYNOMEM;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YY_IGNORE_USELESS_CAST_BEGIN
      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
                  YY_CAST (long, yystacksize)));
      YY_IGNORE_USELESS_CAST_END

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }
#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */


  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;


/*-----------.
| yybackup.  |
`-----------*/
yybackup:
  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, "Reading a token\n"));
      yychar = yylex ();
    }

  if (yychar <= YYEOF)
    {
      yychar = YYEOF;
      yytoken = YYSYMBOL_YYEOF;
      YYDPRINTF ((stderr, "Now at end of input.\n"));
    }
  else if (yychar == YYerror)
    {
      /* The scanner already issued an error message, process directly
         to error recovery.  But do not keep the error token as
         lookahead, it is too special and may lead us to an endless
         loop in error recovery. */
      yychar = YYUNDEF;
      yytoken = YYSYMBOL_YYerror;
      goto yyerrlab1;
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  /* Discard the shifted token.  */
  yychar = YYEMPTY;
  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
  case 2: /* program: top_level_stmts  */
                                {
    if (!parse_error_occurred) {
      gen_init();
      if (options.expand) {
        expand_macros((yyvsp[0].aval));
        if (macro_expansion_errors) {
          cql_cleanup_and_exit(3);
        }
      }
      if (options.semantic) {
        sem_main((yyvsp[0].aval));
      }
      if (options.codegen) {
        rt->code_generator((yyvsp[0].aval));
      }
      else if (options.print_ast) {
        print_root_ast((yyvsp[0].aval));
        cql_output("\n");
      }
      else if (options.print_dot) {
        cql_output("\ndigraph parse {");
        print_dot((yyvsp[0].aval));
        cql_output("\n}\n");
      }
      else if (options.echo_input) {
        gen_stmt_list_to_stdout((yyvsp[0].aval));
      }
      if (options.semantic) {
        cql_exit_on_semantic_errors((yyvsp[0].aval));
      }
    }
  }
    break;

  case 3: /* top_level_stmts: %empty  */
               { (yyval.aval) = NULL; }
    break;

  case 4: /* top_level_stmts: include_stmts  */
                    { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 5: /* top_level_stmts: stmt_list  */
                { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 6: /* top_level_stmts: include_stmts stmt_list  */
                                      {
       (yyval.aval) = (yyvsp[0].aval);
       if ((yyvsp[-1].aval)) {
         // use our tail pointer invariant so we can add at the tail without searching
         // the re-stablish the invariant
         ast_node *tail = (yyvsp[-1].aval)->parent;
         (yyvsp[-1].aval)->parent = (yyvsp[0].aval)->parent;
         ast_set_right(tail, (yyvsp[0].aval));
         (yyval.aval) = (yyvsp[-1].aval);
      }
   }
    break;

  case 7: /* include_section: BEGIN_INCLUDE top_level_stmts END_INCLUDE  */
                                                           { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 8: /* include_stmts: include_section  */
                        { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 9: /* include_stmts: include_section include_stmts  */
                                            {
       if (!(yyvsp[-1].aval)) {
         (yyval.aval) = (yyvsp[0].aval);
       }
       else {
         (yyval.aval) = (yyvsp[-1].aval);
         if ((yyvsp[0].aval)) {
           // use our tail pointer invariant so we can add at the tail without searching
           // the re-establish the invariant
           ast_node *tail = (yyvsp[-1].aval)->parent;
           (yyvsp[-1].aval)->parent = (yyvsp[0].aval)->parent;
           ast_set_right(tail, (yyvsp[0].aval));
        }
      }
    }
    break;

  case 10: /* opt_stmt_list: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 11: /* opt_stmt_list: stmt_list  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 12: /* macro_ref: ID '!'  */
         {
     YY_ERROR_ON_MACRO((yyvsp[-1].sval));
     (yyval.aval) = new_macro_arg_ref_node((yyvsp[-1].sval)); }
    break;

  case 13: /* macro_ref: ID '!' '(' opt_macro_args ')'  */
                                  {
     YY_ERROR_ON_MACRO_ARG((yyvsp[-4].sval));
     (yyval.aval) = new_macro_ref_node((yyvsp[-4].sval), (yyvsp[-1].aval)); }
    break;

  case 14: /* stmt_list: stmt  */
       {
     // We're going to do this cheesy thing with the stmt_list structures so that we can
     // code the stmt_list rules using left recursion.  We're doing this because it's
     // possible that there could be a LOT of statements and this minimizes the use
     // of the bison stack because reductions happen sooner with this pattern.  It does
     // mean we have to do some weird stuff because we need to build the list so that the
     // tail is on the right.  To accomplish this we take advantage of the fact that the
     // parent pointer of the statement list is meaningless while it is unrooted.  It
     // would always be null.  We store the tail of the statement list there so we know
     // where to add new nodes on the right.  When the statement list is put into the tree
     // the parent node is set as usual so nobody will know we did this and we don't
     // have to add anything to the node for this one case.

     // With this done we can handle several thousand statements without using much stack space.

     (yyval.aval) = new_ast_stmt_list((yyvsp[0].aval), NULL);
     (yyval.aval)->lineno = (yyvsp[0].aval)->lineno;

     // set up the tail pointer invariant to use later
     (yyval.aval)->parent = (yyval.aval);
     }
    break;

  case 15: /* stmt_list: stmt_list stmt  */
                          {
     ast_node *new_stmt = new_ast_stmt_list((yyvsp[0].aval), NULL);
     new_stmt->lineno = (yyvsp[0].aval)->lineno;

     // use our tail pointer invariant so we can add at the tail without searching
     ast_node *tail = (yyvsp[-1].aval)->parent;
     ast_set_right(tail, new_stmt);

     // re-establish the tail invariant per the above
     (yyvsp[-1].aval)->parent = new_stmt;
     (yyval.aval) = (yyvsp[-1].aval);
     }
    break;

  case 16: /* stmt: misc_attrs any_stmt ';'  */
                          { (yyval.aval) = make_statement_node((yyvsp[-2].aval), (yyvsp[-1].aval)); }
    break;

  case 17: /* stmt: ifdef_stmt  */
               { (yyval.aval) = make_statement_node(NULL, (yyvsp[0].aval)); }
    break;

  case 18: /* stmt: ifndef_stmt  */
                { (yyval.aval) = make_statement_node(NULL, (yyvsp[0].aval)); }
    break;

  case 19: /* expr_stmt: expr  */
                {
     if (is_ast_stmt_list_macro_ref((yyvsp[0].aval)) || is_ast_stmt_list_macro_arg_ref((yyvsp[0].aval))) {
        (yyval.aval) = (yyvsp[0].aval);
     }
     else {
       (yyval.aval) = new_ast_expr_stmt((yyvsp[0].aval));
     }
   }
    break;

  case 104: /* explain_stmt: EXPLAIN opt_query_plan explain_target  */
                                         { (yyval.aval) = new_ast_explain_stmt(new_ast_option((yyvsp[-1].ival)), (yyvsp[0].aval)); }
    break;

  case 105: /* opt_query_plan: %empty  */
             { (yyval.ival) = EXPLAIN_NONE; }
    break;

  case 106: /* opt_query_plan: QUERY_PLAN  */
                { (yyval.ival) = EXPLAIN_QUERY_PLAN; }
    break;

  case 118: /* previous_schema_stmt: AT_PREVIOUS_SCHEMA  */
                      { (yyval.aval) = new_ast_previous_schema_stmt(); }
    break;

  case 119: /* schema_upgrade_script_stmt: AT_SCHEMA_UPGRADE_SCRIPT  */
                            { (yyval.aval) = new_ast_schema_upgrade_script_stmt(); }
    break;

  case 120: /* schema_upgrade_version_stmt: AT_SCHEMA_UPGRADE_VERSION '(' INTLIT ')'  */
                                            {
    (yyval.aval) = new_ast_schema_upgrade_version_stmt(new_ast_option(atoi((yyvsp[-1].sval)))); }
    break;

  case 121: /* set_stmt: SET sql_name ":=" expr  */
                            { (yyval.aval) = new_ast_assign((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 122: /* set_stmt: SET sql_name FROM CURSOR name  */
                                              { (yyval.aval) = new_ast_set_from_cursor((yyvsp[-3].aval), (yyvsp[0].aval)); }
    break;

  case 123: /* set_stmt: SET sql_name '[' arg_list ']' ":=" expr  */
                                               { (yyval.aval) = new_ast_expr_stmt(new_ast_expr_assign(new_ast_array((yyvsp[-5].aval), (yyvsp[-3].aval)), (yyvsp[0].aval))); }
    break;

  case 124: /* let_stmt: LET sql_name ":=" expr  */
                            { (yyval.aval) = new_ast_let_stmt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 125: /* const_stmt: CONST sql_name ":=" expr  */
                              { (yyval.aval) = new_ast_const_stmt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 126: /* version_attrs_opt_recreate: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 127: /* version_attrs_opt_recreate: AT_RECREATE opt_delete_plain_attr  */
                                       { (yyval.aval) = new_ast_recreate_attr(NULL, (yyvsp[0].aval)); }
    break;

  case 128: /* version_attrs_opt_recreate: AT_RECREATE '(' name ')' opt_delete_plain_attr  */
                                                    { (yyval.aval) = new_ast_recreate_attr((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 129: /* version_attrs_opt_recreate: version_attrs  */
                   { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 130: /* opt_delete_plain_attr: %empty  */
             {(yyval.aval) = NULL; }
    break;

  case 131: /* opt_delete_plain_attr: AT_DELETE  */
              { (yyval.aval) = new_ast_delete_attr(NULL, NULL); }
    break;

  case 132: /* opt_version_attrs: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 133: /* opt_version_attrs: version_attrs  */
                   { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 134: /* version_attrs: AT_CREATE version_annotation opt_version_attrs  */
                                                  { (yyval.aval) = new_ast_create_attr((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 135: /* version_attrs: AT_DELETE version_annotation opt_version_attrs  */
                                                    { (yyval.aval) = new_ast_delete_attr((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 136: /* opt_delete_version_attr: %empty  */
             {(yyval.aval) = NULL; }
    break;

  case 137: /* opt_delete_version_attr: AT_DELETE version_annotation  */
                                  { (yyval.aval) = new_ast_delete_attr((yyvsp[0].aval), NULL); }
    break;

  case 138: /* drop_table_stmt: DROP TABLE IF EXISTS sql_name  */
                                 { (yyval.aval) = new_ast_drop_table_stmt(new_ast_option(1), (yyvsp[0].aval));  }
    break;

  case 139: /* drop_table_stmt: DROP TABLE sql_name  */
                         { (yyval.aval) = new_ast_drop_table_stmt(NULL, (yyvsp[0].aval));  }
    break;

  case 140: /* drop_view_stmt: DROP VIEW IF EXISTS sql_name  */
                                { (yyval.aval) = new_ast_drop_view_stmt(new_ast_option(1), (yyvsp[0].aval));  }
    break;

  case 141: /* drop_view_stmt: DROP VIEW sql_name  */
                        { (yyval.aval) = new_ast_drop_view_stmt(NULL, (yyvsp[0].aval));  }
    break;

  case 142: /* drop_index_stmt: DROP INDEX IF EXISTS sql_name  */
                                 { (yyval.aval) = new_ast_drop_index_stmt(new_ast_option(1), (yyvsp[0].aval));  }
    break;

  case 143: /* drop_index_stmt: DROP INDEX sql_name  */
                         { (yyval.aval) = new_ast_drop_index_stmt(NULL, (yyvsp[0].aval));  }
    break;

  case 144: /* drop_trigger_stmt: DROP TRIGGER IF EXISTS sql_name  */
                                   { (yyval.aval) = new_ast_drop_trigger_stmt(new_ast_option(1), (yyvsp[0].aval));  }
    break;

  case 145: /* drop_trigger_stmt: DROP TRIGGER sql_name  */
                           { (yyval.aval) = new_ast_drop_trigger_stmt(NULL, (yyvsp[0].aval));  }
    break;

  case 146: /* create_virtual_table_stmt: CREATE VIRTUAL TABLE opt_vtab_flags sql_name USING name opt_module_args AS '(' col_key_list ')' opt_delete_version_attr  */
                                                                           {
    int flags = (yyvsp[-9].ival);
    struct ast_node *flags_node = new_ast_option(flags);
    struct ast_node *name = (yyvsp[-8].aval);
    struct ast_node *col_key_list = (yyvsp[-2].aval);
    struct ast_node *version_info = (yyvsp[0].aval) ? (yyvsp[0].aval) : new_ast_recreate_attr(NULL, NULL);
    struct ast_node *table_flags_attrs = new_ast_table_flags_attrs(flags_node, version_info);
    struct ast_node *table_name_flags = new_ast_create_table_name_flags(table_flags_attrs, name);
    struct ast_node *create_table_stmt =  new_ast_create_table_stmt(table_name_flags, col_key_list);
    struct ast_node *module_info = new_ast_module_info((yyvsp[-6].aval), (yyvsp[-5].aval));
    (yyval.aval) = new_ast_create_virtual_table_stmt(module_info, create_table_stmt);
  }
    break;

  case 147: /* opt_module_args: %empty  */
                           { (yyval.aval) = NULL; }
    break;

  case 148: /* opt_module_args: '(' misc_attr_value_list ')'  */
                                 { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 149: /* opt_module_args: '(' ARGUMENTS FOLLOWING ')'  */
                                { (yyval.aval) = new_ast_following(); }
    break;

  case 150: /* create_table_prefix_opt_temp: CREATE opt_temp TABLE  */
                        {
    /* This node only exists so that we can get an early reduce in the table flow to grab the doc comment */
   (yyval.ival) = (yyvsp[-1].ival); table_comment_saved = get_last_doc_comment();
  }
    break;

  case 151: /* create_table_stmt: create_table_prefix_opt_temp opt_if_not_exists sql_name '(' col_key_list ')' opt_no_rowid version_attrs_opt_recreate  */
                                                                                                                        {
    int flags = (yyvsp[-7].ival) | (yyvsp[-6].ival) | (yyvsp[-1].ival);
    struct ast_node *flags_node = new_ast_option(flags);
    struct ast_node *name = (yyvsp[-5].aval);
    struct ast_node *col_key_list = (yyvsp[-3].aval);
    struct ast_node *table_flags_attrs = new_ast_table_flags_attrs(flags_node, (yyvsp[0].aval));
    struct ast_node *table_name_flags = new_ast_create_table_name_flags(table_flags_attrs, name);
    (yyval.aval) =  new_ast_create_table_stmt(table_name_flags, col_key_list);
  }
    break;

  case 152: /* opt_temp: %empty  */
             { (yyval.ival) = 0; }
    break;

  case 153: /* opt_temp: TEMP  */
          { (yyval.ival) = GENERIC_IS_TEMP; }
    break;

  case 154: /* opt_if_not_exists: %empty  */
             { (yyval.ival) = 0;  }
    break;

  case 155: /* opt_if_not_exists: IF NOT EXISTS  */
                   { (yyval.ival) = GENERIC_IF_NOT_EXISTS; }
    break;

  case 156: /* opt_no_rowid: %empty  */
             { (yyval.ival) = 0; }
    break;

  case 157: /* opt_no_rowid: WITHOUT ROWID  */
                   { (yyval.ival) = TABLE_IS_NO_ROWID; }
    break;

  case 158: /* opt_vtab_flags: %empty  */
            { (yyval.ival) = 0; }
    break;

  case 159: /* opt_vtab_flags: IF NOT EXISTS  */
                   { (yyval.ival) = GENERIC_IF_NOT_EXISTS; }
    break;

  case 160: /* opt_vtab_flags: AT_EPONYMOUS  */
                 { (yyval.ival) = VTAB_IS_EPONYMOUS; }
    break;

  case 161: /* opt_vtab_flags: AT_EPONYMOUS IF NOT EXISTS  */
                                { (yyval.ival) = VTAB_IS_EPONYMOUS | GENERIC_IF_NOT_EXISTS; }
    break;

  case 162: /* opt_vtab_flags: IF NOT EXISTS AT_EPONYMOUS  */
                               { (yyval.ival) = VTAB_IS_EPONYMOUS | GENERIC_IF_NOT_EXISTS; }
    break;

  case 163: /* col_key_list: col_key_def  */
               { (yyval.aval) = new_ast_col_key_list((yyvsp[0].aval), NULL); }
    break;

  case 164: /* col_key_list: col_key_def ',' col_key_list  */
                                       { (yyval.aval) = new_ast_col_key_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 171: /* check_def: CONSTRAINT name CHECK '(' expr ')'  */
                                     { (yyval.aval) = new_ast_check_def((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 172: /* check_def: CHECK '(' expr ')'  */
                        { (yyval.aval) = new_ast_check_def(NULL, (yyvsp[-1].aval)); }
    break;

  case 173: /* shape_exprs: shape_expr ',' shape_exprs  */
                                   { (yyval.aval) = new_ast_shape_exprs((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 174: /* shape_exprs: shape_expr  */
               { (yyval.aval) = new_ast_shape_exprs((yyvsp[0].aval), NULL); }
    break;

  case 175: /* shape_expr: sql_name  */
            { (yyval.aval) = new_ast_shape_expr((yyvsp[0].aval), (yyvsp[0].aval)); }
    break;

  case 176: /* shape_expr: '-' sql_name  */
                  { (yyval.aval) = new_ast_shape_expr((yyvsp[0].aval), NULL); }
    break;

  case 177: /* shape_def: shape_def_base  */
                    { (yyval.aval) = new_ast_shape_def((yyvsp[0].aval), NULL); }
    break;

  case 178: /* shape_def: shape_def_base '(' shape_exprs ')'  */
                                       { (yyval.aval) = new_ast_shape_def((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 179: /* shape_def_base: LIKE sql_name  */
                  { (yyval.aval) = new_ast_like((yyvsp[0].aval), NULL); }
    break;

  case 180: /* shape_def_base: LIKE name ARGUMENTS  */
                        { (yyval.aval) = new_ast_like((yyvsp[-1].aval), (yyvsp[-1].aval)); }
    break;

  case 181: /* sql_name: name  */
        { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 182: /* sql_name: QID  */
        { (yyval.aval) = new_ast_qstr_quoted((yyvsp[0].sval)); }
    break;

  case 183: /* misc_attr_key: name  */
        { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 184: /* misc_attr_key: name ':' name  */
                             { (yyval.aval) = new_ast_dot((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 185: /* cql_attr_key: name  */
       { (yyval.aval) = new_ast_dot(new_ast_str("cql"), (yyvsp[0].aval)); }
    break;

  case 186: /* cql_attr_key: name ':' name  */
                             { (yyval.aval) = new_ast_dot((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 187: /* misc_attr_value_list: misc_attr_value  */
                   { (yyval.aval) = new_ast_misc_attr_value_list((yyvsp[0].aval), NULL); }
    break;

  case 188: /* misc_attr_value_list: misc_attr_value ',' misc_attr_value_list  */
                                                   { (yyval.aval) = new_ast_misc_attr_value_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 189: /* misc_attr_value: sql_name  */
            { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 190: /* misc_attr_value: any_literal  */
                 { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 191: /* misc_attr_value: const_expr  */
                { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 192: /* misc_attr_value: '(' misc_attr_value_list ')'  */
                                  { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 193: /* misc_attr_value: '-' num_literal  */
                     { (yyval.aval) = new_ast_uminus((yyvsp[0].aval));}
    break;

  case 194: /* misc_attr_value: '+' num_literal  */
                     { (yyval.aval) = (yyvsp[0].aval);}
    break;

  case 195: /* misc_attr: AT_ATTRIBUTE '(' misc_attr_key ')'  */
                                      { (yyval.aval) = new_ast_misc_attr((yyvsp[-1].aval), NULL); }
    break;

  case 196: /* misc_attr: AT_ATTRIBUTE '(' misc_attr_key '=' misc_attr_value ')'  */
                                                           { (yyval.aval) = new_ast_misc_attr((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 197: /* misc_attr: '[' '[' cql_attr_key ']' ']'  */
                                 { (yyval.aval) = new_ast_misc_attr((yyvsp[-2].aval), NULL); }
    break;

  case 198: /* misc_attr: '[' '[' cql_attr_key '=' misc_attr_value ']' ']'  */
                                                      { (yyval.aval) = new_ast_misc_attr((yyvsp[-4].aval), (yyvsp[-2].aval)); }
    break;

  case 199: /* misc_attrs: %empty  */
                         { (yyval.aval) = NULL; }
    break;

  case 200: /* misc_attrs: misc_attr misc_attrs  */
                                          { (yyval.aval) = new_ast_misc_attrs((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 201: /* col_def: misc_attrs sql_name data_type_any col_attrs  */
                                               {
  struct ast_node *name_type = new_ast_col_def_name_type((yyvsp[-2].aval), (yyvsp[-1].aval));
  struct ast_node *col_def_type_attrs = new_ast_col_def_type_attrs(name_type, (yyvsp[0].aval));
  (yyval.aval) = make_coldef_node(col_def_type_attrs, (yyvsp[-3].aval));
  }
    break;

  case 202: /* pk_def: CONSTRAINT sql_name PRIMARY KEY '(' indexed_columns ')' opt_conflict_clause  */
                                                                              {
    ast_node *indexed_columns_conflict_clause = new_ast_indexed_columns_conflict_clause((yyvsp[-2].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_pk_def((yyvsp[-6].aval), indexed_columns_conflict_clause);
  }
    break;

  case 203: /* pk_def: PRIMARY KEY '(' indexed_columns ')' opt_conflict_clause  */
                                                            {
    ast_node *indexed_columns_conflict_clause = new_ast_indexed_columns_conflict_clause((yyvsp[-2].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_pk_def(NULL, indexed_columns_conflict_clause);
  }
    break;

  case 204: /* opt_conflict_clause: %empty  */
            { (yyval.aval) = NULL; }
    break;

  case 205: /* opt_conflict_clause: conflict_clause  */
                    { (yyval.aval) = new_ast_option((yyvsp[0].ival)); }
    break;

  case 206: /* conflict_clause: ON_CONFLICT ROLLBACK  */
                       { (yyval.ival) = ON_CONFLICT_ROLLBACK; }
    break;

  case 207: /* conflict_clause: ON_CONFLICT ABORT  */
                      { (yyval.ival) = ON_CONFLICT_ABORT; }
    break;

  case 208: /* conflict_clause: ON_CONFLICT FAIL  */
                     { (yyval.ival) = ON_CONFLICT_FAIL; }
    break;

  case 209: /* conflict_clause: ON_CONFLICT IGNORE  */
                       { (yyval.ival) = ON_CONFLICT_IGNORE; }
    break;

  case 210: /* conflict_clause: ON_CONFLICT REPLACE  */
                        { (yyval.ival) = ON_CONFLICT_REPLACE; }
    break;

  case 211: /* opt_fk_options: %empty  */
             { (yyval.ival) = 0; }
    break;

  case 212: /* opt_fk_options: fk_options  */
                { (yyval.ival) = (yyvsp[0].ival); }
    break;

  case 213: /* fk_options: fk_on_options  */
                 { (yyval.ival) = (yyvsp[0].ival); }
    break;

  case 214: /* fk_options: fk_deferred_options  */
                         { (yyval.ival) = (yyvsp[0].ival); }
    break;

  case 215: /* fk_options: fk_on_options fk_deferred_options  */
                                       { (yyval.ival) = (yyvsp[-1].ival) | (yyvsp[0].ival); }
    break;

  case 216: /* fk_on_options: ON DELETE fk_action  */
                       { (yyval.ival) = (yyvsp[0].ival); }
    break;

  case 217: /* fk_on_options: ON UPDATE fk_action  */
                         { (yyval.ival) = ((yyvsp[0].ival) << 4); }
    break;

  case 218: /* fk_on_options: ON UPDATE fk_action ON DELETE fk_action  */
                                                       { (yyval.ival) = ((yyvsp[-3].ival) << 4) | (yyvsp[0].ival); }
    break;

  case 219: /* fk_on_options: ON DELETE fk_action ON UPDATE fk_action  */
                                                       { (yyval.ival) = ((yyvsp[0].ival) << 4) | (yyvsp[-3].ival); }
    break;

  case 220: /* fk_action: SET "NULL"  */
             { (yyval.ival) = FK_SET_NULL; }
    break;

  case 221: /* fk_action: SET DEFAULT  */
                 { (yyval.ival) = FK_SET_DEFAULT; }
    break;

  case 222: /* fk_action: CASCADE  */
             { (yyval.ival) = FK_CASCADE; }
    break;

  case 223: /* fk_action: RESTRICT  */
              { (yyval.ival) = FK_RESTRICT; }
    break;

  case 224: /* fk_action: NO ACTION  */
               { (yyval.ival) = FK_NO_ACTION; }
    break;

  case 225: /* fk_deferred_options: DEFERRABLE fk_initial_state  */
                               { (yyval.ival) = FK_DEFERRABLE | (yyvsp[0].ival); }
    break;

  case 226: /* fk_deferred_options: NOT_DEFERRABLE fk_initial_state  */
                                     { (yyval.ival) = FK_NOT_DEFERRABLE | (yyvsp[0].ival); }
    break;

  case 227: /* fk_initial_state: %empty  */
             { (yyval.ival) = 0; }
    break;

  case 228: /* fk_initial_state: INITIALLY DEFERRED  */
                        { (yyval.ival) = FK_INITIALLY_DEFERRED; }
    break;

  case 229: /* fk_initial_state: INITIALLY IMMEDIATE  */
                         { (yyval.ival) = FK_INITIALLY_IMMEDIATE; }
    break;

  case 230: /* fk_def: CONSTRAINT sql_name FOREIGN KEY '(' sql_name_list ')' fk_target_options  */
                                                                           {
    ast_node *fk_info = new_ast_fk_info((yyvsp[-2].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_fk_def((yyvsp[-6].aval), fk_info); }
    break;

  case 231: /* fk_def: FOREIGN KEY '(' sql_name_list ')' fk_target_options  */
                                                         {
    ast_node *fk_info = new_ast_fk_info((yyvsp[-2].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_fk_def(NULL, fk_info); }
    break;

  case 232: /* fk_target_options: REFERENCES sql_name '(' sql_name_list ')' opt_fk_options  */
                                                            {
    (yyval.aval) = new_ast_fk_target_options(new_ast_fk_target((yyvsp[-4].aval), (yyvsp[-2].aval)), new_ast_option((yyvsp[0].ival))); }
    break;

  case 233: /* unq_def: CONSTRAINT sql_name UNIQUE '(' indexed_columns ')' opt_conflict_clause  */
                                                                         {
    ast_node *indexed_columns_conflict_clause = new_ast_indexed_columns_conflict_clause((yyvsp[-2].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_unq_def((yyvsp[-5].aval), indexed_columns_conflict_clause);
  }
    break;

  case 234: /* unq_def: UNIQUE '(' indexed_columns ')' opt_conflict_clause  */
                                                       {
    ast_node *indexed_columns_conflict_clause = new_ast_indexed_columns_conflict_clause((yyvsp[-2].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_unq_def(NULL, indexed_columns_conflict_clause);
  }
    break;

  case 235: /* opt_unique: %empty  */
             { (yyval.ival) = 0; }
    break;

  case 236: /* opt_unique: UNIQUE  */
            { (yyval.ival) = 1; }
    break;

  case 237: /* indexed_column: expr opt_asc_desc  */
                     {
    (yyval.aval) = new_ast_indexed_column((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 238: /* indexed_columns: indexed_column  */
                  { (yyval.aval) = new_ast_indexed_columns((yyvsp[0].aval), NULL); }
    break;

  case 239: /* indexed_columns: indexed_column ',' indexed_columns  */
                                            { (yyval.aval) = new_ast_indexed_columns((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 240: /* create_index_stmt: CREATE opt_unique INDEX opt_if_not_exists sql_name ON sql_name '(' indexed_columns ')' opt_where opt_delete_version_attr  */
                                                                                                                                                {
    int flags = 0;
    if ((yyvsp[-10].ival)) flags |= INDEX_UNIQUE;
    if ((yyvsp[-8].ival)) flags |= INDEX_IFNE;

    ast_node *create_index_on_list = new_ast_create_index_on_list((yyvsp[-7].aval), (yyvsp[-5].aval));
    ast_node *index_names_and_attrs = new_ast_index_names_and_attrs((yyvsp[-3].aval), (yyvsp[-1].aval));
    ast_node *connector = new_ast_connector(index_names_and_attrs, (yyvsp[0].aval));
    ast_node *flags_names_attrs = new_ast_flags_names_attrs(new_ast_option(flags), connector);
    (yyval.aval) = new_ast_create_index_stmt(create_index_on_list, flags_names_attrs);
  }
    break;

  case 241: /* name: ID  */
      { (yyval.aval) = new_ast_str((yyvsp[0].sval)); }
    break;

  case 242: /* name: ABORT  */
          { (yyval.aval) = new_ast_str("abort"); }
    break;

  case 243: /* name: ACTION  */
           { (yyval.aval) = new_ast_str("action"); }
    break;

  case 244: /* name: ADD  */
        { (yyval.aval) = new_ast_str("add"); }
    break;

  case 245: /* name: AFTER  */
          { (yyval.aval) = new_ast_str("after"); }
    break;

  case 246: /* name: ALTER  */
          { (yyval.aval) = new_ast_str("alter"); }
    break;

  case 247: /* name: ASC  */
        { (yyval.aval) = new_ast_str("asc"); }
    break;

  case 248: /* name: AT_ID '(' text_args ')'  */
                            { (yyval.aval) = new_ast_at_id((yyvsp[-1].aval)); }
    break;

  case 249: /* name: AT_TMP '(' text_args ')'  */
                             { (yyval.aval) = new_ast_at_id(new_ast_text_args(new_ast_str("@TMP"), (yyvsp[-1].aval))); }
    break;

  case 250: /* name: AUTOINCREMENT  */
                  { (yyval.aval) = new_ast_str("autoincrement"); }
    break;

  case 251: /* name: BEFORE  */
           { (yyval.aval) = new_ast_str("before"); }
    break;

  case 252: /* name: CASCADE  */
            { (yyval.aval) = new_ast_str("cascade"); }
    break;

  case 253: /* name: COLUMN  */
           { (yyval.aval) = new_ast_str("column"); }
    break;

  case 254: /* name: CREATE  */
           { (yyval.aval) = new_ast_str("create"); }
    break;

  case 255: /* name: CTE_TABLES  */
               { (yyval.aval) = new_ast_str("cte_tables"); }
    break;

  case 256: /* name: DEFAULT  */
            { (yyval.aval) = new_ast_str("default"); }
    break;

  case 257: /* name: DEFERRABLE  */
               { (yyval.aval) = new_ast_str("deferrable"); }
    break;

  case 258: /* name: DEFERRED  */
             { (yyval.aval) = new_ast_str("deferred"); }
    break;

  case 259: /* name: DELETE  */
           { (yyval.aval) = new_ast_str("delete"); }
    break;

  case 260: /* name: DESC  */
         { (yyval.aval) = new_ast_str("desc"); }
    break;

  case 261: /* name: DROP  */
         { (yyval.aval) = new_ast_str("drop"); }
    break;

  case 262: /* name: ENCODE  */
           { (yyval.aval) = new_ast_str("encode"); }
    break;

  case 263: /* name: EXCLUSIVE  */
              { (yyval.aval) = new_ast_str("exclusive"); }
    break;

  case 264: /* name: EXPLAIN  */
            { (yyval.aval) = new_ast_str("explain"); }
    break;

  case 265: /* name: EXPR  */
         { (yyval.aval) = new_ast_str("expr"); }
    break;

  case 266: /* name: FAIL  */
         { (yyval.aval) = new_ast_str("fail"); }
    break;

  case 267: /* name: FETCH  */
          { (yyval.aval) = new_ast_str("fetch"); }
    break;

  case 268: /* name: FIRST  */
          { (yyval.aval) = new_ast_str("first"); }
    break;

  case 269: /* name: FOLLOWING  */
              { (yyval.aval) = new_ast_str("following"); }
    break;

  case 270: /* name: GROUPS  */
           { (yyval.aval) = new_ast_str("groups"); }
    break;

  case 271: /* name: HIDDEN  */
           { (yyval.aval) = new_ast_str("hidden"); }
    break;

  case 272: /* name: IGNORE  */
           { (yyval.aval) = new_ast_str("ignore"); }
    break;

  case 273: /* name: IMMEDIATE  */
              { (yyval.aval) = new_ast_str("immediate"); }
    break;

  case 274: /* name: INDEX  */
          { (yyval.aval) = new_ast_str("index"); }
    break;

  case 275: /* name: INITIALLY  */
              { (yyval.aval) = new_ast_str("initially"); }
    break;

  case 276: /* name: INSTEAD  */
            { (yyval.aval) = new_ast_str("instead"); }
    break;

  case 277: /* name: INTO  */
         { (yyval.aval) = new_ast_str("into"); }
    break;

  case 278: /* name: KEY  */
         { (yyval.aval) = new_ast_str("key"); }
    break;

  case 279: /* name: LAST  */
         { (yyval.aval) = new_ast_str("last"); }
    break;

  case 280: /* name: NULLS  */
          { (yyval.aval) = new_ast_str("nulls"); }
    break;

  case 281: /* name: OUTER  */
          { (yyval.aval) = new_ast_str("outer"); }
    break;

  case 282: /* name: PARTITION  */
              { (yyval.aval) = new_ast_str("partition"); }
    break;

  case 283: /* name: PRECEDING  */
              { (yyval.aval) = new_ast_str("preceding"); }
    break;

  case 284: /* name: PRIVATE  */
            { (yyval.aval) = new_ast_str("private"); }
    break;

  case 285: /* name: QUERY_PARTS  */
                { (yyval.aval) = new_ast_str("query_parts"); }
    break;

  case 286: /* name: RANGE  */
          { (yyval.aval) = new_ast_str("range"); }
    break;

  case 287: /* name: REFERENCES  */
               { (yyval.aval) = new_ast_str("references"); }
    break;

  case 288: /* name: RELEASE  */
            { (yyval.aval) = new_ast_str("release"); }
    break;

  case 289: /* name: RENAME  */
           { (yyval.aval) = new_ast_str("rename"); }
    break;

  case 290: /* name: REPLACE  */
             { (yyval.aval) = new_ast_str("replace"); }
    break;

  case 291: /* name: RESTRICT  */
             { (yyval.aval) = new_ast_str("restrict"); }
    break;

  case 292: /* name: ROWID  */
           { (yyval.aval) = new_ast_str("rowid"); }
    break;

  case 293: /* name: SAVEPOINT  */
              { (yyval.aval) = new_ast_str("savepoint"); }
    break;

  case 294: /* name: SELECT_CORE  */
                { (yyval.aval) = new_ast_str("select_core"); }
    break;

  case 295: /* name: SELECT_EXPR  */
                { (yyval.aval) = new_ast_str("select_expr"); }
    break;

  case 296: /* name: STATEMENT  */
              { (yyval.aval) = new_ast_str("statement"); }
    break;

  case 297: /* name: STMT_LIST  */
              { (yyval.aval) = new_ast_str("stmt_list"); }
    break;

  case 298: /* name: TABLE  */
          { (yyval.aval) = new_ast_str("table"); }
    break;

  case 299: /* name: TEMP  */
         { (yyval.aval) = new_ast_str("temp"); }
    break;

  case 300: /* name: TEXT  */
          { (yyval.aval) = new_ast_str("text"); }
    break;

  case 301: /* name: TRANSACTION  */
                { (yyval.aval) = new_ast_str("transaction"); }
    break;

  case 302: /* name: TRIGGER  */
             { (yyval.aval) = new_ast_str("trigger"); }
    break;

  case 303: /* name: TYPE  */
         { (yyval.aval) = new_ast_str("type"); }
    break;

  case 304: /* name: VIEW  */
         { (yyval.aval) = new_ast_str("view"); }
    break;

  case 305: /* name: VIRTUAL  */
            { (yyval.aval) = new_ast_str("virtual"); }
    break;

  case 306: /* name: WITHOUT  */
            { (yyval.aval) = new_ast_str("without"); }
    break;

  case 307: /* loose_name: name  */
       { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 308: /* loose_name: CALL  */
         { (yyval.aval) = new_ast_str("call"); }
    break;

  case 309: /* loose_name: SET  */
        { (yyval.aval) = new_ast_str("set"); }
    break;

  case 310: /* loose_name: "BOOL"  */
          { (yyval.aval) = new_ast_str("bool"); }
    break;

  case 311: /* loose_name: INT_  */
         { (yyval.aval) = new_ast_str("int"); }
    break;

  case 312: /* loose_name: LONG_  */
          { (yyval.aval) = new_ast_str("long"); }
    break;

  case 313: /* loose_name: REAL  */
         { (yyval.aval) = new_ast_str("real"); }
    break;

  case 314: /* loose_name: BLOB  */
         { (yyval.aval) = new_ast_str("blob"); }
    break;

  case 315: /* loose_name: OBJECT  */
           { (yyval.aval) = new_ast_str("object"); }
    break;

  case 316: /* loose_name: RIGHT  */
          { (yyval.aval) = new_ast_str("right"); }
    break;

  case 317: /* loose_name: LEFT  */
         { (yyval.aval) = new_ast_str("left"); }
    break;

  case 318: /* loose_name_or_type: loose_name  */
                { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 319: /* loose_name_or_type: ALL  */
        { (yyval.aval) = new_ast_str("all"); }
    break;

  case 320: /* loose_name_or_type: loose_name '<' loose_name '>'  */
                                          {
     EXTRACT_STRING(n1, (yyvsp[-3].aval));
     EXTRACT_STRING(n2, (yyvsp[-1].aval));
     (yyval.aval) = new_ast_str(dup_printf("%s<%s>", n1, n2)); }
    break;

  case 321: /* opt_sql_name: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 322: /* opt_sql_name: sql_name  */
              { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 323: /* name_list: name  */
        { (yyval.aval) = new_ast_name_list((yyvsp[0].aval), NULL); }
    break;

  case 324: /* name_list: name ',' name_list  */
                             { (yyval.aval) = new_ast_name_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 325: /* sql_name_list: sql_name  */
            { (yyval.aval) = new_ast_name_list((yyvsp[0].aval), NULL); }
    break;

  case 326: /* sql_name_list: sql_name ',' sql_name_list  */
                                     { (yyval.aval) = new_ast_name_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 327: /* opt_name_list: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 328: /* opt_name_list: name_list  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 329: /* opt_sql_name_list: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 330: /* opt_sql_name_list: sql_name_list  */
                   { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 331: /* cte_binding_list: cte_binding  */
              { (yyval.aval) = new_ast_cte_binding_list((yyvsp[0].aval), NULL); }
    break;

  case 332: /* cte_binding_list: cte_binding ',' cte_binding_list  */
                                          { (yyval.aval) = new_ast_cte_binding_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 333: /* cte_binding: name name  */
                                       { (yyval.aval) = new_ast_cte_binding((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 334: /* cte_binding: name AS name  */
                                 { (yyval.aval) = new_ast_cte_binding((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 335: /* col_attrs: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 336: /* col_attrs: not_null opt_conflict_clause col_attrs  */
                                                { (yyval.aval) = new_ast_col_attrs_not_null((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 337: /* col_attrs: PRIMARY KEY opt_conflict_clause col_attrs  */
                                                   {
    ast_node *autoinc_and_conflict_clause = new_ast_autoinc_and_conflict_clause(NULL, (yyvsp[-1].aval));
    (yyval.aval) = new_ast_col_attrs_pk(autoinc_and_conflict_clause, (yyvsp[0].aval));
  }
    break;

  case 338: /* col_attrs: PRIMARY KEY opt_conflict_clause AUTOINCREMENT col_attrs  */
                                                                 {
    ast_node *autoinc_and_conflict_clause = new_ast_autoinc_and_conflict_clause(new_ast_col_attrs_autoinc(), (yyvsp[-2].aval));
    (yyval.aval) = new_ast_col_attrs_pk(autoinc_and_conflict_clause, (yyvsp[0].aval));
  }
    break;

  case 339: /* col_attrs: DEFAULT '-' num_literal col_attrs  */
                                           { (yyval.aval) = new_ast_col_attrs_default(new_ast_uminus((yyvsp[-1].aval)), (yyvsp[0].aval));}
    break;

  case 340: /* col_attrs: DEFAULT '+' num_literal col_attrs  */
                                           { (yyval.aval) = new_ast_col_attrs_default((yyvsp[-1].aval), (yyvsp[0].aval));}
    break;

  case 341: /* col_attrs: DEFAULT num_literal col_attrs  */
                                       { (yyval.aval) = new_ast_col_attrs_default((yyvsp[-1].aval), (yyvsp[0].aval));}
    break;

  case 342: /* col_attrs: DEFAULT const_expr col_attrs  */
                                      { (yyval.aval) = new_ast_col_attrs_default((yyvsp[-1].aval), (yyvsp[0].aval));}
    break;

  case 343: /* col_attrs: DEFAULT str_literal col_attrs  */
                                       { (yyval.aval) = new_ast_col_attrs_default((yyvsp[-1].aval), (yyvsp[0].aval));}
    break;

  case 344: /* col_attrs: COLLATE name col_attrs  */
                                { (yyval.aval) = new_ast_col_attrs_collate((yyvsp[-1].aval), (yyvsp[0].aval));}
    break;

  case 345: /* col_attrs: CHECK '(' expr ')' col_attrs  */
                                      { (yyval.aval) = new_ast_col_attrs_check((yyvsp[-2].aval), (yyvsp[0].aval));}
    break;

  case 346: /* col_attrs: UNIQUE opt_conflict_clause col_attrs  */
                                              { (yyval.aval) = new_ast_col_attrs_unique((yyvsp[-1].aval), (yyvsp[0].aval));}
    break;

  case 347: /* col_attrs: HIDDEN col_attrs  */
                          { (yyval.aval) = new_ast_col_attrs_hidden(NULL, (yyvsp[0].aval));}
    break;

  case 348: /* col_attrs: AT_SENSITIVE col_attrs  */
                                { (yyval.aval) = new_ast_sensitive_attr(NULL, (yyvsp[0].aval)); }
    break;

  case 349: /* col_attrs: AT_CREATE version_annotation col_attrs  */
                                                { (yyval.aval) = new_ast_create_attr((yyvsp[-1].aval), (yyvsp[0].aval));}
    break;

  case 350: /* col_attrs: AT_DELETE version_annotation col_attrs  */
                                                { (yyval.aval) = new_ast_delete_attr((yyvsp[-1].aval), (yyvsp[0].aval));}
    break;

  case 351: /* col_attrs: fk_target_options col_attrs  */
                                     { (yyval.aval) = new_ast_col_attrs_fk((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 352: /* version_annotation: '(' INTLIT ',' name ')'  */
                           {
    (yyval.aval) = new_ast_version_annotation(new_ast_option(atoi((yyvsp[-3].sval))), (yyvsp[-1].aval)); }
    break;

  case 353: /* version_annotation: '(' INTLIT ',' name ':' name ')'  */
                                                {
    ast_node *dot = new_ast_dot((yyvsp[-3].aval), (yyvsp[-1].aval));
    (yyval.aval) = new_ast_version_annotation(new_ast_option(atoi((yyvsp[-5].sval))), dot); }
    break;

  case 354: /* version_annotation: '(' INTLIT ')'  */
                    {
    (yyval.aval) = new_ast_version_annotation(new_ast_option(atoi((yyvsp[-1].sval))), NULL); }
    break;

  case 355: /* opt_kind: %empty  */
            { (yyval.aval) = NULL; }
    break;

  case 356: /* opt_kind: '<' name '>'  */
                 { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 357: /* data_type_numeric: INT_ opt_kind  */
                { (yyval.aval) = new_ast_type_int((yyvsp[0].aval)); }
    break;

  case 358: /* data_type_numeric: INTEGER opt_kind  */
                     { (yyval.aval) = new_ast_type_int((yyvsp[0].aval)); }
    break;

  case 359: /* data_type_numeric: REAL opt_kind  */
                  { (yyval.aval) = new_ast_type_real((yyvsp[0].aval)); }
    break;

  case 360: /* data_type_numeric: LONG_ opt_kind  */
                   { (yyval.aval) = new_ast_type_long((yyvsp[0].aval)); }
    break;

  case 361: /* data_type_numeric: "BOOL" opt_kind  */
                   { (yyval.aval) = new_ast_type_bool((yyvsp[0].aval)); }
    break;

  case 362: /* data_type_numeric: LONG_ INTEGER opt_kind  */
                           { (yyval.aval) = new_ast_type_long((yyvsp[0].aval)); }
    break;

  case 363: /* data_type_numeric: LONG_ INT_ opt_kind  */
                        { (yyval.aval) = new_ast_type_long((yyvsp[0].aval)); }
    break;

  case 364: /* data_type_numeric: LONG_INT opt_kind  */
                      { (yyval.aval) = new_ast_type_long((yyvsp[0].aval)); }
    break;

  case 365: /* data_type_numeric: LONG_INTEGER opt_kind  */
                          { (yyval.aval) = new_ast_type_long((yyvsp[0].aval)); }
    break;

  case 366: /* data_type_any: data_type_numeric  */
                    { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 367: /* data_type_any: TEXT opt_kind  */
                   { (yyval.aval) = new_ast_type_text((yyvsp[0].aval));  }
    break;

  case 368: /* data_type_any: BLOB opt_kind  */
                   { (yyval.aval) = new_ast_type_blob((yyvsp[0].aval)); }
    break;

  case 369: /* data_type_any: OBJECT opt_kind  */
                    { (yyval.aval) = new_ast_type_object((yyvsp[0].aval)); }
    break;

  case 370: /* data_type_any: OBJECT '<' name CURSOR '>'  */
                               { /* special case for boxed cursor */
    CSTR type = dup_printf("%s CURSOR", AST_STR((yyvsp[-2].aval)));
    (yyval.aval) = new_ast_type_object(new_ast_str(type)); }
    break;

  case 371: /* data_type_any: OBJECT '<' name SET '>'  */
                            { /* special case for result sets */
    CSTR type = dup_printf("%s SET", AST_STR((yyvsp[-2].aval)));
    (yyval.aval) = new_ast_type_object(new_ast_str(type)); }
    break;

  case 372: /* data_type_any: ID  */
       { (yyval.aval) = new_ast_str((yyvsp[0].sval)); }
    break;

  case 373: /* data_type_any: AT_ID '(' text_args ')'  */
                            { (yyval.aval) = new_ast_at_id((yyvsp[-1].aval)); }
    break;

  case 376: /* data_type_with_options: data_type_any  */
                { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 377: /* data_type_with_options: data_type_any not_null  */
                           { (yyval.aval) = new_ast_notnull((yyvsp[-1].aval)); }
    break;

  case 378: /* data_type_with_options: data_type_any AT_SENSITIVE  */
                               { (yyval.aval) = new_ast_sensitive_attr((yyvsp[-1].aval), NULL); }
    break;

  case 379: /* data_type_with_options: data_type_any AT_SENSITIVE not_null  */
                                        { (yyval.aval) = new_ast_sensitive_attr(new_ast_notnull((yyvsp[-2].aval)), NULL); }
    break;

  case 380: /* data_type_with_options: data_type_any not_null AT_SENSITIVE  */
                                        { (yyval.aval) = new_ast_sensitive_attr(new_ast_notnull((yyvsp[-2].aval)), NULL); }
    break;

  case 381: /* str_literal: str_chain  */
            { (yyval.aval) = reduce_str_chain((yyvsp[0].aval)); }
    break;

  case 382: /* str_chain: str_leaf  */
           { (yyval.aval) = new_ast_str_chain((yyvsp[0].aval), NULL); }
    break;

  case 383: /* str_chain: str_leaf str_chain  */
                             { (yyval.aval) = new_ast_str_chain((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 384: /* str_leaf: STRLIT  */
          { (yyval.aval) = new_ast_str((yyvsp[0].sval));}
    break;

  case 385: /* str_leaf: CSTRLIT  */
             { (yyval.aval) = new_ast_cstr((yyvsp[0].sval)); }
    break;

  case 386: /* num_literal: INTLIT  */
          { (yyval.aval) = new_ast_num(NUM_INT, (yyvsp[0].sval)); }
    break;

  case 387: /* num_literal: LONGLIT  */
             { (yyval.aval) = new_ast_num(NUM_LONG, (yyvsp[0].sval)); }
    break;

  case 388: /* num_literal: REALLIT  */
             { (yyval.aval) = new_ast_num(NUM_REAL, (yyvsp[0].sval)); }
    break;

  case 389: /* num_literal: "TRUE"  */
          { (yyval.aval) = new_ast_num(NUM_BOOL, "1"); }
    break;

  case 390: /* num_literal: "FALSE"  */
           { (yyval.aval) = new_ast_num(NUM_BOOL, "0"); }
    break;

  case 391: /* const_expr: CONST '(' expr ')'  */
                     { (yyval.aval) = new_ast_const((yyvsp[-1].aval)); }
    break;

  case 392: /* any_literal: str_literal  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 393: /* any_literal: num_literal  */
                 { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 394: /* any_literal: "NULL"  */
           { (yyval.aval) = new_ast_null(); }
    break;

  case 395: /* any_literal: AT_FILE '(' str_literal ')'  */
                                 { (yyval.aval) = file_literal((yyvsp[-1].aval)); }
    break;

  case 396: /* any_literal: AT_LINE  */
             { (yyval.aval) = new_ast_num(NUM_INT, dup_printf("%d", yylineno)); }
    break;

  case 397: /* any_literal: AT_MACRO_LINE  */
                  { (yyval.aval) = new_ast_str("@MACRO_LINE"); }
    break;

  case 398: /* any_literal: AT_MACRO_FILE  */
                  { (yyval.aval) = new_ast_str("@MACRO_FILE"); }
    break;

  case 399: /* any_literal: AT_PROC  */
             { (yyval.aval) = new_ast_str("@PROC"); }
    break;

  case 400: /* any_literal: AT_TEXT '(' text_args ')'  */
                              { (yyval.aval) = new_ast_macro_text((yyvsp[-1].aval)); }
    break;

  case 401: /* any_literal: BLOBLIT  */
             { (yyval.aval) = new_ast_blob((yyvsp[0].sval)); }
    break;

  case 402: /* text_args: text_arg  */
            { (yyval.aval) = new_ast_text_args((yyvsp[0].aval), NULL); }
    break;

  case 403: /* text_args: text_arg ',' text_args  */
                                { (yyval.aval) = new_ast_text_args((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 405: /* raise_expr: RAISE '(' IGNORE ')'  */
                        { (yyval.aval) = new_ast_raise(new_ast_option(RAISE_IGNORE), NULL); }
    break;

  case 406: /* raise_expr: RAISE '(' ROLLBACK ',' expr ')'  */
                                      { (yyval.aval) = new_ast_raise(new_ast_option(RAISE_ROLLBACK), (yyvsp[-1].aval)); }
    break;

  case 407: /* raise_expr: RAISE '(' ABORT ',' expr ')'  */
                                   { (yyval.aval) = new_ast_raise(new_ast_option(RAISE_ABORT), (yyvsp[-1].aval)); }
    break;

  case 408: /* raise_expr: RAISE '(' FAIL ',' expr ')'  */
                                  { (yyval.aval) = new_ast_raise(new_ast_option(RAISE_FAIL), (yyvsp[-1].aval)); }
    break;

  case 409: /* opt_distinct: %empty  */
            { (yyval.aval) = NULL; }
    break;

  case 410: /* opt_distinct: DISTINCT  */
             { (yyval.aval) = new_ast_distinct(); }
    break;

  case 411: /* simple_call: loose_name '(' opt_distinct arg_list ')' opt_filter_clause  */
                                                                    {
      YY_ERROR_ON_CQL_INFERRED_NOTNULL((yyvsp[-5].aval));
      struct ast_node *call_filter_clause = new_ast_call_filter_clause((yyvsp[-3].aval), (yyvsp[0].aval));
      struct ast_node *call_arg_list = new_ast_call_arg_list(call_filter_clause, (yyvsp[-2].aval));
      (yyval.aval) = new_ast_call((yyvsp[-5].aval), call_arg_list); }
    break;

  case 412: /* simple_call: GLOB '(' opt_distinct arg_list ')' opt_filter_clause  */
                                                          {
      ast_node *name = new_ast_str("glob");
      struct ast_node *call_filter_clause = new_ast_call_filter_clause((yyvsp[-3].aval), (yyvsp[0].aval));
      struct ast_node *call_arg_list = new_ast_call_arg_list(call_filter_clause, (yyvsp[-2].aval));
      (yyval.aval) = new_ast_call(name, call_arg_list); }
    break;

  case 413: /* simple_call: LIKE '(' opt_distinct arg_list ')' opt_filter_clause  */
                                                          {
      ast_node *name = new_ast_str("like");
      struct ast_node *call_filter_clause = new_ast_call_filter_clause((yyvsp[-3].aval), (yyvsp[0].aval));
      struct ast_node *call_arg_list = new_ast_call_arg_list(call_filter_clause, (yyvsp[-2].aval));
      (yyval.aval) = new_ast_call(name, call_arg_list); }
    break;

  case 414: /* call: simple_call  */
              { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 415: /* call: basic_expr ':' simple_call  */
                               { (yyval.aval) = new_ast_reverse_apply((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 416: /* call: basic_expr ':' loose_name  */
                                    { (yyval.aval) = new_ast_reverse_apply((yyvsp[-2].aval), new_simple_call_from_name((yyvsp[0].aval))); }
    break;

  case 417: /* call: basic_expr ':' '(' arg_list ')'  */
                                    { (yyval.aval) = new_ast_reverse_apply_poly_args((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 418: /* call: basic_expr ':' ID '!'  */
                          {
     YY_ERROR_ON_MACRO_ARG((yyvsp[-1].sval));
     (yyval.aval) = new_macro_ref_node((yyvsp[-1].sval), new_ast_macro_args(new_ast_expr_macro_arg((yyvsp[-3].aval)), NULL)); }
    break;

  case 419: /* call: basic_expr ':' ID '!' '(' opt_macro_args ')'  */
                                                 {
     YY_ERROR_ON_MACRO_ARG((yyvsp[-4].sval));
     (yyval.aval) = new_macro_ref_node((yyvsp[-4].sval), new_ast_macro_args(new_ast_expr_macro_arg((yyvsp[-6].aval)), (yyvsp[-1].aval))); }
    break;

  case 420: /* basic_expr: name  */
        { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 421: /* basic_expr: QID  */
        { (yyval.aval) = new_ast_qstr_quoted((yyvsp[0].sval)); }
    break;

  case 422: /* basic_expr: macro_ref  */
              { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 423: /* basic_expr: '*'  */
        { (yyval.aval) = new_ast_star(); }
    break;

  case 424: /* basic_expr: AT_RC  */
          { (yyval.aval) = new_ast_str("@RC"); }
    break;

  case 425: /* basic_expr: basic_expr '.' sql_name  */
                                      { (yyval.aval) = new_ast_dot((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 426: /* basic_expr: basic_expr '.' '*'  */
                            { (yyval.aval) = new_ast_table_star((yyvsp[-2].aval)); }
    break;

  case 427: /* basic_expr: any_literal  */
                 { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 428: /* basic_expr: const_expr  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 429: /* basic_expr: '(' expr ')'  */
                  { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 430: /* basic_expr: call  */
          { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 431: /* basic_expr: window_func_inv  */
                     { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 432: /* basic_expr: raise_expr  */
                { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 433: /* basic_expr: '(' select_stmt ')'  */
                         { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 434: /* basic_expr: '(' select_stmt IF NOTHING expr ')'  */
                                         { (yyval.aval) = new_ast_select_if_nothing_expr((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 435: /* basic_expr: '(' select_stmt IF NOTHING OR "NULL" expr ')'  */
                                                  { (yyval.aval) = new_ast_select_if_nothing_or_null_expr((yyvsp[-6].aval), (yyvsp[-1].aval)); }
    break;

  case 436: /* basic_expr: '(' select_stmt IF NOTHING OR "NULL" THEN expr ')'  */
                                                       { (yyval.aval) = new_ast_select_if_nothing_or_null_expr((yyvsp[-7].aval), (yyvsp[-1].aval)); }
    break;

  case 437: /* basic_expr: '(' select_stmt IF NOTHING OR "NULL" THEN THROW ')'  */
                                                        { (yyval.aval) = new_ast_select_if_nothing_or_null_throw_expr((yyvsp[-7].aval)); }
    break;

  case 438: /* basic_expr: '(' select_stmt IF NOTHING OR "NULL" THROW ')'  */
                                                   { (yyval.aval) = new_ast_select_if_nothing_or_null_throw_expr((yyvsp[-6].aval)); }
    break;

  case 439: /* basic_expr: '(' select_stmt IF NOTHING THEN expr ')'  */
                                              { (yyval.aval) = new_ast_select_if_nothing_expr((yyvsp[-5].aval), (yyvsp[-1].aval)); }
    break;

  case 440: /* basic_expr: '(' select_stmt IF NOTHING THEN THROW ')'  */
                                              { (yyval.aval) = new_ast_select_if_nothing_throw_expr((yyvsp[-5].aval)); }
    break;

  case 441: /* basic_expr: '(' select_stmt IF NOTHING THROW ')'  */
                                         { (yyval.aval) = new_ast_select_if_nothing_throw_expr((yyvsp[-4].aval)); }
    break;

  case 442: /* basic_expr: EXISTS '(' select_stmt ')'  */
                                { (yyval.aval) = new_ast_exists_expr((yyvsp[-1].aval)); }
    break;

  case 443: /* basic_expr: CASE expr case_list END  */
                                   { (yyval.aval) = new_ast_case_expr((yyvsp[-2].aval), new_ast_connector((yyvsp[-1].aval), NULL)); }
    break;

  case 444: /* basic_expr: CASE expr case_list ELSE expr END  */
                                                     { (yyval.aval) = new_ast_case_expr((yyvsp[-4].aval), new_ast_connector((yyvsp[-3].aval), (yyvsp[-1].aval)));}
    break;

  case 445: /* basic_expr: CASE case_list END  */
                        { (yyval.aval) = new_ast_case_expr(NULL, new_ast_connector((yyvsp[-1].aval), NULL));}
    break;

  case 446: /* basic_expr: CASE case_list ELSE expr END  */
                                        { (yyval.aval) = new_ast_case_expr(NULL, new_ast_connector((yyvsp[-3].aval), (yyvsp[-1].aval)));}
    break;

  case 447: /* basic_expr: CAST '(' expr AS data_type_any ')'  */
                                              { (yyval.aval) = new_ast_cast_expr((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 448: /* basic_expr: TYPE_CHECK '(' expr AS data_type_with_options ')'  */
                                                                  { (yyval.aval) = new_ast_type_check_expr((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 449: /* basic_expr: basic_expr '[' arg_list ']'  */
                                       { (yyval.aval) = new_ast_array((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 450: /* basic_expr: basic_expr '~' data_type_any '~'  */
                                          { (yyval.aval) = new_ast_cast_expr((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 451: /* basic_expr: basic_expr JEX1 basic_expr  */
                                          { (yyval.aval) = new_ast_jex1((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 452: /* basic_expr: basic_expr JEX2 '~' data_type_any '~' basic_expr  */
                                                               { (yyval.aval) = new_ast_jex2((yyvsp[-5].aval), new_ast_jex2((yyvsp[-2].aval),(yyvsp[0].aval))); }
    break;

  case 453: /* math_expr: basic_expr  */
              { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 454: /* math_expr: math_expr '&' math_expr  */
                                       { (yyval.aval) = new_ast_bin_and((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 455: /* math_expr: math_expr '|' math_expr  */
                                       { (yyval.aval) = new_ast_bin_or((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 456: /* math_expr: math_expr "<<" math_expr  */
                                      { (yyval.aval) = new_ast_lshift((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 457: /* math_expr: math_expr ">>" math_expr  */
                                       { (yyval.aval) = new_ast_rshift((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 458: /* math_expr: math_expr '+' math_expr  */
                                       { (yyval.aval) = new_ast_add((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 459: /* math_expr: math_expr '-' math_expr  */
                                       { (yyval.aval) = new_ast_sub((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 460: /* math_expr: math_expr '*' math_expr  */
                                       { (yyval.aval) = new_ast_mul((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 461: /* math_expr: math_expr '/' math_expr  */
                                       { (yyval.aval) = new_ast_div((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 462: /* math_expr: math_expr '%' math_expr  */
                                       { (yyval.aval) = new_ast_mod((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 463: /* math_expr: math_expr IS_NOT_TRUE  */
                                { (yyval.aval) = new_ast_is_not_true((yyvsp[-1].aval)); }
    break;

  case 464: /* math_expr: math_expr IS_NOT_FALSE  */
                                 { (yyval.aval) = new_ast_is_not_false((yyvsp[-1].aval)); }
    break;

  case 465: /* math_expr: math_expr ISNULL  */
                           { (yyval.aval) = new_ast_is((yyvsp[-1].aval), new_ast_null()); }
    break;

  case 466: /* math_expr: math_expr NOTNULL  */
                            { (yyval.aval) = new_ast_is_not((yyvsp[-1].aval), new_ast_null()); }
    break;

  case 467: /* math_expr: math_expr IS_TRUE  */
                            { (yyval.aval) = new_ast_is_true((yyvsp[-1].aval)); }
    break;

  case 468: /* math_expr: math_expr IS_FALSE  */
                             { (yyval.aval) = new_ast_is_false((yyvsp[-1].aval)); }
    break;

  case 469: /* math_expr: '-' math_expr  */
                                    { (yyval.aval) = new_ast_uminus((yyvsp[0].aval)); }
    break;

  case 470: /* math_expr: '+' math_expr  */
                                    { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 471: /* math_expr: '~' math_expr  */
                                    { (yyval.aval) = new_ast_tilde((yyvsp[0].aval)); }
    break;

  case 472: /* math_expr: NOT math_expr  */
                        { (yyval.aval) = new_ast_not((yyvsp[0].aval)); }
    break;

  case 473: /* math_expr: math_expr '=' math_expr  */
                                       { (yyval.aval) = new_ast_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 474: /* math_expr: math_expr "==" math_expr  */
                                        { (yyval.aval) = new_ast_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 475: /* math_expr: math_expr '<' math_expr  */
                                       { (yyval.aval) = new_ast_lt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 476: /* math_expr: math_expr '>' math_expr  */
                                       { (yyval.aval) = new_ast_gt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 477: /* math_expr: math_expr "<>" math_expr  */
                                      { (yyval.aval) = new_ast_ne((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 478: /* math_expr: math_expr "!=" math_expr  */
                                       { (yyval.aval) = new_ast_ne((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 479: /* math_expr: math_expr ">=" math_expr  */
                                      { (yyval.aval) = new_ast_ge((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 480: /* math_expr: math_expr "<=" math_expr  */
                                      { (yyval.aval) = new_ast_le((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 481: /* math_expr: math_expr NOT_IN '(' opt_expr_list ')'  */
                                                 { (yyval.aval) = new_ast_not_in((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 482: /* math_expr: math_expr NOT_IN '(' select_stmt ')'  */
                                               { (yyval.aval) = new_ast_not_in((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 483: /* math_expr: math_expr IN '(' opt_expr_list ')'  */
                                             { (yyval.aval) = new_ast_in_pred((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 484: /* math_expr: math_expr IN '(' select_stmt ')'  */
                                           { (yyval.aval) = new_ast_in_pred((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 485: /* math_expr: math_expr LIKE math_expr  */
                                        { (yyval.aval) = new_ast_like((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 486: /* math_expr: math_expr NOT_LIKE math_expr  */
                                           { (yyval.aval) = new_ast_not_like((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 487: /* math_expr: math_expr MATCH math_expr  */
                                         { (yyval.aval) = new_ast_match((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 488: /* math_expr: math_expr NOT_MATCH math_expr  */
                                            { (yyval.aval) = new_ast_not_match((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 489: /* math_expr: math_expr REGEXP math_expr  */
                                          { (yyval.aval) = new_ast_regexp((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 490: /* math_expr: math_expr NOT_REGEXP math_expr  */
                                             { (yyval.aval) = new_ast_not_regexp((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 491: /* math_expr: math_expr GLOB math_expr  */
                                        { (yyval.aval) = new_ast_glob((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 492: /* math_expr: math_expr NOT_GLOB math_expr  */
                                           { (yyval.aval) = new_ast_not_glob((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 493: /* math_expr: math_expr BETWEEN math_expr AND math_expr  */
                                                                            { (yyval.aval) = new_ast_between((yyvsp[-4].aval), new_ast_range((yyvsp[-2].aval),(yyvsp[0].aval))); }
    break;

  case 494: /* math_expr: math_expr NOT_BETWEEN math_expr AND math_expr  */
                                                                                { (yyval.aval) = new_ast_not_between((yyvsp[-4].aval), new_ast_range((yyvsp[-2].aval),(yyvsp[0].aval))); }
    break;

  case 495: /* math_expr: math_expr IS_NOT math_expr  */
                                          { (yyval.aval) = new_ast_is_not((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 496: /* math_expr: math_expr IS math_expr  */
                                      { (yyval.aval) = new_ast_is((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 497: /* math_expr: math_expr "||" math_expr  */
                                          { (yyval.aval) = new_ast_concat((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 498: /* math_expr: math_expr COLLATE name  */
                                { (yyval.aval) = new_ast_collate((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 499: /* expr: math_expr  */
            { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 500: /* expr: expr AND expr  */
                             { (yyval.aval) = new_ast_and((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 501: /* expr: expr OR expr  */
                            { (yyval.aval) = new_ast_or((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 502: /* expr: expr ":=" expr  */
                               { (yyval.aval) = new_ast_expr_assign((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 503: /* expr: expr ADD_EQ expr  */
                               { (yyval.aval) = new_ast_add_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 504: /* expr: expr SUB_EQ expr  */
                               { (yyval.aval) = new_ast_sub_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 505: /* expr: expr DIV_EQ expr  */
                               { (yyval.aval) = new_ast_div_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 506: /* expr: expr MUL_EQ expr  */
                               { (yyval.aval) = new_ast_mul_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 507: /* expr: expr MOD_EQ expr  */
                               { (yyval.aval) = new_ast_mod_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 508: /* expr: expr AND_EQ expr  */
                               { (yyval.aval) = new_ast_and_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 509: /* expr: expr OR_EQ expr  */
                              { (yyval.aval) = new_ast_or_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 510: /* expr: expr LS_EQ expr  */
                              { (yyval.aval) = new_ast_ls_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 511: /* expr: expr RS_EQ expr  */
                              { (yyval.aval) = new_ast_rs_eq((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 512: /* case_list: WHEN expr THEN expr  */
                               { (yyval.aval) = new_ast_case_list(new_ast_when((yyvsp[-2].aval), (yyvsp[0].aval)), NULL); }
    break;

  case 513: /* case_list: WHEN expr THEN expr case_list  */
                                               { (yyval.aval) = new_ast_case_list(new_ast_when((yyvsp[-3].aval), (yyvsp[-1].aval)), (yyvsp[0].aval));}
    break;

  case 514: /* arg_expr: expr  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 515: /* arg_expr: shape_arguments  */
                    { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 516: /* arg_exprs: arg_expr  */
            { (yyval.aval) = new_ast_arg_list((yyvsp[0].aval), NULL); }
    break;

  case 517: /* arg_exprs: arg_expr ',' arg_exprs  */
                                { (yyval.aval) = new_ast_arg_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 518: /* arg_list: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 519: /* arg_list: arg_exprs  */
              { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 520: /* opt_expr_list: %empty  */
            { (yyval.aval) = NULL; }
    break;

  case 521: /* opt_expr_list: expr_list  */
              { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 522: /* expr_list: expr  */
        { (yyval.aval) = new_ast_expr_list((yyvsp[0].aval), NULL); }
    break;

  case 523: /* expr_list: expr ',' expr_list  */
                            { (yyval.aval) = new_ast_expr_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 524: /* shape_arguments: FROM name  */
             { (yyval.aval) = new_ast_from_shape((yyvsp[0].aval), NULL); }
    break;

  case 525: /* shape_arguments: FROM name shape_def  */
                         { (yyval.aval) = new_ast_from_shape((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 526: /* shape_arguments: FROM ARGUMENTS  */
                    { (yyval.aval) = new_ast_from_shape(new_ast_str("ARGUMENTS"), NULL); }
    break;

  case 527: /* shape_arguments: FROM ARGUMENTS shape_def  */
                              { (yyval.aval) = new_ast_from_shape(new_ast_str("ARGUMENTS"), (yyvsp[0].aval)); }
    break;

  case 528: /* column_calculation: AT_COLUMNS '(' col_calcs ')'  */
                               {
    (yyval.aval) = new_ast_column_calculation((yyvsp[-1].aval), NULL); }
    break;

  case 529: /* column_calculation: AT_COLUMNS '(' DISTINCT col_calcs ')'  */
                                          {
    (yyval.aval) = new_ast_column_calculation((yyvsp[-1].aval), new_ast_distinct()); }
    break;

  case 530: /* col_calcs: col_calc  */
            { (yyval.aval) = new_ast_col_calcs((yyvsp[0].aval), NULL); }
    break;

  case 531: /* col_calcs: col_calc ',' col_calcs  */
                                 { (yyval.aval) = new_ast_col_calcs((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 532: /* col_calc: sql_name  */
           { (yyval.aval) = new_ast_col_calc((yyvsp[0].aval), NULL); }
    break;

  case 533: /* col_calc: shape_def  */
              { (yyval.aval) = new_ast_col_calc(NULL, (yyvsp[0].aval)); }
    break;

  case 534: /* col_calc: sql_name shape_def  */
                       { (yyval.aval) = new_ast_col_calc((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 535: /* col_calc: sql_name '.' sql_name  */
                                  { (yyval.aval) = new_ast_col_calc(new_ast_dot((yyvsp[-2].aval), (yyvsp[0].aval)), NULL); }
    break;

  case 536: /* cte_tables: cte_table  */
             { (yyval.aval) = new_ast_cte_tables((yyvsp[0].aval), NULL); }
    break;

  case 537: /* cte_tables: cte_table ',' cte_tables  */
                                  { (yyval.aval) = new_ast_cte_tables((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 538: /* cte_decl: name '(' sql_name_list ')'  */
                              { (yyval.aval) = new_ast_cte_decl((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 539: /* cte_decl: name '(' '*' ')'  */
                      { (yyval.aval) = new_ast_cte_decl((yyvsp[-3].aval), new_ast_star()); }
    break;

  case 540: /* cte_decl: name  */
         { (yyval.aval) = new_ast_cte_decl((yyvsp[0].aval), new_ast_star()); }
    break;

  case 541: /* shared_cte: call_stmt  */
            { (yyval.aval) = new_ast_shared_cte((yyvsp[0].aval), NULL); }
    break;

  case 542: /* shared_cte: call_stmt USING cte_binding_list  */
                                     { (yyval.aval) = new_ast_shared_cte((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 543: /* cte_table: cte_decl AS '(' select_stmt ')'  */
                                   { (yyval.aval) = new_ast_cte_table((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 544: /* cte_table: cte_decl AS '(' shared_cte ')'  */
                                  { (yyval.aval) = new_ast_cte_table((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 545: /* cte_table: '(' call_stmt ')'  */
                      {
      ast_node *name = ast_clone_tree((yyvsp[-1].aval)->left);
      ast_node *cte_decl =  new_ast_cte_decl(name, new_ast_star());
      ast_node *shared_cte = new_ast_shared_cte((yyvsp[-1].aval), NULL);
      (yyval.aval) = new_ast_cte_table(cte_decl, shared_cte); }
    break;

  case 546: /* cte_table: '(' call_stmt USING cte_binding_list ')'  */
                                             {
      ast_node *name = ast_clone_tree((yyvsp[-3].aval)->left);
      ast_node *cte_decl =  new_ast_cte_decl(name, new_ast_star());
      ast_node *shared_cte = new_ast_shared_cte((yyvsp[-3].aval), (yyvsp[-1].aval));
      (yyval.aval) = new_ast_cte_table(cte_decl, shared_cte); }
    break;

  case 547: /* cte_table: cte_decl LIKE '(' select_stmt ')'  */
                                       {
      (yyval.aval) = new_ast_cte_table((yyvsp[-4].aval), new_ast_like((yyvsp[-1].aval), NULL)); }
    break;

  case 548: /* cte_table: cte_decl LIKE sql_name  */
                            {
      (yyval.aval) = new_ast_cte_table((yyvsp[-2].aval), new_ast_like((yyvsp[0].aval), NULL)); }
    break;

  case 549: /* cte_table: macro_ref  */
                   { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 550: /* with_prefix: WITH cte_tables  */
                   { (yyval.aval) = new_ast_with((yyvsp[0].aval)); }
    break;

  case 551: /* with_prefix: WITH RECURSIVE cte_tables  */
                               { (yyval.aval) = new_ast_with_recursive((yyvsp[0].aval)); }
    break;

  case 552: /* with_select_stmt: with_prefix select_stmt_no_with  */
                                   { (yyval.aval) = new_ast_with_select_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 553: /* select_nothing_stmt: SELECT NOTHING  */
                 { (yyval.aval) = new_ast_select_nothing_stmt(); }
    break;

  case 554: /* select_stmt: with_select_stmt  */
                    { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 555: /* select_stmt: select_stmt_no_with  */
                         { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 556: /* select_stmt_no_with: select_core_list opt_orderby opt_limit opt_offset  */
                                                     {
      struct ast_node *select_offset = new_ast_select_offset((yyvsp[0].aval), NULL);
      struct ast_node *select_limit = new_ast_select_limit((yyvsp[-1].aval), select_offset);
      struct ast_node *select_orderby = new_ast_select_orderby((yyvsp[-2].aval), select_limit);
       (yyval.aval) = new_ast_select_stmt((yyvsp[-3].aval), select_orderby);
  }
    break;

  case 557: /* select_core_list: select_core  */
              { (yyval.aval) = new_ast_select_core_list((yyvsp[0].aval), NULL); }
    break;

  case 558: /* select_core_list: select_core compound_operator select_core_list  */
                                                         {
     ast_node *select_core_compound = new_ast_select_core_compound(new_ast_option((yyvsp[-1].ival)), (yyvsp[0].aval));
     (yyval.aval) = new_ast_select_core_list((yyvsp[-2].aval), select_core_compound); }
    break;

  case 559: /* values: '(' insert_list ')'  */
                       {
    (yyval.aval) = new_ast_values((yyvsp[-1].aval), NULL);
  }
    break;

  case 560: /* values: '(' insert_list ')' ',' values  */
                                        {
    (yyval.aval) = new_ast_values((yyvsp[-3].aval), (yyvsp[0].aval));
  }
    break;

  case 561: /* select_core: SELECT select_opts select_expr_list opt_from_query_parts opt_where opt_groupby opt_having opt_select_window  */
                                                                                                               {
    struct ast_node *select_having = new_ast_select_having((yyvsp[-1].aval), (yyvsp[0].aval));
    struct ast_node *select_groupby = new_ast_select_groupby((yyvsp[-2].aval), select_having);
    struct ast_node *select_where = new_ast_select_where((yyvsp[-3].aval), select_groupby);
    struct ast_node *select_from_etc = new_ast_select_from_etc((yyvsp[-4].aval), select_where);
    struct ast_node *select_expr_list_con = new_ast_select_expr_list_con((yyvsp[-5].aval), select_from_etc);
     (yyval.aval) = new_ast_select_core((yyvsp[-6].aval), select_expr_list_con);
  }
    break;

  case 562: /* select_core: ROWS '(' macro_ref ')'  */
                           { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 563: /* select_core: VALUES values  */
                   {
    (yyval.aval) = new_ast_select_core(new_ast_select_values(), (yyvsp[0].aval));
  }
    break;

  case 564: /* compound_operator: UNION  */
         { (yyval.ival) = COMPOUND_OP_UNION; }
    break;

  case 565: /* compound_operator: UNION_ALL  */
               { (yyval.ival) = COMPOUND_OP_UNION_ALL; }
    break;

  case 566: /* compound_operator: INTERSECT  */
               { (yyval.ival) = COMPOUND_OP_INTERSECT; }
    break;

  case 567: /* compound_operator: EXCEPT  */
            { (yyval.ival) = COMPOUND_OP_EXCEPT; }
    break;

  case 568: /* window_func_inv: simple_call OVER window_name_or_defn  */
                                        {
    EXTRACT(call, (yyvsp[-2].aval));
    EXTRACT_NOTNULL(call_arg_list, call->right);
    EXTRACT_NOTNULL(call_filter_clause, call_arg_list->left);
    EXTRACT(distinct, call_filter_clause->left);
    YY_ERROR_ON_DISTINCT(distinct);
    (yyval.aval) = new_ast_window_func_inv((yyvsp[-2].aval), (yyvsp[0].aval));
  }
    break;

  case 569: /* opt_filter_clause: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 570: /* opt_filter_clause: FILTER '(' opt_where ')'  */
                              { (yyval.aval) = new_ast_opt_filter_clause((yyvsp[-1].aval)); }
    break;

  case 573: /* window_defn: '(' opt_partition_by opt_orderby opt_frame_spec ')'  */
                                                       {
    ast_node *window_defn_orderby = new_ast_window_defn_orderby((yyvsp[-2].aval), (yyvsp[-1].aval));
    (yyval.aval) = new_ast_window_defn((yyvsp[-3].aval), window_defn_orderby);
  }
    break;

  case 574: /* opt_frame_spec: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 575: /* opt_frame_spec: frame_type frame_boundary_opts frame_exclude  */
                                                  {
    int32_t frame_boundary_opts_flags = (int32_t)((int_ast_node *)((yyvsp[-1].aval))->left)->value;
    int32_t flags = (yyvsp[-2].ival) | frame_boundary_opts_flags | (yyvsp[0].ival);
    ast_node *expr_list = (yyvsp[-1].aval)->right;
    (yyval.aval) = new_ast_opt_frame_spec(new_ast_option(flags), expr_list);
  }
    break;

  case 576: /* frame_type: RANGE  */
         { (yyval.ival) = FRAME_TYPE_RANGE; }
    break;

  case 577: /* frame_type: ROWS  */
          { (yyval.ival) = FRAME_TYPE_ROWS; }
    break;

  case 578: /* frame_type: GROUPS  */
            { (yyval.ival) = FRAME_TYPE_GROUPS; }
    break;

  case 579: /* frame_exclude: %empty  */
             { (yyval.ival) = FRAME_EXCLUDE_NONE; }
    break;

  case 580: /* frame_exclude: EXCLUDE_NO_OTHERS  */
                       { (yyval.ival) = FRAME_EXCLUDE_NO_OTHERS; }
    break;

  case 581: /* frame_exclude: EXCLUDE_CURRENT_ROW  */
                         { (yyval.ival) = FRAME_EXCLUDE_CURRENT_ROW; }
    break;

  case 582: /* frame_exclude: EXCLUDE_GROUP  */
                   { (yyval.ival) = FRAME_EXCLUDE_GROUP; }
    break;

  case 583: /* frame_exclude: EXCLUDE_TIES  */
                  { (yyval.ival) = FRAME_EXCLUDE_TIES; }
    break;

  case 584: /* frame_boundary_opts: frame_boundary  */
                  {
    ast_node *ast_flags = (yyvsp[0].aval)->left;
    ast_node *expr_list = new_ast_expr_list((yyvsp[0].aval)->right, NULL);
    (yyval.aval) = new_ast_frame_boundary_opts(ast_flags, expr_list);
  }
    break;

  case 585: /* frame_boundary_opts: BETWEEN frame_boundary_start AND frame_boundary_end  */
                                                         {
    int32_t flags = (int32_t)(((int_ast_node *)(yyvsp[-2].aval)->left)->value | ((int_ast_node *)(yyvsp[0].aval)->left)->value);
    ast_node *expr_list = new_ast_expr_list((yyvsp[-2].aval)->right, (yyvsp[0].aval)->right);
    (yyval.aval) = new_ast_frame_boundary_opts(new_ast_option(flags), expr_list);
  }
    break;

  case 586: /* frame_boundary_start: UNBOUNDED PRECEDING  */
                       { (yyval.aval) = new_ast_frame_boundary_start(new_ast_option(FRAME_BOUNDARY_START_UNBOUNDED), NULL); }
    break;

  case 587: /* frame_boundary_start: expr PRECEDING  */
                    { (yyval.aval) = new_ast_frame_boundary_start(new_ast_option(FRAME_BOUNDARY_START_PRECEDING), (yyvsp[-1].aval)); }
    break;

  case 588: /* frame_boundary_start: CURRENT_ROW  */
                 { (yyval.aval) = new_ast_frame_boundary_start(new_ast_option(FRAME_BOUNDARY_START_CURRENT_ROW), NULL); }
    break;

  case 589: /* frame_boundary_start: expr FOLLOWING  */
                    { (yyval.aval) = new_ast_frame_boundary_start(new_ast_option(FRAME_BOUNDARY_START_FOLLOWING), (yyvsp[-1].aval)); }
    break;

  case 590: /* frame_boundary_end: expr PRECEDING  */
                  { (yyval.aval) = new_ast_frame_boundary_end(new_ast_option(FRAME_BOUNDARY_END_PRECEDING), (yyvsp[-1].aval)); }
    break;

  case 591: /* frame_boundary_end: CURRENT_ROW  */
                 { (yyval.aval) = new_ast_frame_boundary_end(new_ast_option(FRAME_BOUNDARY_END_CURRENT_ROW), NULL); }
    break;

  case 592: /* frame_boundary_end: expr FOLLOWING  */
                    { (yyval.aval) = new_ast_frame_boundary_end(new_ast_option(FRAME_BOUNDARY_END_FOLLOWING), (yyvsp[-1].aval)); }
    break;

  case 593: /* frame_boundary_end: UNBOUNDED FOLLOWING  */
                         { (yyval.aval) = new_ast_frame_boundary_end(new_ast_option(FRAME_BOUNDARY_END_UNBOUNDED), NULL); }
    break;

  case 594: /* frame_boundary: UNBOUNDED PRECEDING  */
                       { (yyval.aval) = new_ast_frame_boundary(new_ast_option(FRAME_BOUNDARY_UNBOUNDED), NULL); }
    break;

  case 595: /* frame_boundary: expr PRECEDING  */
                    { (yyval.aval) = new_ast_frame_boundary(new_ast_option(FRAME_BOUNDARY_PRECEDING), (yyvsp[-1].aval)); }
    break;

  case 596: /* frame_boundary: CURRENT_ROW  */
                 { (yyval.aval) = new_ast_frame_boundary(new_ast_option(FRAME_BOUNDARY_CURRENT_ROW), NULL); }
    break;

  case 597: /* opt_partition_by: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 598: /* opt_partition_by: PARTITION BY expr_list  */
                            { (yyval.aval) = new_ast_opt_partition_by((yyvsp[0].aval)); }
    break;

  case 599: /* opt_select_window: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 600: /* opt_select_window: window_clause  */
                   { (yyval.aval) = new_ast_opt_select_window((yyvsp[0].aval)); }
    break;

  case 601: /* window_clause: WINDOW window_name_defn_list  */
                                { (yyval.aval) = new_ast_window_clause((yyvsp[0].aval)); }
    break;

  case 602: /* window_name_defn_list: window_name_defn  */
                    { (yyval.aval) = new_ast_window_name_defn_list((yyvsp[0].aval), NULL); }
    break;

  case 603: /* window_name_defn_list: window_name_defn ',' window_name_defn_list  */
                                                      { (yyval.aval) = new_ast_window_name_defn_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 604: /* window_name_defn: name AS window_defn  */
                       { (yyval.aval) = new_ast_window_name_defn((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 605: /* region_spec: name  */
          { (yyval.aval) = new_ast_region_spec((yyvsp[0].aval), new_ast_option(PUBLIC_REGION)); }
    break;

  case 606: /* region_spec: name PRIVATE  */
                  { (yyval.aval) = new_ast_region_spec((yyvsp[-1].aval), new_ast_option(PRIVATE_REGION)); }
    break;

  case 607: /* region_list: region_spec ',' region_list  */
                                   { (yyval.aval) = new_ast_region_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 608: /* region_list: region_spec  */
                 { (yyval.aval) = new_ast_region_list((yyvsp[0].aval), NULL); }
    break;

  case 609: /* declare_schema_region_stmt: AT_DECLARE_SCHEMA_REGION name  */
                                 { (yyval.aval) = new_ast_declare_schema_region_stmt((yyvsp[0].aval), NULL); }
    break;

  case 610: /* declare_schema_region_stmt: AT_DECLARE_SCHEMA_REGION name USING region_list  */
                                                     { (yyval.aval) = new_ast_declare_schema_region_stmt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 611: /* declare_deployable_region_stmt: AT_DECLARE_DEPLOYABLE_REGION name  */
                                      { (yyval.aval) = new_ast_declare_deployable_region_stmt((yyvsp[0].aval), NULL); }
    break;

  case 612: /* declare_deployable_region_stmt: AT_DECLARE_DEPLOYABLE_REGION name USING region_list  */
                                                         { (yyval.aval) = new_ast_declare_deployable_region_stmt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 613: /* begin_schema_region_stmt: AT_BEGIN_SCHEMA_REGION name  */
                               {(yyval.aval) = new_ast_begin_schema_region_stmt((yyvsp[0].aval)); }
    break;

  case 614: /* end_schema_region_stmt: AT_END_SCHEMA_REGION  */
                        {(yyval.aval) = new_ast_end_schema_region_stmt(); }
    break;

  case 615: /* schema_unsub_stmt: AT_UNSUB '(' sql_name ')'  */
                             { (yyval.aval) = new_ast_schema_unsub_stmt(new_ast_version_annotation(new_ast_option(1), (yyvsp[-1].aval))); }
    break;

  case 616: /* schema_ad_hoc_migration_stmt: AT_SCHEMA_AD_HOC_MIGRATION version_annotation  */
    { (yyval.aval) = new_ast_schema_ad_hoc_migration_stmt((yyvsp[0].aval), NULL); }
    break;

  case 617: /* schema_ad_hoc_migration_stmt: AT_SCHEMA_AD_HOC_MIGRATION FOR AT_RECREATE '(' name ',' name ')'  */
    { (yyval.aval) = new_ast_schema_ad_hoc_migration_stmt((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 618: /* emit_enums_stmt: AT_EMIT_ENUMS opt_name_list  */
                              { (yyval.aval) = new_ast_emit_enums_stmt((yyvsp[0].aval)); }
    break;

  case 619: /* emit_group_stmt: AT_EMIT_GROUP opt_name_list  */
                              { (yyval.aval) = new_ast_emit_group_stmt((yyvsp[0].aval)); }
    break;

  case 620: /* emit_constants_stmt: AT_EMIT_CONSTANTS name_list  */
                              { (yyval.aval) = new_ast_emit_constants_stmt((yyvsp[0].aval)); }
    break;

  case 621: /* opt_from_query_parts: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 622: /* opt_from_query_parts: FROM query_parts  */
                      { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 623: /* opt_where: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 624: /* opt_where: WHERE expr  */
                { (yyval.aval) = new_ast_opt_where((yyvsp[0].aval)); }
    break;

  case 625: /* opt_groupby: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 626: /* opt_groupby: GROUP BY groupby_list  */
                           { (yyval.aval) = new_ast_opt_groupby((yyvsp[0].aval)); }
    break;

  case 627: /* groupby_list: groupby_item  */
                { (yyval.aval) = new_ast_groupby_list((yyvsp[0].aval), NULL); }
    break;

  case 628: /* groupby_list: groupby_item ',' groupby_list  */
                                       { (yyval.aval) = new_ast_groupby_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 629: /* groupby_item: expr  */
        { (yyval.aval) = new_ast_groupby_item((yyvsp[0].aval)); }
    break;

  case 630: /* opt_asc_desc: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 631: /* opt_asc_desc: ASC opt_nullsfirst_nullslast  */
                                  { (yyval.aval) = new_ast_asc((yyvsp[0].aval)); }
    break;

  case 632: /* opt_asc_desc: DESC opt_nullsfirst_nullslast  */
                                   { (yyval.aval) = new_ast_desc((yyvsp[0].aval)); }
    break;

  case 633: /* opt_nullsfirst_nullslast: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 634: /* opt_nullsfirst_nullslast: NULLS FIRST  */
                 { (yyval.aval) = new_ast_nullsfirst(); }
    break;

  case 635: /* opt_nullsfirst_nullslast: NULLS LAST  */
                { (yyval.aval) = new_ast_nullslast(); }
    break;

  case 636: /* opt_having: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 637: /* opt_having: HAVING expr  */
                 { (yyval.aval) = new_ast_opt_having((yyvsp[0].aval)); }
    break;

  case 638: /* opt_orderby: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 639: /* opt_orderby: ORDER BY orderby_list  */
                           { (yyval.aval) = new_ast_opt_orderby((yyvsp[0].aval)); }
    break;

  case 640: /* orderby_list: orderby_item  */
                { (yyval.aval) = new_ast_orderby_list((yyvsp[0].aval), NULL); }
    break;

  case 641: /* orderby_list: orderby_item ',' orderby_list  */
                                       { (yyval.aval) = new_ast_orderby_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 642: /* orderby_item: expr opt_asc_desc  */
                     { (yyval.aval) = new_ast_orderby_item((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 643: /* opt_limit: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 644: /* opt_limit: LIMIT expr  */
                { (yyval.aval) = new_ast_opt_limit((yyvsp[0].aval)); }
    break;

  case 645: /* opt_offset: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 646: /* opt_offset: OFFSET expr  */
                 { (yyval.aval) = new_ast_opt_offset((yyvsp[0].aval)); }
    break;

  case 647: /* select_opts: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 648: /* select_opts: ALL  */
         { (yyval.aval) = new_ast_select_opts(new_ast_all()); }
    break;

  case 649: /* select_opts: DISTINCT  */
              { (yyval.aval) = new_ast_select_opts(new_ast_distinct()); }
    break;

  case 650: /* select_opts: DISTINCTROW  */
                 { (yyval.aval) = new_ast_select_opts(new_ast_distinctrow()); }
    break;

  case 651: /* select_expr_list: select_expr  */
               { (yyval.aval) = new_ast_select_expr_list((yyvsp[0].aval), NULL); }
    break;

  case 652: /* select_expr_list: select_expr ',' select_expr_list  */
                                           { (yyval.aval) = new_ast_select_expr_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 653: /* select_expr: expr opt_as_alias  */
                     {
    if (is_ast_select_expr_macro_ref((yyvsp[-1].aval)) || is_ast_select_expr_macro_arg_ref((yyvsp[-1].aval))) {
       (yyval.aval) = (yyvsp[-1].aval);
    }
    else if (is_ast_table_star((yyvsp[-1].aval)) || is_ast_star((yyvsp[-1].aval))) {
      YY_ERROR_ON_ALIAS_PRESENT((yyvsp[0].aval));
      (yyval.aval) = (yyvsp[-1].aval);
    }
    else {
      (yyval.aval) = new_ast_select_expr((yyvsp[-1].aval), (yyvsp[0].aval));
    }
  }
    break;

  case 654: /* select_expr: column_calculation  */
                        { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 655: /* opt_as_alias: %empty  */
             { (yyval.aval) = NULL;  }
    break;

  case 657: /* as_alias: AS sql_name  */
               { (yyval.aval) = new_ast_opt_as_alias((yyvsp[0].aval)); }
    break;

  case 658: /* as_alias: sql_name  */
              { (yyval.aval) = new_ast_opt_as_alias((yyvsp[0].aval)); }
    break;

  case 659: /* query_parts: table_or_subquery_list  */
                          { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 660: /* query_parts: join_clause  */
                 { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 661: /* table_or_subquery_list: table_or_subquery  */
                     { (yyval.aval) = new_ast_table_or_subquery_list((yyvsp[0].aval), NULL); }
    break;

  case 662: /* table_or_subquery_list: table_or_subquery ',' table_or_subquery_list  */
                                                       { (yyval.aval) = new_ast_table_or_subquery_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 663: /* join_clause: table_or_subquery join_target_list  */
                                      { (yyval.aval) = new_ast_join_clause((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 664: /* join_target_list: join_target  */
               { (yyval.aval) = new_ast_join_target_list((yyvsp[0].aval), NULL); }
    break;

  case 665: /* join_target_list: join_target join_target_list  */
                                       { (yyval.aval) = new_ast_join_target_list((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 666: /* table_or_subquery: sql_name opt_as_alias  */
                         { (yyval.aval) = new_ast_table_or_subquery((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 667: /* table_or_subquery: '(' select_stmt ')' opt_as_alias  */
                                      { (yyval.aval) = new_ast_table_or_subquery((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 668: /* table_or_subquery: '(' shared_cte ')' opt_as_alias  */
                                     { (yyval.aval) = new_ast_table_or_subquery((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 669: /* table_or_subquery: table_function opt_as_alias  */
                                 { (yyval.aval) = new_ast_table_or_subquery((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 670: /* table_or_subquery: '(' query_parts ')'  */
                         { (yyval.aval) = new_ast_table_or_subquery((yyvsp[-1].aval), NULL); }
    break;

  case 671: /* table_or_subquery: macro_ref opt_as_alias  */
                                { (yyval.aval) = new_ast_table_or_subquery((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 672: /* join_type: %empty  */
                 { (yyval.ival) = JOIN_INNER; }
    break;

  case 673: /* join_type: LEFT  */
                 { (yyval.ival) = JOIN_LEFT; }
    break;

  case 674: /* join_type: RIGHT  */
                 { (yyval.ival) = JOIN_RIGHT; }
    break;

  case 675: /* join_type: LEFT OUTER  */
                 { (yyval.ival) = JOIN_LEFT_OUTER; }
    break;

  case 676: /* join_type: RIGHT OUTER  */
                 { (yyval.ival) = JOIN_RIGHT_OUTER; }
    break;

  case 677: /* join_type: INNER  */
                 { (yyval.ival) = JOIN_INNER; }
    break;

  case 678: /* join_type: CROSS  */
                 { (yyval.ival) = JOIN_CROSS; }
    break;

  case 679: /* join_target: join_type JOIN table_or_subquery opt_join_cond  */
                                                             {
      struct ast_node *asti_join_type = new_ast_option((yyvsp[-3].ival));
      struct ast_node *table_join = new_ast_table_join((yyvsp[-1].aval), (yyvsp[0].aval));
      (yyval.aval) = new_ast_join_target(asti_join_type, table_join); }
    break;

  case 680: /* opt_join_cond: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 682: /* join_cond: ON expr  */
           { (yyval.aval) = new_ast_join_cond(new_ast_on(), (yyvsp[0].aval)); }
    break;

  case 683: /* join_cond: USING '(' name_list ')'  */
                             { (yyval.aval) = new_ast_join_cond(new_ast_using(), (yyvsp[-1].aval)); }
    break;

  case 684: /* table_function: name '(' arg_list ')'  */
                         { (yyval.aval) = new_ast_table_function((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 685: /* create_view_stmt: CREATE opt_temp VIEW opt_if_not_exists sql_name AS select_stmt opt_delete_version_attr  */
                                                                                          {
    ast_node *flags = new_ast_option((yyvsp[-6].ival) | (yyvsp[-4].ival));
    ast_node *view_details = new_ast_view_details((yyvsp[-3].aval), NULL);
    ast_node *view_details_select = new_ast_view_details_select(view_details, (yyvsp[-1].aval));
    ast_node *view_and_attrs = new_ast_view_and_attrs(view_details_select, (yyvsp[0].aval));
  (yyval.aval) = new_ast_create_view_stmt(flags, view_and_attrs); }
    break;

  case 686: /* create_view_stmt: CREATE opt_temp VIEW opt_if_not_exists sql_name '(' name_list ')' AS select_stmt opt_delete_version_attr  */
                                                                                                              {
    ast_node *flags = new_ast_option((yyvsp[-9].ival) | (yyvsp[-7].ival));
    ast_node *view_details = new_ast_view_details((yyvsp[-6].aval), (yyvsp[-4].aval));
    ast_node *view_details_select = new_ast_view_details_select(view_details, (yyvsp[-1].aval));
    ast_node *view_and_attrs = new_ast_view_and_attrs(view_details_select, (yyvsp[0].aval));
    (yyval.aval) = new_ast_create_view_stmt(flags, view_and_attrs); }
    break;

  case 687: /* delete_stmt: delete_stmt_plain  */
                       { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 688: /* delete_stmt: delete_stmt_plain returning_suffix  */
                                        {
     (yyval.aval) = new_ast_delete_returning_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 689: /* delete_stmt: with_prefix delete_stmt_plain  */
                                   {
     (yyval.aval) = new_ast_with_delete_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 690: /* delete_stmt: with_prefix delete_stmt_plain returning_suffix  */
                                                    {
     ast_node *tmp = new_ast_with_delete_stmt((yyvsp[-2].aval), (yyvsp[-1].aval)); 
     (yyval.aval) = new_ast_delete_returning_stmt(tmp, (yyvsp[0].aval)); }
    break;

  case 691: /* delete_stmt_plain: DELETE FROM sql_name opt_where  */
                                  {
   (yyval.aval) = new_ast_delete_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 692: /* opt_insert_dummy_spec: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 693: /* opt_insert_dummy_spec: AT_DUMMY_SEED '(' expr ')' dummy_modifier  */
                                               {
    (yyval.aval) = new_ast_insert_dummy_spec((yyvsp[-2].aval), new_ast_option((yyvsp[0].ival))); }
    break;

  case 694: /* dummy_modifier: %empty  */
             { (yyval.ival) = 0; }
    break;

  case 695: /* dummy_modifier: AT_DUMMY_NULLABLES  */
                        { (yyval.ival) = INSERT_DUMMY_NULLABLES; }
    break;

  case 696: /* dummy_modifier: AT_DUMMY_DEFAULTS  */
                       { (yyval.ival) = INSERT_DUMMY_DEFAULTS; }
    break;

  case 697: /* dummy_modifier: AT_DUMMY_NULLABLES AT_DUMMY_DEFAULTS  */
                                          { (yyval.ival) = INSERT_DUMMY_NULLABLES | INSERT_DUMMY_DEFAULTS; }
    break;

  case 698: /* dummy_modifier: AT_DUMMY_DEFAULTS AT_DUMMY_NULLABLES  */
                                          { (yyval.ival) = INSERT_DUMMY_NULLABLES | INSERT_DUMMY_DEFAULTS; }
    break;

  case 699: /* insert_stmt_type: INSERT INTO  */
               { (yyval.aval) = new_ast_insert_normal();  }
    break;

  case 700: /* insert_stmt_type: INSERT OR REPLACE INTO  */
                            { (yyval.aval) = new_ast_insert_or_replace(); }
    break;

  case 701: /* insert_stmt_type: INSERT OR IGNORE INTO  */
                           { (yyval.aval) = new_ast_insert_or_ignore(); }
    break;

  case 702: /* insert_stmt_type: INSERT OR ROLLBACK INTO  */
                             { (yyval.aval) = new_ast_insert_or_rollback(); }
    break;

  case 703: /* insert_stmt_type: INSERT OR ABORT INTO  */
                          { (yyval.aval) = new_ast_insert_or_abort(); }
    break;

  case 704: /* insert_stmt_type: INSERT OR FAIL INTO  */
                         { (yyval.aval) = new_ast_insert_or_fail(); }
    break;

  case 705: /* insert_stmt_type: REPLACE INTO  */
                  { (yyval.aval) = new_ast_insert_replace(); }
    break;

  case 706: /* opt_column_spec: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 707: /* opt_column_spec: '(' opt_sql_name_list ')'  */
                               { (yyval.aval) = new_ast_column_spec((yyvsp[-1].aval)); }
    break;

  case 708: /* opt_column_spec: '(' shape_def ')'  */
                       { (yyval.aval) = new_ast_column_spec((yyvsp[-1].aval)); }
    break;

  case 709: /* column_spec: '(' sql_name_list ')'  */
                         { (yyval.aval) = new_ast_column_spec((yyvsp[-1].aval)); }
    break;

  case 710: /* column_spec: '(' shape_def ')'  */
                       { (yyval.aval) = new_ast_column_spec((yyvsp[-1].aval)); }
    break;

  case 711: /* from_shape: FROM CURSOR name opt_column_spec  */
                                    { (yyval.aval) = new_ast_from_shape((yyvsp[0].aval), (yyvsp[-1].aval)); }
    break;

  case 712: /* from_shape: FROM name opt_column_spec  */
                               { (yyval.aval) = new_ast_from_shape((yyvsp[0].aval), (yyvsp[-1].aval)); }
    break;

  case 713: /* from_shape: FROM ARGUMENTS opt_column_spec  */
                                    { (yyval.aval) = new_ast_from_shape((yyvsp[0].aval), new_ast_str("ARGUMENTS")); }
    break;

  case 714: /* insert_stmt_plain: insert_stmt_type sql_name opt_column_spec select_stmt opt_insert_dummy_spec  */
                                                                               {
    struct ast_node *columns_values = new_ast_columns_values((yyvsp[-2].aval), (yyvsp[-1].aval));
    struct ast_node *name_columns_values = new_ast_name_columns_values((yyvsp[-3].aval), columns_values);
    ast_set_left((yyvsp[-4].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_insert_stmt((yyvsp[-4].aval), name_columns_values);  }
    break;

  case 715: /* insert_stmt_plain: insert_stmt_type sql_name opt_column_spec from_shape opt_insert_dummy_spec  */
                                                                                {
    struct ast_node *columns_values = new_ast_columns_values((yyvsp[-2].aval), (yyvsp[-1].aval));
    struct ast_node *name_columns_values = new_ast_name_columns_values((yyvsp[-3].aval), columns_values);
    ast_set_left((yyvsp[-4].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_insert_stmt((yyvsp[-4].aval), name_columns_values);  }
    break;

  case 716: /* insert_stmt_plain: insert_stmt_type sql_name DEFAULT VALUES  */
                                              {
    struct ast_node *default_columns_values = new_ast_default_columns_values();
    struct ast_node *name_columns_values = new_ast_name_columns_values((yyvsp[-2].aval), default_columns_values);
    (yyval.aval) = new_ast_insert_stmt((yyvsp[-3].aval), name_columns_values); }
    break;

  case 717: /* insert_stmt_plain: insert_stmt_type sql_name USING select_stmt  */
                                                {
    struct ast_node *name_columns_values = new_ast_name_columns_values((yyvsp[-2].aval), (yyvsp[0].aval));
    ast_set_left((yyvsp[-3].aval), NULL); // dummy spec not allowed in this form
    (yyval.aval) = new_ast_insert_stmt((yyvsp[-3].aval), name_columns_values); }
    break;

  case 718: /* insert_stmt_plain: insert_stmt_type sql_name USING expr_names opt_insert_dummy_spec  */
                                                                     {
    struct ast_node *name_columns_values = new_ast_name_columns_values((yyvsp[-3].aval), (yyvsp[-1].aval));
    ast_set_left((yyvsp[-4].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_insert_stmt((yyvsp[-4].aval), name_columns_values); }
    break;

  case 719: /* returning_suffix: RETURNING select_expr_list  */
                                             { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 720: /* insert_stmt: insert_stmt_plain  */
                       { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 721: /* insert_stmt: insert_stmt_plain returning_suffix  */
                                        {
     (yyval.aval) = new_ast_insert_returning_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 722: /* insert_stmt: with_prefix insert_stmt_plain  */
                                   {
     (yyval.aval) = new_ast_with_insert_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 723: /* insert_stmt: with_prefix insert_stmt_plain returning_suffix  */
                                                    {
     ast_node *tmp = new_ast_with_insert_stmt((yyvsp[-2].aval), (yyvsp[-1].aval)); 
     (yyval.aval) = new_ast_insert_returning_stmt(tmp, (yyvsp[0].aval)); }
    break;

  case 724: /* insert_list_item: expr  */
       { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 725: /* insert_list_item: shape_arguments  */
                     {(yyval.aval) = (yyvsp[0].aval); }
    break;

  case 726: /* insert_list: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 727: /* insert_list: insert_list_item  */
                     { (yyval.aval) = new_ast_insert_list((yyvsp[0].aval), NULL); }
    break;

  case 728: /* insert_list: insert_list_item ',' insert_list  */
                                          { (yyval.aval) = new_ast_insert_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 729: /* basic_update_stmt: UPDATE opt_sql_name SET update_list opt_from_query_parts opt_where  */
                                                                      {
    struct ast_node *orderby = new_ast_update_orderby(NULL, NULL);
    struct ast_node *where = new_ast_update_where((yyvsp[0].aval), orderby);
    struct ast_node *from = new_ast_update_from((yyvsp[-1].aval), where);
    struct ast_node *list = new_ast_update_set((yyvsp[-2].aval), from);
    (yyval.aval) = new_ast_update_stmt((yyvsp[-4].aval), list); }
    break;

  case 730: /* update_stmt: update_stmt_plain  */
                       { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 731: /* update_stmt: update_stmt_plain returning_suffix  */
                                        {
     (yyval.aval) = new_ast_update_returning_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 732: /* update_stmt: with_prefix update_stmt_plain  */
                                   {
     (yyval.aval) = new_ast_with_update_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 733: /* update_stmt: with_prefix update_stmt_plain returning_suffix  */
                                                    {
     ast_node *tmp = new_ast_with_update_stmt((yyvsp[-2].aval), (yyvsp[-1].aval)); 
     (yyval.aval) = new_ast_update_returning_stmt(tmp, (yyvsp[0].aval)); }
    break;

  case 734: /* update_stmt_plain: UPDATE sql_name SET update_list opt_from_query_parts opt_where opt_orderby opt_limit  */
                                                                                        {
    struct ast_node *limit = (yyvsp[0].aval);
    struct ast_node *orderby = new_ast_update_orderby((yyvsp[-1].aval), limit);
    struct ast_node *where = new_ast_update_where((yyvsp[-2].aval), orderby);
    struct ast_node *from = new_ast_update_from((yyvsp[-3].aval), where);
    struct ast_node *list = new_ast_update_set((yyvsp[-4].aval), from);
    (yyval.aval) = new_ast_update_stmt((yyvsp[-6].aval), list); }
    break;

  case 735: /* update_stmt_plain: UPDATE sql_name SET column_spec '=' '(' insert_list ')' opt_from_query_parts opt_where opt_orderby opt_limit  */
                                                                                                                  {
    struct ast_node *limit = (yyvsp[0].aval);
    struct ast_node *orderby = new_ast_update_orderby((yyvsp[-1].aval), limit);
    struct ast_node *where = new_ast_update_where((yyvsp[-2].aval), orderby);
    struct ast_node *from = new_ast_update_from((yyvsp[-3].aval), where);
    struct ast_node *columns_values = new_ast_columns_values((yyvsp[-8].aval), (yyvsp[-5].aval));
    struct ast_node *list = new_ast_update_set(columns_values, from);
    (yyval.aval) = new_ast_update_stmt((yyvsp[-10].aval), list); }
    break;

  case 736: /* update_entry: sql_name '=' expr  */
                     { (yyval.aval) = new_ast_update_entry((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 737: /* update_list: update_entry  */
                { (yyval.aval) = new_ast_update_list((yyvsp[0].aval), NULL); }
    break;

  case 738: /* update_list: update_entry ',' update_list  */
                                      { (yyval.aval) = new_ast_update_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 739: /* upsert_stmt: upsert_stmt_plain  */
                       { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 740: /* upsert_stmt: upsert_stmt_plain returning_suffix  */
                                        {
     (yyval.aval) = new_ast_upsert_returning_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 741: /* upsert_stmt: with_prefix upsert_stmt_plain  */
                                   {
     (yyval.aval) = new_ast_with_upsert_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 742: /* upsert_stmt: with_prefix upsert_stmt_plain returning_suffix  */
                                                    {
     ast_node *tmp = new_ast_with_upsert_stmt((yyvsp[-2].aval), (yyvsp[-1].aval)); 
     (yyval.aval) = new_ast_upsert_returning_stmt(tmp, (yyvsp[0].aval)); }
    break;

  case 743: /* upsert_stmt_plain: insert_stmt_plain ON_CONFLICT conflict_target DO NOTHING  */
                                                                    {
    struct ast_node *upsert_update = new_ast_upsert_update((yyvsp[-2].aval), NULL);
    (yyval.aval) = new_ast_upsert_stmt((yyvsp[-4].aval), upsert_update); }
    break;

  case 744: /* upsert_stmt_plain: insert_stmt_plain ON_CONFLICT conflict_target DO basic_update_stmt  */
                                                                                {
    struct ast_node *upsert_update = new_ast_upsert_update((yyvsp[-2].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_upsert_stmt((yyvsp[-4].aval), upsert_update); }
    break;

  case 745: /* update_cursor_stmt: UPDATE CURSOR name opt_column_spec FROM VALUES '(' insert_list ')'  */
                                                                      {
    struct ast_node *columns_values = new_ast_columns_values((yyvsp[-5].aval), (yyvsp[-1].aval));
    (yyval.aval) = new_ast_update_cursor_stmt((yyvsp[-6].aval), columns_values); }
    break;

  case 746: /* update_cursor_stmt: UPDATE CURSOR name opt_column_spec from_shape  */
                                                   {
    struct ast_node *columns_values = new_ast_columns_values((yyvsp[-1].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_update_cursor_stmt((yyvsp[-2].aval), columns_values); }
    break;

  case 747: /* update_cursor_stmt: UPDATE CURSOR name USING expr_names  */
                                        {
    (yyval.aval) = new_ast_update_cursor_stmt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 748: /* conflict_target: %empty  */
             { (yyval.aval) = new_ast_conflict_target(NULL, NULL); }
    break;

  case 749: /* conflict_target: '(' indexed_columns ')' opt_where  */
                                       {
    (yyval.aval) = new_ast_conflict_target((yyvsp[-2].aval), (yyvsp[0].aval));
  }
    break;

  case 752: /* declare_out_call_stmt: DECLARE OUT call_stmt  */
                        { (yyval.aval) = new_ast_declare_out_call_stmt((yyvsp[0].aval)); }
    break;

  case 753: /* declare_enum_stmt: DECLARE ENUM name data_type_numeric '(' enum_values ')'  */
                                                          {
     ast_node *typed_name = new_ast_typed_name((yyvsp[-4].aval), (yyvsp[-3].aval));
     (yyval.aval) = new_ast_declare_enum_stmt(typed_name, (yyvsp[-1].aval)); }
    break;

  case 754: /* enum_values: enum_value  */
               { (yyval.aval) = new_ast_enum_values((yyvsp[0].aval), NULL); }
    break;

  case 755: /* enum_values: enum_value ',' enum_values  */
                                     { (yyval.aval) = new_ast_enum_values((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 756: /* enum_value: name  */
         { (yyval.aval) = new_ast_enum_value((yyvsp[0].aval), NULL); }
    break;

  case 757: /* enum_value: name '=' expr  */
                  { (yyval.aval) = new_ast_enum_value((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 758: /* declare_const_stmt: DECLARE CONST GROUP name '(' const_values ')'  */
                                                {
    (yyval.aval) = new_ast_declare_const_stmt((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 759: /* declare_group_stmt: DECLARE GROUP name BEGIN_ simple_variable_decls END  */
                                                      {
    (yyval.aval) = new_ast_declare_group_stmt((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 760: /* simple_variable_decls: declare_vars_stmt ';'  */
                             { (yyval.aval) = new_ast_stmt_list((yyvsp[-1].aval), NULL); }
    break;

  case 761: /* simple_variable_decls: declare_vars_stmt ';' simple_variable_decls  */
                                                           { (yyval.aval) = new_ast_stmt_list((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 762: /* const_values: const_value  */
               { (yyval.aval) = new_ast_const_values((yyvsp[0].aval), NULL);  }
    break;

  case 763: /* const_values: const_value ',' const_values  */
                                       { (yyval.aval) = new_ast_const_values((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 764: /* const_value: name '=' expr  */
                            { (yyval.aval) = new_ast_const_value((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 765: /* declare_select_func_stmt: DECLARE SELECT function name '(' params ')' data_type_with_options  */
                                                                       {
      (yyval.aval) = new_ast_declare_select_func_stmt((yyvsp[-4].aval), new_ast_func_params_return((yyvsp[-2].aval), (yyvsp[0].aval))); }
    break;

  case 766: /* declare_select_func_stmt: DECLARE SELECT function name '(' params ')' '(' typed_names ')'  */
                                                                     {
      (yyval.aval) = new_ast_declare_select_func_stmt((yyvsp[-6].aval), new_ast_func_params_return((yyvsp[-4].aval), (yyvsp[-1].aval))); }
    break;

  case 767: /* declare_select_func_stmt: DECLARE SELECT function name NO CHECK data_type_with_options  */
                                                                 {
      (yyval.aval)  = new_ast_declare_select_func_no_check_stmt((yyvsp[-3].aval), new_ast_func_params_return(NULL, (yyvsp[0].aval))); }
    break;

  case 768: /* declare_select_func_stmt: DECLARE SELECT function name NO CHECK '(' typed_names ')'  */
                                                              {
      (yyval.aval) = new_ast_declare_select_func_no_check_stmt((yyvsp[-5].aval), new_ast_func_params_return(NULL, (yyvsp[-1].aval))); }
    break;

  case 769: /* declare_func_stmt: DECLARE function loose_name '(' func_params ')' data_type_with_options  */
                                                                                {
      (yyval.aval) = new_ast_declare_func_stmt((yyvsp[-4].aval), new_ast_func_params_return((yyvsp[-2].aval), (yyvsp[0].aval))); }
    break;

  case 770: /* declare_func_stmt: DECLARE function loose_name '(' func_params ')' CREATE data_type_with_options  */
                                                                                         {
      ast_node *create_data_type = new_ast_create_data_type((yyvsp[0].aval));
      (yyval.aval) = new_ast_declare_func_stmt((yyvsp[-5].aval), new_ast_func_params_return((yyvsp[-3].aval), create_data_type)); }
    break;

  case 771: /* declare_func_stmt: DECLARE function loose_name NO CHECK data_type_with_options  */
                                                                       {
      (yyval.aval) = new_ast_declare_func_no_check_stmt((yyvsp[-3].aval), new_ast_func_params_return(NULL, (yyvsp[0].aval))); }
    break;

  case 772: /* declare_func_stmt: DECLARE function loose_name NO CHECK CREATE data_type_with_options  */
                                                                              {
      ast_node *create_data_type = new_ast_create_data_type((yyvsp[0].aval));
      (yyval.aval) = new_ast_declare_func_no_check_stmt((yyvsp[-4].aval), new_ast_func_params_return(NULL, create_data_type)); }
    break;

  case 775: /* declare_proc_no_check_stmt: DECLARE procedure loose_name NO CHECK  */
                                              {
    (yyval.aval) = new_ast_declare_proc_no_check_stmt((yyvsp[-2].aval)); }
    break;

  case 776: /* declare_proc_stmt: DECLARE procedure loose_name '(' func_params ')'  */
                                                                  {
      ast_node *proc_name_flags = new_ast_proc_name_type((yyvsp[-3].aval), new_ast_option(PROC_FLAG_BASIC));
      (yyval.aval) = new_ast_declare_proc_stmt(proc_name_flags, new_ast_proc_params_stmts((yyvsp[-1].aval), NULL)); }
    break;

  case 777: /* declare_proc_stmt: DECLARE procedure loose_name '(' func_params ')' '(' typed_names ')'  */
                                                                                        {
      ast_node *proc_name_flags = new_ast_proc_name_type((yyvsp[-6].aval), new_ast_option(PROC_FLAG_STRUCT_TYPE | PROC_FLAG_USES_DML));
      (yyval.aval) = new_ast_declare_proc_stmt(proc_name_flags, new_ast_proc_params_stmts((yyvsp[-4].aval), (yyvsp[-1].aval))); }
    break;

  case 778: /* declare_proc_stmt: DECLARE procedure loose_name '(' func_params ')' USING TRANSACTION  */
                                                                                      {
      ast_node *proc_name_flags = new_ast_proc_name_type((yyvsp[-5].aval), new_ast_option(PROC_FLAG_USES_DML));
      (yyval.aval) = new_ast_declare_proc_stmt(proc_name_flags, new_ast_proc_params_stmts((yyvsp[-3].aval), NULL)); }
    break;

  case 779: /* declare_proc_stmt: DECLARE procedure loose_name '(' func_params ')' OUT '(' typed_names ')'  */
                                                                                            {
      ast_node *proc_name_flags = new_ast_proc_name_type((yyvsp[-7].aval), new_ast_option(PROC_FLAG_STRUCT_TYPE | PROC_FLAG_USES_OUT));
      (yyval.aval) = new_ast_declare_proc_stmt(proc_name_flags, new_ast_proc_params_stmts((yyvsp[-5].aval), (yyvsp[-1].aval))); }
    break;

  case 780: /* declare_proc_stmt: DECLARE procedure loose_name '(' func_params ')' OUT '(' typed_names ')' USING TRANSACTION  */
                                                                                                              {
      ast_node *proc_name_flags = new_ast_proc_name_type((yyvsp[-9].aval), new_ast_option(PROC_FLAG_STRUCT_TYPE | PROC_FLAG_USES_OUT | PROC_FLAG_USES_DML));
      (yyval.aval) = new_ast_declare_proc_stmt(proc_name_flags, new_ast_proc_params_stmts((yyvsp[-7].aval), (yyvsp[-3].aval))); }
    break;

  case 781: /* declare_proc_stmt: DECLARE procedure loose_name '(' func_params ')' OUT UNION '(' typed_names ')'  */
                                                                                                  {
      ast_node *proc_name_flags = new_ast_proc_name_type((yyvsp[-8].aval), new_ast_option(PROC_FLAG_STRUCT_TYPE | PROC_FLAG_USES_OUT_UNION));
      (yyval.aval) = new_ast_declare_proc_stmt(proc_name_flags, new_ast_proc_params_stmts((yyvsp[-6].aval), (yyvsp[-1].aval))); }
    break;

  case 782: /* declare_proc_stmt: DECLARE procedure loose_name '(' func_params ')' OUT UNION '(' typed_names ')' USING TRANSACTION  */
                                                                                                                    {
      ast_node *proc_name_flags = new_ast_proc_name_type((yyvsp[-10].aval), new_ast_option(PROC_FLAG_STRUCT_TYPE | PROC_FLAG_USES_OUT_UNION | PROC_FLAG_USES_DML));
      (yyval.aval) = new_ast_declare_proc_stmt(proc_name_flags, new_ast_proc_params_stmts((yyvsp[-8].aval), (yyvsp[-3].aval))); }
    break;

  case 783: /* declare_interface_stmt: DECLARE INTERFACE name '(' typed_names ')'  */
                                              {
      (yyval.aval) = new_ast_declare_interface_stmt((yyvsp[-3].aval), new_ast_proc_params_stmts(NULL, (yyvsp[-1].aval))); }
    break;

  case 784: /* declare_interface_stmt: INTERFACE name '(' typed_names ')'  */
                                        {
      (yyval.aval) = new_ast_declare_interface_stmt((yyvsp[-3].aval), new_ast_proc_params_stmts(NULL, (yyvsp[-1].aval))); }
    break;

  case 785: /* create_proc_stmt: CREATE procedure loose_name '(' params ')' BEGIN_ opt_stmt_list END  */
                                                                             {
    (yyval.aval) = new_ast_create_proc_stmt((yyvsp[-6].aval), new_ast_proc_params_stmts((yyvsp[-4].aval), (yyvsp[-1].aval))); }
    break;

  case 786: /* create_proc_stmt: procedure loose_name '(' params ')' BEGIN_ opt_stmt_list END  */
                                                                        {
    (yyval.aval) = new_ast_create_proc_stmt((yyvsp[-6].aval), new_ast_proc_params_stmts((yyvsp[-4].aval), (yyvsp[-1].aval))); }
    break;

  case 787: /* inout: IN  */
      { (yyval.aval) = new_ast_in(); }
    break;

  case 788: /* inout: OUT  */
         { (yyval.aval) = new_ast_out(); }
    break;

  case 789: /* inout: INOUT  */
           { (yyval.aval) = new_ast_inout(); }
    break;

  case 790: /* typed_name: sql_name data_type_with_options  */
                                   { (yyval.aval) = new_ast_typed_name((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 791: /* typed_name: shape_def  */
               { (yyval.aval) = new_ast_typed_name(NULL, (yyvsp[0].aval)); }
    break;

  case 792: /* typed_name: name shape_def  */
                    { (yyval.aval) = new_ast_typed_name((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 793: /* typed_names: typed_name  */
              { (yyval.aval) = new_ast_typed_names((yyvsp[0].aval), NULL); }
    break;

  case 794: /* typed_names: typed_name ',' typed_names  */
                                    { (yyval.aval) = new_ast_typed_names((yyvsp[-2].aval), (yyvsp[0].aval));}
    break;

  case 795: /* func_param: param  */
        { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 796: /* func_param: name CURSOR  */
                { (yyval.aval) = new_ast_param(NULL, new_ast_param_detail((yyvsp[-1].aval), new_ast_type_cursor())); }
    break;

  case 797: /* func_params: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 798: /* func_params: func_param  */
                { (yyval.aval) = new_ast_params((yyvsp[0].aval), NULL); }
    break;

  case 799: /* func_params: func_param ',' func_params  */
                                      { (yyval.aval) = new_ast_params((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 800: /* param: sql_name data_type_with_options  */
                                   { (yyval.aval) = new_ast_param(NULL, new_ast_param_detail((yyvsp[-1].aval), (yyvsp[0].aval))); }
    break;

  case 801: /* param: inout sql_name data_type_with_options  */
                                           { (yyval.aval) = new_ast_param((yyvsp[-2].aval), new_ast_param_detail((yyvsp[-1].aval), (yyvsp[0].aval))); }
    break;

  case 802: /* param: shape_def  */
               { (yyval.aval) = new_ast_param(NULL, new_ast_param_detail(NULL, (yyvsp[0].aval))); }
    break;

  case 803: /* param: name shape_def  */
                    { (yyval.aval) = new_ast_param(NULL, new_ast_param_detail((yyvsp[-1].aval), (yyvsp[0].aval))); }
    break;

  case 804: /* params: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 805: /* params: param  */
           { (yyval.aval) = new_ast_params((yyvsp[0].aval), NULL); }
    break;

  case 806: /* params: param ',' params  */
                            { (yyval.aval) = new_ast_params((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 807: /* declare_value_cursor: DECLARE name CURSOR shape_def  */
                                 { (yyval.aval) = new_ast_declare_cursor_like_name((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 808: /* declare_value_cursor: CURSOR name shape_def  */
                           { (yyval.aval) = new_ast_declare_cursor_like_name((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 809: /* declare_value_cursor: DECLARE name CURSOR LIKE select_stmt  */
                                          { (yyval.aval) = new_ast_declare_cursor_like_select((yyvsp[-3].aval), (yyvsp[0].aval)); }
    break;

  case 810: /* declare_value_cursor: CURSOR name LIKE select_stmt  */
                                  { (yyval.aval) = new_ast_declare_cursor_like_select((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 811: /* declare_value_cursor: DECLARE name CURSOR LIKE '(' typed_names ')'  */
                                                 { (yyval.aval) = new_ast_declare_cursor_like_typed_names((yyvsp[-5].aval), (yyvsp[-1].aval)); }
    break;

  case 812: /* declare_value_cursor: CURSOR name LIKE '(' typed_names ')'  */
                                         { (yyval.aval) = new_ast_declare_cursor_like_typed_names((yyvsp[-4].aval), (yyvsp[-1].aval)); }
    break;

  case 820: /* declare_forward_read_cursor_stmt: DECLARE name CURSOR FOR row_source  */
                                      { (yyval.aval) = new_ast_declare_cursor((yyvsp[-3].aval), (yyvsp[0].aval)); }
    break;

  case 821: /* declare_forward_read_cursor_stmt: CURSOR name FOR row_source  */
                                { (yyval.aval) = new_ast_declare_cursor((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 822: /* declare_forward_read_cursor_stmt: DECLARE name CURSOR FOR expr  */
                                     { (yyval.aval) = new_ast_declare_cursor((yyvsp[-3].aval), (yyvsp[0].aval)); }
    break;

  case 823: /* declare_forward_read_cursor_stmt: CURSOR name FOR expr  */
                             { (yyval.aval) = new_ast_declare_cursor((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 824: /* declare_fetched_value_cursor_stmt: DECLARE name CURSOR FETCH FROM call_stmt  */
                                            { (yyval.aval) = new_ast_declare_value_cursor((yyvsp[-4].aval), (yyvsp[0].aval)); }
    break;

  case 825: /* declare_fetched_value_cursor_stmt: CURSOR name FETCH FROM call_stmt  */
                                      { (yyval.aval) = new_ast_declare_value_cursor((yyvsp[-3].aval), (yyvsp[0].aval)); }
    break;

  case 826: /* declare_type_stmt: DECLARE name TYPE data_type_with_options  */
                                           { (yyval.aval) = new_ast_declare_named_type((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 827: /* declare_type_stmt: TYPE name data_type_with_options  */
                                     { (yyval.aval) = new_ast_declare_named_type((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 828: /* declare_vars_stmt: DECLARE sql_name_list data_type_with_options  */
                                                { (yyval.aval) = new_ast_declare_vars_type((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 829: /* declare_vars_stmt: VAR name_list data_type_with_options  */
                                          { (yyval.aval) = new_ast_declare_vars_type((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 830: /* declare_vars_stmt: declare_value_cursor  */
                         { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 831: /* call_stmt: CALL loose_name '(' arg_list ')'  */
                                                   {
   YY_ERROR_ON_CQL_INFERRED_NOTNULL((yyvsp[-3].aval));
   (yyval.aval) = new_ast_call_stmt((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 832: /* for_stmt: FOR expr ';' stmt_list BEGIN_ opt_stmt_list END  */
                                                                {
   (yyval.aval) = new_ast_for_stmt((yyvsp[-5].aval), new_ast_for_info((yyvsp[-3].aval), (yyvsp[-1].aval))); }
    break;

  case 833: /* while_stmt: WHILE expr BEGIN_ opt_stmt_list END  */
                                       { (yyval.aval) = new_ast_while_stmt((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 834: /* switch_stmt: SWITCH expr switch_case switch_cases  */
                                       {
    ast_node *cases = new_ast_switch_case((yyvsp[-1].aval), (yyvsp[0].aval));
    ast_node *switch_body = new_ast_switch_body((yyvsp[-2].aval), cases);
    (yyval.aval) = new_ast_switch_stmt(new_ast_option(0), switch_body);  }
    break;

  case 835: /* switch_stmt: SWITCH expr ALL VALUES switch_case switch_cases  */
                                                    {
    ast_node *cases = new_ast_switch_case((yyvsp[-1].aval), (yyvsp[0].aval));
    ast_node *switch_body = new_ast_switch_body((yyvsp[-4].aval), cases);
    (yyval.aval) = new_ast_switch_stmt(new_ast_option(1), switch_body);  }
    break;

  case 836: /* switch_case: WHEN expr_list THEN stmt_list  */
                                { (yyval.aval) = new_ast_connector((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 837: /* switch_case: WHEN expr_list THEN NOTHING  */
                                { (yyval.aval) = new_ast_connector((yyvsp[-2].aval), NULL); }
    break;

  case 838: /* switch_cases: switch_case switch_cases  */
                                 {
    (yyval.aval) = new_ast_switch_case((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 839: /* switch_cases: ELSE stmt_list END  */
                       {
    ast_node *conn = new_ast_connector(NULL, (yyvsp[-1].aval));
    (yyval.aval) = new_ast_switch_case(conn, NULL); }
    break;

  case 840: /* switch_cases: END  */
        { (yyval.aval) = NULL; }
    break;

  case 841: /* loop_stmt: LOOP fetch_stmt BEGIN_ opt_stmt_list END  */
                                            { (yyval.aval) = new_ast_loop_stmt((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 842: /* leave_stmt: LEAVE  */
         { (yyval.aval) = new_ast_leave_stmt(); }
    break;

  case 843: /* return_stmt: RETURN  */
          { (yyval.aval) = new_ast_return_stmt(); }
    break;

  case 844: /* rollback_return_stmt: ROLLBACK RETURN  */
                  { (yyval.aval) = new_ast_rollback_return_stmt(); }
    break;

  case 845: /* commit_return_stmt: COMMIT RETURN  */
                 { (yyval.aval) = new_ast_commit_return_stmt(); }
    break;

  case 846: /* throw_stmt: THROW  */
         { (yyval.aval) = new_ast_throw_stmt(); }
    break;

  case 847: /* trycatch_stmt: BEGIN_ TRY opt_stmt_list END TRY ';' BEGIN_ CATCH opt_stmt_list END CATCH  */
                                                                                         { (yyval.aval) = new_ast_trycatch_stmt((yyvsp[-8].aval), (yyvsp[-2].aval)); }
    break;

  case 848: /* trycatch_stmt: TRY opt_stmt_list CATCH opt_stmt_list END  */
                                                          { (yyval.aval) = new_ast_trycatch_stmt((yyvsp[-3].aval), (yyvsp[-1].aval)); }
    break;

  case 849: /* continue_stmt: CONTINUE  */
            { (yyval.aval) = new_ast_continue_stmt(); }
    break;

  case 850: /* fetch_stmt: FETCH name INTO name_list  */
                             { (yyval.aval) = new_ast_fetch_stmt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 851: /* fetch_stmt: FETCH name  */
                { (yyval.aval) = new_ast_fetch_stmt((yyvsp[0].aval), NULL); }
    break;

  case 852: /* fetch_values_stmt: FETCH name opt_column_spec FROM VALUES '(' insert_list ')' opt_insert_dummy_spec  */
                                                                                    {
    struct ast_node *columns_values = new_ast_columns_values((yyvsp[-6].aval), (yyvsp[-2].aval));
    struct ast_node *name_columns_values = new_ast_name_columns_values((yyvsp[-7].aval), columns_values);
    (yyval.aval) = new_ast_fetch_values_stmt((yyvsp[0].aval), name_columns_values); }
    break;

  case 853: /* fetch_values_stmt: FETCH name opt_column_spec from_shape opt_insert_dummy_spec  */
                                                                 {
    struct ast_node *columns_values = new_ast_columns_values((yyvsp[-2].aval), (yyvsp[-1].aval));
    struct ast_node *name_columns_values = new_ast_name_columns_values((yyvsp[-3].aval), columns_values);
    (yyval.aval) = new_ast_fetch_values_stmt((yyvsp[0].aval), name_columns_values); }
    break;

  case 854: /* fetch_values_stmt: FETCH name USING expr_names opt_insert_dummy_spec  */
                                                      {
    struct ast_node *name_columns_values = new_ast_name_columns_values((yyvsp[-3].aval), (yyvsp[-1].aval));
    (yyval.aval) = new_ast_fetch_values_stmt((yyvsp[0].aval), name_columns_values); }
    break;

  case 855: /* expr_names: expr_name  */
             { (yyval.aval) = new_ast_expr_names((yyvsp[0].aval), NULL); }
    break;

  case 856: /* expr_names: expr_name ',' expr_names  */
                                    { (yyval.aval) = new_ast_expr_names((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 857: /* expr_name: expr as_alias  */
                         { (yyval.aval) = new_ast_expr_name((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 858: /* fetch_call_stmt: FETCH name opt_column_spec FROM call_stmt  */
                                             {
    YY_ERROR_ON_COLUMNS((yyvsp[-2].aval));  // not really allowed, see macro for details.
    (yyval.aval) = new_ast_fetch_call_stmt((yyvsp[-3].aval), (yyvsp[0].aval)); }
    break;

  case 859: /* close_stmt: CLOSE name  */
              { (yyval.aval) = new_ast_close_stmt((yyvsp[0].aval)); }
    break;

  case 860: /* out_stmt: OUT name  */
            { (yyval.aval) = new_ast_out_stmt((yyvsp[0].aval)); }
    break;

  case 861: /* out_union_stmt: OUT UNION name  */
                  { (yyval.aval) = new_ast_out_union_stmt((yyvsp[0].aval)); }
    break;

  case 862: /* out_union_parent_child_stmt: OUT UNION call_stmt JOIN child_results  */
                                         { (yyval.aval) = new_ast_out_union_parent_child_stmt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 863: /* child_results: child_result  */
                { (yyval.aval) = new_ast_child_results((yyvsp[0].aval), NULL); }
    break;

  case 864: /* child_results: child_result AND child_results  */
                                          { (yyval.aval) = new_ast_child_results((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 865: /* child_result: call_stmt USING '(' name_list ')'  */
                                    { (yyval.aval) = new_ast_child_result((yyvsp[-4].aval), new_ast_named_result(NULL, (yyvsp[-1].aval))); }
    break;

  case 866: /* child_result: call_stmt USING '(' name_list ')' AS name  */
                                              { (yyval.aval) = new_ast_child_result((yyvsp[-6].aval), new_ast_named_result((yyvsp[0].aval), (yyvsp[-3].aval))); }
    break;

  case 869: /* if_stmt: IF expr THEN opt_stmt_list opt_elseif_list opt_else if_ending  */
                                                                {
    struct ast_node *if_alt = new_ast_if_alt((yyvsp[-2].aval), (yyvsp[-1].aval));
    struct ast_node *cond_action = new_ast_cond_action((yyvsp[-5].aval), (yyvsp[-3].aval));
    (yyval.aval) = new_ast_if_stmt(cond_action, if_alt); }
    break;

  case 870: /* opt_else: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 871: /* opt_else: ELSE opt_stmt_list  */
                        { (yyval.aval) = new_ast_else((yyvsp[0].aval)); }
    break;

  case 872: /* elseif_item: ELSE_IF expr THEN opt_stmt_list  */
                                   {
    struct ast_node *cond_action = new_ast_cond_action((yyvsp[-2].aval), (yyvsp[0].aval));
    (yyval.aval) = new_ast_elseif(cond_action, NULL); }
    break;

  case 873: /* elseif_list: elseif_item  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 874: /* elseif_list: elseif_item elseif_list  */
                                  { ast_set_right((yyvsp[-1].aval), (yyvsp[0].aval)); (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 875: /* opt_elseif_list: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 876: /* opt_elseif_list: elseif_list  */
                 { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 877: /* control_stmt: commit_return_stmt  */
                      { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 878: /* control_stmt: continue_stmt  */
                   { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 879: /* control_stmt: leave_stmt  */
                { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 880: /* control_stmt: return_stmt  */
                 { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 881: /* control_stmt: rollback_return_stmt  */
                          { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 882: /* control_stmt: throw_stmt  */
                { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 883: /* guard_stmt: IF expr control_stmt  */
                        { (yyval.aval) = new_ast_guard_stmt((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 884: /* transaction_mode: %empty  */
            { (yyval.ival) = TRANS_DEFERRED; }
    break;

  case 885: /* transaction_mode: DEFERRED  */
             { (yyval.ival) = TRANS_DEFERRED; }
    break;

  case 886: /* transaction_mode: IMMEDIATE  */
              { (yyval.ival) = TRANS_IMMEDIATE; }
    break;

  case 887: /* transaction_mode: EXCLUSIVE  */
              { (yyval.ival) = TRANS_EXCLUSIVE; }
    break;

  case 888: /* begin_trans_stmt: BEGIN_ transaction_mode TRANSACTION  */
                                      { (yyval.aval) = new_ast_begin_trans_stmt(new_ast_option((yyvsp[-1].ival))); }
    break;

  case 889: /* begin_trans_stmt: BEGIN_ transaction_mode  */
                            { (yyval.aval) = new_ast_begin_trans_stmt(new_ast_option((yyvsp[0].ival))); }
    break;

  case 890: /* rollback_trans_stmt: ROLLBACK  */
            {
      (yyval.aval) = new_ast_rollback_trans_stmt(NULL); }
    break;

  case 891: /* rollback_trans_stmt: ROLLBACK TRANSACTION  */
                          {
      (yyval.aval) = new_ast_rollback_trans_stmt(NULL); }
    break;

  case 892: /* rollback_trans_stmt: ROLLBACK TO savepoint_name  */
                                {
      (yyval.aval) = new_ast_rollback_trans_stmt((yyvsp[0].aval)); }
    break;

  case 893: /* rollback_trans_stmt: ROLLBACK TRANSACTION TO savepoint_name  */
                                            {
      (yyval.aval) = new_ast_rollback_trans_stmt((yyvsp[0].aval)); }
    break;

  case 894: /* rollback_trans_stmt: ROLLBACK TO SAVEPOINT savepoint_name  */
                                          {
      (yyval.aval) = new_ast_rollback_trans_stmt((yyvsp[0].aval)); }
    break;

  case 895: /* rollback_trans_stmt: ROLLBACK TRANSACTION TO SAVEPOINT savepoint_name  */
                                                      {
      (yyval.aval) = new_ast_rollback_trans_stmt((yyvsp[0].aval)); }
    break;

  case 896: /* commit_trans_stmt: COMMIT TRANSACTION  */
                      { (yyval.aval) = new_ast_commit_trans_stmt(); }
    break;

  case 897: /* commit_trans_stmt: COMMIT  */
           { (yyval.aval) = new_ast_commit_trans_stmt(); }
    break;

  case 898: /* proc_savepoint_stmt: procedure SAVEPOINT BEGIN_ opt_stmt_list END  */
                                                                   {
    (yyval.aval) = new_ast_proc_savepoint_stmt((yyvsp[-1].aval));
  }
    break;

  case 899: /* savepoint_name: AT_PROC  */
          { (yyval.aval) = new_ast_str("@PROC"); }
    break;

  case 900: /* savepoint_name: name  */
         { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 901: /* savepoint_stmt: SAVEPOINT savepoint_name  */
                            {
    (yyval.aval) = new_ast_savepoint_stmt((yyvsp[0].aval)); }
    break;

  case 902: /* release_savepoint_stmt: RELEASE savepoint_name  */
                          {
    (yyval.aval) = new_ast_release_savepoint_stmt((yyvsp[0].aval)); }
    break;

  case 903: /* release_savepoint_stmt: RELEASE SAVEPOINT savepoint_name  */
                                      {
    (yyval.aval) = new_ast_release_savepoint_stmt((yyvsp[0].aval)); }
    break;

  case 904: /* echo_stmt: AT_ECHO name ',' str_literal  */
                                { (yyval.aval) = new_ast_echo_stmt((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 905: /* echo_stmt: AT_ECHO name ',' AT_TEXT '(' text_args ')'  */
                                               { (yyval.aval) = new_ast_echo_stmt((yyvsp[-5].aval), new_ast_macro_text((yyvsp[-1].aval))); }
    break;

  case 906: /* alter_table_add_column_stmt: ALTER TABLE sql_name ADD COLUMN col_def  */
                                           {
    (yyval.aval) = new_ast_alter_table_add_column_stmt((yyvsp[-3].aval), (yyvsp[0].aval)); }
    break;

  case 907: /* create_trigger_stmt: CREATE opt_temp TRIGGER opt_if_not_exists trigger_def opt_delete_version_attr  */
                                                                                 {
    int flags = (yyvsp[-4].ival) | (yyvsp[-2].ival);
    (yyval.aval) = new_ast_create_trigger_stmt(
        new_ast_option(flags),
        new_ast_trigger_body_vers((yyvsp[-1].aval), (yyvsp[0].aval))); }
    break;

  case 908: /* trigger_def: sql_name trigger_condition trigger_operation ON sql_name trigger_action  */
                                                                                   {
  (yyval.aval) = new_ast_trigger_def(
        (yyvsp[-5].aval),
        new_ast_trigger_condition(
          new_ast_option((yyvsp[-4].ival)),
          new_ast_trigger_op_target(
            (yyvsp[-3].aval),
            new_ast_trigger_target_action(
              (yyvsp[-1].aval),
              (yyvsp[0].aval))))); }
    break;

  case 909: /* trigger_condition: %empty  */
             { (yyval.ival) = TRIGGER_BEFORE; /* before is the default per https://sqlite.org/lang_createtrigger.html */ }
    break;

  case 910: /* trigger_condition: BEFORE  */
            { (yyval.ival) = TRIGGER_BEFORE; }
    break;

  case 911: /* trigger_condition: AFTER  */
           { (yyval.ival) = TRIGGER_AFTER; }
    break;

  case 912: /* trigger_condition: INSTEAD OF  */
                { (yyval.ival) = TRIGGER_INSTEAD_OF; }
    break;

  case 913: /* trigger_operation: DELETE  */
          { (yyval.aval) = new_ast_trigger_operation(new_ast_option(TRIGGER_DELETE), NULL); }
    break;

  case 914: /* trigger_operation: INSERT  */
            { (yyval.aval) = new_ast_trigger_operation(new_ast_option(TRIGGER_INSERT), NULL); }
    break;

  case 915: /* trigger_operation: UPDATE opt_of  */
                   { (yyval.aval) = new_ast_trigger_operation(new_ast_option(TRIGGER_UPDATE), (yyvsp[0].aval)); }
    break;

  case 916: /* opt_of: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 917: /* opt_of: OF name_list  */
                  { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 918: /* trigger_action: opt_foreachrow opt_when_expr BEGIN_ trigger_stmts END  */
                                                         {
  (yyval.aval) = new_ast_trigger_action(
        new_ast_option((yyvsp[-4].ival)),
        new_ast_trigger_when_stmts((yyvsp[-3].aval), (yyvsp[-1].aval))); }
    break;

  case 919: /* opt_foreachrow: %empty  */
             { (yyval.ival) = 0; }
    break;

  case 920: /* opt_foreachrow: FOR_EACH_ROW  */
                  { (yyval.ival) = TRIGGER_FOR_EACH_ROW; }
    break;

  case 921: /* opt_when_expr: %empty  */
             { (yyval.aval) = NULL; }
    break;

  case 922: /* opt_when_expr: WHEN expr  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 923: /* trigger_stmts: trigger_stmt  */
                { (yyval.aval) = new_ast_stmt_list((yyvsp[0].aval), NULL); }
    break;

  case 924: /* trigger_stmts: trigger_stmt trigger_stmts  */
                                     { (yyval.aval) = new_ast_stmt_list((yyvsp[-1].aval), (yyvsp[0].aval)); }
    break;

  case 925: /* trigger_stmt: trigger_update_stmt ';'  */
                           { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 926: /* trigger_stmt: trigger_insert_stmt ';'  */
                             { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 927: /* trigger_stmt: trigger_delete_stmt ';'  */
                             { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 928: /* trigger_stmt: trigger_select_stmt ';'  */
                             { (yyval.aval) = (yyvsp[-1].aval); }
    break;

  case 929: /* trigger_select_stmt: select_stmt_no_with  */
                       { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 930: /* trigger_insert_stmt: insert_stmt  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 931: /* trigger_delete_stmt: delete_stmt  */
               { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 932: /* trigger_update_stmt: basic_update_stmt  */
                     { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 933: /* enforcement_options: FOREIGN KEY ON UPDATE  */
                         { (yyval.aval) = new_ast_option(ENFORCE_FK_ON_UPDATE); }
    break;

  case 934: /* enforcement_options: FOREIGN KEY ON DELETE  */
                           { (yyval.aval) = new_ast_option(ENFORCE_FK_ON_DELETE); }
    break;

  case 935: /* enforcement_options: JOIN  */
          { (yyval.aval) = new_ast_option(ENFORCE_STRICT_JOIN); }
    break;

  case 936: /* enforcement_options: UPSERT STATEMENT  */
                      { (yyval.aval) = new_ast_option(ENFORCE_UPSERT_STMT); }
    break;

  case 937: /* enforcement_options: WINDOW function  */
                     { (yyval.aval) = new_ast_option(ENFORCE_WINDOW_FUNC); }
    break;

  case 938: /* enforcement_options: WITHOUT ROWID  */
                   { (yyval.aval) = new_ast_option(ENFORCE_WITHOUT_ROWID); }
    break;

  case 939: /* enforcement_options: TRANSACTION  */
                { (yyval.aval) = new_ast_option(ENFORCE_TRANSACTION); }
    break;

  case 940: /* enforcement_options: SELECT IF NOTHING  */
                      { (yyval.aval) = new_ast_option(ENFORCE_SELECT_IF_NOTHING); }
    break;

  case 941: /* enforcement_options: INSERT SELECT  */
                  { (yyval.aval) = new_ast_option(ENFORCE_INSERT_SELECT); }
    break;

  case 942: /* enforcement_options: TABLE FUNCTION  */
                   { (yyval.aval) = new_ast_option(ENFORCE_TABLE_FUNCTION); }
    break;

  case 943: /* enforcement_options: IS_TRUE  */
            { (yyval.aval) = new_ast_option(ENFORCE_IS_TRUE); }
    break;

  case 944: /* enforcement_options: CAST  */
         { (yyval.aval) = new_ast_option(ENFORCE_CAST); }
    break;

  case 945: /* enforcement_options: SIGN_FUNCTION  */
                  { (yyval.aval) = new_ast_option(ENFORCE_SIGN_FUNCTION); }
    break;

  case 946: /* enforcement_options: CURSOR_HAS_ROW  */
                   { (yyval.aval) = new_ast_option(ENFORCE_CURSOR_HAS_ROW); }
    break;

  case 947: /* enforcement_options: UPDATE FROM  */
                { (yyval.aval) = new_ast_option(ENFORCE_UPDATE_FROM); }
    break;

  case 948: /* enforcement_options: AND OR NOT "NULL" CHECK  */
                           { (yyval.aval) = new_ast_option(ENFORCE_AND_OR_NOT_NULL_CHECK); }
    break;

  case 949: /* enforce_strict_stmt: AT_ENFORCE_STRICT enforcement_options  */
                                         { (yyval.aval) = new_ast_enforce_strict_stmt((yyvsp[0].aval)); }
    break;

  case 950: /* enforce_normal_stmt: AT_ENFORCE_NORMAL enforcement_options  */
                                         { (yyval.aval) = new_ast_enforce_normal_stmt((yyvsp[0].aval)); }
    break;

  case 951: /* enforce_reset_stmt: AT_ENFORCE_RESET  */
                   { (yyval.aval) = new_ast_enforce_reset_stmt(); }
    break;

  case 952: /* enforce_push_stmt: AT_ENFORCE_PUSH  */
                  { (yyval.aval) = new_ast_enforce_push_stmt(); }
    break;

  case 953: /* enforce_pop_stmt: AT_ENFORCE_POP  */
                 { (yyval.aval) = new_ast_enforce_pop_stmt(); }
    break;

  case 954: /* keep_table_name_in_aliases_stmt: AT_KEEP_TABLE_NAME_IN_ALIASES  */
                                { (yyval.aval) = new_ast_keep_table_name_in_aliases_stmt(); }
    break;

  case 955: /* expr_macro_def: AT_MACRO '(' EXPR ')' name '!' '(' opt_macro_formals ')'  */
                                                           {
    CSTR bad_name = install_macro_args((yyvsp[-1].aval));
    YY_ERROR_ON_FAILED_MACRO_ARG(bad_name);
    (yyval.aval) = new_ast_expr_macro_def(new_ast_macro_name_formals((yyvsp[-4].aval), (yyvsp[-1].aval)), NULL);
    if (is_processing()) {
      EXTRACT_STRING(name, (yyvsp[-4].aval));
      bool_t success = set_macro_info(name, EXPR_MACRO, (yyval.aval));
      YY_ERROR_ON_FAILED_ADD_MACRO(success, name);
    } }
    break;

  case 956: /* stmt_list_macro_def: AT_MACRO '(' STMT_LIST ')' name '!' '(' opt_macro_formals ')'  */
                                                                {
    CSTR bad_name = install_macro_args((yyvsp[-1].aval));
    YY_ERROR_ON_FAILED_MACRO_ARG(bad_name);
    (yyval.aval) = new_ast_stmt_list_macro_def(new_ast_macro_name_formals((yyvsp[-4].aval), (yyvsp[-1].aval)), NULL);
    if (is_processing()) {
      EXTRACT_STRING(name, (yyvsp[-4].aval));
      bool_t success = set_macro_info(name, STMT_LIST_MACRO, (yyval.aval));
      YY_ERROR_ON_FAILED_ADD_MACRO(success, name);
    } }
    break;

  case 957: /* query_parts_macro_def: AT_MACRO '(' QUERY_PARTS ')' name '!' '(' opt_macro_formals ')'  */
                                                                  {
    CSTR bad_name = install_macro_args((yyvsp[-1].aval));
    YY_ERROR_ON_FAILED_MACRO_ARG(bad_name);
    (yyval.aval) = new_ast_query_parts_macro_def(new_ast_macro_name_formals((yyvsp[-4].aval), (yyvsp[-1].aval)), NULL);
    if (is_processing()) {
      EXTRACT_STRING(name, (yyvsp[-4].aval));
      bool_t success = set_macro_info(name, QUERY_PARTS_MACRO, (yyval.aval));
      YY_ERROR_ON_FAILED_ADD_MACRO(success, name);
    } }
    break;

  case 958: /* cte_tables_macro_def: AT_MACRO '(' CTE_TABLES ')' name '!' '(' opt_macro_formals ')'  */
                                                                 {
    CSTR bad_name = install_macro_args((yyvsp[-1].aval));
    YY_ERROR_ON_FAILED_MACRO_ARG(bad_name);
    (yyval.aval) = new_ast_cte_tables_macro_def(new_ast_macro_name_formals((yyvsp[-4].aval), (yyvsp[-1].aval)), NULL);
    if (is_processing()) {
      EXTRACT_STRING(name, (yyvsp[-4].aval));
      bool_t success = set_macro_info(name, CTE_TABLES_MACRO, (yyval.aval));
      YY_ERROR_ON_FAILED_ADD_MACRO(success, name);
    } }
    break;

  case 959: /* select_core_macro_def: AT_MACRO '(' SELECT_CORE ')' name '!' '(' opt_macro_formals ')'  */
                                                                  {
    CSTR bad_name = install_macro_args((yyvsp[-1].aval));
    YY_ERROR_ON_FAILED_MACRO_ARG(bad_name);
    (yyval.aval) = new_ast_select_core_macro_def(new_ast_macro_name_formals((yyvsp[-4].aval), (yyvsp[-1].aval)), NULL);
    if (is_processing()) {
      EXTRACT_STRING(name, (yyvsp[-4].aval));
      bool_t success = set_macro_info(name, SELECT_CORE_MACRO, (yyval.aval));
      YY_ERROR_ON_FAILED_ADD_MACRO(success, name);
    } }
    break;

  case 960: /* select_expr_macro_def: AT_MACRO '(' SELECT_EXPR ')' name '!' '(' opt_macro_formals ')'  */
                                                                  {
    CSTR bad_name = install_macro_args((yyvsp[-1].aval));
    YY_ERROR_ON_FAILED_MACRO_ARG(bad_name);
    (yyval.aval) = new_ast_select_expr_macro_def(new_ast_macro_name_formals((yyvsp[-4].aval), (yyvsp[-1].aval)), NULL);
    if (is_processing()) {
      EXTRACT_STRING(name, (yyvsp[-4].aval));
      bool_t success = set_macro_info(name, SELECT_EXPR_MACRO, (yyval.aval));
      YY_ERROR_ON_FAILED_ADD_MACRO(success, name);
    } }
    break;

  case 961: /* op_stmt: AT_OP data_type_any ':' loose_name loose_name_or_type AS loose_name  */
                                                                                             {
    (yyval.aval) = new_ast_op_stmt((yyvsp[-5].aval), new_ast_op_vals((yyvsp[-3].aval), new_ast_op_vals((yyvsp[-2].aval), (yyvsp[0].aval)))); }
    break;

  case 962: /* op_stmt: AT_OP CURSOR ':' loose_name loose_name_or_type AS loose_name  */
                                                                                 {
    (yyval.aval) = new_ast_op_stmt(new_ast_str("CURSOR"), new_ast_op_vals((yyvsp[-3].aval), new_ast_op_vals((yyvsp[-2].aval), (yyvsp[0].aval)))); }
    break;

  case 963: /* op_stmt: AT_OP "NULL" ':' loose_name loose_name_or_type AS loose_name  */
                                                                                {
    (yyval.aval) = new_ast_op_stmt(new_ast_str("NULL"), new_ast_op_vals((yyvsp[-3].aval), new_ast_op_vals((yyvsp[-2].aval), (yyvsp[0].aval)))); }
    break;

  case 964: /* ifdef: AT_IFDEF name  */
                     { (yyval.aval) = do_ifdef((yyvsp[0].aval)); }
    break;

  case 965: /* ifndef: AT_IFNDEF name  */
                       { (yyval.aval) = do_ifndef((yyvsp[0].aval)); }
    break;

  case 966: /* elsedef: AT_ELSE  */
                 { (yyval.sval) = "else"; do_else(); }
    break;

  case 967: /* endif: AT_ENDIF  */
                { (yyval.sval) = "endif"; do_endif(); }
    break;

  case 968: /* ifdef_stmt: ifdef opt_stmt_list elsedef opt_stmt_list endif  */
                                                                {
      (yyval.aval) = new_ast_ifdef_stmt((yyvsp[-4].aval), new_ast_pre((yyvsp[-3].aval), (yyvsp[-1].aval))); }
    break;

  case 969: /* ifdef_stmt: ifdef opt_stmt_list endif  */
                                    {
      (yyval.aval) = new_ast_ifdef_stmt((yyvsp[-2].aval), new_ast_pre((yyvsp[-1].aval), NULL)); }
    break;

  case 970: /* ifndef_stmt: ifndef opt_stmt_list elsedef opt_stmt_list endif  */
                                                                 {
      (yyval.aval) = new_ast_ifndef_stmt((yyvsp[-4].aval), new_ast_pre((yyvsp[-3].aval), (yyvsp[-1].aval))); }
    break;

  case 971: /* ifndef_stmt: ifndef opt_stmt_list endif  */
                                     {
      (yyval.aval) = new_ast_ifndef_stmt((yyvsp[-2].aval), new_ast_pre((yyvsp[-1].aval), NULL)); }
    break;

  case 972: /* macro_def_stmt: expr_macro_def BEGIN_ expr END  */
                                 {
     (yyval.aval) = (yyvsp[-3].aval);
     ast_set_right((yyval.aval), (yyvsp[-1].aval));
     delete_macro_formals(); }
    break;

  case 973: /* macro_def_stmt: stmt_list_macro_def BEGIN_ stmt_list END  */
                                             {
     (yyval.aval) = (yyvsp[-3].aval);
     ast_set_right((yyval.aval), (yyvsp[-1].aval));
     delete_macro_formals(); }
    break;

  case 974: /* macro_def_stmt: query_parts_macro_def BEGIN_ query_parts END  */
                                                 {
     (yyval.aval) = (yyvsp[-3].aval);
     ast_set_right((yyval.aval), (yyvsp[-1].aval));
     delete_macro_formals(); }
    break;

  case 975: /* macro_def_stmt: cte_tables_macro_def BEGIN_ cte_tables END  */
                                               {
     (yyval.aval) = (yyvsp[-3].aval);
     ast_set_right((yyval.aval), (yyvsp[-1].aval));
     delete_macro_formals(); }
    break;

  case 976: /* macro_def_stmt: select_core_macro_def BEGIN_ select_core_list END  */
                                                      {
     (yyval.aval) = (yyvsp[-3].aval);
     ast_set_right((yyval.aval), (yyvsp[-1].aval));
     delete_macro_formals(); }
    break;

  case 977: /* macro_def_stmt: select_expr_macro_def BEGIN_ select_expr_list END  */
                                                      {
     (yyval.aval) = (yyvsp[-3].aval);
     ast_set_right((yyval.aval), (yyvsp[-1].aval));
     delete_macro_formals(); }
    break;

  case 978: /* opt_macro_args: %empty  */
              { (yyval.aval) = NULL; }
    break;

  case 979: /* opt_macro_args: macro_args  */
                { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 980: /* macro_arg: expr  */
           { (yyval.aval) = new_macro_arg_node((yyvsp[0].aval)); }
    break;

  case 981: /* macro_arg: BEGIN_ stmt_list END  */
                             { (yyval.aval) = new_ast_stmt_list_macro_arg((yyvsp[-1].aval)); }
    break;

  case 982: /* macro_arg: FROM '(' query_parts ')'  */
                                 { (yyval.aval) = new_ast_query_parts_macro_arg((yyvsp[-1].aval)); }
    break;

  case 983: /* macro_arg: WITH '(' cte_tables ')'  */
                                { (yyval.aval) = new_ast_cte_tables_macro_arg((yyvsp[-1].aval)); }
    break;

  case 984: /* macro_arg: ROWS '(' select_core_list ')'  */
                                      { (yyval.aval) = new_ast_select_core_macro_arg((yyvsp[-1].aval)); }
    break;

  case 985: /* macro_arg: SELECT '(' select_expr_list ')'  */
                                        { (yyval.aval) = new_ast_select_expr_macro_arg((yyvsp[-1].aval)); }
    break;

  case 986: /* macro_args: macro_arg  */
             { (yyval.aval) = new_ast_macro_args((yyvsp[0].aval), NULL); }
    break;

  case 987: /* macro_args: macro_arg ',' macro_args  */
                                   { (yyval.aval) = new_ast_macro_args((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 988: /* opt_macro_formals: %empty  */
              { (yyval.aval) = NULL; }
    break;

  case 989: /* opt_macro_formals: macro_formals  */
                   { (yyval.aval) = (yyvsp[0].aval); }
    break;

  case 990: /* macro_formals: macro_formal  */
                { (yyval.aval) = new_ast_macro_formals((yyvsp[0].aval), NULL); }
    break;

  case 991: /* macro_formals: macro_formal ',' macro_formals  */
                                         { (yyval.aval) = new_ast_macro_formals((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 992: /* macro_formal: name '!' macro_type  */
                                  { (yyval.aval) = new_ast_macro_formal((yyvsp[-2].aval), (yyvsp[0].aval)); }
    break;

  case 993: /* macro_type: EXPR  */
        { (yyval.aval) = new_ast_str("EXPR"); }
    break;

  case 994: /* macro_type: STMT_LIST  */
              { (yyval.aval) = new_ast_str("STMT_LIST"); }
    break;

  case 995: /* macro_type: QUERY_PARTS  */
                { (yyval.aval) = new_ast_str("QUERY_PARTS"); }
    break;

  case 996: /* macro_type: CTE_TABLES  */
               { (yyval.aval) = new_ast_str("CTE_TABLES"); }
    break;

  case 997: /* macro_type: SELECT_CORE  */
                { (yyval.aval) = new_ast_str("SELECT_CORE"); }
    break;

  case 998: /* macro_type: SELECT_EXPR  */
                { (yyval.aval) = new_ast_str("SELECT_EXPR"); }
    break;



      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */
  {
    const int yylhs = yyr1[yyn] - YYNTOKENS;
    const int yyi = yypgoto[yylhs] + *yyssp;
    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
               ? yytable[yyi]
               : yydefgoto[yylhs]);
  }

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
      {
        yypcontext_t yyctx
          = {yyssp, yytoken};
        char const *yymsgp = YY_("syntax error");
        int yysyntax_error_status;
        yysyntax_error_status = yysyntax_error (&yymsg_alloc, &yymsg, &yyctx);
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == -1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = YY_CAST (char *,
                             YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
            if (yymsg)
              {
                yysyntax_error_status
                  = yysyntax_error (&yymsg_alloc, &yymsg, &yyctx);
                yymsgp = yymsg;
              }
            else
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = YYENOMEM;
              }
          }
        yyerror (yymsgp);
        if (yysyntax_error_status == YYENOMEM)
          YYNOMEM;
      }
    }

  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct ("Error: discarding",
                      yytoken, &yylval);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:
  /* Pacify compilers when the user code never invokes YYERROR and the
     label yyerrorlab therefore never appears in user code.  */
  if (0)
    YYERROR;
  ++yynerrs;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  /* Pop stack until we find a state that shifts the error token.  */
  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYSYMBOL_YYerror;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct ("Error: popping",
                  YY_ACCESSING_SYMBOL (yystate), yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturnlab;


/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturnlab;


/*-----------------------------------------------------------.
| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
`-----------------------------------------------------------*/
yyexhaustedlab:
  yyerror (YY_("memory exhausted"));
  yyresult = 2;
  goto yyreturnlab;


/*----------------------------------------------------------.
| yyreturnlab -- parsing is finished, clean up and return.  |
`----------------------------------------------------------*/
yyreturnlab:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
  return yyresult;
}



#ifndef _MSC_VER
#pragma clang diagnostic pop
#endif

void yyerror(const char *format, ...) {
  extern int yylineno;
  va_list args;
  va_start(args, format);

  CHARBUF_OPEN(err);
  bprintf(&err, "%s:%d:1: error: ", current_file, yylineno);
  vbprintf(&err, format, args);
  bputc(&err, '\n');
  cql_emit_error(err.ptr);
  CHARBUF_CLOSE(err);
  va_end(args);

  parse_error_occurred = true;
  cql_exit_code = 2;
}

static int next_id = 0;

static void print_dot(struct ast_node *node) {
  assert(node);
  int id = next_id++;

  // we used to hard code the UTF8 for u23DA but that seems to not render consistently
  // so I switched to the codepoint 2307 "earth ground" which doesn't look as nice
  // but doesn't come out as hex-in-a-box on all my machines...
  static CSTR ground_symbol = "&#x2307;";

  // skip the builtin statements
  while (options.hide_builtins && is_ast_stmt_list(node)) {
    EXTRACT_STMT_AND_MISC_ATTRS(stmt, misc_attrs, node);

    if (!misc_attrs || !find_named_attr(misc_attrs, "builtin")) {
      break;
    }
    node = node->right;
  }

  bool_t primitive = true;

  if (is_ast_num(node)) {
    cql_output("\n    %s%u [label = \"%s\" shape=plaintext]", node->type, id, ((struct num_ast_node*)node)->value);
  }
  else if (is_ast_str(node)) {
    EXTRACT_STRING(str, node);
    if (is_id(node)) {
      // unescaped name, clean to emit
      cql_output("\n    %s%u [label = \"%s\" shape=plaintext]", node->type, id, str);
    }
    else {
      // we have to do this dance to from the encoded in SQL format string literal
      // to an escaped in C-style literal.  The dot output for \n should be the characters
      // \ and n not a newline so we need "\n" to become \"\\n\", hence double encode.
      CHARBUF_OPEN(plaintext);
      CHARBUF_OPEN(encoding);
      CHARBUF_OPEN(double_encoding);
      // the at rest format is SQL format, decode that first
      cg_decode_string_literal(str, &plaintext);
      // then double encode it
      cg_encode_c_string_literal(plaintext.ptr, &encoding);
      cg_encode_c_string_literal(encoding.ptr, &double_encoding);
      // ready to use!
      cql_output("\n    %s%u [label = %s shape=plaintext]", node->type, id, double_encoding.ptr);
      CHARBUF_CLOSE(double_encoding);
      CHARBUF_CLOSE(encoding);
      CHARBUF_CLOSE(plaintext);
    }
  }
  else {
    cql_output("\n    %s%u [label = \"%s\" shape=plaintext]", node->type, id, node->type);
    primitive = false;
  }

  if (primitive) {
    return;
  }

  if (!ast_has_left(node) && !ast_has_right(node)) {
    return;
  }

  if (ast_has_left(node)) {
    cql_output("\n    %s%u -> %s%u;", node->type, id, node->left->type, next_id);
    print_dot(node->left);
  }
  else {
    cql_output("\n    _%u [label = \"%s\" shape=plaintext]", id, ground_symbol);
    cql_output("\n    %s%u -> _%u;", node->type, id, id);
  }

  if (ast_has_right(node)) {
    cql_output("\n %s%u -> %s%u;", node->type, id, node->right->type, next_id);
    print_dot(node->right);
  }
  else {
    cql_output("\n    _%u [label = \"%s\" shape=plaintext]", id, ground_symbol);
    cql_output("\n    %s%u -> _%u;", node->type, id, id);
  }
}

cql_data_defn( cmd_options options );

cql_data_defn( const char *global_proc_name );

cql_data_defn( rtdata *rt );

static int32_t gather_arg_params(int32_t a, int32_t argc, char **argv, uint32_t *out_count, char ***out_args);

static int32_t gather_arg_param(int32_t a, int32_t argc, char **argv, char **out_arg, const char *errmsg);

static void parse_cmd(int argc, char **argv) {

  if (argc == 1) {
    cql_usage();
    cql_cleanup_and_exit(0);
  }

  // default result type
  options.rt = "c";
  rt = find_rtdata(options.rt);
  Invariant(rt);

  current_file = "<stdin>";

  // This code is generally not something you want on but it can be useful
  // if you are trying to diagnose a complex failure in a larger build and
  // you need to see what the executions were.  It can also be helpful if
  // you are using CQL in its amalgam form. Though, in that case, the
  // fprintf probably needs to be modified.

  // #define CQL_EXEC_TRACING 1
  #ifdef CQL_EXEC_TRACING

  CHARBUF_OPEN(args);
  bprintf(&args, "cql ");
  for (int32_t i = 1; i < argc; i++) {
    bprintf(&args, "%s%s", argv[i], i == argc - 1 ? "\n" : " ");
  }
  FILE *tr = fopen("/tmp/cqltrace.log", "a+");
  fprintf(tr, "%s", args.ptr);
  fclose(tr);
  CHARBUF_CLOSE(args);

  #endif

  for (int32_t a = 1; a < argc; a++) {
    char *arg = argv[a];
    if (strcmp(arg, "--echo") == 0) {
      options.echo_input = 1;
    }
    else if (strcmp(arg, "--ast") == 0) {
      options.print_ast = 1;
    }
    else if (strcmp(arg, "--ast_no_echo") == 0) {
      options.print_ast = 1;
      options.ast_no_echo = 1;
    }
    else if (strcmp(arg, "--nolines") == 0) {
      options.nolines = 1;
    }
    else if (strcmp(arg, "--hide_builtins") == 0) {
      options.hide_builtins = 1;
    }
    else if (strcmp(arg, "--schema_exclusive") == 0) {
      options.schema_exclusive = 1;
    }
    else if (strcmp(arg, "--dot") == 0) {
      options.print_dot = 1;
    }
    else if (strcmp(arg, "--exp") == 0) {
      options.expand = 1;
    }
    else if (strcmp(arg, "--sem") == 0) {
      options.expand = 1;
      options.semantic = 1;
    }
    else if (strcmp(arg, "--compress") == 0) {
      options.compress = 1;
    }
    else if (strcmp(arg, "--run_unit_tests") == 0) {
      options.run_unit_tests = 1;
    }
    else if (strcmp(arg, "--generate_exports") == 0) {
      options.generate_exports = 1;
    }
    else if (strcmp(arg, "--cg") == 0) {
      a = gather_arg_params(a, argc, argv, &options.file_names_count, &options.file_names);
      options.codegen = 1;
      options.semantic = 1;
      options.expand = 1;
    }
    else if (strcmp(arg, "--include_paths") == 0) {
      a = gather_arg_params(a, argc, argv, &options.include_paths_count, &options.include_paths);
    }
    else if (strcmp(arg, "--defines") == 0) {
      a = gather_arg_params(a, argc, argv, &options.defines_count, &options.defines);
    }
    else if (strcmp(arg, "--include_regions") == 0) {
      a = gather_arg_params(a, argc, argv, &options.include_regions_count, &options.include_regions);
    }
    else if (strcmp(arg, "--exclude_regions") == 0) {
      a = gather_arg_params(a, argc, argv, &options.exclude_regions_count, &options.exclude_regions);
    }
    else if (strcmp(arg, "--cqlrt") == 0) {
      a = gather_arg_param(a, argc, argv, &options.cqlrt, "for the name of the runtime header");
    }
    else if (strcmp(arg, "--rt") == 0) {
      a = gather_arg_param(a, argc, argv, &options.rt, "(e.g., c, lua, json_schema)");
      rt = find_rtdata(options.rt);
      if (!rt) {
        cql_error("unknown cg runtime '%s'\n", options.rt);
        cql_cleanup_and_exit(1);
      }
    }
    else if (strcmp(arg, "--test") == 0) {
      options.test = 1;
    }
    else if (strcmp(arg, "--dev") == 0) {
      options.dev = 1;
    }
    else if (strcmp(arg, "--in") == 0) {
      a = gather_arg_param(a, argc, argv, NULL, "for the file name");
      FILE *f = fopen(argv[a], "r");
      if (!f) {
        cql_error("unable to open '%s' for read\n", argv[a]);
        cql_cleanup_and_exit(1);
      }
      yyset_in(f);
      // reset the scanner to point to the newly input file (yyset_in(f)). Otherwise the scanner
      // might continue to point to the input file from the previous run in case there are still
      // a stream to read.
      // Usually when the parser encouter a syntax error, it stops reading the input file.
      // On the next run the scanner will want to continue and finish from where it stops
      // before moving to the file of the current run.
      // Therefore it's important to always do this because we're in a new run and should ignore
      // previous run because a result were already produced for that prevous run.
      yyrestart(f);

      current_file = argv[a];
    }
    else if (strcmp(arg, "--min_schema_version") == 0) {
      a = gather_arg_param(a, argc, argv, NULL, "for the minimum schema version");
      options.min_schema_version = atoi(argv[a]);
    }
    else if (strcmp(arg, "--global_proc") == 0) {
      a = gather_arg_param(a, argc, argv, NULL,  "for the global proc name");
      global_proc_name = argv[a];
    }
    else if (strcmp(arg, "--c_include_path") == 0) {
      a = gather_arg_param(a, argc, argv, &options.c_include_path, "for the include path of a C header");
    }
    else if (strcmp(arg, "--c_include_namespace") == 0) {
      a = gather_arg_param(a, argc, argv, &options.c_include_namespace, "for the C include namespace");
    }
    else {
      cql_error("unknown arg '%s'\n", argv[a]);
      cql_cleanup_and_exit(1);
    }
  }

  if (options.codegen && options.rt && (rt->required_file_names_count != options.file_names_count && rt->required_file_names_count != -1)) {
    fprintf(stderr,
            "--rt %s requires %" PRId32 " files for --cg, but received %" PRId32 "\n",
            options.rt,
            rt->required_file_names_count,
            options.file_names_count);
    cql_cleanup_and_exit(1);
  }

  if (options.cqlrt) {
    rt->cqlrt = options.cqlrt;
  }
}

#ifndef CQL_IS_NOT_MAIN
  // Normally CQL is the main entry point.  If you are using CQL in an embedded fashion
  // then you want to invoke its main at some other time. If you define CQL_IS_NOT_MAIN
  // then cql_main is not renamed to main.  You call cql_main when you want.
  #define cql_main main
#endif

cql_noexport CSTR cql_builtin_text() {
  return
    "@@begin_include@@"
    "[[builtin]]"
    "declare func cql_partition_create () CREATE OBJECT<partitioning>!;"
    "[[builtin]]"
    "declare func cql_partition_cursor (p OBJECT<partitioning>!, key CURSOR, value CURSOR) BOOL!;"
    "[[builtin]]"
    "declare func cql_extract_partition (p OBJECT<partitioning>!, key CURSOR) CREATE OBJECT!;"

    "[[builtin]]"
    "declare func cql_string_dictionary_create() CREATE OBJECT<cql_string_dictionary>!;"
    "[[builtin]]"
    "declare func cql_string_dictionary_add(dict OBJECT<cql_string_dictionary>!, key text!, value text!) BOOL!;"
    "[[builtin]]"
    "declare func cql_string_dictionary_find(dict OBJECT<cql_string_dictionary>!, key text) text;"

    "[[builtin]]"
    "@op object<cql_string_dictionary> : call add as cql_string_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_string_dictionary> : call find as cql_string_dictionary_find;"
    "[[builtin]]"
    "@op object<cql_string_dictionary> : array set as cql_string_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_string_dictionary> : array get as cql_string_dictionary_find;"

    "[[builtin]]"
    "declare func cql_long_dictionary_create() CREATE OBJECT<cql_long_dictionary>!;"
    "[[builtin]]"
    "declare func cql_long_dictionary_add(dict OBJECT<cql_long_dictionary>!, key text!, value long!) BOOL!;"
    "[[builtin]]"
    "declare func cql_long_dictionary_find(dict OBJECT<cql_long_dictionary>!, key text) long;"

    "[[builtin]]"
    "@op object<cql_long_dictionary> : call add as cql_long_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_long_dictionary> : call find as cql_long_dictionary_find;"
    "[[builtin]]"
    "@op object<cql_long_dictionary> : array set as cql_long_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_long_dictionary> : array get as cql_long_dictionary_find;"


    "[[builtin]]"
    "declare func cql_real_dictionary_create() CREATE OBJECT<cql_real_dictionary>!;"
    "[[builtin]]"
    "declare func cql_real_dictionary_add(dict OBJECT<cql_real_dictionary>!, key text!, value real!) BOOL!;"
    "[[builtin]]"
    "declare func cql_real_dictionary_find(dict OBJECT<cql_real_dictionary>!, key text) real;"

    "[[builtin]]"
    "@op object<cql_real_dictionary> : call add as cql_real_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_real_dictionary> : call find as cql_real_dictionary_find;"
    "[[builtin]]"
    "@op object<cql_real_dictionary> : array set as cql_real_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_real_dictionary> : array get as cql_real_dictionary_find;"

    "[[builtin]]"
    "declare func cql_object_dictionary_create() CREATE OBJECT<cql_object_dictionary>!;"
    "[[builtin]]"
    "declare func cql_object_dictionary_add(dict OBJECT<cql_object_dictionary>!, key text!, value OBJECT!) BOOL!;"
    "[[builtin]]"
    "declare func cql_object_dictionary_find(dict OBJECT<cql_object_dictionary>!, key text) OBJECT;"

    "[[builtin]]"
    "@op object<cql_object_dictionary> : call add as cql_object_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_object_dictionary> : call find as cql_object_dictionary_find;"
    "[[builtin]]"
    "@op object<cql_object_dictionary> : array set as cql_object_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_object_dictionary> : array get as cql_object_dictionary_find;"

    "[[builtin]]"
    "declare func cql_blob_dictionary_create() CREATE OBJECT<cql_blob_dictionary>!;"
    "[[builtin]]"
    "declare func cql_blob_dictionary_add(dict OBJECT<cql_blob_dictionary>!, key text!, value blob!) BOOL!;"
    "[[builtin]]"
    "declare func cql_blob_dictionary_find(dict OBJECT<cql_blob_dictionary>!, key text) blob;"

    "[[builtin]]"
    "@op object<cql_blob_dictionary> : call add as cql_blob_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_blob_dictionary> : call find as cql_blob_dictionary_find;"
    "[[builtin]]"
    "@op object<cql_blob_dictionary> : array set as cql_blob_dictionary_add;"
    "[[builtin]]"
    "@op object<cql_blob_dictionary> : array get as cql_blob_dictionary_find;"

    "[[builtin]]"
    "declare func cql_cursor_format(C cursor) create text!;"
    "[[builtin]]"
    "declare func cql_cursor_hash(C cursor) long!;"
    "[[builtin]]"
    "declare func cql_cursors_equal(l cursor, r cursor) bool!;"
    "[[builtin]]"
    "declare func cql_cursor_diff_index(l cursor, r cursor) int!;"
    "[[builtin]]"
    "declare func cql_cursor_diff_col(l cursor, r cursor) create text;"
    "[[builtin]]"
    "declare func cql_cursor_diff_val(l cursor, r cursor) create text;"

    "[[builtin]]"
    "declare func cql_box_int(x int) create object<cql_box>!;"
    "[[builtin]]"
    "declare func cql_unbox_int(box object<cql_box>) int;"
    "[[builtin]]"
    "declare func cql_box_real(x real) create object<cql_box>!;"
    "[[builtin]]"
    "declare func cql_unbox_real(box object<cql_box>) real;"
    "[[builtin]]"
    "declare func cql_box_bool(x bool) create object<cql_box>!;"
    "[[builtin]]"
    "declare func cql_unbox_bool(box object<cql_box>) bool;"
    "[[builtin]]"
    "declare func cql_box_long(x long) create object<cql_box>!;"
    "[[builtin]]"
    "declare func cql_unbox_long(box object<cql_box>) long;"
    "[[builtin]]"
    "declare func cql_box_text(x text) create object<cql_box>!;"
    "[[builtin]]"
    "declare func cql_unbox_text(box object<cql_box>) text;"
    "[[builtin]]"
    "declare func cql_box_blob(x blob) create object<cql_box>!;"
    "[[builtin]]"
    "declare func cql_unbox_blob(box object<cql_box>) blob;"
    "[[builtin]]"
    "declare func cql_box_object(x object) create object<cql_box>!;"
    "[[builtin]]"
    "declare func cql_unbox_object(box object<cql_box>) object;"
    "[[builtin]]"
    "declare func cql_box_get_type(box object<cql_box>) int!;"

    "[[builtin]]"
    "@op bool : call box as cql_box_bool;"
    "[[builtin]]"
    "@op int : call box as cql_box_int;"
    "[[builtin]]"
    "@op long : call box as cql_box_long;"
    "[[builtin]]"
    "@op real : call box as cql_box_real;"
    "[[builtin]]"
    "@op text : call box as cql_box_text;"
    "[[builtin]]"
    "@op blob : call box as cql_box_blob;"
    "[[builtin]]"
    "@op object : call box as cql_box_object;"
    "[[builtin]]"
    "@op object<cql_box> : call to_bool as cql_unbox_bool;"
    "[[builtin]]"
    "@op object<cql_box> : call to_int as cql_unbox_int;"
    "[[builtin]]"
    "@op object<cql_box> : call to_long as cql_unbox_long;"
    "[[builtin]]"
    "@op object<cql_box> : call to_real as cql_unbox_real;"
    "[[builtin]]"
    "@op object<cql_box> : call to_text as cql_unbox_text;"
    "[[builtin]]"
    "@op object<cql_box> : call to_blob as cql_unbox_blob;"
    "[[builtin]]"
    "@op object<cql_box> : call to_object as cql_unbox_object;"
    "[[builtin]]"
    "@op object<cql_box> : call type as cql_box_get_type;"

    "[[builtin]]"
    "TYPE cql_string_list object<cql_string_list>;"
    "[[builtin]]"
    "declare func cql_string_list_create() create cql_string_list!;"
    "[[builtin]]"
    "declare func cql_string_list_set_at(list cql_string_list!, index_ int!, value_ text!) cql_string_list!;"
    "[[builtin]]"
    "declare func cql_string_list_get_at(list cql_string_list!, index_ int!) text;"
    "[[builtin]]"
    "declare func cql_string_list_count(list cql_string_list!) int!;"
    "[[builtin]]"
    "declare func cql_string_list_add(list cql_string_list!, string text!) cql_string_list!;"

    "[[builtin]]"
    "@op cql_string_list : array set as cql_string_list_set_at;"
    "[[builtin]]"
    "@op cql_string_list : array get as cql_string_list_get_at;"
    "[[builtin]]"
    "@op cql_string_list : call add as cql_string_list_add;"
    "[[builtin]]"
    "@op cql_string_list : get count as cql_string_list_count;"

    "[[builtin]]"
    "TYPE cql_blob_list object<cql_blob_list>;"
    "[[builtin]]"
    "declare func cql_blob_list_create() create cql_blob_list!;"
    "[[builtin]]"
    "declare func cql_blob_list_set_at(list cql_blob_list!, index_ int!, value_ blob!) cql_blob_list!;"
    "[[builtin]]"
    "declare func cql_blob_list_get_at(list cql_blob_list!, index_ int!) blob;"
    "[[builtin]]"
    "declare func cql_blob_list_count(list cql_blob_list!) int!;"
    "[[builtin]]"
    "declare func cql_blob_list_add(list cql_blob_list!, value blob!) cql_blob_list!;"

    "[[builtin]]"
    "@op cql_blob_list : array set as cql_blob_list_set_at;"
    "[[builtin]]"
    "@op cql_blob_list : array get as cql_blob_list_get_at;"
    "[[builtin]]"
    "@op cql_blob_list : call add as cql_blob_list_add;"
    "[[builtin]]"
    "@op cql_blob_list : get count as cql_blob_list_count;"

    "[[builtin]]"
    "TYPE cql_object_list object<cql_object_list>;"
    "[[builtin]]"
    "declare func cql_object_list_create() create cql_object_list!;"
    "[[builtin]]"
    "declare func cql_object_list_set_at(list cql_object_list!, index_ int!, value_ object!) cql_object_list!;"
    "[[builtin]]"
    "declare func cql_object_list_get_at(list cql_object_list!, index_ int!) object;"
    "[[builtin]]"
    "declare func cql_object_list_count(list cql_object_list!) int!;"
    "[[builtin]]"
    "declare func cql_object_list_add(list cql_object_list!, value object!) cql_object_list!;"

    "[[builtin]]"
    "@op cql_object_list : array set as cql_object_list_set_at;"
    "[[builtin]]"
    "@op cql_object_list : array get as cql_object_list_get_at;"
    "[[builtin]]"
    "@op cql_object_list : call add as cql_object_list_add;"
    "[[builtin]]"
    "@op cql_object_list : get count as cql_object_list_count;"

    "[[builtin]]"
    "TYPE cql_long_list object<cql_long_list>;"
    "[[builtin]]"
    "declare func cql_long_list_create() create cql_long_list!;"
    "[[builtin]]"
    "declare func cql_long_list_set_at(list cql_long_list!, index_ int!, value_ long!) cql_long_list!;"
    "[[builtin]]"
    "declare func cql_long_list_get_at(list cql_long_list!, index_ int!) long!;"
    "[[builtin]]"
    "declare func cql_long_list_count(list cql_long_list!) int!;"
    "[[builtin]]"
    "declare func cql_long_list_add(list cql_long_list!, value_ long!) cql_long_list!;"

    "[[builtin]]"
    "@op cql_long_list : array set as cql_long_list_set_at;"
    "[[builtin]]"
    "@op cql_long_list : array get as cql_long_list_get_at;"
    "[[builtin]]"
    "@op cql_long_list : call add as cql_long_list_add;"
    "[[builtin]]"
    "@op cql_long_list : get count as cql_long_list_count;"


     "[[builtin]]"
    "TYPE cql_real_list object<cql_real_list>;"
    "[[builtin]]"
    "declare func cql_real_list_create() create cql_real_list!;"
    "[[builtin]]"
    "declare func cql_real_list_set_at(list cql_real_list!, index_ int!, value_ real!) cql_real_list!;"
    "[[builtin]]"
    "declare func cql_real_list_get_at(list cql_real_list!, index_ int!) real!;"
    "[[builtin]]"
    "declare func cql_real_list_count(list cql_real_list!) int!;"
    "[[builtin]]"
    "declare func cql_real_list_add(list cql_real_list!, value_ real!) cql_real_list!;"

    "[[builtin]]"
    "@op cql_real_list : array set as cql_real_list_set_at;"
    "[[builtin]]"
    "@op cql_real_list : array get as cql_real_list_get_at;"
    "[[builtin]]"
    "@op cql_real_list : call add as cql_real_list_add;"
    "[[builtin]]"
    "@op cql_real_list : get count as cql_real_list_count;"

    "[[builtin]]"
    "declare func cql_cursor_column_count(C cursor) int!;"
    "[[builtin]]"
    "declare func cql_cursor_column_type(C cursor, icol int!) int!;"
    "[[builtin]]"
    "declare func cql_cursor_column_name(C cursor, icol int!) create text;"
    "[[builtin]]"
    "declare func cql_cursor_get_bool(C cursor, icol int!) bool;"
    "[[builtin]]"
    "declare func cql_cursor_get_int(C cursor, icol int!) int;"
    "[[builtin]]"
    "declare func cql_cursor_get_long(C cursor, icol int!) long;"
    "[[builtin]]"
    "declare func cql_cursor_get_real(C cursor, icol int!) real;"
    "[[builtin]]"
    "declare func cql_cursor_get_text(C cursor, icol int!) text;"
    "[[builtin]]"
    "declare func cql_cursor_get_blob(C cursor, icol int!) blob;"
    "[[builtin]]"
    "declare func cql_cursor_get_object(C cursor, icol int!) object;"
    "[[builtin]]"
    "declare func cql_cursor_format_column(C cursor, icol int!) create text!;"
    "[[builtin]]"
    "@op cursor : call format as cql_cursor_format;"
    "[[builtin]]"
    "@op cursor : call hash as cql_cursor_hash;"
    "[[builtin]]"
    "@op cursor : call diff_index as cql_cursor_diff_index;"
    "[[builtin]]"
    "@op cursor : call diff_col as cql_cursor_diff_col;"
    "[[builtin]]"
    "@op cursor : call diff_val as cql_cursor_diff_val;"
    "[[builtin]]"
    "@op cursor : call equals as cql_cursors_equal;"
    "[[builtin]]"
    "@op cursor : call count as cql_cursor_column_count;"
    "[[builtin]]"
    "@op cursor : call type as cql_cursor_column_type;"
    "[[builtin]]"
    "@op cursor : call name as cql_cursor_column_name;"
    "[[builtin]]"
    "@op cursor : call get_bool as cql_cursor_get_bool;"
    "[[builtin]]"
    "@op cursor : call get_int as cql_cursor_get_int;"
    "[[builtin]]"
    "@op cursor : call get_long as cql_cursor_get_long;"
    "[[builtin]]"
    "@op cursor : call get_real as cql_cursor_get_real;"
    "[[builtin]]"
    "@op cursor : call get_text as cql_cursor_get_text;"
    "[[builtin]]"
    "@op cursor : call get_blob as cql_cursor_get_blob;"
    "[[builtin]]"
    "@op cursor : call get_object as cql_cursor_get_object;"
    "[[builtin]]"
    "@op cursor : call format_col as cql_cursor_format_column;"

    "[[builtin]]"
    "declare proc cql_throw(code int!) using transaction;"

    "[[builtin]]"
    "type @ID('bool') bool;"
    "[[builtin]]"
    "type @ID('int') int;"
    "[[builtin]]"
    "type @ID('integer') int;"
    "[[builtin]]"
    "type @ID('long') long;"
    "[[builtin]]"
    "type @ID('real') real;"
    "[[builtin]]"
    "type @ID('text') text;"
    "[[builtin]]"
    "type @ID('object') object;"
    "[[builtin]]"
    "type @ID('blob') blob;"
    "[[builtin]]"
    "type @ID('long_int') long;"

    "[[builtin]]"
    "declare const group cql_data_types("
    "  CQL_DATA_TYPE_NULL      = 0,"
    "  CQL_DATA_TYPE_INT32     = 1,"
    "  CQL_DATA_TYPE_INT64     = 2,"
    "  CQL_DATA_TYPE_DOUBLE    = 3,"
    "  CQL_DATA_TYPE_BOOL      = 4,"
    "  CQL_DATA_TYPE_STRING    = 5,"
    "  CQL_DATA_TYPE_BLOB      = 6,"
    "  CQL_DATA_TYPE_OBJECT    = 7,"
    "  CQL_DATA_TYPE_CORE      = 0x3f,"
    "  CQL_DATA_TYPE_ENCODED   = 0x40,"
    "  CQL_DATA_TYPE_NOT_NULL  = 0x80"
    ");"

    "[[builtin]]"
    "declare proc cql_cursor_to_blob(C cursor, out result blob!) using transaction;"
    "[[builtin]]"
    "@op cursor: call to_blob as cql_cursor_to_blob;"

    "[[builtin]]"
    "declare proc cql_cursor_from_blob(C cursor, b blob) using transaction;"
    "[[builtin]]"
    "@op cursor: call from_blob as cql_cursor_from_blob;"

    "[[builtin]]"
    "declare function cql_blob_from_int(prefix text, val int!) create blob!;"

    "[[builtin]]"
    "declare function cql_format_bool(val bool @sensitive) create text!;"
    "[[builtin]]"
    "declare function cql_format_int(val int @sensitive) create text!;"
    "[[builtin]]"
    "declare function cql_format_long(val long @sensitive) create text!;"
    "[[builtin]]"
    "declare function cql_format_double(val real @sensitive) create text!;"
    "[[builtin]]"
    "declare function cql_format_string(val text @sensitive) create text!;"
    "[[builtin]]"
    "declare function cql_format_blob(val blob @sensitive) create text!;"
    "[[builtin]]"
    "declare function cql_format_object(val object @sensitive) create text!;"
    "[[builtin]]"
    "declare function cql_format_null(ignored bool @sensitive) create text!;"

    "[[builtin]]"
    "@op bool : call fmt as cql_format_bool;"
    "[[builtin]]"
    "@op int : call fmt as cql_format_int;"
    "[[builtin]]"
    "@op long : call fmt as cql_format_long;"
    "[[builtin]]"
    "@op real : call fmt as cql_format_double;"
    "[[builtin]]"
    "@op text : call fmt as cql_format_string;"
    "[[builtin]]"
    "@op blob : call fmt as cql_format_blob;"
    "[[builtin]]"
    "@op object : call fmt as cql_format_object;"
    "[[builtin]]"
    "@op null : call fmt as cql_format_null;"

    "@@end_include@@"
    ;
}

int cql_main(int argc, char **argv) {
  cql_exit_code = 0;
  yylineno = 1;
  parse_error_occurred = false;
  cql_ifdef_state = NULL;

  if (!setjmp(cql_for_exit)) {
    parse_cmd(argc, argv);
    ast_init();

    // add the builtin declares before we process the real input
    cql_setup_defines();
    cql_reset_open_includes();
    cql_setup_for_builtins();

    if (options.run_unit_tests) {
      run_unit_tests();
    }
    else {
      if (yyparse() || parse_error_occurred) {
        cql_exit_on_parse_errors();
      }
    }
  }

  cg_c_cleanup();
  sem_cleanup();
  ast_cleanup();
  gen_cleanup();
  rt_cleanup();
  parse_cleanup();
  cql_cleanup_open_includes();
  cql_cleanup_defines();

#ifdef CQL_AMALGAM
  // the variables need to be set back to zero so we can
  // be called again as though we were just loaded
  cql_reset_globals();
#endif

  return cql_exit_code;
}

#undef cql_main

// Use the longjmp buffer with the indicated code, see the comments above
// for why this has to be this way.  Note we do this in one line so that
// we don't get bogus code coverage errors for not covering the trialing brace
_Noreturn void cql_cleanup_and_exit(int32_t code)
{ release_open_charbufs(); cql_exit_code = code;  longjmp(cql_for_exit, 1); }

static void cql_exit_on_parse_errors() {
  cql_error("Parse errors found, no further passes will run.\n");
  cql_cleanup_and_exit(2);
}

static void parse_cleanup() {
  parse_error_occurred = false;
}

static int32_t gather_arg_params(int32_t a, int32_t argc, char **argv, uint32_t *out_count, char ***out_args) {
  if (a + 1 < argc) {
    a++;
    *out_args = &argv[a];
    *out_count = 1;
    while ((a + 1 < argc) && (strncmp("--", argv[a + 1], 2) != 0)) {
      a++;
      (*out_count)++;
    }
  }
  else {
    cql_error("%s requires additional arguments.\n", argv[a]);
    cql_cleanup_and_exit(1);
  }

  return a;
}

static int32_t gather_arg_param(int32_t a, int32_t argc, char **argv, char **out_arg, const char *errmsg) {
  if (a + 1 < argc) {
    a++;
    if (out_arg) {
      *out_arg = argv[a];
    }
  }
  else {
    cql_error("%s requires an additional param%s%s.\n", argv[a], errmsg ? " " : "", errmsg);
    cql_cleanup_and_exit(1);
  }

  return a;
}

extern int yylineno;

void line_directive(const char *directive) {
  char *directive_start = strchr(directive, '#');
  Invariant(directive_start != NULL);
  char *line_start = strchr(directive_start + 1, ' ');
  Invariant(line_start != NULL);
  int line = atoi(line_start + 1);
  yyset_lineno(line -1);  // we are about to process the linefeed

  char *q1 = strchr(directive_start +1, '"');
  if (!q1) return;
  char *q2 = strchr(q1+1, '"');
  if (!q2) return;

  CHARBUF_OPEN(temp);
  cg_decode_c_string_literal(q1, &temp);
  current_file = Strdup(temp.ptr);
  CHARBUF_CLOSE(temp);

  // we don't free the current file because it is used in the trees alongside lineno
  // free(current_file);  Don't do this.
}

// Make a string literal node based on the current file
// the node includes a search term, the literal begins at the pattern
// that is present.  So if the current dir is /var/foo/bar/baz/YourProjectRoot
// you can start at YourProjectRoot easily.
static ast_node *file_literal(ast_node *ast) {
  CHARBUF_OPEN(filter);
  EXTRACT_STRING(str, ast);
  cg_decode_string_literal(str, &filter);

  const char *p = strstr(current_file, filter.ptr);
  if (!p) {
    p = current_file;
  }

  CHARBUF_OPEN(literal);
  cg_encode_string_literal(p, &literal);
  ast_node *ret = new_ast_str(Strdup(literal.ptr));
  CHARBUF_CLOSE(literal);

  CHARBUF_CLOSE(filter);
  return ret;
}

#ifndef cql_emit_error

// CQL "stderr" outputs are emitted with this API
// You can define it to be a method of your choice with
// "#define cql_emit_error your_method" and then your method will get
// the data instead. This will be whatever output the
// compiler would have emitted to to stderr.  This includes semantic
// errors or invalid argument combinations.  Note that CQL never
// emits error fragments with this API, you always get all the text of
// one error.  This is important if you are filtering or looking for
// particular errors in a test harness or some such.
// You must copy the memory if you intend to keep it. "data" will be freed.

// Note: you may use cql_cleanup_and_exit to force a failure from within
// this API but doing so might result in unexpected cleanup paths that have
// not been tested.

void cql_emit_error(const char *err) {
  fprintf(stderr, "%s", err);
  if (error_capture) {
    bprintf(error_capture, "%s", err);
  }
}

#endif

#ifndef cql_emit_output

// CQL "stdout" outputs are emitted (in arbitrarily small pieces) with this API
// You can define it to be a method of your choice with
// "#define cql_emit_output your_method" and then your method will get
// the data instead. This will be whatever output the
// compiler would have emitted to to stdout.  This is usually
// reformated CQL or semantic trees and such -- not the normal compiler output.
// You must copy the memory if you intend to keep it. "data" will be freed.

// Note: you may use cql_cleanup_and_exit to force a failure from within
// this API but doing so might result in unexpected cleanup paths that have
// not been tested.

void cql_emit_output(const char *msg) {
  printf("%s", msg);
}

#endif

// Perform the formatting and then call cql_emit_error (which may be replaced)
// The point of all this is so that cql can have a printf-like error API but
// if you are trying to integrate with CQL you only have to handle the much
// simpler cql_emit_error API.

void cql_error(const char *format, ...)  {
  va_list args;
  va_start(args, format);
  CHARBUF_OPEN(err);
  vbprintf(&err, format, args);
  cql_emit_error(err.ptr);
  CHARBUF_CLOSE(err);
  va_end(args);
}

// Perform the formatting and the call cql_emit_output (which may be replaced)
// The point of all this is so that cql can have a printf-like output API but
// if you are trying to integrate with CQL you only have to handle the much
// simple cql_emit_output API.

void cql_output(const char *format, ...)  {
  va_list args;
  va_start(args, format);
  CHARBUF_OPEN(err);
  vbprintf(&err, format, args);
  cql_emit_output(err.ptr);
  CHARBUF_CLOSE(err);
  va_end(args);
}

#ifndef cql_open_file_for_write

// Not a normal integration point, the normal thing to do is replace cql_write_file
// but if all you need to do is adjust the path or something like that you could replace
// this method instead.  This presumes that a FILE * is still ok for your scenario.

FILE *_Nonnull cql_open_file_for_write(const char *_Nonnull file_name) {
  FILE *file;
  if (!(file = fopen(file_name, "w"))) {
    cql_error("unable to open %s for write\n", file_name);
    cql_cleanup_and_exit(1);
  }
  return file;
}

#endif

#ifndef cql_write_file

// CQL code generation outputs are emitted in one "gulp" with this API
// You can refine it to be a method of your choice with
// "#define cql_write_file your_method" and then your method will get
// the filename and the data. This will be whatever output the
// compiler would have emitted to one of it's --cg arguments. You can
// then write it to a location of your choice.
// You must copy the memory if you intend to keep it. "data" will be freed.

// Note: you *may* use cql_cleanup_and_exit to force a failure from within
// this API.  That's a normal failure mode that is well-tested.

void cql_write_file(const char *_Nonnull file_name, const char *_Nonnull data) {
  FILE *file = cql_open_file_for_write(file_name);
  fprintf(file, "%s", data);
  fclose(file);
}

#endif

static void cql_usage() {
  cql_emit_output(
    "Usage:\n"
    "--in file\n"
    "  reads the given file for the input instead of stdin\n"
    "--sem\n"
    "  performs semantic analysis on the input file ONLY\n"
    "--ast\n"
    "  prints the internal AST to stdout\n"
    "--ast_no_echo\n"
    "  prints the internal AST to stdout with no source inline (useful to debug)\n"
    "--echo\n"
    "  echoes the input in normalized form from the AST\n"
    "--dot\n"
    "  prints the internal AST to stdout in DOT format for graph visualization\n"
    "--cg output1 output2 ...\n"
    "  codegen into the named outputs\n"
    "  any number of output files may be needed for a particular result type, two is common\n"
    "--defines\n"
    "  define symbols for use with @ifdef and @ifndef\n"
    "--include_paths\n"
    "  specify prefixes to use with the @include directive\n"
    "--nolines\n"
    "  suppress the #line directives for lines; useful if you need to debug the C code\n"
    "--global_proc name\n"
    "  any loose SQL statements not in a stored proc are gathered and put into a procedure of the given name\n"
    "--compress\n"
    "  compresses SQL text into fragements that can be assembled into queries to save space\n"
    "--test\n"
    "  some of the output types can include extra diagnostics if --test is included\n"
    "--dev\n"
    "  some codegen features only make sense during development, this enables dev mode\n"
    "  example: explain query plans\n"
    "\n"
    "Result Types (--rt *) These are the various outputs the compiler can produce.\n"
    "\n"
    "--rt c\n"
    "  this is the standard C compilation of the sql file\n"
    "  requires two output files (foo.h and foo.c)\n"
    "--rt lua\n"
    "  this is the lua compilation of the sql file\n"
    "  requires one output files (foo.lua)\n"
    "--rt json_schema\n"
    "  produces JSON output suitable for consumption by downstream codegen tools\n"
    "  requires one output file (foo.json)\n"
    "--rt schema\n"
    "  produces the canonical schema for the given input files; stored procedures etc. are removed\n"
    "  requires one output file\n"
    "--rt schema_upgrade\n"
    "  produces a CQL schema upgrade script which can then be compiled with CQL itself\n"
    "  requires one output file (foo.sql)\n"
    "--rt query_plan\n"
    "  produces a set of helper procedures that create a query plan for every DML statement in the input\n"
    "  requires one output file (foo_queryplans.sql)\n"
    "--rt stats\n"
    "  produces a simple .csv file with node count information for AST nodes per procedure in the input\n"
    "  requires one output file (foo.csv)\n"
    "\n"
    "--include_regions a b c\n"
    "  the indicated regions will be declared;\n"
    "  used with --rt schema_upgrade or --rt schema\n"
    "--exclude_regions x y z\n"
    "  the indicated regions will still be declared but the upgrade code will be suppressed\n"
    "  used with --rt schema_upgrade\n"
    "--min_schema_version n\n"
    "  the schema upgrade script will not include upgrade steps for schema older than the version specified\n"
    "  used with --rt schema_upgrade\n"
    "--schema_exclusive\n"
    "  the schema upgrade script assumes it owns all the schema in the database, it aggressively removes other things\n"
    "  used with --rt schema_upgrade\n"
    "--c_include_namespace\n"
    "  for the C codegen runtimes, headers will be referenced as #include <namespace/file.h>\n"
    "--c_include_path\n"
    "  for C codegen runtimes this will be used to create the #include directive at the start of the C\n"
    "--cqlrt foo.h\n"
    "  emits foo.h into the C output instead of cqlrt.h\n"
    "--generate_exports\n"
    "  requires another output file to --cg; it contains the procedure declarations for the input\n"
    "  used with --rt c\n"
    );
}

// the reduction for a statement is pretty complicated compared to others:
//
// * procedures, views, and tables can get a doc comment add to their misc attributes
//   * if the node is one of those, we look for a recent saved comment and make an
//     attribute node eqivalent to [[doc_comment="your comment"]]
// * once this is done, if there are attributes, we wrap the statement with the attributes
//   using new_ast_stmt_and_attr
// * otherwise we just return the statement as no wrapper is needed
static ast_node *make_statement_node(
  ast_node *misc_attrs,
  ast_node *any_stmt)
{
  if (is_ast_create_proc_stmt(any_stmt) ||
      is_ast_create_view_stmt(any_stmt) ||
      is_ast_create_table_stmt(any_stmt)) {
    // Add the most recent doc comment (if any) to any table/view/proc
    CSTR comment = table_comment_saved ? table_comment_saved : get_last_doc_comment();
    if (comment) {
       ast_node *misc_attr_key = new_ast_dot(new_ast_str("cql"), new_ast_str("doc_comment"));
       ast_node *misc_attr = new_ast_misc_attr(misc_attr_key, new_ast_cstr(comment));
       misc_attrs = new_ast_misc_attrs(misc_attr, misc_attrs);
    }
  }

  // in any case, we get one chance to use this
  table_comment_saved = NULL;

  if (misc_attrs) {
     return new_ast_stmt_and_attr(misc_attrs, any_stmt);
  }
  else {
     return any_stmt;
  }
}

// creates a column definition node with a doc comment if needed
static ast_node *make_coldef_node(
  ast_node *col_def_type_attrs,
  ast_node *misc_attrs)
{
  // This is the equivalent of:
  //
  // $$ = new_ast_col_def(col_def_type_attrs, $misc_attrs);
  //
  // (with optional comment node)

  CSTR comment = get_last_doc_comment();
  if (comment) {
     ast_node *misc_attr_key = new_ast_dot(new_ast_str("cql"), new_ast_str("doc_comment"));
     ast_node *misc_attr = new_ast_misc_attr(misc_attr_key, new_ast_cstr(comment));
     misc_attrs = new_ast_misc_attrs(misc_attr, misc_attrs);
  }

  return new_ast_col_def(col_def_type_attrs, misc_attrs);
}

// When a chain of strings appears like this "xxx" "yyy" we reduce it to a single
// string literal by concatenating all the pieces.
static ast_node *reduce_str_chain(ast_node *str_chain) {
  Contract(is_ast_str_chain(str_chain));

  // trivial case, length one chain
  if (!str_chain->right) {
    return str_chain->left;
  }

  CHARBUF_OPEN(tmp);
  CHARBUF_OPEN(result);

  for (ast_node *item = str_chain; item; item = item->right) {
    Invariant(is_ast_str_chain(item));
    Invariant(is_ast_str(item->left));

    str_ast_node *str_node = (str_ast_node *)item->left;
    cg_decode_string_literal(str_node->value, &tmp);
  }

  cg_encode_string_literal(tmp.ptr, &result);
  ast_node *lit = new_ast_str(Strdup(result.ptr));

  // this just forces the literal to be echoed as a C literal
  // so that it is prettier in the echoed output, otherwise no difference
  // all literals are stored in SQL format.
  ((str_ast_node *)lit)->str_type = STRING_TYPE_C;

  CHARBUF_CLOSE(result);
  CHARBUF_CLOSE(tmp);

  return lit;
}

// This will hold the defined symbols -- the ones that came in
// via the --defines command line.  Currently there is no @define
// so you only get what came in on the command line
static symtab *defines;

// Add the defined symbol from the command line to the symbol table
static void cql_setup_defines() {
  Contract(!defines);
  defines = symtab_new();

  cql_add_define(dup_printf("__rt__%s", options.rt));

  for (int32_t i = 0; i < options.defines_count; i++) {
    cql_add_define(options.defines[i]);
  }
}

// free the defines table if it exists
static void cql_cleanup_defines() {
  SYMTAB_CLEANUP(defines);
}

// adds the given symbol to the set of defined symbols
static void cql_add_define(CSTR name) {
  Contract(defines);
  symtab_add(defines, name, (void*)1);
}

// tests if the conditional named is defined
cql_noexport bool_t cql_is_defined(CSTR name) {
  Contract(defines);
  symtab_entry *entry = symtab_find(defines, name);
  return entry && entry->val;
}

// this creates a simple call with no arguments
static ast_node *new_simple_call_from_name(ast_node *name) {
  ast_node *call_filter_clause = new_ast_call_filter_clause(NULL, NULL);
  ast_node *call_arg_list = new_ast_call_arg_list(call_filter_clause, NULL);
  return new_ast_call(name, call_arg_list);
}

// if there is no ifdef block or if the ifdef proc indicates
// we are current processing then we are processing.
static bool_t is_processing() {
  return !cql_ifdef_state || cql_ifdef_state->processing;
}

// In case of ifndef we test the symbol we process now if
// 1. we are already processing, and
// 2. the symbol is defined.
//
// Condition 1 might be false if we are for instance already
// in an @ifdef body and the body was not selected. In that
// case neither the main body or the else body will be processed.
static ast_node *do_ifdef(ast_node *ast) {
  EXTRACT_STRING(name, ast);
  cql_ifdef_state_t *new_state = _ast_pool_new(cql_ifdef_state_t);
  new_state->prev = cql_ifdef_state;
  bool_t processing = is_processing();
  new_state->processing = processing && cql_is_defined(name);
  new_state->process_else = processing && !new_state->processing;
  ast = new_state->processing ? new_ast_is_true(ast) : new_ast_is_false(ast);
  cql_ifdef_state = new_state;
  return ast;
}

// In case of ifndef we test the symbol we process now if
// 1. we are already processing, and
// 2. the symbol is not defined.
//
// Condition 1 might be false if we are for instance already
// in an @ifdef body and the body was not selected. In that
// case neither the main body or the else body will be processed.
static ast_node *do_ifndef(ast_node *ast) {
  EXTRACT_STRING(name, ast);
  cql_ifdef_state_t *new_state = _ast_pool_new(cql_ifdef_state_t);
  new_state->prev = cql_ifdef_state;
  bool_t processing = is_processing();
  new_state->processing = processing && !cql_is_defined(name);
  new_state->process_else = processing && !new_state->processing;
  ast = new_state->processing ? new_ast_is_true(ast) : new_ast_is_false(ast);
  cql_ifdef_state = new_state;
  return ast;
}

// having encountered an else
static void do_else() {
  // an else block cannot happen unless we are in an ifdef/ifndef
  // hence there must be state.
  Contract(cql_ifdef_state);

  // follow the instruction that was computed when we hit the ifdef
  cql_ifdef_state->processing = cql_ifdef_state->process_else;
}

// pops the pending ifdef state off the stack
static void do_endif() {
  Contract(cql_ifdef_state);

  cql_ifdef_state_t *prev = cql_ifdef_state->prev;
  cql_ifdef_state = prev;
}

// creates a macro argument reference node for the indicated macro type
// this is the use of a macro in any context (could be a macro body or not)
cql_noexport ast_node *new_macro_ref_node(CSTR name, ast_node *args) {
  int32_t macro_type = resolve_macro_name(name);
  ast_node *id = new_ast_str(name);
  switch (macro_type) {
    case EXPR_MACRO:         return new_ast_expr_macro_ref(id, args);
    case STMT_LIST_MACRO:    return new_ast_stmt_list_macro_ref(id, args);
    case QUERY_PARTS_MACRO:  return new_ast_query_parts_macro_ref(id, args);
    case CTE_TABLES_MACRO:   return new_ast_cte_tables_macro_ref(id, args);
    case SELECT_CORE_MACRO:  return new_ast_select_core_macro_ref(id, args);
    case SELECT_EXPR_MACRO:  return new_ast_select_expr_macro_ref(id, args);
  }
  return new_ast_unknown_macro_ref(id, args);
}

// creates a macro argument reference node for the indicated macro type
// this is the use of an argument inside the body of a macro.  Macro arguments
// obviously can only appear inside of macros bodies.
cql_noexport ast_node *new_macro_arg_ref_node(CSTR name) {
  int32_t macro_type = resolve_macro_name(name);
  ast_node *id = new_ast_str(name);
  switch (macro_type) {
    case EXPR_MACRO:         return new_ast_expr_macro_arg_ref(id);
    case STMT_LIST_MACRO:    return new_ast_stmt_list_macro_arg_ref(id);
    case QUERY_PARTS_MACRO:  return new_ast_query_parts_macro_arg_ref(id);
    case CTE_TABLES_MACRO:   return new_ast_cte_tables_macro_arg_ref(id);
    case SELECT_CORE_MACRO:  return new_ast_select_core_macro_arg_ref(id);
    case SELECT_EXPR_MACRO:  return new_ast_select_expr_macro_arg_ref(id);
  }
  return new_ast_unknown_macro_arg_ref(id);
}

// converts from the token to the friendly name of the macro
cql_noexport CSTR macro_type_from_name(CSTR name) {
  int32_t macro_type = resolve_macro_name(name);
  switch (macro_type) {
    case EXPR_MACRO:         return "expr";
    case STMT_LIST_MACRO:    return "stmt_list";
    case QUERY_PARTS_MACRO:  return "query_parts";
    case CTE_TABLES_MACRO:   return "cte_tables";
    case SELECT_CORE_MACRO:  return "select_core";
    case SELECT_EXPR_MACRO:  return "select_expr";
  }
  return "unknown";
}

// Converts from the ast node type to the token identifier
// So ast_expr_macro_arg becomes EXPR MACRO.
cql_noexport int32_t macro_arg_type(ast_node *macro_arg) {
  if (is_ast_expr_macro_arg(macro_arg)) return EXPR_MACRO;
  if (is_ast_stmt_list_macro_arg(macro_arg)) return STMT_LIST_MACRO;
  if (is_ast_query_parts_macro_arg(macro_arg)) return QUERY_PARTS_MACRO;
  if (is_ast_cte_tables_macro_arg(macro_arg)) return CTE_TABLES_MACRO;
  if (is_ast_select_core_macro_arg(macro_arg)) return SELECT_CORE_MACRO;
  if (is_ast_select_expr_macro_arg(macro_arg)) return SELECT_EXPR_MACRO;
  return EOF;
}

// Converts from the macro string like "STMT_LIST" to the constant
// like STMT_LIST_MACRO.  These tokens are only visible in this file
// so this code has to be here.

cql_noexport int32_t macro_type_from_str(CSTR type) {
  int32_t macro_type = EOF;
  if (!strcmp("EXPR", type)) {
    macro_type = EXPR_MACRO;
  }
  else if (!strcmp("STMT_LIST", type)) {
    macro_type = STMT_LIST_MACRO;
  }
  else if (!strcmp("QUERY_PARTS", type)) {
    macro_type = QUERY_PARTS_MACRO;
  }
  else if (!strcmp("CTE_TABLES", type)) {
    macro_type = CTE_TABLES_MACRO;
  }
  else if (!strcmp("SELECT_CORE", type)) {
    macro_type = SELECT_CORE_MACRO;
  }
  else if (!strcmp("SELECT_EXPR", type)) {
    macro_type = SELECT_EXPR_MACRO;
  }
  Contract(macro_type != EOF);
  return macro_type;
}



#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    
    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
     *       access to the local variable yy_act. Since yyless() is a macro, it would break
     *       existing scanners that call yyless() from OUTSIDE yylex.
     *       One obvious solution it to make yy_act a global. I tried that, and saw
     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
     *       normally declared as a register variable-- so it is not worth it.
     */
    #define  YY_LESS_LINENO(n) \
            do { \
                int yyl;\
                for ( yyl = n; yyl < yyleng; ++yyl )\
                    if ( yytext[yyl] == '\n' )\
                        --yylineno;\
            }while(0)
    #define YY_LINENO_REWIND_TO(dst) \
            do {\
                const char *p;\
                for ( p = yy_cp-1; p >= (dst); --p)\
                    if ( *p == '\n' )\
                        --yylineno;\
            }while(0)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart ( FILE *input_file  );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
void yy_delete_buffer ( YY_BUFFER_STATE b  );
void yy_flush_buffer ( YY_BUFFER_STATE b  );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state ( void );

static void yyensure_buffer_stack ( void );
static void yy_load_buffer_state ( void );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

#define yywrap() (/*CONSTCOND*/1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state ( void );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
static int yy_get_next_buffer ( void );
static void yynoreturn yy_fatal_error ( const char* msg  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 290
#define YY_END_OF_BUFFER 291
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static const flex_int16_t yy_accept[1360] =
    {   0,
        0,    0,    2,    2,  291,  286,  284,  284,  278,  286,
      278,  278,  286,  278,  278,  278,  278,  278,  278,  271,
      271,  278,  278,  278,  278,  286,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  279,  280,  286,  281,  278,  282,  284,  286,  290,
        2,  290,  251,    0,  275,    0,  252,  253,    0,    0,
      276,  254,  255,  285,  256,  249,  273,  289,  257,  273,
      271,  272,    0,  258,  259,  261,  262,  263,  264,  265,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,  283,  283,  283,
      283,  283,  283,  283,  283,   58,  283,  283,  283,  283,
       66,  283,  283,  283,  283,  283,  283,  283,  283,  283,
       96,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  129,  283,  283,  132,  144,
      283,  283,  283,  283,  283,  283,  283,  164,  283,  283,
      178,  180,  182,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      225,  283,  283,  283,  283,  283,  283,  283,  283,  283,
        0,    0,  274,  267,  268,    0,    0,    0,    0,    2,

        0,    3,    0,  285,  250,    0,  273,  269,  260,  266,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   32,    0,    0,    0,    0,    0,
       38,    0,   41,    0,    0,    0,    0,    0,    0,  283,
      283,   52,  283,   54,  283,   56,  283,   59,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  101,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  118,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  139,

        0,  283,  283,  152,  283,  283,  283,  156,  283,  283,
      283,  283,  283,  165,  283,  283,  283,    0,  283,  184,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  215,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  229,  283,  283,  283,  283,
      283,  283,  283,  240,  283,  283,  283,  283,  283,  283,
      277,    0,    0,    0,    0,  273,  270,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,   48,    0,  283,  283,  283,
      283,  283,  283,  283,  283,  283,   64,   65,   67,  283,
       69,   70,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,   93,
      283,   97,   98,  283,  102,  283,  283,  283,  283,  111,
      112,  283,  283,  283,  283,  283,    0,  283,  121,  122,
      124,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  143,    0,    0,    0,  283,  151,  153,
      283,  155,  157,  283,  159,  162,  283,    0,  283,  283,
      175,  283,  283,    0,  283,  283,  186,  283,  283,  283,

      283,  191,  283,  283,  283,  197,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  210,  283,  283,
      283,  283,  283,  283,  283,  221,  222,  223,  283,  283,
      283,  228,  230,  283,  283,  283,  283,  283,  283,  283,
      241,  283,  243,  283,  283,  283,  247,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   20,
        6,    0,    0,    0,    0,    0,   31,    0,    0,    0,
        0,   34,    0,    0,   40,    0,    0,    0,   47,    0,
       50,  283,   53,   55,  283,  283,  283,   62,  283,  283,
       71,   72,   73,  283,  283,  283,   77,  283,  283,  283,

       83,  283,  283,  283,  283,  283,  283,  283,  283,    0,
      283,  283,  283,  283,  283,  113,  114,  283,  116,  283,
        0,  283,  283,  125,  283,  283,  283,  283,  133,  283,
      135,  136,  283,  283,  283,  283,    0,    0,    0,  283,
      154,  158,  283,  163,    0,    0,    0,    0,    0,    0,
        0,  283,  283,  176,  283,  283,    0,  183,  185,  283,
      283,  283,  283,  283,  283,  195,  196,  283,  283,  283,
      283,  283,  283,  283,  283,  207,  283,  209,  283,  283,
        0,  283,  283,  283,  220,  224,  283,  283,  283,  283,
      233,  283,  283,  283,  238,  283,  283,  244,  245,  283,

      283,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    7,    0,    0,    0,    4,    0,    0,
        0,   37,    0,    0,    0,    0,   49,   51,  283,  283,
       61,  283,  283,  283,   75,   76,  283,  283,  283,   82,
      283,  283,   86,  283,  283,  283,   92,  283,    0,  100,
      103,  283,  283,  109,  283,  115,  283,    0,  283,  283,
      126,  127,  128,  130,  283,  283,  137,  283,  283,  283,
      283,    0,    0,    0,  145,  283,    0,    0,    0,    0,
        0,    0,    0,  283,  283,  177,  179,    0,  283,  283,
      283,  283,  283,    0,  283,  283,  283,  200,  283,  202,

      283,  283,  205,  283,  283,  212,    0,  283,  283,  219,
      283,  283,  283,  283,    0,  235,  236,  237,  239,  283,
      246,  283,    0,  287,    0,    0,    0,    0,    0,    0,
       13,    0,   16,    0,    0,    0,    0,    0,    0,    0,
        5,    0,    0,    0,    0,    0,    0,    0,  283,  283,
       63,   68,   74,  283,  283,  283,  283,  283,    0,   88,
       89,  283,  283,  283,    0,  283,  283,  110,  283,    0,
      119,  283,  283,  283,  138,  140,  283,  283,    0,  147,
      147,    0,  283,    0,    0,    0,  171,    0,    0,    0,
      166,  167,    0,  283,  283,  189,  190,  283,    0,  283,

      283,  283,  201,  203,  283,  283,  283,  283,  283,    0,
      283,  283,  283,  227,  283,  283,    0,  242,  248,  287,
        0,    0,    0,    0,    0,   12,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    1,    0,    0,    0,
        0,    0,    0,    0,  283,  283,  283,    0,   81,  283,
        0,    0,  283,   91,   94,   99,    0,  283,  283,    0,
      123,  283,  283,  283,  283,    0,    0,    0,    0,  150,
      160,    0,    0,    0,    0,    0,    0,    0,  283,  283,
      283,    0,  283,  283,  283,  204,  283,  208,  283,  283,
      283,    0,  283,  283,  283,  283,  283,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   42,    0,    0,
        0,   57,  283,  283,    0,    0,  283,    0,    0,  283,
      283,    0,    0,    0,    0,  108,  117,    0,  131,  134,
      141,  142,  146,    0,    0,  283,    0,    0,  170,  172,
        0,    0,    0,  187,  188,  192,    0,  283,  198,  283,
      206,  211,  283,  283,    0,  217,  218,  283,  283,  232,
        0,    0,    0,    0,   10,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   30,
        0,    0,    0,    0,    0,    0,   46,  283,   78,    0,

        0,   84,    0,    0,   90,  283,    0,    0,    0,    0,
        0,    0,    0,  283,    0,    0,  173,    0,    0,    0,
      283,  199,  283,  283,    0,  283,  231,  234,    0,  288,
        0,    0,    0,    0,    0,    0,    0,   19,    0,   22,
       23,    0,    0,    0,    0,    0,    0,    0,   35,   36,
        0,    0,    0,  283,    0,    0,    0,    0,   95,    0,
        0,    0,    0,    0,    0,    0,  283,    0,    0,  174,
        0,  194,  193,  213,  214,    0,  226,  288,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   26,    0,
        0,    0,    0,    0,    0,    0,  283,    0,    0,   85,

        0,    0,    0,    0,    0,    0,    0,  149,  161,  168,
        0,  181,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   27,    0,    0,    0,    0,    0,    0,
       60,    0,   80,    0,    0,    0,    0,  107,  120,  148,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   28,    0,    0,    0,    0,    0,    0,    0,
        0,  105,    0,    0,  216,    0,    9,    0,    0,    0,
       17,    0,   21,    0,   25,   29,    0,    0,    0,    0,
       79,   87,    0,    0,  169,    0,    0,    0,    0,   18,
        0,    0,   39,    0,    0,    0,    0,    8,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   24,    0,    0,    0,    0,    0,  106,    0,    0,
        0,    0,    0,    0,    0,    0,   11,    0,    0,    0,
        0,    0,    0,  104,    0,    0,    0,    0,    0,    0,
        0,   15,    0,    0,   44,    0,    0,    0,    0,   45,
        0,    0,   43,    0,    0,   14,    0,   33,    0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    6,    7,    8,    1,    9,   10,   11,   12,
       12,   13,   14,   12,   15,   16,   17,   18,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   20,   12,   21,
       22,   23,    1,   24,   25,   26,   27,   28,   29,   30,
       31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
       41,   42,   43,   44,   45,   46,   47,   48,   49,   50,
       51,   52,   53,   12,   54,   55,   56,   57,   58,   59,

       60,   61,   62,   63,   64,   65,   66,   67,   68,   69,
       70,   71,   72,   73,   74,   75,   76,   77,   78,   79,
       80,   50,   81,   82,   83,   12,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[84] =
    {   0,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        3,    1,    1,    1,    1,    1,    1,    4,    4,    1,
        1,    1,    1,    1,    4,    4,    4,    4,    4,    4,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        1,    1,    1,    5,    1,    4,    4,    4,    4,    4,
        4,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        1,    1,    1
    } ;

static const flex_int16_t yy_base[1400] =
    {   0,
        0,   79,   83,   84, 2615, 2750, 2750, 2750, 2592,   85,
     2590, 2587,   90, 2750, 2586, 2585,   80,   78,   85,   90,
       94, 2584,   93, 2583,   77,  146,  197,   82,  249,   90,
       86,  247,   91,   92,  271,   65,   76,  205,   95,  139,
      304,  155,   83,  271,  319,  353,  208,  162,  135, 2589,
        0, 2750, 2750, 2542, 2750,  118, 2750,  136,  141, 2750,
      191,   87, 2750,  140, 2750,    0, 2750, 2750,  226,  238,
     2584, 2750, 2750,    0, 2750, 2571,  338, 2750, 2750,  340,
      352, 2750,    0, 2750, 2571, 2750, 2750, 2750, 2750, 2570,
      258,  157,  202,  256,  207,  374,  214,  346,  230,  235,

      272,  266,  313,  333,  360,  367,  334,    0,  351,  355,
      378,  364,  381,  394,  393,  401,  385,  419,  392,  395,
        0,  408,  407,  399,  434,  418,  417,  412,  457,  415,
        0,  422,  421,  446,  479,  443,  422,  454,  472,  429,
      448,  459,  470,  465,  485,    0,  478,  483,  520,  523,
      490,  477,  491,  511,  525,  530,  491,  502,  513,  518,
      526,  248,  542,  527,  544,  532,  549,  546,  543,  595,
      554,  567,  550,  574,  566,  586,  565,  589,  584,  588,
        0,  622,  597,  617,  616,  625,  637,  643,  647,  639,
     2578, 2533, 2281, 2750, 2750,  252,  624,  335,  632,  528,

      675, 2750,    0,    0, 2750,  703,  676,  648, 2750, 2750,
      659,  654,  649,  666,  663,  671,  693,  664,  674,  666,
      679,  705,  674,  689, 2750,  710,  699,  705,  701,  714,
     2750,  713, 2750,  718,  714,  709,  701,  710,  710,  712,
      722,    0,  729,    0,  730,    0,  716,    0,  723,  724,
      734,  721,  745,  738,  739,  768,  755,  760,  745,  755,
      759,  760,  776,  764, 2109,  766,  774,  786,  785,  789,
      773,  780,  792,  784,    0,  787,  800,  782,  808,  794,
      790,  810,  805,  810,  821,  857,  821,  836,  839,  821,
      836,  842,  832,  843,  844,  830,  847,  832,  849,  853,

      909,  834,  847,    0,  843,  844,  847,    0,  866,  865,
      868,  866,  885,  923,  879,  890,  877,  929,  898,  903,
      891,  891,  909,  903,  911,  899,  899,  913,  909,  903,
      923,  925,  928,  934,  924,  918,  920,  936,  938,  961,
      948,  952,    0,  944,  945,  951,  953,  962,  960,  957,
      964,  964,  968,  976,  980,    0,  981,  972,  975,  990,
      988,  980,  974,    0,  974,  978,  985,  988, 1002, 1004,
     2750,    0, 1038, 1001, 1041, 1044, 2750, 1013, 1023, 1022,
     1032, 1021, 1043, 1033, 1042, 1035, 1034, 1045, 1032, 1044,
     1039, 1041, 1051, 1052, 1055, 1048, 1045, 1057, 1045, 1042,

     1062, 1048, 1062, 1049, 1049, 2750, 1049, 1057, 1067, 1071,
     1084, 1090, 1095, 1087, 1092, 1102,    0,    0,    0, 1108,
        0,    0, 1102, 1100, 1107, 1113, 1102, 1107, 1097, 1113,
     1099, 1102, 1103, 1119, 1110, 1125, 1106, 1110, 1109,    0,
     1121,    0, 1184, 1128,    0, 1123, 1123, 1131, 1163,    0,
        0, 1161, 1159, 1163, 1149, 1156, 1196, 1163,    0, 1153,
        0, 1160, 1164, 1174, 1162, 1177, 1159, 1175, 1167, 1166,
     1169, 1183, 1187,    0, 1188, 1175, 1173, 1180,    0,    0,
     1188,    0,    0, 1176, 2052,    0, 1198, 1260, 1199, 1192,
     1207, 1225, 1224, 1215, 1216, 1217,    0, 1231, 1238, 1244,

     1245, 1243, 1224, 1245, 1246,    0, 1234, 1235, 1230, 1254,
     1243, 1257, 1245, 1250, 1250, 1273, 1284,    0, 1274, 1288,
     1324, 1287, 1978, 1293, 1292,    0,    0,    0, 1284, 1289,
     1303,    0, 1948, 1290, 1298, 1292, 1294, 1297, 1309, 1312,
        0, 1297,    0, 1315, 1319, 1310, 1311, 1980, 1917, 1324,
     1321, 1823, 1322, 1318, 1320, 1314, 1334, 1316, 1312, 2750,
     2750, 1809, 1334, 1331, 1334, 1328, 2750, 1348, 1353, 1338,
     1764, 2750, 1354, 1361, 2750, 1367, 1360, 1365, 2750, 1373,
        0, 1362,    0,    0, 1372, 1364, 1374,    0, 1375, 1378,
        0,    0,    0, 1366, 1373, 1368, 1373, 1368, 1379, 1389,

        0, 1394, 1382, 1379, 1380, 1387, 1384, 1407, 1400, 1453,
     1410, 1396, 1416, 1402, 1423,    0,    0, 1418,    0, 1414,
     1437, 1432, 1431, 1422, 1435, 1430, 1443, 1440,    0, 1449,
        0,    0, 1433, 1453, 1450, 1455, 1444, 1437, 1437, 1447,
        0,    0, 1451,    0, 1459, 1460, 1464, 1463, 1469, 1481,
     1478, 1480, 1485,    0, 1478, 1479, 1486,    0,    0, 1481,
     1498, 1485, 1484, 1502, 1534,    0,    0, 1491, 1506, 1500,
     1498, 1513, 1516, 1511, 1507,    0, 1521,    0, 1508, 1504,
     1562, 1513, 1515, 1528,    0,    0, 1537, 1534, 1541, 1531,
     1578, 1541, 1555, 1541,    0, 1543, 1562,    0,    0, 1542,

     1545, 1810, 1732, 1557, 1563, 1571, 1217, 1560, 1573, 1561,
     1575, 1212, 1578, 2750, 1579, 1581, 1573, 2750, 1581, 1584,
     1569, 1203, 1575, 1594, 1597, 1580, 2750,    0, 1587, 1603,
        0, 1593, 1603, 1617,    0,    0, 1622, 1604, 1604,    0,
     1625, 1608, 1652, 1629, 1615, 1635,    0, 1638, 1636,    0,
        0, 1638, 1635,    0, 1631,    0, 1637, 1644, 1634, 1634,
        0,    0,    0,    0, 1649, 1639,    0, 1648, 1639, 1659,
     1656, 1643, 1706, 1658,    0, 1650, 1648, 1663, 1655,    0,
     1674, 1666, 1682, 1683, 1684,    0,    0, 1691, 1689, 1693,
     1678, 1699, 1684, 1728, 1691, 1699, 1696,    0, 1706,    0,

     1707, 1711, 1706, 1715, 1710, 1201, 1701, 1718, 1715,    0,
     1722, 1708, 1722, 1727, 1759,    0,    0,    0,    0, 1720,
        0, 1727, 1148,    0, 1757,  829, 1734, 1737, 1740, 1745,
     2750, 1760, 2750, 1762, 1752, 1754, 1751, 1762, 1766, 1757,
     2750, 1768, 1773, 1771, 1759, 1762,  633, 1775, 1765, 1768,
        0,    0,    0, 1778, 1828, 1783, 1780, 1843, 1844,    0,
        0, 1808, 1816, 1806,    0, 1849, 1806,    0, 1815, 1823,
        0, 1818, 1813, 1822,    0,    0, 1832, 1833, 1832, 2750,
     1864,    0, 1818, 1817, 1838, 1842, 2750, 1841, 1844, 1843,
        0,    0, 1837, 1835, 1840,    0,    0, 1837, 1844, 1857,

     1839, 1869,    0,    0, 1853, 1862, 1871, 1874, 1888, 1876,
     1880, 1876, 1876,    0, 1892, 1893, 1887,    0,    0,    0,
     1937, 1893, 1902, 1886, 1905, 2750,  586, 1904, 1889, 1906,
     1898, 1893, 1901, 1912,  582, 1899, 2750, 1921, 1925, 1926,
     1919, 1939, 1949, 1924, 1930, 1947, 1939, 1979,    0, 1950,
     1978, 1957, 1949,    0, 1944, 2750, 1995, 1958, 1957, 1990,
        0, 1967, 1949, 1974, 1965,    0, 2019, 1986, 1970, 2750,
     1985, 1986, 1986,    0,    0, 1998, 1983, 2002, 1998, 2007,
     2012, 2019, 2005, 2019, 2021,    0, 2021,    0, 2011, 2017,
     2010, 2033, 2021, 2024, 2038, 2046, 2046, 2040,  617, 2039,

     2046, 2055, 2053, 2060, 2060, 2056, 2064, 2052, 2060, 2053,
     2063, 2095, 2058, 2073, 2074, 2073,  554, 2750, 2084, 2074,
     2088,    0, 2081, 2076, 2083, 2076, 2084, 2091, 2093, 2110,
     2105, 2101, 2105, 2111, 2119,    0,    0, 2152,    0,    0,
        0,    0, 2750, 2119, 2114, 2129, 2133, 2123, 2750, 2750,
        0, 2131, 2145,    0,    0,    0, 2135, 2130,    0, 2133,
        0,    0, 2137, 2140, 2138,    0,    0, 2145, 2150,    0,
        0,  531, 2160, 2143, 2750, 2160, 2163, 2168, 2172, 2162,
     2171, 2156, 2158, 2166, 2183, 2170, 2182, 2183, 2170, 2750,
     2188, 2193, 2195, 2190,  478, 2203, 2750, 2206,    0, 2200,

     2198,    0, 2194, 2242,    0, 2195, 2204, 2210, 2249, 2221,
     2217, 2214, 2230, 2231, 2223, 2237, 2750,    0, 2219,    0,
     2225,    0, 2241, 2229, 2241, 2237,    0, 2750,  433,    0,
     2240, 2250, 2242, 2242, 2251, 2239, 2260, 2750, 2261, 2750,
     2750,  310, 2247, 2255, 2253, 2254, 2256,  297, 2750, 2750,
     2273, 2271, 2262, 2270, 2266, 2283,    0, 2316,    0, 2277,
     2277, 2328, 2280, 2277, 2296,    0, 2290,    0, 2311, 2750,
        0, 2750,    0,    0,    0, 2299,    0,    0, 2295, 2312,
     2319, 2309, 2317, 2311, 2322, 2311, 2309, 2315, 2750, 2325,
     2330, 2327, 2323, 2330, 2325, 2340, 2322, 2333,    0, 2750,

     2334, 2345, 2341, 2340,    0,    0,    0, 2750,    0, 2750,
     2349, 2750, 2348, 2359,  323,  289, 2355, 2362, 2356, 2366,
     2359, 2377, 2382, 2750, 2364, 2382, 2385, 2382, 2386, 2386,
        0, 2381, 2750, 2373, 2383,    0, 2390, 2750, 2750, 2750,
     2394,    0, 2395,  314, 2384, 2378, 2403, 2386, 2403, 2392,
     2405, 2407, 2750, 2402, 2410, 2411,  282, 2420,    0,    0,
     2412, 2750, 2432,    0, 2750,  297, 2750, 2433, 2439,  259,
     2750, 2422, 2750, 2435, 2750, 2750, 2440, 2445, 2434,  209,
     2750, 2750, 2470, 2431, 2750,  221, 2445, 2455, 2440, 2750,
     2444,  189, 2750, 2451, 2442, 2484, 2447, 2750, 2458, 2458,

     2468, 2460, 2470, 2474, 2479, 2479, 2470,    0, 2471, 2482,
     2486, 2750, 2480, 2478, 2481, 2482, 2480, 2750, 2492,  140,
     2498,  112, 2507, 2500, 2492,    0, 2750, 2496, 2504, 2519,
     2501, 2506, 2514, 2750, 2521, 2514, 2517, 2523, 2515, 2521,
     2534, 2750, 2534, 2529, 2750, 2532, 2538, 2547, 2535, 2750,
     2540, 2537, 2750, 2544, 2556, 2750, 2543, 2750, 2750, 2617,
     2622, 2627, 2629, 2634, 2639, 2644,  141, 2647,  139, 2651,
     2656, 2659, 2662, 2667, 2670, 2673, 2676, 2679, 2682, 2685,
     2688, 2693, 2696, 2699, 2704, 2707, 2710, 2713, 2716, 2719,
     2722, 2725, 2728, 2731, 2734, 2737, 2740, 2743, 2746

    } ;

static const flex_int16_t yy_def[1400] =
    {   0,
     1359,    1, 1360, 1360, 1359, 1359, 1359, 1359, 1359, 1361,
     1359, 1359, 1362, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1359, 1359, 1364, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1365, 1359, 1361, 1359, 1361, 1359, 1359, 1362, 1362,
     1359, 1359, 1359, 1366, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1367, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,

     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1368, 1364, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,

     1365, 1359, 1365, 1366, 1359, 1359, 1359, 1367, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,

     1359, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1359, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1359, 1369, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,

     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1359, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1359, 1359, 1359, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1359, 1363, 1363,
     1363, 1363, 1363, 1359, 1363, 1363, 1363, 1363, 1363, 1363,

     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1368, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,

     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1359,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1359, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1359, 1359, 1359, 1363,
     1363, 1363, 1363, 1363, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1363, 1363, 1363, 1363, 1363, 1359, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1359, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,

     1363, 1370, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1359, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1359, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1359, 1371, 1359, 1363, 1363, 1359, 1359, 1359, 1372,
     1359, 1359, 1359, 1363, 1363, 1363, 1363, 1359, 1363, 1363,
     1363, 1363, 1363, 1359, 1363, 1363, 1363, 1363, 1363, 1363,

     1363, 1363, 1363, 1363, 1363, 1363, 1359, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1359, 1363, 1363, 1363, 1363, 1363,
     1363, 1363, 1370, 1373, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1363, 1363,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1359, 1363,
     1363, 1363, 1363, 1363, 1374, 1363, 1363, 1363, 1363, 1359,
     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1359, 1359,
     1359, 1375, 1363, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1363, 1363, 1359, 1363, 1363, 1363, 1363, 1363, 1359, 1363,

     1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1359,
     1363, 1363, 1363, 1363, 1363, 1363, 1359, 1363, 1363, 1373,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1363, 1363, 1363, 1359, 1363, 1363,
     1359, 1359, 1363, 1363, 1363, 1359, 1359, 1363, 1363, 1359,
     1363, 1363, 1363, 1363, 1363, 1376, 1359, 1359, 1359, 1359,
     1363, 1359, 1359, 1377, 1378, 1359, 1359, 1359, 1363, 1363,
     1363, 1359, 1363, 1363, 1363, 1363, 1363, 1363, 1363, 1363,
     1363, 1359, 1363, 1363, 1363, 1363, 1363, 1359, 1359, 1359,

     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1363, 1363, 1363, 1359, 1359, 1363, 1359, 1359, 1363,
     1363, 1359, 1359, 1359, 1359, 1363, 1363, 1359, 1363, 1363,
     1363, 1363, 1359, 1359, 1359, 1363, 1359, 1359, 1359, 1359,
     1379, 1359, 1359, 1363, 1363, 1363, 1359, 1363, 1363, 1363,
     1363, 1363, 1363, 1363, 1359, 1363, 1363, 1363, 1363, 1363,
     1380, 1381, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1363, 1363, 1359,

     1359, 1363, 1359, 1359, 1363, 1363, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1363, 1359, 1359, 1359, 1382, 1359, 1383,
     1363, 1363, 1363, 1363, 1359, 1363, 1363, 1359, 1381, 1384,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1363, 1359, 1359, 1385, 1359, 1363, 1359,
     1359, 1359, 1359, 1359, 1359, 1386, 1363, 1387, 1359, 1359,
     1388, 1359, 1363, 1363, 1363, 1359, 1363, 1384, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1363, 1359, 1389, 1359,

     1359, 1359, 1359, 1359, 1390, 1391, 1392, 1359, 1363, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1363, 1359, 1359, 1359, 1359, 1393, 1359, 1359, 1359, 1359,
     1359, 1394, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1395, 1396,
     1359, 1359, 1359, 1397, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,

     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1398, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1399, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,    0, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359

    } ;

static const flex_int16_t yy_nxt[2834] =
    {   0,
        6,    7,    8,    7,    7,    9,   10,    6,   11,   12,
       13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
       23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
       33,   34,   35,   36,   37,   38,   39,   40,   41,   42,
       43,   44,   45,   46,   47,   48,   49,   50,   51,   51,
       52,    6,   53,   51,   54,   27,   28,   29,   30,   31,
       32,   33,   34,   35,   36,   37,   38,   39,   40,   41,
       42,   43,   44,   45,   46,   47,   48,   49,   50,   51,
       55,   56,   57,   58,   61,   61,   59,   61,   61,   62,
       62,   65,   70,  202,   74,   77,   77,   78,   89,   90,

       71,   75,   76,  151,  152,   80,   79,   81,   81,   80,
      118,   81,   81,   85,   86,   87,  144,  119,  129,  157,
      120,  133,  130,  134,  145,   82,  142,  168,  131,   82,
      121,  132,  143,  135,  151,  152,   66,   83,  203,  194,
      196,  118,  548,  197,  208,  198,   65,  144,  119,  129,
      157,  120,  133,  130,  134,  145,   82,  142,  168,  131,
       82,  121,  132,  143,  135, 1330,  189,  190,   83,   91,
       92,   93,   94,   95,   96,   97,  199,  158,   98,  166,
       99,  100,  101,  159,  102,  103,  187,  104,  105,  106,
      107,   66,  200, 1328,  188,  200,  167,  189,  190,  195,

      213,   92,   93,   94,   95,   96,   97,  199,  158,   98,
      166,   99,  100,  101,  159,  102,  103,  187,  104,  105,
      106,  107,  109,  110,  111,  188,  112,  167,   70,  153,
      214,  213,  113,  154,  114,  217,   71,  155,  115,  116,
       70,  117, 1303,  156, 1298,  184,  224,  185,   71,  318,
      186,  218,  318,  109,  110,  111,  196,  112,  228,  197,
      153,  214, 1295,  113,  154,  114,  217,  229,  155,  115,
      116,  136,  117,  122,  156,  137,  184,  224,  185,  138,
      123,  186,  218,  211,  124,  139,  212,  125,  140,  228,
      126,  141,  127,  128,  215,  169,  230,  216,  229,  170,

      146,  147,  136,  171,  122,  231,  137,  148,  149,  172,
      138,  123, 1289,  150,  211,  124,  139,  212,  125,  140,
     1286,  126,  141,  127,  128,  215,  169,  230,  216,  160,
      170,  146,  147,  161,  171, 1279,  231, 1267,  148,  149,
      172,  162, 1245,  173,  150,  163, 1244,  174,  164,  165,
     1193,  175,  373,  373,  232,   77,   77,  207,  207,  233,
      160,  234,  176, 1187,  161,  177,  206,   80,  206,   81,
       81,  239,  162,  225,  173,  226,  163,  178,  174,  164,
      165,  179,  175,  227,  180,  232,  235,   82,  236,  240,
      233,  181,  234,  176,  182,  237,  177,  206,  241,  206,

      219,  183,  239,  238,  225,  242,  226,  243,  178,  220,
      221,  222,  179,  223,  227,  180,  244,  235,   82,  236,
      240,  246,  181,  247,  245,  182,  237,  248,  249,  241,
      253,  219,  183,  254,  238,  258,  242,  259,  243, 1130,
      220,  221,  222,  255,  223,  265,  263,  244,  250,  251,
      256,  257,  246,  266,  247,  245,  264,  271,  248,  249,
      272,  253,  252,  273,  254,  282,  258,  287,  259,  260,
      261,  262,  274,  275,  255,  280,  265,  263,  281,  250,
      251,  256,  257,  267,  266,  288,  268,  264,  271,  283,
      276,  272,  269,  252,  273,  284,  282,  289,  287,  270,

      260,  261,  262,  274,  275,  277,  280,  285,  290,  281,
      291,  278,  292,  286,  267,  293,  288,  268,  279,  294,
      283,  276,  303,  269,  301,  304,  284,  301,  289,  200,
      270, 1152,  200,  305,  313,  306,  277, 1130,  285,  290,
      307,  291,  278,  292,  286,  314,  293,  295,  315,  279,
      294,  316,  296,  303,  308,  317,  304,  297,  298,  309,
      302,  310,  299,  300,  305,  313,  306,  311,  312,  319,
      320,  307,  321,  322,  326,  327,  314,  323,  295,  315,
      328,  324,  316,  296,  338,  308,  317,  325,  297,  298,
      309,  302,  310,  299,  300,  341,  344,  347,  311,  312,

      319,  320,  339,  321,  322,  326,  327, 1094,  323,  342,
      345,  328,  324,  340,  348,  338,  351,  343,  325,  329,
      349,  330,  346, 1072,  331,  332,  341,  344,  347,  352,
      333,  350,  334,  339,  335, 1012,  357,  336,  337, 1004,
      342,  345,  358,  360,  340,  348,  353,  351,  343,  359,
      329,  349,  330,  346,  354,  331,  332,  362,  361,  199,
      352,  333,  350,  334,  374,  335,  355,  357,  336,  337,
      356,  365,  363,  358,  360,  367,  369,  353,  364,  368,
      359,  202,  370,  377,  366,  354,  943,  378,  362,  361,
      199,  379,  380,  207,  207,  374,  381,  355,  382,  383,

      386,  356,  365,  363,  206,  387,  367,  369,  388,  364,
      368,  389,  392,  370,  377,  366,  375,  375,  378,  384,
      376,  376,  379,  380,  393,  396,  203,  381,  385,  382,
      383,  386,  390,  397,  391,  206,  387,  394,  398,  388,
      399,  400,  389,  392,  402,  403,  404,  395,  405,  406,
      384,  401,  407,  408,  409,  393,  396,  410,  411,  385,
      412,  413,  414,  390,  397,  391,  415,  416,  394,  398,
      417,  399,  400,  418,  419,  402,  403,  404,  395,  405,
      406,  423,  401,  407,  408,  409,  424,  425,  410,  411,
      426,  412,  413,  414,  420,  428,  421,  415,  416,  427,

      431,  417,  429,  430,  418,  419,  432,  434,  435,  436,
      437,  422,  423,  439,  438,  440,  441,  424,  425,  442,
      443,  426,  444,  445,  448,  420,  428,  421,  446,  451,
      427,  431,  452,  429,  430,  447,  453,  432,  434,  435,
      436,  437,  422,  449,  439,  438,  440,  441,  454,  450,
      442,  443,  455,  444,  445,  448,  456,  459,  457,  446,
      451,  457,  460,  452,  461,  462,  447,  453,  463,  464,
      465,  466,  467,  468,  449,  469,  470,  471,  478,  454,
      450,  473,  922,  455,  479,  458,  480,  456,  459,  481,
      482,  474,  472,  460,  483,  461,  462,  484,  485,  463,

      464,  465,  466,  467,  468,  486,  469,  470,  471,  478,
      301,  487,  473,  301,  491,  479,  458,  480,  492,  493,
      481,  482,  474,  472,  488,  483,  495,  488,  484,  485,
      318,  496,  497,  318,  498,  499,  486,  502,  475,  500,
      503,  504,  487,  505,  506,  491,  476,  507,  501,  492,
      493,  508,  477,  509,  489,  494,  510,  495,  511,  512,
      490,  513,  496,  497,  514,  498,  499,  515,  502,  475,
      500,  503,  504,  516,  505,  506,  519,  476,  507,  501,
      520,  521,  508,  477,  509,  489,  494,  510,  522,  511,
      512,  490,  513,  517,  523,  514,  524,  525,  515,  526,

      527,  528,  529,  518,  516,  530,  531,  519,  532,  533,
      534,  520,  521,  535,  537,  536,  538,  539,  540,  522,
      541,  542,  543,  545,  517,  523,  544,  524,  525,  546,
      526,  527,  528,  529,  518,  547,  530,  531,  550,  532,
      533,  534,  549,  551,  535,  537,  536,  538,  539,  540,
      552,  541,  542,  543,  545,  373,  373,  544,  376,  376,
      546,  376,  376,  553,  554,  555,  547,  556,  557,  550,
      558,  559,  560,  561,  551,  562,  563,  565,  566,  567,
      568,  552,  569,  570,  571,  572,  573,  574,  575,  576,
      577,  578,  579,  580,  553,  554,  555,  564,  556,  557,

      581,  558,  559,  560,  561,  582,  562,  563,  565,  566,
      567,  568,  583,  569,  570,  571,  572,  573,  574,  575,
      576,  577,  578,  579,  580,  584,  585,  586,  587,  588,
      589,  581,  590,  591,  592,  593,  582,  594,  595,  596,
      597,  598,  600,  583,  601,  599,  602,  603,  604,  605,
      606,  607,  608,  609,  824,  611,  584,  585,  586,  587,
      588,  589,  612,  590,  591,  592,  593,  613,  594,  595,
      596,  597,  598,  600,  614,  601,  599,  602,  603,  604,
      605,  606,  607,  608,  609,  610,  611,  615,  610,  616,
      617,  618,  619,  612,  620,  622,  623,  457,  613,  624,

      457,  625,  626,  627,  628,  614,  629,  630,  631,  632,
      633,  634,  637,  638,  639,  640,  641,  635,  615,  642,
      616,  617,  618,  619,  621,  620,  622,  623,  636,  644,
      624,  652,  625,  626,  627,  628,  653,  629,  630,  631,
      632,  633,  634,  637,  638,  639,  640,  641,  635,  654,
      642,  655,  656,  657,  909,  621,  844,  658,  659,  636,
      644,  488,  652,  660,  488,  834,  661,  653,  662,  663,
      829,  664,  665,  666,  667,  668,  669,  670,  671,  672,
      654,  673,  655,  656,  657,  645,  674,  646,  658,  659,
      647,  675,  648,  676,  660,  649,  650,  661,  677,  662,

      663,  651,  664,  665,  666,  667,  668,  669,  670,  671,
      672,  678,  673,  679,  680,  682,  645,  674,  646,  684,
      685,  647,  675,  648,  676,  681,  649,  650,  681,  677,
      686,  687,  651,  688,  690,  691,  692,  693,  694,  695,
      696,  697,  678,  698,  679,  680,  682,  699,  700,  701,
      684,  685,  703,  704,  706,  707,  708,  709,  710,  711,
      712,  686,  687,  714,  688,  690,  691,  692,  693,  694,
      695,  696,  697,  715,  698,  716,  717,  718,  699,  700,
      701,  719,  720,  703,  704,  706,  707,  708,  709,  710,
      711,  712,  722,  723,  714,  724,  725,  726,  727,  728,

      729,  730,  731,  732,  715,  733,  716,  717,  718,  734,
      735,  736,  719,  720,  737,  738,  739,  740,  741,  742,
      743,  744,  745,  722,  723,  746,  724,  725,  726,  727,
      728,  729,  730,  731,  732,  747,  733,  748,  750,  751,
      734,  735,  736,  752,  754,  737,  738,  739,  740,  741,
      742,  743,  744,  745,  610,  755,  746,  610,  753,  756,
      757,  758,  759,  760,  761,  762,  747,  763,  748,  750,
      751,  764,  765,  766,  752,  754,  767,  768,  769,  772,
      773,  774,  775,  776,  770,  749,  755,  777,  778,  753,
      756,  757,  758,  759,  760,  761,  762,  771,  763,  779,

      780,  781,  764,  765,  766,  782,  783,  767,  768,  769,
      772,  773,  774,  775,  776,  770,  749,  784,  777,  778,
      785,  786,  787,  788,  789,  790,  791,  792,  771,  793,
      779,  780,  781,  796,  797,  794,  782,  783,  794,  798,
      799,  800,  801,  802,  803,  804,  805,  806,  784,  808,
      809,  785,  786,  787,  788,  789,  790,  791,  792,  810,
      793,  811,  812,  681,  796,  797,  681,  813,  814,  816,
      798,  799,  800,  801,  802,  803,  804,  805,  806,  815,
      808,  809,  815,  817,  818,  819,  820,  795,  821,  822,
      810,  807,  811,  812,  826,  827,  828,  830,  813,  814,

      816,  831,  832,  833,  835,  838,  836,  839,  837,  840,
      841,  842,  843,  845,  817,  818,  819,  820,  846,  821,
      822,  847,  807,  848,  849,  826,  827,  828,  830,  850,
      851,  852,  831,  832,  833,  835,  838,  836,  839,  837,
      840,  841,  842,  843,  845,  853,  854,  855,  856,  846,
      857,  858,  847,  859,  848,  849,  859,  860,  861,  862,
      850,  851,  852,  863,  864,  865,  866,  867,  868,  869,
      870,  871,  872,  873,  874,  875,  853,  854,  855,  856,
      876,  857,  858,  877,  878,  879,  882,  883,  860,  861,
      862,  884,  885,  886,  863,  864,  865,  866,  867,  868,

      869,  870,  871,  872,  873,  874,  875,  881,  888,  889,
      881,  876,  890,  891,  877,  878,  879,  882,  883,  892,
      893,  894,  884,  885,  886,  895,  896,  897,  898,  794,
      900,  901,  794,  902,  903,  904,  825,  905,  906,  888,
      889,  907,  908,  890,  891,  910,  911,  912,  913,  914,
      892,  893,  894,  915,  916,  918,  895,  896,  897,  898,
      815,  900,  901,  815,  902,  903,  904,  899,  905,  906,
      919,  923,  907,  908,  921,  921,  910,  911,  912,  913,
      914,  924,  925,  917,  915,  916,  918,  926,  927,  928,
      931,  932,  933,  934,  935,  936,  937,  938,  899,  929,

      939,  919,  923,  941,  930,  942,  940,  944,  945,  946,
      947,  949,  924,  925,  917,  950,  824,  721,  926,  927,
      928,  931,  932,  933,  934,  935,  936,  937,  938,  948,
      929,  939,  948,  953,  941,  930,  942,  940,  944,  945,
      946,  947,  949,  954,  951,  859,  950,  951,  859,  955,
      957,  958,  959,  957,  960,  961,  962,  963,  964,  965,
      966,  971,  713,  972,  953,  967,  973,  974,  967,  975,
      976,  977,  978,  979,  954,  952,  705,  980,  981,  982,
      955,  983,  958,  959,  984,  960,  961,  962,  963,  964,
      965,  966,  971,  968,  972,  985,  986,  973,  974,  987,

      975,  976,  977,  978,  979,  988,  952,  969,  980,  981,
      982,  989,  983,  992,  990,  984,  991,  993,  994,  995,
      996,  997,  998,  702,  968, 1000,  985,  986, 1001, 1002,
      987, 1003, 1005, 1006, 1007, 1008,  988, 1009,  969, 1010,
     1011,  999,  989, 1013,  992,  990, 1014,  991,  993,  994,
      995,  996,  997,  998,  921,  921, 1000, 1015, 1016, 1001,
     1002, 1017, 1003, 1005, 1006, 1007, 1008, 1018, 1009, 1021,
     1010, 1011, 1022, 1019, 1013, 1023, 1024, 1014, 1027,  951,
      948, 1029,  951,  948, 1030, 1031, 1036, 1037, 1015, 1016,
      371, 1038, 1017, 1020, 1038, 1039,  957, 1040, 1018,  957,

     1021,  689, 1041, 1022, 1019, 1025, 1023, 1024, 1042, 1027,
     1044, 1045, 1029, 1046, 1047, 1030, 1031, 1036, 1037, 1028,
      967, 1032, 1026,  967, 1020, 1033, 1039, 1048, 1040, 1051,
     1052,  683, 1034, 1041, 1053, 1054, 1025, 1055, 1035, 1042,
     1056, 1044, 1045, 1057, 1046, 1047, 1058, 1059,  968, 1060,
     1028, 1061, 1032, 1026, 1062, 1063, 1033, 1064, 1048, 1065,
     1051, 1052,  969, 1034, 1066, 1053, 1054, 1067, 1055, 1035,
     1068, 1056, 1069, 1070, 1057, 1071, 1073, 1058, 1059,  968,
     1060, 1074, 1061, 1075, 1076, 1062, 1063, 1077, 1064, 1079,
     1065, 1080, 1081,  969, 1082, 1066, 1083, 1084, 1067, 1085,

     1090, 1068, 1078, 1069, 1070,  643, 1071, 1073, 1091, 1092,
     1093, 1095, 1074, 1096, 1075, 1076, 1097, 1098, 1077, 1099,
     1079, 1100, 1080, 1081, 1101, 1082, 1102, 1083, 1084, 1103,
     1085, 1090, 1086, 1078, 1087, 1104, 1088, 1089, 1105, 1091,
     1092, 1093, 1095, 1106, 1096, 1107, 1108, 1097, 1098, 1109,
     1099, 1110, 1100, 1038, 1112, 1101, 1038, 1102, 1113, 1114,
     1103, 1115,  433, 1086, 1116, 1087, 1104, 1088, 1089, 1105,
     1118, 1119, 1120, 1121, 1106, 1122, 1107, 1108, 1123, 1124,
     1109, 1125, 1110, 1126, 1127, 1112, 1131, 1132, 1133, 1113,
     1114, 1134, 1115, 1111, 1135, 1116, 1136, 1137, 1138, 1139,

     1140, 1118, 1119, 1120, 1121, 1141, 1122, 1142, 1143, 1123,
     1124, 1146, 1125, 1147, 1126, 1127, 1148, 1131, 1132, 1133,
     1144, 1149, 1134, 1150, 1111, 1135, 1145, 1136, 1137, 1138,
     1139, 1140, 1151, 1153, 1154, 1155, 1141, 1156, 1142, 1143,
     1157, 1159, 1146, 1158, 1147, 1160, 1158, 1148, 1161, 1163,
     1162, 1144, 1149, 1162, 1150, 1164, 1165, 1145, 1166, 1167,
     1168, 1169, 1171, 1151, 1153, 1154, 1155, 1173, 1156, 1174,
     1175, 1157, 1159, 1176, 1177, 1179, 1160, 1180, 1181, 1161,
     1163, 1182, 1183, 1184, 1185, 1186, 1164, 1165, 1188, 1166,
     1167, 1168, 1169, 1171, 1189, 1190, 1191, 1192, 1173, 1194,

     1174, 1175, 1195, 1196, 1176, 1177, 1179, 1197, 1180, 1181,
     1198, 1199, 1182, 1183, 1184, 1185, 1186, 1158, 1202, 1188,
     1158, 1203, 1205, 1206, 1207, 1189, 1190, 1191, 1192, 1162,
     1194, 1209, 1162, 1195, 1196,  192, 1211, 1213, 1197, 1214,
     1215, 1198, 1199, 1216, 1217, 1218, 1219, 1220, 1221, 1202,
     1222, 1223, 1203, 1205, 1206, 1207, 1224, 1201, 1225, 1226,
     1227, 1228, 1209, 1229, 1230, 1231, 1204, 1211, 1213, 1232,
     1214, 1215, 1234, 1235, 1216, 1217, 1218, 1219, 1220, 1221,
     1236, 1222, 1223, 1237, 1241, 1242, 1243, 1224, 1201, 1225,
     1226, 1227, 1228, 1246, 1229, 1230, 1231, 1204, 1247, 1248,

     1232, 1249, 1250, 1234, 1235, 1251, 1252, 1253, 1254, 1255,
     1256, 1236, 1257, 1258, 1237, 1241, 1242, 1243, 1259, 1260,
     1261, 1263, 1264, 1266, 1246, 1268, 1269, 1270, 1271, 1247,
     1248, 1272, 1249, 1250, 1273, 1274, 1251, 1252, 1253, 1254,
     1255, 1256, 1275, 1257, 1258, 1276, 1277, 1278, 1280, 1259,
     1260, 1261, 1263, 1264, 1266, 1283, 1268, 1269, 1270, 1271,
     1284, 1287, 1272, 1288, 1290, 1273, 1274, 1291, 1292, 1293,
     1294, 1296, 1297, 1275, 1296, 1299, 1276, 1277, 1278, 1280,
     1300, 1301, 1302, 1304, 1305, 1296, 1283, 1306, 1296, 1308,
     1309, 1284, 1287, 1310, 1288, 1290, 1311, 1312, 1291, 1292,

     1293, 1294, 1313, 1297, 1314, 1315, 1299, 1316, 1317, 1319,
     1320, 1300, 1301, 1302, 1304, 1305, 1321, 1322, 1306, 1323,
     1308, 1309, 1324, 1325, 1310, 1307, 1326, 1311, 1312, 1327,
     1329, 1331, 1332, 1313, 1333, 1314, 1315, 1335, 1316, 1317,
     1319, 1320, 1336, 1337, 1338, 1339, 1340, 1321, 1322, 1341,
     1323, 1342, 1343, 1324, 1325, 1344, 1307, 1326, 1345, 1346,
     1327, 1329, 1331, 1332, 1347, 1333, 1348, 1349, 1335, 1350,
     1351, 1352, 1353, 1336, 1337, 1338, 1339, 1340, 1354, 1355,
     1341, 1356, 1342, 1343, 1357, 1358, 1344,  193,  371, 1345,
     1346,  210,  209,  205,   69, 1347,  193, 1348, 1349,  191,

     1350, 1351, 1352, 1353,   88,   84,   73,   72,   68, 1354,
     1355,   67, 1356,   63, 1359, 1357, 1358,   60,   60,   60,
       60,   60,   64, 1359,   64,   64,   64,   69,   69,   69,
       69,   69,  108,  108,  192, 1359,  192,  192,  192,  201,
     1359,  201,  201,  201,  204, 1359,  204,  204,  204,  372,
      372,  823,  823,  823,  823,  823,  880,  880,  880,  887,
      887,  887,  920, 1359,  920,  920,  920,  956,  956,  956,
      970,  970,  970, 1043, 1043, 1043, 1049, 1049, 1049, 1050,
     1050, 1050, 1117, 1117, 1117, 1128, 1128, 1128, 1129, 1129,
     1129, 1129, 1129, 1170, 1170, 1170, 1172, 1172, 1172, 1178,

     1359, 1178, 1178, 1178, 1200, 1200, 1200, 1208, 1208, 1208,
     1210, 1210, 1210, 1212, 1212, 1212, 1233, 1233, 1233, 1238,
     1238, 1238, 1239, 1239, 1239, 1240, 1240, 1240, 1262, 1262,
     1262, 1265, 1265, 1265, 1281, 1281, 1281, 1282, 1282, 1282,
     1285, 1285, 1285, 1318, 1318, 1318, 1334, 1334, 1334,    5,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,

     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359
    } ;

static const flex_int16_t yy_chk[2834] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    2,    3,    4,    2,    3,    4,    3,
        4,   10,   13,   62,   17,   18,   18,   19,   25,   25,

       13,   17,   17,   36,   37,   20,   19,   20,   20,   21,
       28,   21,   21,   23,   23,   23,   34,   28,   30,   39,
       28,   31,   30,   31,   34,   20,   33,   43,   30,   21,
       28,   30,   33,   31,   36,   37,   10,   20,   62,   56,
       58,   28, 1369,   58, 1367,   59,   64,   34,   28,   30,
       39,   28,   31,   30,   31,   34,   20,   33,   43,   30,
       21,   28,   30,   33,   31, 1322,   49,   49,   20,   26,
       26,   26,   26,   26,   26,   26,   59,   40,   26,   42,
       26,   26,   26,   40,   26,   26,   48,   26,   26,   26,
       26,   64,   61, 1320,   48,   61,   42,   49,   49,   56,

       92,   26,   26,   26,   26,   26,   26,   59,   40,   26,
       42,   26,   26,   26,   40,   26,   26,   48,   26,   26,
       26,   26,   27,   27,   27,   48,   27,   42,   69,   38,
       93,   92,   27,   38,   27,   95,   69,   38,   27,   27,
       70,   27, 1292,   38, 1286,   47,   97,   47,   70,  162,
       47,   95,  162,   27,   27,   27,  196,   27,   99,  196,
       38,   93, 1280,   27,   38,   27,   95,  100,   38,   27,
       27,   32,   27,   29,   38,   32,   47,   97,   47,   32,
       29,   47,   95,   91,   29,   32,   91,   29,   32,   99,
       29,   32,   29,   29,   94,   44,  101,   94,  100,   44,

       35,   35,   32,   44,   29,  102,   32,   35,   35,   44,
       32,   29, 1270,   35,   91,   29,   32,   91,   29,   32,
     1266,   29,   32,   29,   29,   94,   44,  101,   94,   41,
       44,   35,   35,   41,   44, 1257,  102, 1244,   35,   35,
       44,   41, 1216,   45,   35,   41, 1215,   45,   41,   41,
     1148,   45,  198,  198,  103,   77,   77,   80,   80,  104,
       41,  104,   45, 1142,   41,   45,   77,   81,   80,   81,
       81,  107,   41,   98,   45,   98,   41,   46,   45,   41,
       41,   46,   45,   98,   46,  103,  105,   81,  105,  109,
      104,   46,  104,   45,   46,  106,   45,   77,  110,   80,

       96,   46,  107,  106,   98,  111,   98,  112,   46,   96,
       96,   96,   46,   96,   98,   46,  113,  105,   81,  105,
      109,  114,   46,  115,  113,   46,  106,  116,  117,  110,
      119,   96,   46,  120,  106,  123,  111,  124,  112, 1129,
       96,   96,   96,  122,   96,  127,  126,  113,  118,  118,
      122,  122,  114,  128,  115,  113,  126,  130,  116,  117,
      132,  119,  118,  133,  120,  137,  123,  140,  124,  125,
      125,  125,  134,  134,  122,  136,  127,  126,  136,  118,
      118,  122,  122,  129,  128,  141,  129,  126,  130,  138,
      134,  132,  129,  118,  133,  138,  137,  142,  140,  129,

      125,  125,  125,  134,  134,  135,  136,  139,  143,  136,
      144,  135,  145,  139,  129,  147,  141,  129,  135,  148,
      138,  134,  151,  129,  150,  152,  138,  150,  142,  200,
      129, 1095,  200,  153,  157,  154,  135, 1072,  139,  143,
      154,  144,  135,  145,  139,  158,  147,  149,  159,  135,
      148,  160,  149,  151,  154,  161,  152,  149,  149,  155,
      150,  155,  149,  149,  153,  157,  154,  156,  156,  163,
      164,  154,  165,  166,  168,  169,  158,  167,  149,  159,
      169,  167,  160,  149,  171,  154,  161,  167,  149,  149,
      155,  150,  155,  149,  149,  173,  175,  177,  156,  156,

      163,  164,  172,  165,  166,  168,  169, 1017,  167,  174,
      176,  169,  167,  172,  178,  171,  180,  174,  167,  170,
      179,  170,  176,  999,  170,  170,  173,  175,  177,  180,
      170,  179,  170,  172,  170,  935,  183,  170,  170,  927,
      174,  176,  184,  185,  172,  178,  182,  180,  174,  184,
      170,  179,  170,  176,  182,  170,  170,  186,  185,  197,
      180,  170,  179,  170,  199,  170,  182,  183,  170,  170,
      182,  188,  187,  184,  185,  189,  190,  182,  187,  189,
      184,  201,  190,  208,  188,  182,  847,  211,  186,  185,
      197,  212,  213,  207,  207,  199,  214,  182,  215,  216,

      218,  182,  188,  187,  207,  219,  189,  190,  220,  187,
      189,  221,  223,  190,  208,  188,  206,  206,  211,  217,
      206,  206,  212,  213,  224,  227,  201,  214,  217,  215,
      216,  218,  222,  228,  222,  207,  219,  226,  229,  220,
      230,  232,  221,  223,  234,  235,  236,  226,  237,  238,
      217,  232,  239,  240,  241,  224,  227,  243,  245,  217,
      247,  249,  250,  222,  228,  222,  251,  252,  226,  229,
      253,  230,  232,  254,  255,  234,  235,  236,  226,  237,
      238,  257,  232,  239,  240,  241,  258,  259,  243,  245,
      260,  247,  249,  250,  256,  261,  256,  251,  252,  260,

      263,  253,  262,  262,  254,  255,  264,  266,  266,  267,
      268,  256,  257,  269,  268,  270,  271,  258,  259,  272,
      273,  260,  274,  276,  278,  256,  261,  256,  277,  280,
      260,  263,  281,  262,  262,  277,  282,  264,  266,  266,
      267,  268,  256,  279,  269,  268,  270,  271,  283,  279,
      272,  273,  284,  274,  276,  278,  285,  287,  286,  277,
      280,  286,  288,  281,  289,  290,  277,  282,  291,  292,
      293,  294,  295,  296,  279,  297,  298,  299,  302,  283,
      279,  300,  826,  284,  303,  286,  305,  285,  287,  306,
      307,  300,  299,  288,  309,  289,  290,  310,  311,  291,

      292,  293,  294,  295,  296,  312,  297,  298,  299,  302,
      301,  313,  300,  301,  315,  303,  286,  305,  316,  317,
      306,  307,  300,  299,  314,  309,  319,  314,  310,  311,
      318,  320,  321,  318,  322,  323,  312,  325,  301,  324,
      326,  327,  313,  328,  329,  315,  301,  330,  324,  316,
      317,  331,  301,  332,  314,  318,  333,  319,  334,  335,
      314,  336,  320,  321,  337,  322,  323,  338,  325,  301,
      324,  326,  327,  339,  328,  329,  341,  301,  330,  324,
      342,  344,  331,  301,  332,  314,  318,  333,  345,  334,
      335,  314,  336,  340,  346,  337,  347,  348,  338,  349,

      350,  351,  352,  340,  339,  353,  354,  341,  355,  357,
      358,  342,  344,  359,  360,  359,  361,  362,  363,  345,
      365,  366,  367,  368,  340,  346,  367,  347,  348,  369,
      349,  350,  351,  352,  340,  370,  353,  354,  374,  355,
      357,  358,  373,  378,  359,  360,  359,  361,  362,  363,
      379,  365,  366,  367,  368,  373,  373,  367,  375,  375,
      369,  376,  376,  380,  381,  382,  370,  383,  384,  374,
      385,  386,  387,  388,  378,  389,  390,  391,  392,  393,
      394,  379,  395,  396,  397,  398,  399,  400,  401,  402,
      403,  404,  405,  407,  380,  381,  382,  390,  383,  384,

      408,  385,  386,  387,  388,  409,  389,  390,  391,  392,
      393,  394,  410,  395,  396,  397,  398,  399,  400,  401,
      402,  403,  404,  405,  407,  411,  412,  413,  414,  415,
      416,  408,  420,  423,  424,  425,  409,  426,  427,  428,
      429,  430,  431,  410,  432,  430,  433,  434,  435,  436,
      437,  438,  439,  441,  823,  444,  411,  412,  413,  414,
      415,  416,  446,  420,  423,  424,  425,  447,  426,  427,
      428,  429,  430,  431,  448,  432,  430,  433,  434,  435,
      436,  437,  438,  439,  441,  443,  444,  449,  443,  452,
      453,  454,  455,  446,  456,  458,  460,  457,  447,  462,

      457,  463,  464,  465,  466,  448,  467,  468,  469,  470,
      471,  472,  475,  476,  477,  478,  481,  473,  449,  484,
      452,  453,  454,  455,  457,  456,  458,  460,  473,  487,
      462,  489,  463,  464,  465,  466,  490,  467,  468,  469,
      470,  471,  472,  475,  476,  477,  478,  481,  473,  491,
      484,  492,  493,  494,  806,  457,  722,  495,  496,  473,
      487,  488,  489,  498,  488,  712,  499,  490,  500,  501,
      707,  502,  503,  504,  505,  507,  508,  509,  510,  511,
      491,  512,  492,  493,  494,  488,  513,  488,  495,  496,
      488,  514,  488,  515,  498,  488,  488,  499,  516,  500,

      501,  488,  502,  503,  504,  505,  507,  508,  509,  510,
      511,  517,  512,  519,  520,  522,  488,  513,  488,  524,
      525,  488,  514,  488,  515,  521,  488,  488,  521,  516,
      529,  530,  488,  531,  534,  535,  536,  537,  538,  539,
      540,  542,  517,  544,  519,  520,  522,  545,  546,  547,
      524,  525,  550,  551,  553,  554,  555,  556,  557,  558,
      559,  529,  530,  563,  531,  534,  535,  536,  537,  538,
      539,  540,  542,  564,  544,  565,  566,  568,  545,  546,
      547,  569,  570,  550,  551,  553,  554,  555,  556,  557,
      558,  559,  573,  574,  563,  576,  577,  578,  580,  582,

      585,  586,  587,  589,  564,  590,  565,  566,  568,  594,
      595,  596,  569,  570,  597,  598,  599,  600,  602,  603,
      604,  605,  606,  573,  574,  607,  576,  577,  578,  580,
      582,  585,  586,  587,  589,  608,  590,  609,  611,  612,
      594,  595,  596,  613,  614,  597,  598,  599,  600,  602,
      603,  604,  605,  606,  610,  615,  607,  610,  613,  618,
      620,  621,  622,  623,  624,  625,  608,  626,  609,  611,
      612,  627,  628,  630,  613,  614,  633,  634,  635,  637,
      638,  639,  640,  643,  636,  610,  615,  645,  646,  613,
      618,  620,  621,  622,  623,  624,  625,  636,  626,  647,

      648,  649,  627,  628,  630,  650,  651,  633,  634,  635,
      637,  638,  639,  640,  643,  636,  610,  652,  645,  646,
      653,  655,  656,  657,  660,  661,  662,  663,  636,  664,
      647,  648,  649,  668,  669,  665,  650,  651,  665,  670,
      671,  672,  673,  674,  675,  677,  679,  680,  652,  682,
      683,  653,  655,  656,  657,  660,  661,  662,  663,  684,
      664,  687,  688,  681,  668,  669,  681,  689,  690,  692,
      670,  671,  672,  673,  674,  675,  677,  679,  680,  691,
      682,  683,  691,  693,  694,  696,  697,  665,  700,  701,
      684,  681,  687,  688,  704,  705,  706,  708,  689,  690,

      692,  709,  710,  711,  713,  715,  713,  716,  713,  717,
      719,  720,  721,  723,  693,  694,  696,  697,  724,  700,
      701,  725,  681,  726,  729,  704,  705,  706,  708,  730,
      732,  733,  709,  710,  711,  713,  715,  713,  716,  713,
      717,  719,  720,  721,  723,  734,  737,  738,  739,  724,
      741,  742,  725,  743,  726,  729,  743,  744,  745,  746,
      730,  732,  733,  746,  748,  749,  752,  753,  755,  757,
      758,  759,  760,  765,  766,  768,  734,  737,  738,  739,
      769,  741,  742,  770,  771,  772,  774,  776,  744,  745,
      746,  777,  778,  779,  746,  748,  749,  752,  753,  755,

      757,  758,  759,  760,  765,  766,  768,  773,  781,  782,
      773,  769,  783,  784,  770,  771,  772,  774,  776,  785,
      788,  789,  777,  778,  779,  790,  791,  792,  793,  794,
      795,  796,  794,  797,  799,  801,  703,  802,  803,  781,
      782,  804,  805,  783,  784,  807,  808,  809,  811,  812,
      785,  788,  789,  813,  814,  820,  790,  791,  792,  793,
      815,  795,  796,  815,  797,  799,  801,  794,  802,  803,
      822,  827,  804,  805,  825,  825,  807,  808,  809,  811,
      812,  828,  829,  815,  813,  814,  820,  830,  832,  834,
      835,  836,  837,  838,  839,  840,  842,  843,  794,  834,

      844,  822,  827,  845,  834,  846,  844,  848,  849,  850,
      854,  856,  828,  829,  815,  857,  702,  571,  830,  832,
      834,  835,  836,  837,  838,  839,  840,  842,  843,  855,
      834,  844,  855,  862,  845,  834,  846,  844,  848,  849,
      850,  854,  856,  863,  858,  859,  857,  858,  859,  864,
      866,  867,  869,  866,  870,  872,  873,  874,  877,  878,
      879,  883,  562,  884,  862,  881,  885,  886,  881,  888,
      889,  890,  893,  894,  863,  859,  552,  895,  898,  899,
      864,  900,  867,  869,  901,  870,  872,  873,  874,  877,
      878,  879,  883,  881,  884,  902,  905,  885,  886,  906,

      888,  889,  890,  893,  894,  907,  859,  881,  895,  898,
      899,  908,  900,  910,  909,  901,  909,  911,  912,  913,
      915,  916,  917,  549,  881,  922,  902,  905,  923,  924,
      906,  925,  928,  929,  930,  931,  907,  932,  881,  933,
      934,  921,  908,  936,  910,  909,  938,  909,  911,  912,
      913,  915,  916,  917,  921,  921,  922,  939,  940,  923,
      924,  941,  925,  928,  929,  930,  931,  942,  932,  944,
      933,  934,  945,  943,  936,  946,  947,  938,  950,  951,
      948,  952,  951,  948,  953,  955,  958,  959,  939,  940,
      548,  960,  941,  943,  960,  962,  957,  963,  942,  957,

      944,  533,  964,  945,  943,  948,  946,  947,  965,  950,
      968,  969,  952,  971,  972,  953,  955,  958,  959,  951,
      967,  957,  948,  967,  943,  957,  962,  973,  963,  976,
      977,  523,  957,  964,  978,  979,  948,  980,  957,  965,
      981,  968,  969,  982,  971,  972,  983,  984,  967,  985,
      951,  987,  957,  948,  989,  990,  957,  991,  973,  992,
      976,  977,  967,  957,  993,  978,  979,  994,  980,  957,
      995,  981,  996,  997,  982,  998, 1000,  983,  984,  967,
      985, 1001,  987, 1002, 1003,  989,  990, 1004,  991, 1005,
      992, 1006, 1007,  967, 1008,  993, 1009, 1010,  994, 1011,

     1013,  995, 1004,  996,  997,  485,  998, 1000, 1014, 1015,
     1016, 1019, 1001, 1020, 1002, 1003, 1021, 1023, 1004, 1024,
     1005, 1025, 1006, 1007, 1026, 1008, 1027, 1009, 1010, 1028,
     1011, 1013, 1012, 1004, 1012, 1029, 1012, 1012, 1030, 1014,
     1015, 1016, 1019, 1031, 1020, 1032, 1033, 1021, 1023, 1034,
     1024, 1035, 1025, 1038, 1044, 1026, 1038, 1027, 1045, 1046,
     1028, 1047,  265, 1012, 1048, 1012, 1029, 1012, 1012, 1030,
     1052, 1053, 1057, 1058, 1031, 1060, 1032, 1033, 1063, 1064,
     1034, 1065, 1035, 1068, 1069, 1044, 1073, 1074, 1076, 1045,
     1046, 1077, 1047, 1038, 1078, 1048, 1079, 1080, 1081, 1082,

     1083, 1052, 1053, 1057, 1058, 1084, 1060, 1085, 1086, 1063,
     1064, 1088, 1065, 1089, 1068, 1069, 1091, 1073, 1074, 1076,
     1087, 1092, 1077, 1093, 1038, 1078, 1087, 1079, 1080, 1081,
     1082, 1083, 1094, 1096, 1098, 1100, 1084, 1101, 1085, 1086,
     1103, 1106, 1088, 1104, 1089, 1107, 1104, 1091, 1108, 1110,
     1109, 1087, 1092, 1109, 1093, 1111, 1112, 1087, 1113, 1114,
     1115, 1116, 1119, 1094, 1096, 1098, 1100, 1121, 1101, 1123,
     1124, 1103, 1106, 1125, 1126, 1131, 1107, 1132, 1133, 1108,
     1110, 1134, 1135, 1136, 1137, 1139, 1111, 1112, 1143, 1113,
     1114, 1115, 1116, 1119, 1144, 1145, 1146, 1147, 1121, 1151,

     1123, 1124, 1152, 1153, 1125, 1126, 1131, 1154, 1132, 1133,
     1155, 1156, 1134, 1135, 1136, 1137, 1139, 1158, 1160, 1143,
     1158, 1161, 1163, 1164, 1165, 1144, 1145, 1146, 1147, 1162,
     1151, 1167, 1162, 1152, 1153,  193, 1169, 1176, 1154, 1179,
     1180, 1155, 1156, 1181, 1182, 1183, 1184, 1185, 1186, 1160,
     1187, 1188, 1161, 1163, 1164, 1165, 1190, 1158, 1191, 1192,
     1193, 1194, 1167, 1195, 1196, 1197, 1162, 1169, 1176, 1198,
     1179, 1180, 1201, 1202, 1181, 1182, 1183, 1184, 1185, 1186,
     1203, 1187, 1188, 1204, 1211, 1213, 1214, 1190, 1158, 1191,
     1192, 1193, 1194, 1217, 1195, 1196, 1197, 1162, 1218, 1219,

     1198, 1220, 1221, 1201, 1202, 1222, 1223, 1225, 1226, 1227,
     1228, 1203, 1229, 1230, 1204, 1211, 1213, 1214, 1232, 1234,
     1235, 1237, 1241, 1243, 1217, 1245, 1246, 1247, 1248, 1218,
     1219, 1249, 1220, 1221, 1250, 1251, 1222, 1223, 1225, 1226,
     1227, 1228, 1252, 1229, 1230, 1254, 1255, 1256, 1258, 1232,
     1234, 1235, 1237, 1241, 1243, 1261, 1245, 1246, 1247, 1248,
     1263, 1268, 1249, 1269, 1272, 1250, 1251, 1274, 1277, 1278,
     1279, 1283, 1284, 1252, 1283, 1287, 1254, 1255, 1256, 1258,
     1288, 1289, 1291, 1294, 1295, 1296, 1261, 1295, 1296, 1297,
     1299, 1263, 1268, 1300, 1269, 1272, 1301, 1302, 1274, 1277,

     1278, 1279, 1303, 1284, 1304, 1305, 1287, 1306, 1307, 1309,
     1310, 1288, 1289, 1291, 1294, 1295, 1311, 1313, 1295, 1314,
     1297, 1299, 1315, 1316, 1300, 1296, 1317, 1301, 1302, 1319,
     1321, 1323, 1324, 1303, 1325, 1304, 1305, 1328, 1306, 1307,
     1309, 1310, 1329, 1330, 1331, 1332, 1333, 1311, 1313, 1335,
     1314, 1336, 1337, 1315, 1316, 1338, 1296, 1317, 1339, 1340,
     1319, 1321, 1323, 1324, 1341, 1325, 1343, 1344, 1328, 1346,
     1347, 1348, 1349, 1329, 1330, 1331, 1332, 1333, 1351, 1352,
     1335, 1354, 1336, 1337, 1355, 1357, 1338,  192,  191, 1339,
     1340,   90,   85,   76,   71, 1341,   54, 1343, 1344,   50,

     1346, 1347, 1348, 1349,   24,   22,   16,   15,   12, 1351,
     1352,   11, 1354,    9,    5, 1355, 1357, 1360, 1360, 1360,
     1360, 1360, 1361,    0, 1361, 1361, 1361, 1362, 1362, 1362,
     1362, 1362, 1363, 1363, 1364,    0, 1364, 1364, 1364, 1365,
        0, 1365, 1365, 1365, 1366,    0, 1366, 1366, 1366, 1368,
     1368, 1370, 1370, 1370, 1370, 1370, 1371, 1371, 1371, 1372,
     1372, 1372, 1373,    0, 1373, 1373, 1373, 1374, 1374, 1374,
     1375, 1375, 1375, 1376, 1376, 1376, 1377, 1377, 1377, 1378,
     1378, 1378, 1379, 1379, 1379, 1380, 1380, 1380, 1381, 1381,
     1381, 1381, 1381, 1382, 1382, 1382, 1383, 1383, 1383, 1384,

        0, 1384, 1384, 1384, 1385, 1385, 1385, 1386, 1386, 1386,
     1387, 1387, 1387, 1388, 1388, 1388, 1389, 1389, 1389, 1390,
     1390, 1390, 1391, 1391, 1391, 1392, 1392, 1392, 1393, 1393,
     1393, 1394, 1394, 1394, 1395, 1395, 1395, 1396, 1396, 1396,
     1397, 1397, 1397, 1398, 1398, 1398, 1399, 1399, 1399, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,

     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359, 1359,
     1359, 1359, 1359
    } ;

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[291] =
    {   0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
    1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
    0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 
    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 
    0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,     };

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;


/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// In case there is any doubt, 'cql.l' is included in the license as well as
// the code flex generates from it.


#ifndef _MSC_VER

#else

static char *realpath(const char *relpath, char *absPathBuffer) {
    // Check if the file exists before resolving
    if (_access(relpath, 0) != 0) {
        return NULL;  // File does not exist
    }

    // Resolve absolute path
    return _fullpath(absPathBuffer, relpath, _MAX_PATH);
}

static char *dirname(char *path) {
    if (path == NULL || *path == '\0') {
        return ".";  // Return current directory for empty paths
    }

    // Find last backslash or forward slash
    char *lastSlash = strrchr(path, '\\');
    if (!lastSlash) {
        lastSlash = strrchr(path, '/');
    }

    if (lastSlash) {
        if (lastSlash == path) {  // If the only slash is at the start (e.g., "/home")
            *(lastSlash + 1) = '\0';
        } else {
            *lastSlash = '\0';  // Truncate path at last slash
        }
    } else {
        return ".";  // No slash found, return current directory
    }

    return path;
}

#endif

void yyerror(const char *s, ...);
void line_directive(const char *);
char *Strdup(const char *);
static CSTR last_doc_comment = NULL;

static bool_t cql_already_processed_file(CSTR);
static void cql_record_processed_file(CSTR);

#ifndef CQL_AMALGAM
// already in the headers in the amalgam
int fileno(FILE *);
#endif

// the lexer has unused functions and implicit conversions, not easily removed

#ifndef _MSC_VER

#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wconversion"
#pragma clang diagnostic ignored "-Wmisleading-indentation"

#endif


cql_noexport CSTR get_last_doc_comment() {
  CSTR result = last_doc_comment;
  last_doc_comment = NULL;
  return result;
}

static bool cql_builtins_processing = false;
static bool cql_delete_main_buffer = false;
static YY_BUFFER_STATE cql_main_buffer;

// this remembers the directory in which we found the most recent file
// later paths are relative to this by default
static char ambient_path[PATH_MAX];

cql_noexport void cql_setup_for_builtins() {
  // stash a buffer for the main input, note that we might already have a buffer
  // in the amalgam case, if we do then use that.
  if (YY_CURRENT_BUFFER) {
    cql_main_buffer = YY_CURRENT_BUFFER;
    cql_delete_main_buffer = false;
  }
  else {
    // if we don't already have a buffer make one using yyin or stdin
    cql_main_buffer = yy_create_buffer(yyin ? yyin : stdin, YY_BUF_SIZE);
    cql_delete_main_buffer = true;
  }

  // add the builtin declares before we process the real input
  yy_scan_string(cql_builtin_text());
  cql_builtins_processing = true;

  // use the path part of the initial input file as the starting ambient path
  if (!strcmp("<stdin>", current_file)) {
     ambient_path[0] = '\0';
  }
  else {
    strncpy(ambient_path, current_file, sizeof(ambient_path));
    ambient_path[sizeof(ambient_path)-1] = 0;
    dirname(ambient_path);
  }
}

#define MAX_INCLUDES 10

typedef struct {
  YY_BUFFER_STATE buf;
  int32_t line_saved;
  char *filename_saved;
  char *ambient_saved;
} cql_include_state;

static cql_include_state cql_includes[MAX_INCLUDES];
static int cql_include_index = 0;

static symtab *processed_files;

cql_noexport void cql_reset_open_includes() {
  ambient_path[0] = '\0';
  cql_include_index = 0;
  memset(cql_includes, 0, sizeof(cql_includes));
  if (processed_files) {
    symtab_delete(processed_files);
    processed_files = NULL;
  }
}

cql_noexport void cql_cleanup_open_includes() {
  for (int32_t i = 0; i < cql_include_index; i++) {
     cql_include_state *inc = &cql_includes[i];
     yy_delete_buffer(inc->buf);
  }
  cql_reset_open_includes();
}

static void cql_setup_for_include(CSTR str) {
  if (!processed_files) {
    processed_files = symtab_new();
  }

  if (cql_include_index >= MAX_INCLUDES) {
    cql_error("%s:%d includes nested too deeply.\n", current_file, yylineno);
    cql_cleanup_and_exit(4);
  }

  cql_include_state *inc = &cql_includes[cql_include_index];

  inc->buf = YY_CURRENT_BUFFER;
  inc->line_saved = yylineno;
  inc->filename_saved = current_file;
  inc->ambient_saved = Strdup(ambient_path);
  cql_include_index++;

  CHARBUF_OPEN(name);
  CHARBUF_OPEN(path);
  char resolved_path[PATH_MAX];  // PATH_MAX is defined in limits.h

  cg_decode_c_string_literal(str, &name);

  yyin = NULL;

  // Call realpath to resolve the pathname
  bclear(&path);
  if (ambient_path[0]) {
    bprintf(&path, "%s/%s", ambient_path, name.ptr);
  }
  else {
    bprintf(&path, "%s", name.ptr);
  }

  CSTR opened_name = path.ptr;

  char *abspath = realpath(path.ptr, resolved_path);
  if (abspath) {
    if (cql_already_processed_file(abspath)) {
      yy_switch_to_buffer(yy_scan_string(""));
      goto done;
    }
    strcpy(ambient_path, path.ptr);
    dirname(ambient_path);
    yyin = fopen(abspath, "r");
  }

  if (!yyin) {
     for (int i = 0; i < options.include_paths_count; i++) {
        bclear(&path);
        bprintf(&path, "%s/%s", options.include_paths[i], name.ptr);
        abspath = realpath(path.ptr, resolved_path);
        if (abspath) {
          if (cql_already_processed_file(abspath)) {
            yy_switch_to_buffer(yy_scan_string(""));
            goto done;
          }

          strcpy(ambient_path, path.ptr);
          dirname(ambient_path);
          yyin = fopen(path.ptr, "r");
          if (yyin) {
            opened_name = path.ptr;
            break;
          }
        }
     }
  }

  if (!yyin) {
     cql_error("%s:%d unable to open %s\n", current_file, yylineno, str);
     cql_cleanup_and_exit(1);
  }

  cql_record_processed_file(abspath);
  yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));

done:

  yylineno = 1;
  current_file = Strdup(opened_name);

  CHARBUF_CLOSE(path);
  CHARBUF_CLOSE(name);
}

static void cql_finish_stream() {
  // when we read the end of the temporary buffer we switch to the main buffer
  cql_builtins_processing = false;
  yy_delete_buffer(YY_CURRENT_BUFFER);
  yy_switch_to_buffer(cql_main_buffer);
}

static void cql_record_processed_file(CSTR str) {
  Contract(processed_files);
  symtab_add(processed_files, Strdup(str), NULL);
}

static bool_t cql_already_processed_file(CSTR str) {
  Contract(processed_files);
  return !!symtab_find(processed_files, str);
}


#define INITIAL 0
#define at_inc 1

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals ( void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( void );

int yyget_debug ( void );

void yyset_debug ( int debug_flag  );

YY_EXTRA_TYPE yyget_extra ( void );

void yyset_extra ( YY_EXTRA_TYPE user_defined  );

FILE *yyget_in ( void );

void yyset_in  ( FILE * _in_str  );

FILE *yyget_out ( void );

void yyset_out  ( FILE * _out_str  );

			int yyget_leng ( void );

char *yyget_text ( void );

int yyget_lineno ( void );

void yyset_lineno ( int _line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( void );
#else
extern int yywrap ( void );
#endif
#endif

#ifndef YY_NO_UNPUT
    
    static void yyunput ( int c, char *buf_ptr  );
    
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( void );
#else
static int input ( void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
				(yytext[yyleng - 1] == '\n'); \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    
	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE );
		}

		yy_load_buffer_state(  );
		}

	{



	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
		yy_current_state += YY_AT_BOL();
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 1360 )
					yy_c = yy_meta[yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 1359 );
		yy_cp = (yy_last_accepting_cpos);
		yy_current_state = (yy_last_accepting_state);

yy_find_action:
		yy_act = yy_accept[yy_current_state];

		YY_DO_BEFORE_ACTION;

		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
			{
			int yyl;
			for ( yyl = 0; yyl < yyleng; ++yyl )
				if ( yytext[yyl] == '\n' )
					
    yylineno++;
;
			}

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
YY_RULE_SETUP
{
                                   BEGIN(at_inc);
                                   return BEGIN_INCLUDE;
                                 }
	YY_BREAK
case 2:
YY_RULE_SETUP

	YY_BREAK
case 3:
YY_RULE_SETUP
{
                                   cql_setup_for_include(yytext);
                                   BEGIN(INITIAL);
                                 }
	YY_BREAK
case 4:
YY_RULE_SETUP
{ return AT_IFDEF; }
	YY_BREAK
case 5:
YY_RULE_SETUP
{ return AT_IFNDEF; }
	YY_BREAK
case 6:
YY_RULE_SETUP
{ return AT_ELSE; }
	YY_BREAK
case 7:
YY_RULE_SETUP
{ return AT_ENDIF; }
	YY_BREAK
case 8:
YY_RULE_SETUP
{ return BEGIN_INCLUDE; }
	YY_BREAK
case 9:
YY_RULE_SETUP
{ return END_INCLUDE; }
	YY_BREAK
case 10:
YY_RULE_SETUP
{ return AT_ATTRIBUTE; }
	YY_BREAK
case 11:
YY_RULE_SETUP
{ return AT_BEGIN_SCHEMA_REGION; }
	YY_BREAK
case 12:
YY_RULE_SETUP
{ return AT_COLUMNS; }
	YY_BREAK
case 13:
YY_RULE_SETUP
{ return AT_CREATE; }
	YY_BREAK
case 14:
YY_RULE_SETUP
{ return AT_DECLARE_DEPLOYABLE_REGION; }
	YY_BREAK
case 15:
YY_RULE_SETUP
{ return AT_DECLARE_SCHEMA_REGION; }
	YY_BREAK
case 16:
YY_RULE_SETUP
{ return AT_DELETE; }
	YY_BREAK
case 17:
YY_RULE_SETUP
{ return AT_DUMMY_DEFAULTS; }
	YY_BREAK
case 18:
YY_RULE_SETUP
{ return AT_DUMMY_NULLABLES; }
	YY_BREAK
case 19:
YY_RULE_SETUP
{ return AT_DUMMY_SEED; }
	YY_BREAK
case 20:
YY_RULE_SETUP
{ return AT_ECHO; }
	YY_BREAK
case 21:
YY_RULE_SETUP
{ return AT_EMIT_CONSTANTS; }
	YY_BREAK
case 22:
YY_RULE_SETUP
{ return AT_EMIT_ENUMS; }
	YY_BREAK
case 23:
YY_RULE_SETUP
{ return AT_EMIT_GROUP; }
	YY_BREAK
case 24:
YY_RULE_SETUP
{ return AT_END_SCHEMA_REGION; }
	YY_BREAK
case 25:
YY_RULE_SETUP
{ return AT_ENFORCE_NORMAL; }
	YY_BREAK
case 26:
YY_RULE_SETUP
{ return AT_ENFORCE_POP; }
	YY_BREAK
case 27:
YY_RULE_SETUP
{ return AT_ENFORCE_PUSH; }
	YY_BREAK
case 28:
YY_RULE_SETUP
{ return AT_ENFORCE_RESET; }
	YY_BREAK
case 29:
YY_RULE_SETUP
{ return AT_ENFORCE_STRICT; }
	YY_BREAK
case 30:
YY_RULE_SETUP
{ return AT_EPONYMOUS; }
	YY_BREAK
case 31:
YY_RULE_SETUP
{ return AT_FILE; }
	YY_BREAK
case 32:
YY_RULE_SETUP
{ return AT_ID; }
	YY_BREAK
case 33:
YY_RULE_SETUP
{ return AT_KEEP_TABLE_NAME_IN_ALIASES; }
	YY_BREAK
case 34:
YY_RULE_SETUP
{ return AT_LINE; }
	YY_BREAK
case 35:
YY_RULE_SETUP
{ return AT_MACRO_FILE; }
	YY_BREAK
case 36:
YY_RULE_SETUP
{ return AT_MACRO_LINE; }
	YY_BREAK
case 37:
YY_RULE_SETUP
{ return AT_MACRO; }
	YY_BREAK
case 38:
YY_RULE_SETUP
{ return AT_OP; }
	YY_BREAK
case 39:
YY_RULE_SETUP
{ return AT_PREVIOUS_SCHEMA; }
	YY_BREAK
case 40:
YY_RULE_SETUP
{ return AT_PROC; }
	YY_BREAK
case 41:
YY_RULE_SETUP
{ return AT_RC; }
	YY_BREAK
case 42:
YY_RULE_SETUP
{ return AT_RECREATE; }
	YY_BREAK
case 43:
YY_RULE_SETUP
{ return AT_SCHEMA_AD_HOC_MIGRATION; }
	YY_BREAK
case 44:
YY_RULE_SETUP
{ return AT_SCHEMA_UPGRADE_SCRIPT; }
	YY_BREAK
case 45:
YY_RULE_SETUP
{ return AT_SCHEMA_UPGRADE_VERSION; }
	YY_BREAK
case 46:
YY_RULE_SETUP
{ return AT_SENSITIVE; }
	YY_BREAK
case 47:
YY_RULE_SETUP
{ return AT_TEXT; }
	YY_BREAK
case 48:
YY_RULE_SETUP
{ return AT_TMP; }
	YY_BREAK
case 49:
YY_RULE_SETUP
{ return AT_UNSUB; }
	YY_BREAK
case 50:
YY_RULE_SETUP
{ return ABORT; }
	YY_BREAK
case 51:
YY_RULE_SETUP
{ return ACTION; }
	YY_BREAK
case 52:
YY_RULE_SETUP
{ return ADD; }
	YY_BREAK
case 53:
YY_RULE_SETUP
{ return AFTER; }
	YY_BREAK
case 54:
YY_RULE_SETUP
{ return ALL; }
	YY_BREAK
case 55:
YY_RULE_SETUP
{ return ALTER; }
	YY_BREAK
case 56:
YY_RULE_SETUP
{ return AND; }
	YY_BREAK
case 57:
YY_RULE_SETUP
{ return ARGUMENTS; }
	YY_BREAK
case 58:
YY_RULE_SETUP
{ return AS; }
	YY_BREAK
case 59:
YY_RULE_SETUP
{ return ASC; }
	YY_BREAK
case 60:
YY_RULE_SETUP
{ return AUTOINCREMENT; }
	YY_BREAK
case 61:
YY_RULE_SETUP
{ return BEFORE; }
	YY_BREAK
case 62:
YY_RULE_SETUP
{ return BEGIN_; }
	YY_BREAK
case 63:
YY_RULE_SETUP
{ return BETWEEN; }
	YY_BREAK
case 64:
YY_RULE_SETUP
{ return BLOB; }
	YY_BREAK
case 65:
YY_RULE_SETUP
{ return BOOL_; }
	YY_BREAK
case 66:
YY_RULE_SETUP
{ return BY; }
	YY_BREAK
case 67:
YY_RULE_SETUP
{ return CALL; }
	YY_BREAK
case 68:
YY_RULE_SETUP
{ return CASCADE; }
	YY_BREAK
case 69:
YY_RULE_SETUP
{ return CASE; }
	YY_BREAK
case 70:
YY_RULE_SETUP
{ return CAST; }
	YY_BREAK
case 71:
YY_RULE_SETUP
{ return CATCH; }
	YY_BREAK
case 72:
YY_RULE_SETUP
{ return CHECK; }
	YY_BREAK
case 73:
YY_RULE_SETUP
{ return CLOSE; }
	YY_BREAK
case 74:
YY_RULE_SETUP
{ return COLLATE; }
	YY_BREAK
case 75:
YY_RULE_SETUP
{ return COLUMN; }
	YY_BREAK
case 76:
YY_RULE_SETUP
{ return COMMIT; }
	YY_BREAK
case 77:
YY_RULE_SETUP
{ return CONST; }
	YY_BREAK
case 78:
YY_RULE_SETUP
{ return CONSTRAINT; }
	YY_BREAK
case 79:
/* rule 79 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return CONTEXT_COLUMN; }
	YY_BREAK
case 80:
/* rule 80 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return CONTEXT_TYPE; }
	YY_BREAK
case 81:
YY_RULE_SETUP
{ return CONTINUE; }
	YY_BREAK
case 82:
YY_RULE_SETUP
{ return CREATE; }
	YY_BREAK
case 83:
YY_RULE_SETUP
{ return CROSS; }
	YY_BREAK
case 84:
YY_RULE_SETUP
{ return CTE_TABLES; }
	YY_BREAK
case 85:
/* rule 85 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return CURRENT_ROW; }
	YY_BREAK
case 86:
YY_RULE_SETUP
{ return CURSOR; }
	YY_BREAK
case 87:
/* rule 87 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return CURSOR_HAS_ROW; }
	YY_BREAK
case 88:
YY_RULE_SETUP
{ return DECLARE; }
	YY_BREAK
case 89:
YY_RULE_SETUP
{ return DEFAULT; }
	YY_BREAK
case 90:
YY_RULE_SETUP
{ return DEFERRABLE; }
	YY_BREAK
case 91:
YY_RULE_SETUP
{ return DEFERRED; }
	YY_BREAK
case 92:
YY_RULE_SETUP
{ return DELETE; }
	YY_BREAK
case 93:
YY_RULE_SETUP
{ return DESC; }
	YY_BREAK
case 94:
YY_RULE_SETUP
{ return DISTINCT; }
	YY_BREAK
case 95:
YY_RULE_SETUP
{ return DISTINCTROW; }
	YY_BREAK
case 96:
YY_RULE_SETUP
{ return DO; }
	YY_BREAK
case 97:
YY_RULE_SETUP
{ return DROP; }
	YY_BREAK
case 98:
YY_RULE_SETUP
{ return ELSE; }
	YY_BREAK
case 99:
/* rule 99 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return ELSE_IF; }
	YY_BREAK
case 100:
YY_RULE_SETUP
{ return ENCODE; }
	YY_BREAK
case 101:
YY_RULE_SETUP
{ return END; }
	YY_BREAK
case 102:
YY_RULE_SETUP
{ return ENUM; }
	YY_BREAK
case 103:
YY_RULE_SETUP
{ return EXCEPT; }
	YY_BREAK
case 104:
/* rule 104 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return EXCLUDE_CURRENT_ROW; }
	YY_BREAK
case 105:
/* rule 105 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return EXCLUDE_GROUP; }
	YY_BREAK
case 106:
/* rule 106 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return EXCLUDE_NO_OTHERS; }
	YY_BREAK
case 107:
/* rule 107 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return EXCLUDE_TIES; }
	YY_BREAK
case 108:
YY_RULE_SETUP
{ return EXCLUSIVE; }
	YY_BREAK
case 109:
YY_RULE_SETUP
{ return EXISTS; }
	YY_BREAK
case 110:
YY_RULE_SETUP
{ return EXPLAIN; }
	YY_BREAK
case 111:
YY_RULE_SETUP
{ return EXPR; }
	YY_BREAK
case 112:
YY_RULE_SETUP
{ return FAIL; }
	YY_BREAK
case 113:
YY_RULE_SETUP
{ return FALSE_; }
	YY_BREAK
case 114:
YY_RULE_SETUP
{ return FETCH; }
	YY_BREAK
case 115:
YY_RULE_SETUP
{ return FILTER; }
	YY_BREAK
case 116:
YY_RULE_SETUP
{ return FIRST; }
	YY_BREAK
case 117:
YY_RULE_SETUP
{ return FOLLOWING; }
	YY_BREAK
case 118:
YY_RULE_SETUP
{ return FOR; }
	YY_BREAK
case 119:
YY_RULE_SETUP
{ return FOREIGN; }
	YY_BREAK
case 120:
/* rule 120 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return FOR_EACH_ROW; }
	YY_BREAK
case 121:
YY_RULE_SETUP
{ return FROM; }
	YY_BREAK
case 122:
YY_RULE_SETUP
{ return FUNC; }
	YY_BREAK
case 123:
YY_RULE_SETUP
{ return FUNCTION; }
	YY_BREAK
case 124:
YY_RULE_SETUP
{ return GLOB; }
	YY_BREAK
case 125:
YY_RULE_SETUP
{ return GROUP; }
	YY_BREAK
case 126:
YY_RULE_SETUP
{ return GROUPS; }
	YY_BREAK
case 127:
YY_RULE_SETUP
{ return HAVING; }
	YY_BREAK
case 128:
YY_RULE_SETUP
{ return HIDDEN; }
	YY_BREAK
case 129:
YY_RULE_SETUP
{ return IF; }
	YY_BREAK
case 130:
YY_RULE_SETUP
{ return IGNORE; }
	YY_BREAK
case 131:
YY_RULE_SETUP
{ return IMMEDIATE; }
	YY_BREAK
case 132:
YY_RULE_SETUP
{ return IN; }
	YY_BREAK
case 133:
YY_RULE_SETUP
{ return INDEX; }
	YY_BREAK
case 134:
YY_RULE_SETUP
{ return INITIALLY; }
	YY_BREAK
case 135:
YY_RULE_SETUP
{ return INNER; }
	YY_BREAK
case 136:
YY_RULE_SETUP
{ return INOUT; }
	YY_BREAK
case 137:
YY_RULE_SETUP
{ return INSERT; }
	YY_BREAK
case 138:
YY_RULE_SETUP
{ return INSTEAD; }
	YY_BREAK
case 139:
YY_RULE_SETUP
{ return INT_; }
	YY_BREAK
case 140:
YY_RULE_SETUP
{ return INTEGER; }
	YY_BREAK
case 141:
YY_RULE_SETUP
{ return INTERFACE; }
	YY_BREAK
case 142:
YY_RULE_SETUP
{ return INTERSECT; }
	YY_BREAK
case 143:
YY_RULE_SETUP
{ return INTO; }
	YY_BREAK
case 144:
YY_RULE_SETUP
{ return IS; }
	YY_BREAK
case 145:
YY_RULE_SETUP
{ return ISNULL; }
	YY_BREAK
case 146:
/* rule 146 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return IS_FALSE; }
	YY_BREAK
case 147:
/* rule 147 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return IS_NOT; }
	YY_BREAK
case 148:
/* rule 148 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return IS_NOT_FALSE; }
	YY_BREAK
case 149:
/* rule 149 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return IS_NOT_TRUE; }
	YY_BREAK
case 150:
/* rule 150 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return IS_TRUE; }
	YY_BREAK
case 151:
YY_RULE_SETUP
{ return JOIN; }
	YY_BREAK
case 152:
YY_RULE_SETUP
{ return KEY; }
	YY_BREAK
case 153:
YY_RULE_SETUP
{ return LAST; }
	YY_BREAK
case 154:
YY_RULE_SETUP
{ return LEAVE; }
	YY_BREAK
case 155:
YY_RULE_SETUP
{ return LEFT; }
	YY_BREAK
case 156:
YY_RULE_SETUP
{ return LET; }
	YY_BREAK
case 157:
YY_RULE_SETUP
{ return LIKE; }
	YY_BREAK
case 158:
YY_RULE_SETUP
{ return LIMIT; }
	YY_BREAK
case 159:
YY_RULE_SETUP
{ return LONG_; }
	YY_BREAK
case 160:
YY_RULE_SETUP
{ return LONG_INT; }
	YY_BREAK
case 161:
YY_RULE_SETUP
{ return LONG_INTEGER; }
	YY_BREAK
case 162:
YY_RULE_SETUP
{ return LOOP; }
	YY_BREAK
case 163:
YY_RULE_SETUP
{ return MATCH; }
	YY_BREAK
case 164:
YY_RULE_SETUP
{ return NO; }
	YY_BREAK
case 165:
YY_RULE_SETUP
{ return NOT; }
	YY_BREAK
case 166:
YY_RULE_SETUP
{ return NOTHING; }
	YY_BREAK
case 167:
YY_RULE_SETUP
{ return NOTNULL; }
	YY_BREAK
case 168:
/* rule 168 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return NOT_BETWEEN; }
	YY_BREAK
case 169:
/* rule 169 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return NOT_DEFERRABLE; }
	YY_BREAK
case 170:
/* rule 170 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return NOT_GLOB; }
	YY_BREAK
case 171:
/* rule 171 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return NOT_IN; }
	YY_BREAK
case 172:
/* rule 172 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return NOT_LIKE; }
	YY_BREAK
case 173:
/* rule 173 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return NOT_MATCH; }
	YY_BREAK
case 174:
/* rule 174 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return NOT_REGEXP; }
	YY_BREAK
case 175:
YY_RULE_SETUP
{ return NULL_; }
	YY_BREAK
case 176:
YY_RULE_SETUP
{ return NULLS; }
	YY_BREAK
case 177:
YY_RULE_SETUP
{ return OBJECT; }
	YY_BREAK
case 178:
YY_RULE_SETUP
{ return OF; }
	YY_BREAK
case 179:
YY_RULE_SETUP
{ return OFFSET; }
	YY_BREAK
case 180:
YY_RULE_SETUP
{ return ON; }
	YY_BREAK
case 181:
/* rule 181 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return ON_CONFLICT; }
	YY_BREAK
case 182:
YY_RULE_SETUP
{ return OR; }
	YY_BREAK
case 183:
YY_RULE_SETUP
{ return ORDER; }
	YY_BREAK
case 184:
YY_RULE_SETUP
{ return OUT; }
	YY_BREAK
case 185:
YY_RULE_SETUP
{ return OUTER; }
	YY_BREAK
case 186:
YY_RULE_SETUP
{ return OVER; }
	YY_BREAK
case 187:
YY_RULE_SETUP
{ return PARTITION; }
	YY_BREAK
case 188:
YY_RULE_SETUP
{ return PRECEDING; }
	YY_BREAK
case 189:
YY_RULE_SETUP
{ return PRIMARY; }
	YY_BREAK
case 190:
YY_RULE_SETUP
{ return PRIVATE; }
	YY_BREAK
case 191:
YY_RULE_SETUP
{ return PROC; }
	YY_BREAK
case 192:
YY_RULE_SETUP
{ return PROCEDURE; }
	YY_BREAK
case 193:
YY_RULE_SETUP
{ return QUERY_PARTS; }
	YY_BREAK
case 194:
/* rule 194 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return QUERY_PLAN; }
	YY_BREAK
case 195:
YY_RULE_SETUP
{ return RAISE; }
	YY_BREAK
case 196:
YY_RULE_SETUP
{ return RANGE; }
	YY_BREAK
case 197:
YY_RULE_SETUP
{ return REAL; }
	YY_BREAK
case 198:
YY_RULE_SETUP
{ return RECURSIVE; }
	YY_BREAK
case 199:
YY_RULE_SETUP
{ return REFERENCES; }
	YY_BREAK
case 200:
YY_RULE_SETUP
{ return REGEXP; }
	YY_BREAK
case 201:
YY_RULE_SETUP
{ return RELEASE; }
	YY_BREAK
case 202:
YY_RULE_SETUP
{ return RENAME; }
	YY_BREAK
case 203:
YY_RULE_SETUP
{ return REPLACE; }
	YY_BREAK
case 204:
YY_RULE_SETUP
{ return RESTRICT; }
	YY_BREAK
case 205:
YY_RULE_SETUP
{ return RETURN; }
	YY_BREAK
case 206:
YY_RULE_SETUP
{ return RETURNING; }
	YY_BREAK
case 207:
YY_RULE_SETUP
{ return RIGHT; }
	YY_BREAK
case 208:
YY_RULE_SETUP
{ return ROLLBACK; }
	YY_BREAK
case 209:
YY_RULE_SETUP
{ return ROWID; }
	YY_BREAK
case 210:
YY_RULE_SETUP
{ return ROWS; }
	YY_BREAK
case 211:
YY_RULE_SETUP
{ return SAVEPOINT; }
	YY_BREAK
case 212:
YY_RULE_SETUP
{ return SELECT; }
	YY_BREAK
case 213:
YY_RULE_SETUP
{ return SELECT_CORE; }
	YY_BREAK
case 214:
YY_RULE_SETUP
{ return SELECT_EXPR; }
	YY_BREAK
case 215:
YY_RULE_SETUP
{ return SET; }
	YY_BREAK
case 216:
/* rule 216 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return SIGN_FUNCTION; }
	YY_BREAK
case 217:
YY_RULE_SETUP
{ return STATEMENT; }
	YY_BREAK
case 218:
YY_RULE_SETUP
{ return STMT_LIST; }
	YY_BREAK
case 219:
YY_RULE_SETUP
{ return SWITCH; }
	YY_BREAK
case 220:
YY_RULE_SETUP
{ return TABLE; }
	YY_BREAK
case 221:
YY_RULE_SETUP
{ return TEMP; }
	YY_BREAK
case 222:
YY_RULE_SETUP
{ return TEXT; }
	YY_BREAK
case 223:
YY_RULE_SETUP
{ return THEN; }
	YY_BREAK
case 224:
YY_RULE_SETUP
{ return THROW; }
	YY_BREAK
case 225:
YY_RULE_SETUP
{ return TO; }
	YY_BREAK
case 226:
YY_RULE_SETUP
{ return TRANSACTION; }
	YY_BREAK
case 227:
YY_RULE_SETUP
{ return TRIGGER; }
	YY_BREAK
case 228:
YY_RULE_SETUP
{ return TRUE_; }
	YY_BREAK
case 229:
YY_RULE_SETUP
{ return TRY; }
	YY_BREAK
case 230:
YY_RULE_SETUP
{ return TYPE; }
	YY_BREAK
case 231:
YY_RULE_SETUP
{ return TYPE_CHECK; }
	YY_BREAK
case 232:
YY_RULE_SETUP
{ return UNBOUNDED; }
	YY_BREAK
case 233:
YY_RULE_SETUP
{ return UNION; }
	YY_BREAK
case 234:
/* rule 234 can match eol */
*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
(yy_c_buf_p) = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
{ return UNION_ALL; }
	YY_BREAK
case 235:
YY_RULE_SETUP
{ return UNIQUE; }
	YY_BREAK
case 236:
YY_RULE_SETUP
{ return UPDATE; }
	YY_BREAK
case 237:
YY_RULE_SETUP
{ return UPSERT; }
	YY_BREAK
case 238:
YY_RULE_SETUP
{ return USING; }
	YY_BREAK
case 239:
YY_RULE_SETUP
{ return VALUES; }
	YY_BREAK
case 240:
YY_RULE_SETUP
{ return VAR; }
	YY_BREAK
case 241:
YY_RULE_SETUP
{ return VIEW; }
	YY_BREAK
case 242:
YY_RULE_SETUP
{ return VIRTUAL; }
	YY_BREAK
case 243:
YY_RULE_SETUP
{ return WHEN; }
	YY_BREAK
case 244:
YY_RULE_SETUP
{ return WHERE; }
	YY_BREAK
case 245:
YY_RULE_SETUP
{ return WHILE; }
	YY_BREAK
case 246:
YY_RULE_SETUP
{ return WINDOW; }
	YY_BREAK
case 247:
YY_RULE_SETUP
{ return WITH; }
	YY_BREAK
case 248:
YY_RULE_SETUP
{ return WITHOUT; }
	YY_BREAK
case 249:
YY_RULE_SETUP
{ return JEX1; }
	YY_BREAK
case 250:
YY_RULE_SETUP
{ return JEX2; }
	YY_BREAK
case 251:
YY_RULE_SETUP
{ return NE_; }
	YY_BREAK
case 252:
YY_RULE_SETUP
{ return MOD_EQ; }
	YY_BREAK
case 253:
YY_RULE_SETUP
{ return AND_EQ; }
	YY_BREAK
case 254:
YY_RULE_SETUP
{ return MUL_EQ; }
	YY_BREAK
case 255:
YY_RULE_SETUP
{ return ADD_EQ; }
	YY_BREAK
case 256:
YY_RULE_SETUP
{ return SUB_EQ; }
	YY_BREAK
case 257:
YY_RULE_SETUP
{ return DIV_EQ; }
	YY_BREAK
case 258:
YY_RULE_SETUP
{ return ASSIGN; }
	YY_BREAK
case 259:
YY_RULE_SETUP
{ return LS; }
	YY_BREAK
case 260:
YY_RULE_SETUP
{ return LS_EQ; }
	YY_BREAK
case 261:
YY_RULE_SETUP
{ return LE; }
	YY_BREAK
case 262:
YY_RULE_SETUP
{ return NE; }
	YY_BREAK
case 263:
YY_RULE_SETUP
{ return EQEQ; }
	YY_BREAK
case 264:
YY_RULE_SETUP
{ return GE; }
	YY_BREAK
case 265:
YY_RULE_SETUP
{ return RS; }
	YY_BREAK
case 266:
YY_RULE_SETUP
{ return RS_EQ; }
	YY_BREAK
case 267:
YY_RULE_SETUP
{ return OR_EQ; }
	YY_BREAK
case 268:
YY_RULE_SETUP
{ return CONCAT; }
	YY_BREAK
case 269:
YY_RULE_SETUP
{ char *s = Strdup(yytext);
                                   yylval.sval = s;
                                   errno = 0;
                                   return (strtoll(s+2, NULL, 16) <= 0x7fffffff  && errno == 0) ? INTLIT: LONGLIT; }
	YY_BREAK
case 270:
YY_RULE_SETUP
{ char *s = Strdup(yytext);
                                   s[strlen(s)-1] = 0; /* remove the L */
                                   yylval.sval = s;
                                   return LONGLIT; }
	YY_BREAK
case 271:
YY_RULE_SETUP
{ char *s = Strdup(yytext);
                                   yylval.sval = s;
                                   errno = 0;
                                   return (strtoll(s, NULL, 10) <= 0x7fffffff  && errno == 0) ? INTLIT: LONGLIT; }
	YY_BREAK
case 272:
YY_RULE_SETUP
{ char *s = Strdup(yytext);
                                   s[strlen(s)-1] = 0; /* remove the L */
                                   yylval.sval = s;
                                   return LONGLIT; }
	YY_BREAK
case 273:
YY_RULE_SETUP
{ yylval.sval = Strdup(yytext); return REALLIT; }
	YY_BREAK
case 274:
YY_RULE_SETUP
{ yylval.sval = Strdup(yytext); return QID; }
	YY_BREAK
case 275:
YY_RULE_SETUP
{ yylval.sval = Strdup(yytext); return CSTRLIT; }
	YY_BREAK
case 276:
/* rule 276 can match eol */
YY_RULE_SETUP
{ yylval.sval = Strdup(yytext); return STRLIT; }
	YY_BREAK
case 277:
YY_RULE_SETUP
{ yylval.sval = Strdup(yytext); return BLOBLIT; }
	YY_BREAK
case 278:
YY_RULE_SETUP
{ return yytext[0]; }
	YY_BREAK
case 279:
YY_RULE_SETUP
{ return yytext[0]; }
	YY_BREAK
case 280:
YY_RULE_SETUP
{ return yytext[0]; }
	YY_BREAK
case 281:
YY_RULE_SETUP
{ return yytext[0]; }
	YY_BREAK
case 282:
YY_RULE_SETUP
{ return yytext[0]; }
	YY_BREAK
case 283:
YY_RULE_SETUP
{ yylval.sval = Strdup(yytext); return ID; }
	YY_BREAK
case 284:
/* rule 284 can match eol */
YY_RULE_SETUP
;
	YY_BREAK
case 285:
YY_RULE_SETUP
;
	YY_BREAK
case 286:
YY_RULE_SETUP
{ yyerror("Unexpected %s\n", yytext); }
	YY_BREAK
case 287:
/* rule 287 can match eol */
YY_RULE_SETUP
{ line_directive(yytext); }
	YY_BREAK
case 288:
/* rule 288 can match eol */
YY_RULE_SETUP
{ line_directive(yytext); }
	YY_BREAK
case 289:
YY_RULE_SETUP
{ // sqlite supports C style comments... ignore those
                                   CHARBUF_OPEN(tmp);
                                   int c1 = 0, c2 = input();
                                   bool_t save_comment = false;
                                   if (c2 == '!' || c2 == '*') {
                                     save_comment = true;
                                     bputc(&tmp, '/');
                                     bputc(&tmp, '*');
                                   }
                                   for (;;) {
                                     if (c2 == EOF) break;
                                     if (save_comment) {
                                       bputc(&tmp, c2);
                                     }
                                     if (c1 == '*' && c2 == '/') break;
                                     c1 = c2;
                                     c2 = input();
                                   }
                                   if (save_comment) {
                                     CHARBUF_OPEN(strlit);
                                     cg_encode_c_string_literal(tmp.ptr, &strlit);
                                     last_doc_comment = Strdup(strlit.ptr);
                                     CHARBUF_CLOSE(strlit);
                                   }
                                   CHARBUF_CLOSE(tmp);
                                 }
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(at_inc):
{
                                   if (cql_builtins_processing)  {
                                     cql_finish_stream();
                                   }
                                   else if (!cql_include_index) {
                                     if (cql_delete_main_buffer) {
                                        yy_delete_buffer(YY_CURRENT_BUFFER);
                                        cql_delete_main_buffer = false;
                                     }
                                     yyterminate();
                                   }
                                   else {
                                     yy_delete_buffer(YY_CURRENT_BUFFER);
                                     cql_include_state *inc = &cql_includes[--cql_include_index];
                                     yy_switch_to_buffer(inc->buf);
                                     yylineno = inc->line_saved;
                                     current_file = inc->filename_saved;
                                     strcpy(ambient_path, inc->ambient_saved);
                                     return END_INCLUDE;
                                   }
                                 }
	YY_BREAK
case 290:
YY_RULE_SETUP
ECHO;
	YY_BREAK

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_last_accepting_cpos);
				yy_current_state = (yy_last_accepting_state);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap(  ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = (yytext_ptr);
	int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b->yy_ch_buf,
							 (yy_size_t) (b->yy_buf_size + 2)  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    
	yy_current_state = (yy_start);
	yy_current_state += YY_AT_BOL();

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 1360 )
				yy_c = yy_meta[yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	int yy_is_jam;
    	char *yy_cp = (yy_c_buf_p);

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 1360 )
			yy_c = yy_meta[yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 1359);

		return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp )
{
	char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = (yy_n_chars) + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

    if ( c == '\n' ){
        --yylineno;
    }

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap(  ) )
						return 0;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
	if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )
		
    yylineno++;
;

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE );
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
	yy_load_buffer_state(  );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree( (void *) b->yy_ch_buf  );

	yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state(  );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(  );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state(  );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	yy_size_t num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (const char * yystr )
{
    
	return yy_scan_bytes( yystr, (int) strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) (_yybytes_len + 2);
	buf = (char *) yyalloc( n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (const char* msg )
{
			fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int yyget_lineno  (void)
{
    
    return yylineno;
}

/** Get the input stream.
 * 
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 * 
 */
void yyset_lineno (int  _line_number )
{
    
    yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  _in_str )
{
        yyin = _in_str ;
}

void yyset_out (FILE *  _out_str )
{
        yyout = _out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  _bdebug )
{
        yy_flex_debug = _bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    /* We do not touch yylineno unless the option is enabled. */
    yylineno =  1;
    
    (yy_buffer_stack) = NULL;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = NULL;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer( YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n )
{
		
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s )
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
			return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
		
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr )
{
			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#ifndef _MSC_VER
#pragma clang diagnostic pop
#endif
static void cql_reset_globals() {
  current_file = 0;
  base_fragment_name = 0;
  macro_expansion_errors = 0;
  ast_pool = 0;
  stmt_nesting_level = 0;
  cg_header_output = 0;
  cg_main_output = 0;
  cg_constants_output = 0;
  cg_fwd_ref_output = 0;
  cg_declarations_output = 0;
  cg_scratch_vars_output = 0;
  cg_cleanup_output = 0;
  cg_pieces_output = 0;
  cg_stmts = 0;
  cg_funcs = 0;
  cg_exprs = 0;
  charbuf_open_count = 0;
  __charbufs_in_flight = 0;
  memset(&options, 0, sizeof(options));;
  global_proc_name = 0;
  rt = 0;
  current_file = 0;
  gen_stmt_level = 0;
  ast_pool = 0;
  str_pool = 0;
  schema_annotations = 0;
  recreate_annotations = 0;
  all_tables_list = 0;
  all_subscriptions_list = 0;
  all_functions_list = 0;
  all_views_list = 0;
  all_indices_list = 0;
  all_triggers_list = 0;
  all_regions_list = 0;
  all_ad_hoc_list = 0;
  all_select_functions_list = 0;
  all_enums_list = 0;
  all_constant_groups_list = 0;
  schema_regions = 0;
  current_proc = 0;
  error_capture = 0;
  cte_cur = 0;
  ref_sources_for_target_table = 0;
  ref_targets_for_source_table = 0;
  included_regions = 0;
  excluded_regions = 0;
  global_proc_flags = 0;
  ad_hoc_recreate_actions = 0;
  in_upsert = 0;
  in_upsert_rewrite = 0;
  current_upsert_table_ast = 0;
  recreate_group_deps = 0;
  keep_table_name_in_aliases = 0;
}
