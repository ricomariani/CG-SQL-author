/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

-- This file generates dbhelp.c, dbhelp.c is licensed per the below.

-- ------ cql-verify db helpers

@echo c, "\n";
@echo c, "\n";
@echo c, "//\n";
@echo c, "// This file (dbhelp.c) is auto-generated by dbhelp.sql, it is checked in just\n";
@echo c, "// in case CQL is broken by a change.  The Last Known Good Verifier\n";
@echo c, "// can be used to verify the tests pass again, or report failures\n";
@echo c, "// while things are still otherwise broken.  Rebuild with 'regen.sh'\n";
@echo c, "//\n";
@echo c, "\n";


@echo c, "#undef cql_error_trace\n";
@echo c, "#define cql_error_trace() fprintf(stderr, \"SQL Failure %d %s: %s %d\\n\", _rc_, sqlite3_errmsg(_db_), __FILE__, __LINE__)\n";

declare proc printf no check;

declare function cql_fopen(name text!, mode text!) create object<file>;
declare function readline_object_file(f object<file>!) create text;
declare function atoi_at_text(str text, `offset` int!) int!;
declare function len_text(self text) int!;
declare function octet_text(self text, `offset` int!) int!;
declare function after_text(self text, `offset` int!) create text;
declare function starts_with_text(haystack text!, needle text!) bool!;
declare function index_of_text(haystack text!, needle text!) int!;
declare function contains_at_text(haystack text!, needle text!, `offset` int!) bool!;

var sql_name text;
var result_name text;
var attempts int!;
var errors int!;
var tests int!;
var last_rowid long!;

-- setup the table and the index
[[private]]
proc setup()
begin
  create table test_output(
     line int!,
     data text!
  );

  create index __idx__test_lines on test_output (line);

  create table source_input(
     line int!,
     data text!
  );

  create index __idx__source_lines on source_input (line);
end;

[[private]]
proc prev_line(line_ int!, out prev int!)
begin
  begin try
     set prev := (select ifnull(max(line),-1) from test_output where line < line_);
  end try;
  begin catch
     set prev := 0;
  end catch;
end;

-- dump all the output lines that were associated with the given input line
[[private]]
proc dump_output(line_ int!, pat text!)
begin
  let p := (select "%" || pat || "%");
  declare C cursor for
    select rowid, line, data
    from test_output where line = line_;
  loop fetch C
  begin
    printf(
      "%3s%s\n",
      case when last_rowid == C.rowid
           then ">  "
           when C.data like p then "!  "
           else "" end,
      C.data
    );
  end;
end;

-- find the line number of the statement that came after line_
[[private]]
proc find_search_line(line_ int!, out search_line int!)
begin
  /* the pattern match line is before the statement that generates the output like so:

     1:  -- TEST : something
     2:  -- + foo                           <-- we have this line number, e.g. 2
     3:  -- - bar
     4:  select something where something;  <-- we need this line number, e.g. 4

     We need to find the number of a line in the test output that has been charged
     to an input line greater than the one we are on.
  */
  begin try
    set search_line := (select line from test_output where line >= line_ limit 1);
  end try;
  begin catch
    printf("no lines come after %d\n", line_);
    printf("available test output lines: %d\n", (select count(*) from test_output));
    printf("max line number: %d\n", (select max(line) from test_output));
    throw;
  end catch;
end;

-- find the statement that came after line_
-- search the results of that statement for the indicated pattern
-- find the next match, the matches have to be in order
[[private]]
proc find_next(line_ int!, pattern text!, out search_line int!, out found int!)
begin
  call find_search_line(line_, search_line);

  -- once we have it, search for matches on that line and return the number we found
  declare C cursor for
    select rowid
      from test_output
      where line = search_line and data like ("%" || pattern || "%") and rowid > last_rowid;

  fetch C;
  if C then
    set last_rowid := C.rowid;
    set found := 1;
  else
    set found := 0;
  end if;
end;

-- search for a match on the same rowid as the last match we found
[[private]]
proc find_same(line_ int!, pattern text!, out search_line int!, out found int!)
begin
  set found := (
    select data like ("%" || pattern || "%")
      from test_output
      where rowid = last_rowid
      if nothing false);
end;


-- find the statement that came after line_
-- search the results of that statement for the indicated pattern
[[private]]
proc find_count(line_ int!, pattern text!, out search_line int!, out found int!)
begin
  call find_search_line(line_, search_line);

  -- once we have it, search for matches on that line and return the number we found
  set found := (select count(*) from test_output where line = search_line and data like ("%" || pattern || "%"));
end;

-- dump all of the input lines starting from line1 up to but not including line2
[[private]]
proc dump_source(line1 int!, line2 int!, current_line int!)
begin
  declare C cursor for
    select line, data
      from source_input 
      where line > line1 and line <= line2;
  loop fetch C
  begin
    printf("%5s %05d: %s\n",
      case when C.line == current_line then "FAIL" else "" end,
      C.line, 
      C.data);
  end;
end;

-- if anything goes wrong matching, we use this to print the error
[[private]]
proc print_error_message(pattern text!, line int!, expected int!)
begin
  printf("\n%s:%d error: expected '%s' %spresent", 
    sql_name,
    line,
    pattern, 
    case when expected != 0 then "" else "not " end);

  -- this indicates we expected a certain exact number of matches
  if expected != 0 then
    printf(" %s%d times\n", 
      case when expected == -1 then "at least " else "" end, 
      case when expected == -1 then 1 else expected end);
  end if;
  printf("\n");
end;

[[private]]
proc match_multiline(buffer text!, out result bool!)
begin
  result := false;

  if buffer::len() < 7 return;
  if not buffer::starts_with("-- +") return;
  let digit := buffer::octet(4);
  let space := buffer::octet(5);
  if space != 32 return;
  if digit < 48 or digit > 48+9 return;

  result := true;
end;

proc match_actual(buffer text!, line int!) 
begin
  var search_line int!;
  var found int!;
  var expected_count int!;
  var pattern text;

  -- the comments encode the matches, early out if that fails
  if not buffer::starts_with("-- ") then
    -- lines can be out of order or re-visited
    -- we don't want a segment of rows that is later in the file
    -- to prevent later matching.  This can happen with 
    -- # line directives in the stream and it does
    last_rowid := 0;
    return;
  end if;

  -- the standard test prefix it just counts tests, this doesn't mean anything
  -- but it's a useful statistic
  if buffer::starts_with("-- TEST:") then
    tests += 1;
  end if;

  if buffer::starts_with("-- - ") then
    -- found -- - foo
    -- negation, none expected
    pattern := buffer::after(5);
    expected_count := 0;
  else if buffer::starts_with("-- * ") then
    -- -- * foo
    -- at least one is expected, any number will do, any buffer order
    pattern := buffer::after(5);
    expected_count := 1;
  else if buffer::starts_with("-- + ") then
    -- -- + foo
    -- at least one is expected, matches have to be in order!
    pattern := buffer::after(5);
    expected_count := -1;
  else if buffer::starts_with("-- = ") then
    -- -- + foo
    -- at least one is expected, matches have to be in order!
    pattern := buffer::after(5);
    expected_count := -2;
  else if match_multiline(buffer) then
    -- -- +7 foo
    -- an exact match (single digit matches)
    pattern := buffer::after(6);
    expected_count := buffer::octet(4) - 48;
  else 
    -- any other line is just a normal comment, ignore it
    return;
  end if;

  attempts += 1;

  let pat := ifnull_throw(pattern);

  if expected_count == -1 then
    call find_next(line, pat, search_line, found);
    if found == 1 return;
  else if expected_count == -2 then
    call find_same(line, pat, search_line, found);
    if found == 1 return;
  else
    -- search among all the matching lines
    call find_count(line, pat, search_line, found);
    if expected_count == found return;
  end if;

  -- print error corresponding to the pattern
  errors += 1;
  print_error_message(pat, line, expected_count);
  printf("found:\n");

  -- dump all the text associated with this line (this could be many lines)
  -- it's all the output associated with this test case
  call dump_output(search_line, pat);

  -- find the line that ended the previous test block
  var prev int!;
  call prev_line(search_line, prev);

  -- dump everything from there to here, that's the test case
  printf("\nThe corresponding test case is:\n");
  call dump_source(prev, search_line, line);

  -- repeat the error so it's at the end also
  print_error_message(pat, line, expected_count);
  
  printf("test file:%d %s\n", line, sql_name);
  printf("result file: %s\n", result_name);
  printf("\n");
end;

[[private]]
proc do_match(buffer text!, line int!) 
begin
  begin try
     match_actual(buffer, line);
  end try;
  begin catch
    printf("unexpected sqlite error\n");
    throw;
  end catch;
end;

[[private]]
create proc process()
begin
  -- this procedure gets us all of the lines and the data on those lines in order
  declare C cursor for select * from source_input;

  -- get the count of rows (lines) and start looping
  loop fetch C
  begin
    do_match(C.data, C.line);
  end;

  printf("Verification results: %d tests matched %d patterns of which %d were errors.\n", tests, attempts, errors);
end;

-- first we read the test results, we're looking for sentinel lines
-- that tell us where in the input these results came from
-- each result will be charged to the input line it is associated
-- with.  The key_string introduces those lines
[[private]]
proc read_test_results(result_name text!)
begin
  let result_file := cql_fopen(result_name, "r");
  if result_file is null then
    printf("unable to open file '%s'\n", result_name);
    throw;
  end if;

  let line := 0;

  let key_string := "The statement ending at line ";

  let len := key_string::len();

  while true
  begin
    let data := result_file:::readline();
    if data is null leave;

    -- lines in the output that start with the key_string demark 
    -- output that corresponds to the given input line

    let loc := data::index_of(key_string);
    
    if loc >= 0 then
      line := data::atoi_at(loc + len);
    end if;

    -- add the indicated text to the database indexed by the line it was on
    insert into test_output values (line, data);
  end;
end;

-- now we're going to read the entire test file and store it in
-- the database indexed by line.  We're going to do this so that
-- we can go backwards for forwards in the lines easily using
-- the database.  We can select ranges of lines, that sort of thing.
[[private]]
proc read_test_file(sql_name text!)
begin
  let sql_file := cql_fopen(sql_name, "r");
  if sql_file is null then
    printf("unable to open file '%s'\n", sql_name);
    throw;
  end if;

  let line := 1;
  
  while true
  begin
    let data := sql_file:::readline();
    if data is null leave;

    insert into source_input values (line, data);
    line += 1;
  end;
end;

[[private]]
proc load_data(sql_name text!, result_name text!)
begin
  call read_test_results(result_name);
  call read_test_file(sql_name);
end;

[[private]]
proc parse_args(args cql_string_list!)
begin
  let argc := args.count;

  if argc != 3 then
    printf("usage cql-verify foo.sql foo.out\n");
    printf("cql-verify is a test tool.  It processes the input foo.sql\n");
    printf("looking for patterns to match in the CQL output foo.out\n");
    return;
  end if;

  -- store the test and output file names
  set sql_name := ifnull_throw(args[1]);
  set result_name := ifnull_throw(args[2]);
end;

-- main entry point
proc dbhelp_main(args cql_string_list!)
begin
  call setup();
  call parse_args(args);

  if sql_name is not null and result_name is not null then
    call load_data(sql_name, result_name);
    call process();
  end if;
end;
 
@echo c, 
"\n" '#include "cqlhelp.h"'
"\n"
"\n" '// super cheesy error handling'
"\n" '#define E(x) \'
"\n" 'if (SQLITE_OK != (x)) { \'
"\n" ' fprintf(stderr, "error encountered at: %s (%s:%d)\n", #x, __FILE__, __LINE__); \'
"\n" ' fprintf(stderr, "sqlite3_errmsg: %s\n", sqlite3_errmsg(db)); \'
"\n" ' errors = -1; \'
"\n" ' goto error; \'
"\n" '}'
"\n"
"\n" 'int main(int argc, char **argv) {'
"\n" '  cql_object_ref args = create_arglist(argc, argv);'
"\n" 
"\n" '  sqlite3 *db = NULL;'
"\n" '  E(sqlite3_open(":memory:", &db));'
"\n" '  E(dbhelp_main(db, args));'
"\n"
"\n" 'error:'
"\n" '  if (db) sqlite3_close(db);'
"\n" '  cql_object_release(args);'
"\n" '  exit(errors ? 1 : 0);'
"\n" '}'
"\n";
