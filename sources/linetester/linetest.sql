/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* This file generates linetest.h, and linetest.c */

@echo c, '
//
// This file is auto-generated by linetest.sql, it is checked in just
// in case CQL is broken by a change.  The Last Known Good Verifier
// can be used to verify the tests pass again, or report failures
// while things are still otherwise broken.  Rebuild with regen.sh
//

// enable detailed error tracing
#undef cql_error_trace
#define cql_error_trace() fprintf(stderr, "SQL Failure %d %s: %s %d\n", _rc_, sqlite3_errmsg(_db_), __FILE__, __LINE__)
';

declare procedure printf no check;

declare function cql_fopen(name text!, mode text!) create object<file>;
declare function readline_object_file(f object<file>!) create text;
declare function atoi_at_text(str text, `offset` int!) int!;
declare function len_text(self text) int!;
declare function octet_text(self text, `offset` int!) int!;
declare function after_text(self text, `offset` int!) create text;
declare function starts_with_text(haystack text!, needle text!) bool!;
declare function index_of_text(haystack text!, needle text!) int!;
declare function contains_at_text(haystack text!, needle text!, `offset` int!) bool!;

@op object<file>: call readline as readline_object_file;
@op text: call atoi_at as atoi_at_text;
@op text: call len as len_text;
@op text: call octet as octet_text;
@op text: call after as after_text;
@op text: call starts_with as starts_with_text;
@op text: call index_of as index_of_text;
@op text: call contains_at as contains_at_text;
@op text: call str_mid as str_mid;
@op text: call str_right as str_right;
@op text: call str_leftg as str_left;

var proc_count int!;
var compares int!;
var errors int!;
var expected_name text;
var actual_name text;

-- setup the table and the index
[[private]]
proc setup()
begin
  create table linedata(
     source text not null,
     procname text not null,
     line integer not null,
     data text not null,
     physical_line integer not null
  );

  create table procs(
     procname text not null primary key);

  create index __idx__test_lines on linedata (source, procname);
end;

-- add a row to the results table
[[private]]
proc add_linedata(like linedata)
begin
  insert into linedata from arguments;
  insert or ignore into procs from arguments(like procs);
end;

[[private]]
proc dump_proc_records(source_ text not null, procname_ text not null)
begin
  declare C cursor for select * from linedata where procname = procname_ and source = source_;
  loop fetch C
  begin
    call printf("%5d %s\n", C.line, C.data);
  end;
end;

[[private]]
proc dump(procname text not null)
begin
  call printf("%s: difference encountered\n", procname);
  call printf("<<<< EXPECTED\n");
  call dump_proc_records("exp", procname);
  call printf(">>>> ACTUAL\n");
  call dump_proc_records("act", procname);
end;

[[private]]
proc compare_lines()
begin
  declare p cursor for select * from procs;
  loop fetch p
  begin
    proc_count += 1;

    declare actual cursor for
      select * from linedata where
        source = 'act' and
        procname = p.procname;

    declare expected cursor for
      select * from linedata where
        source = 'exp' and
        procname = p.procname;

    fetch actual;
    fetch expected;

    while actual and expected
    begin
      set compares := compares + 1;
      if (actual.line != expected.line or
          actual.data != expected.data) then
          call dump(p.procname);
          call printf("\nFirst difference:\n");
          call printf("expected: %5d %s\n", expected.line, expected.data);
          call printf("  actual: %5d %s\n", actual.line, actual.data);
          call printf("\nDifferences at:\n line %d in expected\n line %d in actual", expected.physical_line, actual.physical_line);
          call printf("\n");
          errors += 1;
          leave;
      end if;
      fetch actual;
      fetch expected;
    end;

    if (actual != expected) then
      if (not actual) then
          call dump(p.procname);
          call printf("\nRan out of lines in actual:\n");
          call printf("\nDifferences at:\n line %d in expected\n", expected.physical_line);
          call printf("\n");
          errors += 1;
      end if;

      if (not expected) then
          call dump(p.procname);
          call printf("\nRan out of lines in expected:\n");
          call printf("\nDifferences at:\n line %d in actual\n", actual.physical_line);
          call printf("\n");
          errors += 1;
      end if;
    end if;
  end;
end;

[[private]]
proc read_file(input_name text!, source text!)
begin
  let prefix1 := '#define _PROC_ ';
  let prefix2 := '#undef _PROC_';
  let prefix3 := '#line ';
  let prefix4 := '# ';

  let prefix1_len := prefix1:len();
  let prefix2_len := prefix2:len();
  let prefix3_len := prefix3:len();
  let prefix4_len := prefix4:len();

  let input_file := cql_fopen(input_name, "r");
  if input_file is null then
    printf("unable to open file '%s'\n", input_name);
    throw;
  end if;

  let base_at_next_line := false;
  let line := 0;
  let line_base := 0;
  let physical_line := 0;
  var procname text;

  while true
  begin
    let data := input_file:readline();
    if data is null leave;

    physical_line += 1;

    if data:starts_with(prefix1) then
      -- we keep the name quotes and all, it doesn't matter
      -- as long as it's unique
      procname := data:after(prefix1_len);
      base_at_next_line := true;
      line := 0;
    end if;

    if data:starts_with(prefix2) then
      procname := NULL;
      line := 0;
      line_base := 0;
    end if;

    let line_start := -1;

    let p3 := data:index_of(prefix3);
    if p3 >= 0 then
      line_start := p3 + prefix3_len;
    end if;

    let p4 := data:index_of(prefix4);
    if p4 >= 0 then
      line_start := p4 + prefix4_len;
    end if;
    
    if line_start >= 0 then
      line := data:atoi_at(line_start);
      if (base_at_next_line) then
        line_base := line - 1;
        base_at_next_line := false;
      end if;
      line -= line_base;
      continue;
    end if;

    if procname is null continue;
    add_linedata(source, procname, line, data, physical_line);
  end;
end;

[[private]]
proc parse_args(args cql_string_list!)
begin
  let argc := args.count;

  if argc != 3 then
    printf("usage cql-linetest expected actual\n");
    printf("cql-linetest is a test tool.  It processes the input files\n");
    printf("normalizing the lines to the start of each procedure\n");
    printf("and verifies that the line numbers are as expected\n");
    return;
  end if;

  set expected_name := ifnull_throw(args[1]);
  set actual_name := ifnull_throw(args[2]);
end;

-- main entry point
proc linetest_main(args cql_string_list!)
begin
  call setup();
  call parse_args(args);

  if expected_name is null return;
  read_file(expected_name, "exp");

  if actual_name is null return;
  read_file(actual_name, "act");

  compare_lines();

  printf("\n");
  if errors then
    printf("EXPECTED INPUT FILE: %s\n", expected_name);
    printf("  ACTUAL INPUT FILE: %s\n", actual_name);
  end if;

  printf("Verification results: %d procedures matched %d patterns of which %d were errors.\n",
     proc_count, compares, errors);
end;

@echo c, '
#include "cqlhelp.h"

// super cheesy error handling

#define E(x) \
  if (SQLITE_OK != (x)) { \
   fprintf(stderr, "error encountered at: %s (%s:%d)\n", #x, __FILE__, __LINE__); \
   fprintf(stderr, "sqlite3_errmsg: %s\n", sqlite3_errmsg(db)); \
   errors = -1; \
   goto error; \
  }

int main(int argc, char **argv) {
  cql_object_ref args = create_arglist(argc, argv);

  sqlite3 *db = NULL;
  E(sqlite3_open(":memory:", &db));
  E(linetest_main(db, args));

error:
  if (db) sqlite3_close(db);
  cql_object_release(args);
  exit(errors ? 1 : 0);
}
';
