
require("cqlrt")


-- The statement ending at line XXXX

--[[
[ [ builtin ] ]
DECLARE PROC cql_throw (code INT!) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
[ [ builtin ] ]
DECLARE PROC cql_cursor_to_blob (C CURSOR, OUT result BLOB!) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
[ [ builtin ] ]
DECLARE PROC cql_cursor_from_blob (C CURSOR, b BLOB) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
[ [ builtin ] ]
DECLARE PROC cql_cursor_from_blob_stream (C CURSOR, b BLOB, i INT!) USING TRANSACTION;
--]]
local lua_runtime_generation = 0
local lua_runtime_generation_on_else = 0

-- The statement ending at line XXXX

--[[
DECLARE i0_nullable INT;
--]]
local i0_nullable

-- The statement ending at line XXXX

--[[
DECLARE i1_nullable INT;
--]]
local i1_nullable

-- The statement ending at line XXXX

--[[
DECLARE r0_nullable REAL;
--]]
local r0_nullable

-- The statement ending at line XXXX

--[[
DECLARE l0_nullable LONG;
--]]
local l0_nullable

-- The statement ending at line XXXX

--[[
DECLARE l1_nullable LONG;
--]]
local l1_nullable

-- The statement ending at line XXXX

--[[
DECLARE b0_nullable BOOL;
--]]
local b0_nullable

-- The statement ending at line XXXX

--[[
DECLARE t0_nullable TEXT;
--]]
local t0_nullable

-- The statement ending at line XXXX

--[[
DECLARE i2 INT!;
--]]
local i2 = 0

-- The statement ending at line XXXX

--[[
DECLARE r2 REAL!;
--]]
local r2 = 0.0

-- The statement ending at line XXXX

--[[
DECLARE l2 LONG!;
--]]
local l2 = 0

-- The statement ending at line XXXX

--[[
DECLARE b2 BOOL!;
--]]
local b2 = false

-- The statement ending at line XXXX

--[[
DECLARE t2 TEXT!;
--]]
local t2

-- The statement ending at line XXXX

--[[
PROC test (i INT!)
BEGIN
  IF i THEN
    CALL puts('true');
  END;
END;
--]]

function test(i)
  cql_contract_argument_notnull(i, 1)

  if cql_to_bool(i) then
    puts("true")
  end

end

-- The statement ending at line XXXX

--[[
PROC proc_with_return_guard (a INT)
BEGIN
  IF a IS NOT NULL THEN
    RETURN;
  END;
  LET x := a;
END;
--]]

function proc_with_return_guard(a)
  local x

  if a ~= nil then
    goto cql_cleanup -- return
  end
  x = a

::cql_cleanup::
end
local _between_0_ = 0
local _between_1_
local _between_2_
local _between_3_ = 0
local _between_4_
local _between_5_

-- The statement ending at line XXXX

--[[
PROC out_test (OUT i INT!, OUT ii INT)
BEGIN
  SET i := i2;
  SET ii := i0_nullable;
END;
--]]

function out_test()
  local i = 0
  local ii

  i = i2
  ii = i0_nullable

  return i, ii
end

-- The statement ending at line XXXX

--[[
DECLARE longint_var LONG;
--]]
local longint_var
local foo_cursor_stmt = nil
local foo_cursor = { _has_row_ = false }
local foo_cursor_fields_ = { "id", "i2" }
local foo_cursor_types_ = "II"

-- The statement ending at line XXXX

--[[
DECLARE col1 INT;
--]]
local col1

-- The statement ending at line XXXX

--[[
DECLARE col2 REAL!;
--]]
local col2 = 0.0
local basic_cursor_stmt = nil
local basic_cursor = { _has_row_ = false }
local basic_cursor_fields_ = { "_anon0", "_anon1" }
local basic_cursor_types_ = "ID"

-- The statement ending at line XXXX

--[[
DECLARE arg1 INT!;
--]]
local arg1 = 0

-- The statement ending at line XXXX

--[[
DECLARE arg2 INT!;
--]]
local arg2 = 0
local exchange_cursor_stmt = nil
local exchange_cursor = { _has_row_ = false }
local exchange_cursor_fields_ = { "arg2", "arg1" }
local exchange_cursor_types_ = "II"
local _temp_stmt = nil

-- The statement ending at line XXXX

--[[
PROC outparm_test (OUT foo INT!)
BEGIN
  SET foo := 1;
  DELETE FROM bar WHERE id = foo;
END;
--]]

function outparm_test(_db_)
  local _rc_ = CQL_OK
  local foo = 0
  local _temp_stmt = nil

  foo = 1
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "DELETE FROM bar WHERE id = ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "I", foo)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_, foo
end

-- The statement ending at line XXXX

--[[
PROC throwing ()
BEGIN
  TRY
    DELETE FROM bar;
  CATCH
    CALL printf("error\n");
    THROW;
  END;
END;
--]]

function throwing(_db_)
  local _rc_ = CQL_OK
  -- try

    _rc_ = cql_exec(_db_,
      "DELETE FROM bar")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_1; end
    goto catch_end_1

  ::catch_start_1:: 
  do
    local _rc_thrown_1 = _rc_
    printf("error\n")
    _rc_ = cql_best_error(_rc_thrown_1)
    cql_error_trace(_rc_, _db_)
    goto cql_cleanup
  end

  ::catch_end_1::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end
local _between_6_
local _between_7_
local _between_8_
local _between_9_
local _between_10_
local _between_11_
local _between_12_
local _between_13_

-- The statement ending at line XXXX

--[[
PROC with_result_set ()
BEGIN
  SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar;
END;
--]]

function with_result_set(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function with_result_set_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = with_result_set(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC select_from_view ()
BEGIN
  SELECT id, type
    FROM baz;
END;
--]]

function select_from_view(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, type FROM baz")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function select_from_view_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = select_from_view(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Ii", { "id", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC make_view ()
BEGIN
  CREATE VIEW MyView AS
    SELECT 1 AS f1, 2 AS f2, 3 AS f3;
END;
--]]

function make_view(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE VIEW MyView AS SELECT 1 AS f1, 2 AS f2, 3 AS f3")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC make_index ()
BEGIN
  CREATE INDEX index_1 ON bar (id);
END;
--]]

function make_index(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE INDEX index_1 ON bar (id)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC get_data (name_ TEXT!, id_ INT!)
BEGIN
  SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar
    WHERE id = id_ AND name = name_;
END;
--]]

function get_data(_db_, name_, id_)
  cql_contract_argument_notnull(name_, 1)
  cql_contract_argument_notnull(id_, 2)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar WHERE id = ? AND name = ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _result_stmt, "IS", id_, name_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function get_data_fetch_results(_db_, name_, id_)
  local result_set = nil
  local _rc_
  _rc_, stmt = get_data(_db_, name_, id_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive ] ]
PROC easy_fetch ()
BEGIN
  CURSOR C FOR
    SELECT
        bar.id,
        bar.name,
        bar.rate,
        bar.type,
        bar.size
      FROM bar;
  FETCH C;
  CALL printf("%d %s\n", C.id, C.name);
  CURSOR C2 FOR
    SELECT
        bar.id,
        bar.name,
        bar.rate,
        bar.type,
        bar.size
      FROM bar
      WHERE C AND id = C.id;
END;
--]]

function easy_fetch(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"
  local C2_stmt = nil
  local C2 = { _has_row_ = false }
  local C2_fields_ = { "id", "name", "rate", "type", "size" }
  local C2_types_ = "Islid"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  printf("%d %s\n", C.id, C.name)
  _rc_, C2_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar WHERE ? AND id = ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, C2_stmt, "FI", C._has_row_, C.id)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  cql_finalize_stmt(C2_stmt)
  C2_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC copy_int (a INT, OUT b INT)
BEGIN
  SET b := a;
END;
--]]

function copy_int(a)
  local b

  b = a

  return b
end

-- The statement ending at line XXXX

--[[
PROC insert_rowid_reader ()
BEGIN
  DECLARE row LONG;
  SET row := last_insert_rowid();
END;
--]]

function insert_rowid_reader(_db_)
  local _rc_ = CQL_OK
  local row

  row = cql_last_insert_rowid(_db_)
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC changes_reader ()
BEGIN
  DECLARE ct INT;
  SET ct := changes();
END;
--]]

function changes_reader(_db_)
  local _rc_ = CQL_OK
  local ct

  ct = cql_changes(_db_)
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE s TEXT!;
--]]
local s

-- The statement ending at line XXXX

--[[
DECLARE PROC xyzzy (id INT) (A INT!);
--]]

-- The statement ending at line XXXX

--[[
PROC xyzzy_test ()
BEGIN
  CURSOR xyzzy_cursor FOR
    CALL xyzzy(1);
END;
--]]

function xyzzy_test(_db_)
  local _rc_ = CQL_OK
  local xyzzy_cursor_stmt = nil
  local xyzzy_cursor = { _has_row_ = false }
  local xyzzy_cursor_fields_ = { "A" }
  local xyzzy_cursor_types_ = "I"

  _rc_, xyzzy_cursor_stmt = xyzzy(_db_, 1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(xyzzy_cursor_stmt)
  xyzzy_cursor_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC plugh (id INT);
--]]

-- The statement ending at line XXXX

--[[
PROC complex_return ()
BEGIN
  SELECT
      TRUE AS _bool,
      2 AS _integer,
      CAST(3 AS LONG) AS _longint,
      3.0 AS _real,
      'xyz' AS _text,
      CAST(NULL AS BOOL) AS _nullable_bool;
END;
--]]

function complex_return(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2, CAST(3 AS LONG_INT), 3.0, 'xyz', NULL")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function complex_return_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = complex_return(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "FILDSf", { "_bool", "_integer", "_longint", "_real", "_text", "_nullable_bool" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC hierarchical_query (rate_ LONG!, limit_ INT!, offset_ INT!)
BEGIN
  SELECT foo.id
    FROM foo
    WHERE id IN (SELECT id
    FROM bar
    WHERE rate = rate_
    ORDER BY name
    LIMIT limit_
    OFFSET offset_)
    ORDER BY id;
END;
--]]

function hierarchical_query(_db_, rate_, limit_, offset_)
  cql_contract_argument_notnull(rate_, 1)
  cql_contract_argument_notnull(limit_, 2)
  cql_contract_argument_notnull(offset_, 3)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT foo.id FROM foo WHERE id IN (SELECT id FROM bar WHERE rate = ? ORDER BY name LIMIT ? OFFSET ?) ORDER BY id")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _result_stmt, "LII", rate_, limit_, offset_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function hierarchical_query_fetch_results(_db_, rate_, limit_, offset_)
  local result_set = nil
  local _rc_
  _rc_, stmt = hierarchical_query(_db_, rate_, limit_, offset_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "id" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC hierarchical_unmatched_query (rate_ LONG!, limit_ INT!, offset_ INT!)
BEGIN
  SELECT foo.id
    FROM foo
    WHERE id NOT IN (SELECT id
    FROM bar
    WHERE rate = rate_
    ORDER BY name
    LIMIT limit_
    OFFSET offset_)
    ORDER BY id;
END;
--]]

function hierarchical_unmatched_query(_db_, rate_, limit_, offset_)
  cql_contract_argument_notnull(rate_, 1)
  cql_contract_argument_notnull(limit_, 2)
  cql_contract_argument_notnull(offset_, 3)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT foo.id FROM foo WHERE id NOT IN (SELECT id FROM bar WHERE rate = ? ORDER BY name LIMIT ? OFFSET ?) ORDER BY id")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _result_stmt, "LII", rate_, limit_, offset_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function hierarchical_unmatched_query_fetch_results(_db_, rate_, limit_, offset_)
  local result_set = nil
  local _rc_
  _rc_, stmt = hierarchical_unmatched_query(_db_, rate_, limit_, offset_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "id" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC union_select ()
BEGIN
  SELECT 1 AS A
  UNION
  SELECT 2 AS A;
END;
--]]

function union_select(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1 UNION SELECT 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function union_select_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = union_select(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "A" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC union_all_select ()
BEGIN
  SELECT 1 AS A
  UNION ALL
  SELECT 2 AS A;
END;
--]]

function union_all_select(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1 UNION ALL SELECT 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function union_all_select_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = union_all_select(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "A" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC union_all_with_nullable ()
BEGIN
  SELECT nullable('foo') AS name
  UNION ALL
  SELECT name
    FROM bar;
END;
--]]

function union_all_with_nullable(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 'foo' UNION ALL SELECT name FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function union_all_with_nullable_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = union_all_with_nullable(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "s", { "name" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC with_stmt_using_cursor ()
BEGIN
  CURSOR C FOR
    WITH
      X (a, b, c) AS (
        SELECT 1, 2, 3
      )
    SELECT X.a, X.b, X.c
      FROM X;
  FETCH C;
END;
--]]

function with_stmt_using_cursor(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "a", "b", "c" }
  local C_types_ = "III"

  _rc_, C_stmt = cql_prepare(_db_, 
    "WITH X (a, b, c) AS ( SELECT 1, 2, 3 ) SELECT X.a, X.b, X.c FROM X")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC with_stmt ()
BEGIN
  WITH
    X (a, b, c) AS (
      SELECT 1, 2, 3
    )
  SELECT X.a, X.b, X.c
    FROM X;
END;
--]]

function with_stmt(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "WITH X (a, b, c) AS ( SELECT 1, 2, 3 ) SELECT X.a, X.b, X.c FROM X")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function with_stmt_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = with_stmt(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "a", "b", "c" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC with_recursive_stmt ()
BEGIN
  WITH RECURSIVE
    X (a, b, c) AS (
      SELECT 1, 2, 3
      UNION ALL
      SELECT 4, 5, 6
    )
  SELECT X.a, X.b, X.c
    FROM X;
END;
--]]

function with_recursive_stmt(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "WITH RECURSIVE X (a, b, c) AS ( SELECT 1, 2, 3 UNION ALL SELECT 4, 5, 6 ) SELECT X.a, X.b, X.c FROM X")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function with_recursive_stmt_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = with_recursive_stmt(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "a", "b", "c" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC parent_proc ()
BEGIN
  SELECT 1 AS one, 2 AS two, 3 AS three;
END;
--]]

function parent_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2, 3")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function parent_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = parent_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "one", "two", "three" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC parent_proc_child ()
BEGIN
  SELECT 4 AS four, 5 AS five, 6 AS six;
END;
--]]

function parent_proc_child(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 4, 5, 6")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function parent_proc_child_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = parent_proc_child(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "four", "five", "six" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC outint_nullable (OUT output INT, OUT result BOOL!)
BEGIN
  CURSOR C FOR
    SELECT 1;
  FETCH C INTO output;
  SET result := C;
END;
--]]

function outint_nullable(_db_)
  local _rc_ = CQL_OK
  local output
  local result = false
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "_anon0" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  output = C._anon0
  result = C._has_row_
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, output, result
end

-- The statement ending at line XXXX

--[[
PROC outint_notnull (OUT output INT!, OUT result BOOL!)
BEGIN
  CURSOR C FOR
    SELECT 1;
  FETCH C INTO output;
  SET result := C;
END;
--]]

function outint_notnull(_db_)
  local _rc_ = CQL_OK
  local output = 0
  local result = false
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "_anon0" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  output = C._anon0
  result = C._has_row_
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, output, result
end
local result

-- The statement ending at line XXXX

--[[
DECLARE text_result TEXT;
--]]
local text_result

-- The statement ending at line XXXX

--[[
DECLARE obj_var OBJECT;
--]]
local obj_var

-- The statement ending at line XXXX

--[[
DECLARE obj_var2 OBJECT!;
--]]
local obj_var2

-- The statement ending at line XXXX

--[[
PROC obj_proc (OUT an_object OBJECT)
BEGIN
  SET an_object := NULL;
END;
--]]

function obj_proc()
  local an_object

  an_object = nil

  return an_object
end

-- The statement ending at line XXXX

--[[
PROC cursor_with_object (object_ OBJECT)
BEGIN
  CURSOR C LIKE cursor_with_object ARGUMENTS;
  FETCH C(object_) FROM VALUES (object_);
  OUT C;
END;
--]]

function cursor_with_object(object_)
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "object_" }
  local C_types_ = "o"

  C._has_row_ = true
  C.object_ = object_
  _result_ = cql_clone_row(C)

  return _result_
end

function cursor_with_object_fetch_results(object_)
  local result_set = nil
  _result_ = cursor_with_object(object_)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC unused_temp (i INT, OUT o INT!)
BEGIN
  SET o := coalesce(i, -1);
END;
--]]

function unused_temp(i)
  local o = 0

  repeat
    if i ~= nil then
      o = i
      break
    end
    o = - 1
  until true

  return o
end

-- The statement ending at line XXXX

--[[
@ECHO lua, "local Garbonzo -- a chick pea\n";
--]]
local Garbonzo -- a chick pea

-- The statement ending at line XXXX

--[[
@ECHO lua, "--/'\a\b\f\t\v'\r\n";
--]]
--/'	'

-- The statement ending at line XXXX

--[[
PROC echo_test ()
BEGIN
  DECLARE s TEXT;
  SET s := "before echo";
  @ECHO lua, "s = \"omg echo\"\n";
  SET s := "after echo";
END;
--]]

function echo_test()
  local s

  s = "before echo"
  s = "omg echo"
  s = "after echo"

end

-- The statement ending at line XXXX

--[[
PROC insert_values (id_ INT!, type_ INT)
BEGIN
  INSERT INTO bar(id, type)
    VALUES (id_, type_);
END;
--]]

function insert_values(_db_, id_, type_)
  cql_contract_argument_notnull(id_, 1)

  local _rc_ = CQL_OK
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO bar(id, type) VALUES (?, ?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "Ii", id_, type_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC alter_table_test ()
BEGIN
  ALTER TABLE bar ADD COLUMN size REAL;
END;
--]]

function alter_table_test(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "ALTER TABLE bar ADD COLUMN size REAL")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC drop_table_test ()
BEGIN
  DROP TABLE IF EXISTS bar;
END;
--]]

function drop_table_test(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "DROP TABLE IF EXISTS bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC uses_proc_for_result ()
BEGIN
  CALL with_result_set();
END;
--]]

function uses_proc_for_result(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  cql_finalize_stmt(_result_stmt)
  _result_stmt = nil
  _rc_, _result_stmt = with_result_set(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function uses_proc_for_result_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = uses_proc_for_result(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end

local expanded_select_stmt = nil
local expanded_select = { _has_row_ = false }
local expanded_select_fields_ = { "id", "name", "rate", "type", "size" }
local expanded_select_types_ = "Islid"
local table_expanded_select_stmt = nil
local table_expanded_select = { _has_row_ = false }
local table_expanded_select_fields_ = { "id", "name", "rate", "type", "size" }
local table_expanded_select_types_ = "Islid"

-- The statement ending at line XXXX

--[[
PROC index_dropper ()
BEGIN
  DROP INDEX index_1;
END;
--]]

function index_dropper(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "DROP INDEX index_1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC misc_dml_proc ()
BEGIN
  INSERT INTO foo(id)
    VALUES (NULL);
  INSERT INTO foo(id)
    VALUES (NULL);
  UPDATE bar
    SET name = 'bar'
    WHERE name = 'baz';
  DELETE FROM foo WHERE id = 1;
END;
--]]

function misc_dml_proc(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) VALUES (NULL)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) VALUES (NULL)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "UPDATE bar SET name = 'bar' WHERE name = 'baz'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DELETE FROM foo WHERE id = 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC dummy_user ()
BEGIN
  INSERT INTO bar(id, name, rate, type, size) VALUES (_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_) @DUMMY_SEED(123) @DUMMY_DEFAULTS @DUMMY_NULLABLES;
END;
--]]

function dummy_user(_db_)
  local _rc_ = CQL_OK
  local _seed_ = 0
  local _temp_stmt = nil

  _seed_ = 123
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO bar(id, name, rate, type, size) VALUES (?, printf('name_%d', ?), ?, ?, ?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "IIIII", _seed_, _seed_, _seed_, _seed_, _seed_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC proc_with_out_arg (OUT foo TEXT)
BEGIN
  SET foo := 'x';
END;
--]]

function proc_with_out_arg()
  local foo

  foo = "x"

  return foo
end

-- The statement ending at line XXXX

--[[
PROC calls_out_proc (OUT foo TEXT)
BEGIN
  SET foo := 'x';
  DECLARE bar TEXT;
  CALL proc_with_out_arg(foo);
  CALL proc_with_out_arg(bar);
END;
--]]

function calls_out_proc()
  local foo
  local bar

  foo = "x"
  foo = proc_with_out_arg()
  bar = proc_with_out_arg()

  return foo
end

-- The statement ending at line XXXX

--[[
DECLARE blob_var BLOB;
--]]
local blob_var

-- The statement ending at line XXXX

--[[
DECLARE blob_var2 BLOB!;
--]]
local blob_var2

-- The statement ending at line XXXX

--[[
PROC blob_proc (OUT a_blob BLOB)
BEGIN
  SET a_blob := NULL;
END;
--]]

function blob_proc()
  local a_blob

  a_blob = nil

  return a_blob
end

-- The statement ending at line XXXX

--[[
DECLARE blob_var_notnull BLOB!;
--]]
local blob_var_notnull

-- The statement ending at line XXXX

--[[
PROC blob_returner ()
BEGIN
  SELECT blob_table.blob_id, blob_table.b_notnull, blob_table.b_nullable
    FROM blob_table;
END;
--]]

function blob_returner(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT blob_table.blob_id, blob_table.b_notnull, blob_table.b_nullable FROM blob_table")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function blob_returner_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = blob_returner(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "IBb", { "blob_id", "b_notnull", "b_nullable" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC voidproc ()
BEGIN
  DECLARE unused INT;
END;
--]]

function voidproc()
  local unused


end

-- The statement ending at line XXXX

--[[
PROC out_cursor_proc ()
BEGIN
  CURSOR C FOR
    SELECT
        bar.id,
        bar.name,
        bar.rate,
        bar.type,
        bar.size,
        'xyzzy' AS extra1,
        'plugh' AS extra2
      FROM bar;
  FETCH C;
  OUT C;
END;
--]]

function out_cursor_proc(_db_)
  local _rc_ = CQL_OK
  local _result_ = nil
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size", "extra1", "extra2" }
  local C_types_ = "IslidSS"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size, 'xyzzy', 'plugh' FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _result_ = cql_clone_row(C)
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, _result_
end

function out_cursor_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, _result_ = out_cursor_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
result_set = { _result_ }

::cql_cleanup::
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC read_cursor_proc ()
BEGIN
  CURSOR C FETCH FROM CALL out_cursor_proc();
END;
--]]

function read_cursor_proc(_db_)
  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size", "extra1", "extra2" }
  local C_types_ = "IslidSS"

  _rc_, C = out_cursor_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC declare_cursor_then_fetch_from_proc ()
BEGIN
  CURSOR C LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc();
END;
--]]

function declare_cursor_then_fetch_from_proc(_db_)
  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size", "extra1", "extra2" }
  local C_types_ = "IslidSS"

  _rc_, C = out_cursor_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC fetcher_proc () OUT (a INT, b TEXT);
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC totally_void_proc ();
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC compute (IN a_ INT!, OUT b_ INT!);
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC dml_compute (IN a_ INT!, OUT b_ INT!) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
PROC dml_user (OUT a_ INT!)
BEGIN
  SET a_ := dml_compute(1);
END;
--]]

function dml_user(_db_)
  local _rc_ = CQL_OK
  local a_ = 0

  _rc_, a_ = dml_compute(_db_, 1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, a_
end

-- The statement ending at line XXXX

--[[
PROC thread_theme_info_list (thread_key_ LONG!)
BEGIN
  SELECT T.thread_key
    FROM (SELECT thread_key
          FROM threads) AS T;
END;
--]]

function thread_theme_info_list(_db_, thread_key_)
  cql_contract_argument_notnull(thread_key_, 1)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT T.thread_key FROM (SELECT thread_key FROM threads) AS T")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function thread_theme_info_list_fetch_results(_db_, thread_key_)
  local result_set = nil
  local _rc_
  _rc_, stmt = thread_theme_info_list(_db_, thread_key_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "L", { "thread_key" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC fetch_values_dummy ()
BEGIN
  CURSOR C LIKE SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar;
  FETCH C(id, name, rate, type, size) FROM VALUES (_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_) @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;
--]]

function fetch_values_dummy()
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"
  local _tmp_text_0
  local _seed_ = 0

  _seed_ = 123
  C._has_row_ = true
  C.id = _seed_
  _tmp_text_0 = cql_printf("name_%d", _seed_)
  C.name = _tmp_text_0
  C.rate = _seed_
  C.type = _seed_
  C.size = cql_to_float(_seed_)

end

-- The statement ending at line XXXX

--[[
PROC fetch_values_extended ()
BEGIN
  CURSOR C LIKE (id INT!, name TEXT, rate LONG, type INT, size REAL, xx REAL, yy TEXT);
  FETCH C(id, name, rate, type, size, xx, yy) FROM VALUES (_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_, _seed_, printf('yy_%d', _seed_)) @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;
--]]

function fetch_values_extended()
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size", "xx", "yy" }
  local C_types_ = "Islidds"
  local _tmp_text_0
  local _tmp_text_1
  local _seed_ = 0

  _seed_ = 123
  C._has_row_ = true
  C.id = _seed_
  _tmp_text_0 = cql_printf("name_%d", _seed_)
  C.name = _tmp_text_0
  C.rate = _seed_
  C.type = _seed_
  C.size = cql_to_float(_seed_)
  C.xx = cql_to_float(_seed_)
  _tmp_text_1 = cql_printf("yy_%d", _seed_)
  C.yy = _tmp_text_1

end

-- The statement ending at line XXXX

--[[
PROC c_literal (OUT x TEXT)
BEGIN
  SET x := "\"Testing\" \\''";
END;
--]]

function c_literal()
  local x

  x = "\"Testing\" \\''"

  return x
end

-- The statement ending at line XXXX

--[[
PROC no_cleanup_label_needed_proc ()
BEGIN
  TRY
    CURSOR C FOR
      SELECT 1 AS N;
    FETCH C;
  CATCH
    DECLARE x INT;
  END;
END;
--]]

function no_cleanup_label_needed_proc(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "N" }
  local C_types_ = "I"
  local x

  -- try

    _rc_, C_stmt = cql_prepare(_db_, 
      "SELECT 1")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_2; end
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto catch_start_2; end
    goto catch_end_2

  ::catch_start_2:: 
  do
  end

  ::catch_end_2::
  _rc_ = CQL_OK

  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC no_code_after_catch ()
BEGIN
  TRY
    @ATTRIBUTE(foo)
    DECLARE x INT;
  CATCH
    @ATTRIBUTE(bar)
    DECLARE y INT;
  END;
END;
--]]

function no_code_after_catch(_db_)
  local _rc_ = CQL_OK
  local x
  local y

  -- try

    goto catch_end_3


  do
  end

  ::catch_end_3::
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC out_no_db ()
BEGIN
  CURSOR C LIKE SELECT 1 AS A, 2.5 AS B;
  FETCH C(A, B) FROM VALUES (3, 12);
  OUT C;
END;
--]]

function out_no_db()
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "A", "B" }
  local C_types_ = "ID"

  C._has_row_ = true
  C.A = 3
  C.B = cql_to_float(12)
  _result_ = cql_clone_row(C)

  return _result_
end

function out_no_db_fetch_results()
  local result_set = nil
  _result_ = out_no_db()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC declare_cursor_like_cursor ()
BEGIN
  CURSOR C0 LIKE SELECT 1 AS A, 2.5 AS B;
  CURSOR C1 LIKE C0;
  FETCH C1(A, B) FROM VALUES (3, 12);
  OUT C1;
END;
--]]

function declare_cursor_like_cursor()
  local _result_ = nil
  local C0 = { _has_row_ = false }
  local C0_fields_ = { "A", "B" }
  local C0_types_ = "ID"
  local C1 = { _has_row_ = false }
  local C1_fields_ = { "A", "B" }
  local C1_types_ = "ID"

  C1._has_row_ = true
  C1.A = 3
  C1.B = cql_to_float(12)
  _result_ = cql_clone_row(C1)

  return _result_
end

function declare_cursor_like_cursor_fetch_results()
  local result_set = nil
  _result_ = declare_cursor_like_cursor()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC declare_cursor_like_proc ()
BEGIN
  CURSOR C LIKE fetcher_proc;
  OUT C;
END;
--]]

function declare_cursor_like_proc()
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "a", "b" }
  local C_types_ = "is"

  _result_ = cql_clone_row(C)

  return _result_
end

function declare_cursor_like_proc_fetch_results()
  local result_set = nil
  _result_ = declare_cursor_like_proc()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC declare_cursor_like_table ()
BEGIN
  CURSOR C LIKE bar;
  OUT C;
END;
--]]

function declare_cursor_like_table()
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"

  _result_ = cql_clone_row(C)

  return _result_
end

function declare_cursor_like_table_fetch_results()
  local result_set = nil
  _result_ = declare_cursor_like_table()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC declare_cursor_like_view ()
BEGIN
  CURSOR C LIKE MyView;
  OUT C;
END;
--]]

function declare_cursor_like_view()
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "f1", "f2", "f3" }
  local C_types_ = "III"

  _result_ = cql_clone_row(C)

  return _result_
end

function declare_cursor_like_view_fetch_results()
  local result_set = nil
  _result_ = declare_cursor_like_view()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC weird_quoting ()
BEGIN
  DELETE FROM bar WHERE name LIKE "\n\n";
  DELETE FROM bar WHERE name = ' '' \n '' \';
  DELETE FROM bar WHERE name <> "'";
  DELETE FROM bar WHERE name >= '\';
END;
--]]

function weird_quoting(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name LIKE '\n\n'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name = ' '' \\n '' \\'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name <> ''''")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name >= '\\'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC long_auto_table_maker ()
BEGIN
  CREATE TABLE long_int_autoinc(
    id LONG PRIMARY KEY AUTOINCREMENT,
    name TEXT
  );
END;
--]]

function long_auto_table_maker(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE TABLE long_int_autoinc( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT )")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC blob_out (OUT x BLOB);
--]]

-- The statement ending at line XXXX

--[[
PROC blob_call1 ()
BEGIN
  DECLARE b BLOB;
  CALL blob_out(b);
END;
--]]

function blob_call1()
  local b

  b = blob_out()

end

-- The statement ending at line XXXX

--[[
PROC blob_call2 ()
BEGIN
  DECLARE b BLOB;
  SET b := blob_out();
END;
--]]

function blob_call2()
  local b

  b = blob_out()

end

-- The statement ending at line XXXX

--[[
PROC blob_no_else ()
BEGIN
  DECLARE b BLOB;
  DECLARE b1 BLOB;
  SET b := CASE b
    WHEN b THEN b1
  END;
END;
--]]

function blob_no_else()
  local b
  local b1
  local _tmp_n_blob_1

  repeat
    _tmp_n_blob_1 = b
    if _tmp_n_blob_1 == nil then goto case_else_3 end
    if _tmp_n_blob_1 == b then
      b = b1
      break
    end
    ::case_else_3::
    b = nil
  until true

end

-- The statement ending at line XXXX

--[[
PROC with_inserter ()
BEGIN
  WITH
    x (a) AS (
      SELECT 111
    )
  INSERT INTO foo(id)
    SELECT x.a
      FROM x;
END;
--]]

function with_inserter(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "WITH x (a) AS ( SELECT 111 ) INSERT INTO foo(id) SELECT x.a FROM x")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC multi_rewrite (blob_id_ INT!, b_notnull_ BLOB!, b_nullable_ BLOB, id_ INT!, name_ TEXT, rate_ LONG, type_ INT, size_ REAL, OUT out_arg INT!)
BEGIN
  INSERT INTO blob_table(blob_id, b_notnull, b_nullable) VALUES (blob_id_, b_notnull_, b_nullable_);
  SET out_arg := 1;
END;
--]]

function multi_rewrite(_db_, blob_id_, b_notnull_, b_nullable_, id_, name_, rate_, type_, size_)
  cql_contract_argument_notnull(blob_id_, 1)
  cql_contract_argument_notnull(b_notnull_, 2)
  cql_contract_argument_notnull(id_, 4)

  local _rc_ = CQL_OK
  local out_arg = 0
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO blob_table(blob_id, b_notnull, b_nullable) VALUES (?, ?, ?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "IBb", blob_id_, b_notnull_, b_nullable_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  out_arg = 1
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_, out_arg
end

-- The statement ending at line XXXX

--[[
PROC fetch_to_cursor_from_cursor ()
BEGIN
  CURSOR C0 LIKE SELECT 1 AS A, "foo" AS B;
  CURSOR C1 LIKE C0;
  FETCH C0(A, B) FROM VALUES (2, "bar");
  FETCH C1(A, B) FROM VALUES (C0.A, C0.B);
  OUT C1;
END;
--]]

function fetch_to_cursor_from_cursor()
  local _result_ = nil
  local C0 = { _has_row_ = false }
  local C0_fields_ = { "A", "B" }
  local C0_types_ = "IS"
  local C1 = { _has_row_ = false }
  local C1_fields_ = { "A", "B" }
  local C1_types_ = "IS"

  C0._has_row_ = true
  C0.A = 2
  C0.B = "bar"
  C1._has_row_ = true
  C1.A = C0.A
  C1.B = C0.B
  _result_ = cql_clone_row(C1)

  return _result_
end

function fetch_to_cursor_from_cursor_fetch_results()
  local result_set = nil
  _result_ = fetch_to_cursor_from_cursor()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC loop_statement_cursor ()
BEGIN
  CURSOR C FOR
    SELECT 1 AS A;
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.A);
  END;
END;
--]]

function loop_statement_cursor(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "A" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  while true
  do
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if not C._has_row_ then break end
    printf("%d\n", C.A)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC loop_statement_not_auto_cursor ()
BEGIN
  CURSOR C FOR
    SELECT 1 AS A;
  DECLARE A_ INT!;
  LOOP FETCH C INTO A_
  BEGIN
    CALL printf("%d\n", A_);
  END;
END;
--]]

function loop_statement_not_auto_cursor(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "A" }
  local C_types_ = "I"
  local A_ = 0

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  while true
  do
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    A_ = C.A
    if not C._has_row_ then break end
    printf("%d\n", A_)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ suppress_result_set ] ]
PROC simple_select ()
BEGIN
  SELECT 1 AS x;
END;
--]]

function simple_select(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

-- The statement ending at line XXXX

--[[
PROC call_in_loop ()
BEGIN
  DECLARE i INT;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    CURSOR C FOR
      CALL simple_select();
    FETCH C;
  END;
END;
--]]

function call_in_loop(_db_)
  local _rc_ = CQL_OK
  local i
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  i = 0
  while true
  do
    if not(i < 5) then break end
    i = i + 1
    cql_finalize_stmt(C_stmt)
    _rc_, C_stmt = simple_select(_db_)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC call_in_loop_with_nullable_condition ()
BEGIN
  DECLARE i INT;
  SET i := nullable(0);
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    CURSOR C FOR
      CALL simple_select();
    FETCH C;
  END;
END;
--]]

function call_in_loop_with_nullable_condition(_db_)
  local _rc_ = CQL_OK
  local i
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  i = 0
  while true
  do
    if not(cql_lt(i, 5)) then break end
    i = cql_add(i, 1)
    cql_finalize_stmt(C_stmt)
    _rc_, C_stmt = simple_select(_db_)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC call_in_loop_boxed ()
BEGIN
  DECLARE i INT;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    CURSOR C FOR
      CALL simple_select();
    DECLARE box OBJECT<C CURSOR>;
    SET box FROM CURSOR C;
    CURSOR D FOR box;
    FETCH D;
  END;
END;
--]]

function call_in_loop_boxed(_db_)
  local _rc_ = CQL_OK
  local i
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"
  local box
  local D_stmt = nil
  local D = { _has_row_ = false }
  local D_fields_ = { "x" }
  local D_types_ = "I"

  i = 0
  while true
  do
    if not(i < 5) then break end
    i = i + 1
    C_stmt = nil
    _rc_, C_stmt = simple_select(_db_)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    box = C_stmt
    D_stmt = box
    -- step and fetch
    _rc_ = cql_multifetch(D_stmt, D, D_types_, D_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC out_union_helper ()
BEGIN
  CURSOR C LIKE SELECT 1 AS x;
  FETCH C(x) FROM VALUES (1);
  OUT UNION C;
END;
--]]

function out_union_helper_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  C._has_row_ = true
  C.x = 1
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
PROC out_union_dml_helper ()
BEGIN
  CURSOR C FOR
    SELECT 1 AS x;
  FETCH C;
  OUT UNION C;
END;
--]]

function out_union_dml_helper_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
PROC call_out_union_in_loop ()
BEGIN
  DECLARE i INT;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    CURSOR C FOR
      CALL out_union_helper();
    FETCH C;
  END;
END;
--]]

function call_out_union_in_loop(_db_)
  local _rc_ = CQL_OK
  local i
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  i = 0
  while true
  do
    if not(i < 5) then break end
    i = i + 1
    C_result_set_ = out_union_helper_fetch_results()
    C_row_num_ = 0
    C_row_count_ = #(C_result_set_)
    C_row_num_ = C_row_num_ + 1
    if C_row_num_ <= C_row_count_ then
      C = C_result_set_[C_row_num_]
    else
      C = { _has_row_ = false }
    end
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC forward_out_union ()
BEGIN
  CALL out_union_helper();
END;
--]]

function forward_out_union_fetch_results()
  local _result_set_ = {}
  _result_set_ = out_union_helper_fetch_results()

  return _result_set_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC extern_out_union_helper () OUT UNION (x INT!);
--]]

-- The statement ending at line XXXX

--[[
PROC forward_out_union_extern ()
BEGIN
  CALL extern_out_union_helper();
END;
--]]

function forward_out_union_extern_fetch_results()
  local _result_set_ = {}
  _result_set_ = extern_out_union_helper_fetch_results()

  return _result_set_
end

-- The statement ending at line XXXX

--[[
PROC forward_out_union_dml ()
BEGIN
  CALL out_union_dml_helper();
END;
--]]

function forward_out_union_dml_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _result_set_ = {}
  _rc_, _result_set_ = out_union_dml_helper_fetch_results(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, _result_set_
end
local global_cursor_stmt = nil
local global_cursor = { _has_row_ = false }
local global_cursor_fields_ = { "a", "b" }
local global_cursor_types_ = "II"

-- The statement ending at line XXXX

--[[
PROC make_trigger ()
BEGIN
  CREATE TEMP TRIGGER IF NOT EXISTS trigger1
    BEFORE DELETE ON bar
    FOR EACH ROW
    WHEN old.id > 7
  BEGIN
    SELECT old.id;
  END;
END;
--]]

function make_trigger(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE TEMP TRIGGER IF NOT EXISTS trigger1 BEFORE DELETE ON bar FOR EACH ROW WHEN old.id > 7 BEGIN SELECT old.id; END")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC is_test ()
BEGIN
  DECLARE b BOOL!;
  SET b := 1 IS 1;
  SET b := 'x' IS 'x';
  SET b := 'x' IS 'y';
  SET b := 1 + (3 IS 4);
  LET i := nullable(1);
  LET j := nullable(2);
  SET b := i IS j;
END;
--]]

function is_test()
  local b = false
  local i
  local j

  b = 1 == 1
  b = "x" == "x"
  b = "x" == "y"
  b = cql_to_bool(1 + cql_to_num((3 == 4)))
  i = 1
  j = 2
  b = i == j

end

-- The statement ending at line XXXX

--[[
PROC is_blob ()
BEGIN
  DECLARE bl1 BLOB;
  DECLARE bl2 BLOB;
  DECLARE b BOOL!;
  SET b := bl1 IS bl2;
  SET b := bl1 IS NOT bl2;
END;
--]]

function is_blob()
  local bl1
  local bl2
  local b = false

  b = cql_blob_is_eq(bl1, bl2)
  b = cql_blob_is_ne(bl1, bl2)

end

-- The statement ending at line XXXX

--[[
PROC is_not_test ()
BEGIN
  DECLARE b BOOL!;
  SET b := 1 IS NOT 1;
  SET b := 'x' IS NOT 'x';
  SET b := 'x' IS NOT 'y';
  SET b := 1 + (3 IS NOT 4);
  LET i := nullable(1);
  LET j := nullable(2);
  SET b := i IS NOT j;
END;
--]]

function is_not_test()
  local b = false
  local i
  local j

  b = 1 ~= 1
  b = "x" ~= "x"
  b = "x" ~= "y"
  b = cql_to_bool(1 + cql_to_num((3 ~= 4)))
  i = 1
  j = 2
  b = i ~= j

end

-- The statement ending at line XXXX

--[[
PROC in_test (x INT, OUT b BOOL)
BEGIN
  SET b := NULL IN (1);
END;
--]]

function in_test(x)
  local b

  b = nil

  return b
end

-- The statement ending at line XXXX

--[[
PROC not_in_test (x INT, OUT b BOOL)
BEGIN
  SET b := NULL NOT IN (1);
END;
--]]

function not_in_test(x)
  local b

  b = nil

  return b
end

-- The statement ending at line XXXX

--[[
PROC drop_trigger_test ()
BEGIN
  DROP TRIGGER IF EXISTS trigger1;
  DROP TRIGGER trigger1;
END;
--]]

function drop_trigger_test(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "DROP TRIGGER IF EXISTS trigger1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DROP TRIGGER trigger1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ identity=(id) ] ]
PROC simple_identity ()
BEGIN
  SELECT 1 AS id, 2 AS data;
END;
--]]

function simple_identity(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function simple_identity_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = simple_identity(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "id", "data" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ identity=(col1, col2) ] ]
PROC complex_identity ()
BEGIN
  SELECT 1 AS col1, 2 AS col2, 3 AS data;
END;
--]]

function complex_identity(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2, 3")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function complex_identity_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = complex_identity(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "col1", "col2", "data" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ identity=(id) ] ]
PROC out_cursor_identity ()
BEGIN
  CURSOR C FOR
    SELECT 1 AS id, 2 AS data;
  FETCH C;
  OUT C;
END;
--]]

function out_cursor_identity(_db_)
  local _rc_ = CQL_OK
  local _result_ = nil
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "data" }
  local C_types_ = "II"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _result_ = cql_clone_row(C)
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, _result_
end

function out_cursor_identity_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, _result_ = out_cursor_identity(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
result_set = { _result_ }

::cql_cleanup::
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive ] ]
PROC radioactive_proc ()
BEGIN
  SELECT radioactive.id, radioactive.data
    FROM radioactive;
END;
--]]

function radioactive_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT radioactive.id, radioactive.data FROM radioactive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function radioactive_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = radioactive_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Is", { "id", "data" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC with_deleter ()
BEGIN
  WITH
    x (a) AS (
      SELECT 111
    )
  DELETE FROM foo WHERE id IN (SELECT x.a
    FROM x);
END;
--]]

function with_deleter(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "WITH x (a) AS ( SELECT 111 ) DELETE FROM foo WHERE id IN (SELECT x.a FROM x)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC with_updater ()
BEGIN
  WITH
    x (a) AS (
      SELECT 111
    )
  UPDATE bar
    SET name = 'xyzzy'
    WHERE id IN (SELECT x.a
      FROM x);
END;
--]]

function with_updater(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "WITH x (a) AS ( SELECT 111 ) UPDATE bar SET name = 'xyzzy' WHERE id IN (SELECT x.a FROM x)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ autodrop=(table1, table2) ] ]
PROC autodropper ()
BEGIN
  SELECT 1 AS a, 2 AS b;
END;
--]]

function autodropper(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function autodropper_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = autodropper(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "a", "b" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  cql_autodrop(_db_, {"table1", "table2"})
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC simple_cursor_proc ()
BEGIN
  CURSOR A_CURSOR LIKE SELECT 1 AS id;
  FETCH a_cursor(id) FROM VALUES (1);
  OUT a_cursor;
END;
--]]

function simple_cursor_proc()
  local _result_ = nil
  local A_CURSOR = { _has_row_ = false }
  local A_CURSOR_fields_ = { "id" }
  local A_CURSOR_types_ = "I"

  A_CURSOR._has_row_ = true
  A_CURSOR.id = 1
  _result_ = cql_clone_row(A_CURSOR)

  return _result_
end

function simple_cursor_proc_fetch_results()
  local result_set = nil
  _result_ = simple_cursor_proc()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC redundant_cast ()
BEGIN
  SELECT CAST(5 AS INT) AS plugh, T.xyzzy AS five
    FROM (SELECT 1 AS xyzzy) AS T;
END;
--]]

function redundant_cast(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT (5), T.xyzzy FROM (SELECT 1 AS xyzzy) AS T")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function redundant_cast_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = redundant_cast(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "plugh", "five" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC view_creator ()
BEGIN
  CREATE VIEW alias_preserved AS
    SELECT CAST(5 AS INT) AS plugh, T.xyzzy AS five
      FROM (SELECT 1 AS xyzzy) AS T;
END;
--]]

function view_creator(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE VIEW alias_preserved AS SELECT (5) AS plugh, T.xyzzy AS five FROM (SELECT 1 AS xyzzy) AS T")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC settings_info ()
BEGIN
  CURSOR C FOR
    SELECT SUM(A.unread_pending_thread_count) AS unread_pending_thread_count, SUM(A.switch_account_badge_count) AS switch_account_badge_count
      FROM (SELECT P.unread_pending_thread_count AS unread_pending_thread_count, 0 AS switch_account_badge_count
            FROM unread_pending_threads AS P
          UNION ALL
          SELECT 0 AS unread_pending_thread_count, S.badge_count AS switch_account_badge_count
            FROM switch_account_badges AS S) AS A;
END;
--]]

function settings_info(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "unread_pending_thread_count", "switch_account_badge_count" }
  local C_types_ = "ii"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT SUM(A.unread_pending_thread_count), SUM(A.switch_account_badge_count) FROM (SELECT P.unread_pending_thread_count AS unread_pending_thread_count, 0 AS switch_account_badge_count FROM unread_pending_threads AS P UNION ALL SELECT 0 AS unread_pending_thread_count, S.badge_count AS switch_account_badge_count FROM switch_account_badges AS S) AS A")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC top_level_select_alias_unused ()
BEGIN
  SELECT 1 AS id, 2 AS x
  UNION ALL
  SELECT foo.id, 2 AS x
    FROM foo;
END;
--]]

function top_level_select_alias_unused(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2 UNION ALL SELECT foo.id, 2 FROM foo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function top_level_select_alias_unused_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = top_level_select_alias_unused(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "id", "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC top_level_select_alias_used_in_orderby ()
BEGIN
  SELECT 1 AS id, 2 AS x
  UNION ALL
  SELECT foo.id, 2 AS x
    FROM foo
    ORDER BY id;
END;
--]]

function top_level_select_alias_used_in_orderby(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1 AS id, 2 UNION ALL SELECT foo.id, 2 FROM foo ORDER BY id")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function top_level_select_alias_used_in_orderby_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = top_level_select_alias_used_in_orderby(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "id", "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC use_with_select ()
BEGIN
  DECLARE x INT;
  SET x := (   WITH
    threads2 (count) AS (
      SELECT 1 AS foo
    )
  SELECT COUNT(*)
    FROM threads2 );
END;
--]]

function use_with_select(_db_)
  local _rc_ = CQL_OK
  local x
  local _tmp_int_0 = 0
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "WITH threads2 (count) AS ( SELECT 1 ) SELECT COUNT(*) FROM threads2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_int_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  x = _tmp_int_0
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC rowset_object_reader (rowset OBJECT<rowset>)
BEGIN
  CURSOR C FOR
    SELECT ReadFromRowset.id
      FROM ReadFromRowset(rowset);
END;
--]]

function rowset_object_reader(_db_, rowset)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id" }
  local C_types_ = "i"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT ReadFromRowset.id FROM ReadFromRowset(?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, C_stmt, "o", rowset)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC upsert_do_something ()
BEGIN
  INSERT INTO foo(id)
    SELECT id
      FROM bar
      WHERE 1
  ON CONFLICT (id)
  DO UPDATE
    SET id = 10
    WHERE id <> 10;
END;
--]]

function upsert_do_something(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) SELECT id FROM bar WHERE 1 ON CONFLICT (id) DO UPDATE SET id = 10 WHERE id <> 10")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC with_upsert_form ()
BEGIN
  WITH
    names (id) AS (
      VALUES
        (1),
        (5),
        (3),
        (12)
    )
  INSERT INTO foo(id)
    SELECT id
      FROM names
      WHERE 1
  ON CONFLICT (id)
  DO UPDATE
    SET id = 10
    WHERE id <> 10;
END;
--]]

function with_upsert_form(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "WITH names (id) AS ( VALUES (1), (5), (3), (12) ) INSERT INTO foo(id) SELECT id FROM names WHERE 1 ON CONFLICT (id) DO UPDATE SET id = 10 WHERE id <> 10")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC upsert_do_nothing (id_ INT!)
BEGIN
  INSERT INTO foo(id)
    VALUES (id_)
  ON CONFLICT
  DO NOTHING;
END;
--]]

function upsert_do_nothing(_db_, id_)
  cql_contract_argument_notnull(id_, 1)

  local _rc_ = CQL_OK
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO foo(id) VALUES (?) ON CONFLICT DO NOTHING")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "I", id_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end
local _seed_ = 0

-- The statement ending at line XXXX

--[[
DECLARE PROC p1 () OUT (id INT!, t TEXT);
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC p2 () OUT (id INT!, t TEXT) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
PROC use_many_out_cursors ()
BEGIN
  CURSOR c1 FETCH FROM CALL p1();
  CURSOR c2 FETCH FROM CALL p2();
END;
--]]

function use_many_out_cursors(_db_)
  local _rc_ = CQL_OK
  local c1 = { _has_row_ = false }
  local c1_fields_ = { "id", "t" }
  local c1_types_ = "Is"
  local c2 = { _has_row_ = false }
  local c2_fields_ = { "id", "t" }
  local c2_types_ = "Is"

  c1 = p1()
  _rc_, c2 = p2(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC fetch_many_times (arg BOOL!)
BEGIN
  CURSOR C LIKE p1;
  IF arg = 1 THEN
    FETCH C FROM CALL p1();
  ELSE IF arg = 2 THEN
    FETCH C FROM CALL p2();
  ELSE
    FETCH C FROM CALL p1();
    FETCH C FROM CALL p2();
  END;
END;
--]]

function fetch_many_times(_db_, arg)
  cql_contract_argument_notnull(arg, 1)

  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "t" }
  local C_types_ = "Is"

  if cql_to_num(arg) == 1 then
    C = p1()
  else
    if cql_to_num(arg) == 2 then
      _rc_, C = p2(_db_)
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    else
      C = p1()
      _rc_, C = p2(_db_)
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC out_union_two ()
BEGIN
  CURSOR C LIKE SELECT 1 AS x, '2' AS y;
  FETCH C(x, y) FROM VALUES (1, "y");
  OUT UNION C;
  OUT UNION C;
END;
--]]

function out_union_two_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "IS"

  C._has_row_ = true
  C.x = 1
  C.y = "y"
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
PROC out_union_reader ()
BEGIN
  CURSOR c FOR
    CALL out_union_two();
  LOOP FETCH C
  BEGIN
    CALL printf("%d %s\n", C.x, C.y);
  END;
END;
--]]

function out_union_reader(_db_)
  local _rc_ = CQL_OK
  local c_result_set_ = nil
  local c_row_num_ = 0
  local c_row_count_ = 0
  local c = { _has_row_ = false }
  local c_fields_ = { "x", "y" }
  local c_types_ = "IS"

  c_result_set_ = out_union_two_fetch_results()
  c_row_num_ = 0
  c_row_count_ = #(c_result_set_)
  while true
  do
    c_row_num_ = c_row_num_ + 1
    if c_row_num_ <= c_row_count_ then
      c = c_result_set_[c_row_num_]
    else
      c = { _has_row_ = false }
    end
    if not c._has_row_ then break end
    printf("%d %s\n", c.x, c.y)
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC out_union_from_select ()
BEGIN
  CURSOR C FOR
    SELECT 1 AS x, '2' AS y;
  FETCH C;
  OUT UNION C;
  OUT UNION C;
END;
--]]

function out_union_from_select_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "IS"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1, '2'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
PROC out_union_dml_reader ()
BEGIN
  CURSOR c FOR
    CALL out_union_from_select();
  LOOP FETCH C
  BEGIN
    CALL printf("%d %s\n", C.x, C.y);
  END;
END;
--]]

function out_union_dml_reader(_db_)
  local _rc_ = CQL_OK
  local c_result_set_ = nil
  local c_row_num_ = 0
  local c_row_count_ = 0
  local c = { _has_row_ = false }
  local c_fields_ = { "x", "y" }
  local c_types_ = "IS"

  _rc_, c_result_set_ = out_union_from_select_fetch_results(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  c_row_num_ = 0
  c_row_count_ = #(c_result_set_)
  while true
  do
    c_row_num_ = c_row_num_ + 1
    if c_row_num_ <= c_row_count_ then
      c = c_result_set_[c_row_num_]
    else
      c = { _has_row_ = false }
    end
    if not c._has_row_ then break end
    printf("%d %s\n", c.x, c.y)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC out_union_values (a INT!, b INT!)
BEGIN
  CURSOR x LIKE SELECT 1 AS x, 2 AS y;
  FETCH x(x, y) FROM VALUES (a, b);
  OUT UNION x;
END;
--]]

function out_union_values_fetch_results(a, b)
  cql_contract_argument_notnull(a, 1)
  cql_contract_argument_notnull(b, 2)

  local _rows_ = {}
  local x = { _has_row_ = false }
  local x_fields_ = { "x", "y" }
  local x_types_ = "II"

  x._has_row_ = true
  x.x = a
  x.y = b
  if x._has_row_ then
    table.insert(_rows_, cql_clone_row(x))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
PROC read_out_union_values (a INT!, b INT!)
BEGIN
  CURSOR C FOR
    CALL out_union_values(a, b);
  FETCH C;
END;
--]]

function read_out_union_values(_db_, a, b)
  cql_contract_argument_notnull(a, 1)
  cql_contract_argument_notnull(b, 2)

  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "II"

  C_result_set_ = out_union_values_fetch_results(a, b)
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  C_row_num_ = C_row_num_ + 1
  if C_row_num_ <= C_row_count_ then
    C = C_result_set_[C_row_num_]
  else
    C = { _has_row_ = false }
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ vault_sensitive ] ]
PROC out_union_dml ()
BEGIN
  CURSOR x FOR
    SELECT radioactive.id, radioactive.data
      FROM radioactive;
  FETCH x;
  OUT UNION x;
END;
--]]

function out_union_dml_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local x_stmt = nil
  local x = { _has_row_ = false }
  local x_fields_ = { "id", "data" }
  local x_types_ = "Is"

  _rc_, x_stmt = cql_prepare(_db_, 
    "SELECT radioactive.id, radioactive.data FROM radioactive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(x_stmt, x, x_types_, x_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if x._has_row_ then
    table.insert(_rows_, cql_clone_row(x))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(x_stmt)
  x_stmt = nil
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
[ [ vault_sensitive ] ]
PROC out_union_dml_for_call ()
BEGIN
  CURSOR C FOR
    CALL out_union_dml();
  FETCH C;
END;
--]]

function out_union_dml_for_call(_db_)
  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "data" }
  local C_types_ = "Is"

  _rc_, C_result_set_ = out_union_dml_fetch_results(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  C_row_num_ = C_row_num_ + 1
  if C_row_num_ <= C_row_count_ then
    C = C_result_set_[C_row_num_]
  else
    C = { _has_row_ = false }
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC compound_select_expr ()
BEGIN
  DECLARE x INT;
  SET x := ( SELECT 1
    WHERE 0
  UNION
  SELECT 2
    LIMIT 1 );
END;
--]]

function compound_select_expr(_db_)
  local _rc_ = CQL_OK
  local x
  local _tmp_int_0 = 0
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 1 WHERE 0 UNION SELECT 2 LIMIT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_int_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  x = _tmp_int_0
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC window_function_invocation ()
BEGIN
  SELECT id, 
    row_number() OVER () AS row_num
    FROM foo;
END;
--]]

function window_function_invocation(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id,  row_number() OVER () FROM foo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window_function_invocation_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window_function_invocation(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "id", "row_num" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC update_cursor ()
BEGIN
  CURSOR C LIKE SELECT 1 AS x, 2 AS y;
  UPDATE CURSOR C(x) FROM VALUES (2);
END;
--]]

function update_cursor(_db_)
  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "II"

  if C._has_row_ then
    C.x = 2
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC out_union_with_dml (id INT) OUT UNION (id INT!) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC out_union_no_dml (id INT) OUT UNION (id INT!);
--]]

-- The statement ending at line XXXX

--[[
PROC use_return ()
BEGIN
  TRY
    SELECT 1 AS x;
  CATCH
    RETURN;
  END;
END;
--]]

function use_return(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  -- try

    _rc_, _result_stmt = cql_prepare(_db_, 
      "SELECT 1")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_4; end
    goto catch_end_4

  ::catch_start_4:: 
  do
    _rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error
    goto cql_cleanup -- return
  end

  ::catch_end_4::
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function use_return_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = use_return(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC use_return_no_error_flow ()
BEGIN
  IF 1 THEN
    RETURN;
  END;
END;
--]]

function use_return_no_error_flow()
  if true then
    goto cql_cleanup -- return
  end

::cql_cleanup::
end

-- The statement ending at line XXXX

--[[
PROC empty_proc ()
BEGIN
END;
--]]

function empty_proc()

end

-- The statement ending at line XXXX

--[[
PROC empty_blocks ()
BEGIN
  IF 1 THEN
  END;
  IF 2 THEN
  ELSE
  END;
  IF 3 THEN
  ELSE IF 4 THEN
  ELSE
  END;
  WHILE 1
  BEGIN
  END;
  CURSOR c FOR
    SELECT 1 AS x;
  LOOP FETCH c
  BEGIN
  END;
  TRY
  CATCH
  END;
END;
--]]

function empty_blocks(_db_)
  local _rc_ = CQL_OK
  local c_stmt = nil
  local c = { _has_row_ = false }
  local c_fields_ = { "x" }
  local c_types_ = "I"

  if true then
  end
  if cql_to_bool(2) then
  else
  end
  if cql_to_bool(3) then
  else
    if cql_to_bool(4) then
    else
    end
  end
  while true
  do
    if not(true) then break end
  end
  _rc_, c_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  while true
  do
    -- step and fetch
    _rc_ = cql_multifetch(c_stmt, c, c_types_, c_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if not c._has_row_ then break end
  end
  -- try

    goto catch_end_5


  do
  end

  ::catch_end_5::
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(c_stmt)
  c_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC tail_catch ()
BEGIN
  TRY
  CATCH
    TRY
    CATCH
    END;
  END;
END;
--]]

function tail_catch(_db_)
  local _rc_ = CQL_OK
  -- try

    goto catch_end_6


  do
    -- try

      goto catch_end_7


    do
    end

    ::catch_end_7::
  end

  ::catch_end_6::
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC pretty_print_with_quote ()
BEGIN
  INSERT INTO bar(id, name)
    VALUES (1, "it's high noon\r\n\f\b\t\v");
END;
--]]

function pretty_print_with_quote(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id, name) VALUES (1, 'it''s high noon\r\n\f\b\t\v')")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC hex_quote ()
BEGIN
  INSERT INTO bar(id, name)
    VALUES (1, "\x01\x02\xa1\x1bg");
END;
--]]

function hex_quote(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id, name) VALUES (1, '\x01\x02\xa1\x1bg')")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ suppress_getters ] ]
PROC lotsa_columns_no_getters ()
BEGIN
  SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar;
END;
--]]

function lotsa_columns_no_getters(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function lotsa_columns_no_getters_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = lotsa_columns_no_getters(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ generate_copy ] ]
PROC sproc_with_copy ()
BEGIN
  SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar;
END;
--]]

function sproc_with_copy(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function sproc_with_copy_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = sproc_with_copy(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ emit_setters ] ]
PROC emit_object_with_setters (o OBJECT!, x OBJECT!, i INT!, l LONG!, b BOOL!, d REAL!, t TEXT!, bl BLOB!)
BEGIN
  CURSOR C LIKE emit_object_with_setters ARGUMENTS;
  FETCH C(o, x, i, l, b, d, t, bl) FROM VALUES (o, x, i, l, b, d, t, bl);
  OUT C;
END;
--]]

function emit_object_with_setters(o, x, i, l, b, d, t, bl)
  cql_contract_argument_notnull(o, 1)
  cql_contract_argument_notnull(x, 2)
  cql_contract_argument_notnull(i, 3)
  cql_contract_argument_notnull(l, 4)
  cql_contract_argument_notnull(b, 5)
  cql_contract_argument_notnull(d, 6)
  cql_contract_argument_notnull(t, 7)
  cql_contract_argument_notnull(bl, 8)

  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "o", "x", "i", "l", "b", "d", "t", "bl" }
  local C_types_ = "OOILFDSB"

  C._has_row_ = true
  C.o = o
  C.x = x
  C.i = i
  C.l = l
  C.b = b
  C.d = d
  C.t = t
  C.bl = bl
  _result_ = cql_clone_row(C)

  return _result_
end

function emit_object_with_setters_fetch_results(o, x, i, l, b, d, t, bl)
  local result_set = nil
  _result_ = emit_object_with_setters(o, x, i, l, b, d, t, bl)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
[ [ emit_setters ] ]
PROC emit_setters_with_nullables (o OBJECT, x OBJECT, i INT, l LONG, b BOOL, d REAL, t TEXT, bl BLOB)
BEGIN
  CURSOR C LIKE emit_setters_with_nullables ARGUMENTS;
  FETCH C(o, x, i, l, b, d, t, bl) FROM VALUES (o, x, i, l, b, d, t, bl);
  OUT C;
END;
--]]

function emit_setters_with_nullables(o, x, i, l, b, d, t, bl)
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "o", "x", "i", "l", "b", "d", "t", "bl" }
  local C_types_ = "ooilfdsb"

  C._has_row_ = true
  C.o = o
  C.x = x
  C.i = i
  C.l = l
  C.b = b
  C.d = d
  C.t = t
  C.bl = bl
  _result_ = cql_clone_row(C)

  return _result_
end

function emit_setters_with_nullables_fetch_results(o, x, i, l, b, d, t, bl)
  local result_set = nil
  _result_ = emit_setters_with_nullables(o, x, i, l, b, d, t, bl)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
[ [ emit_setters ] ]
PROC no_out_with_setters ()
BEGIN
  SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar;
END;
--]]

function no_out_with_setters(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function no_out_with_setters_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = no_out_with_setters(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ suppress_result_set ] ]
PROC lotsa_columns_no_result_set ()
BEGIN
  SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar;
END;
--]]

function lotsa_columns_no_result_set(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

-- The statement ending at line XXXX

--[[
PROC early_out_rc_cleared (OUT x INT)
BEGIN
  CURSOR C FOR
    SELECT 1 AS x;
  FETCH C;
  IF C THEN
    RETURN;
  END;
END;
--]]

function early_out_rc_cleared(_db_)
  local _rc_ = CQL_OK
  local x
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if C._has_row_ then
    _rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error
    goto cql_cleanup -- return
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, x
end

-- The statement ending at line XXXX

--[[
[ [ vault_sensitive=(id, name) ] ]
[ [ custom_type_for_encoded_column ] ]
PROC vault_sensitive_with_values_proc ()
BEGIN
  SELECT
      vault_mixed_sensitive.id,
      vault_mixed_sensitive.name,
      vault_mixed_sensitive.title,
      vault_mixed_sensitive.type
    FROM vault_mixed_sensitive;
END;
--]]

function vault_sensitive_with_values_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vault_mixed_sensitive.id, vault_mixed_sensitive.name, vault_mixed_sensitive.title, vault_mixed_sensitive.type FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_with_values_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_with_values_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive=(id, name) ] ]
[ [ custom_type_for_encoded_column ] ]
PROC vault_not_nullable_sensitive_with_values_proc ()
BEGIN
  SELECT
      vault_mixed_not_nullable_sensitive.id,
      vault_mixed_not_nullable_sensitive.name,
      vault_mixed_not_nullable_sensitive.title,
      vault_mixed_not_nullable_sensitive.type
    FROM vault_mixed_not_nullable_sensitive;
END;
--]]

function vault_not_nullable_sensitive_with_values_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vault_mixed_not_nullable_sensitive.id, vault_mixed_not_nullable_sensitive.name, vault_mixed_not_nullable_sensitive.title, vault_mixed_not_nullable_sensitive.type FROM vault_mixed_not_nullable_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_not_nullable_sensitive_with_values_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_not_nullable_sensitive_with_values_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "ISSL", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive ] ]
PROC vault_sensitive_mixed_proc ()
BEGIN
  SELECT
      vault_mixed_sensitive.id,
      vault_mixed_sensitive.name,
      vault_mixed_sensitive.title,
      vault_mixed_sensitive.type
    FROM vault_mixed_sensitive;
END;
--]]

function vault_sensitive_mixed_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vault_mixed_sensitive.id, vault_mixed_sensitive.name, vault_mixed_sensitive.title, vault_mixed_sensitive.type FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_mixed_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_mixed_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive ] ]
PROC vault_union_all_table_proc ()
BEGIN
  SELECT
      vault_mixed_sensitive.id,
      vault_mixed_sensitive.name,
      vault_mixed_sensitive.title,
      vault_mixed_sensitive.type
    FROM vault_mixed_sensitive
  UNION ALL
  SELECT
      vault_non_sensitive.id,
      vault_non_sensitive.name,
      vault_non_sensitive.title,
      vault_non_sensitive.type
    FROM vault_non_sensitive;
END;
--]]

function vault_union_all_table_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vault_mixed_sensitive.id, vault_mixed_sensitive.name, vault_mixed_sensitive.title, vault_mixed_sensitive.type FROM vault_mixed_sensitive UNION ALL SELECT vault_non_sensitive.id, vault_non_sensitive.name, vault_non_sensitive.title, vault_non_sensitive.type FROM vault_non_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_union_all_table_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_union_all_table_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive=alias_name ] ]
PROC vault_alias_column_proc ()
BEGIN
  SELECT name AS alias_name
    FROM vault_mixed_sensitive;
END;
--]]

function vault_alias_column_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT name FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_alias_column_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_alias_column_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "s", { "alias_name" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive=alias_name ] ]
PROC vault_alias_column_name_proc ()
BEGIN
  SELECT name AS alias_name
    FROM vault_mixed_sensitive;
END;
--]]

function vault_alias_column_name_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT name FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_alias_column_name_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_alias_column_name_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "s", { "alias_name" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive ] ]
PROC vault_cursor_proc ()
BEGIN
  CURSOR C FOR
    SELECT name
      FROM vault_mixed_sensitive;
  FETCH c;
END;
--]]

function vault_cursor_proc(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "name" }
  local C_types_ = "s"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT name FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ vault_sensitive=(title, (id, name)) ] ]
PROC vault_sensitive_with_context_and_sensitive_columns_proc ()
BEGIN
  SELECT
      vault_mixed_sensitive.id,
      vault_mixed_sensitive.name,
      vault_mixed_sensitive.title,
      vault_mixed_sensitive.type
    FROM vault_mixed_sensitive;
END;
--]]

function vault_sensitive_with_context_and_sensitive_columns_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vault_mixed_sensitive.id, vault_mixed_sensitive.name, vault_mixed_sensitive.title, vault_mixed_sensitive.type FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_with_context_and_sensitive_columns_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_with_context_and_sensitive_columns_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive=((id, name)) ] ]
PROC vault_sensitive_with_no_context_and_sensitive_columns_proc ()
BEGIN
  SELECT
      vault_mixed_sensitive.id,
      vault_mixed_sensitive.name,
      vault_mixed_sensitive.title,
      vault_mixed_sensitive.type
    FROM vault_mixed_sensitive;
END;
--]]

function vault_sensitive_with_no_context_and_sensitive_columns_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vault_mixed_sensitive.id, vault_mixed_sensitive.name, vault_mixed_sensitive.title, vault_mixed_sensitive.type FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_with_no_context_and_sensitive_columns_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_with_no_context_and_sensitive_columns_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ vault_sensitive=(title, (id, name)) ] ]
PROC vault_sensitive_with_context_and_no_sensitive_columns_proc ()
BEGIN
  SELECT
      vault_non_sensitive.id,
      vault_non_sensitive.name,
      vault_non_sensitive.title,
      vault_non_sensitive.type
    FROM vault_non_sensitive;
END;
--]]

function vault_sensitive_with_context_and_no_sensitive_columns_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vault_non_sensitive.id, vault_non_sensitive.name, vault_non_sensitive.title, vault_non_sensitive.type FROM vault_non_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_with_context_and_no_sensitive_columns_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_with_context_and_no_sensitive_columns_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC try_boxing (OUT result OBJECT<bar CURSOR>)
BEGIN
  CURSOR C FOR
    SELECT
        bar.id,
        bar.name,
        bar.rate,
        bar.type,
        bar.size
      FROM bar;
  SET result FROM CURSOR C;
END;
--]]

function try_boxing(_db_)
  local _rc_ = CQL_OK
  local result
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"

  C_stmt = nil
  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  result = C_stmt
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, result
end

-- The statement ending at line XXXX

--[[
PROC try_unboxing (boxed_cursor OBJECT<bar CURSOR>)
BEGIN
  CURSOR C FOR boxed_cursor;
  FETCH C;
END;
--]]

function try_unboxing(_db_, boxed_cursor)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"

  C_stmt = boxed_cursor
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC local_cast_int_notnull ()
BEGIN
  DECLARE x INT!;
  SET x := CAST(3.2 AS INT);
END;
--]]

function local_cast_int_notnull()
  local x = 0

  x = cql_to_integer(3.2)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_int ()
BEGIN
  DECLARE x INT;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS INT);
END;
--]]

function local_cast_int()
  local x
  local r

  r = 3.2
  x = cql_to_integer(r)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_long_notnull ()
BEGIN
  DECLARE x LONG!;
  SET x := CAST(3.2 AS LONG);
END;
--]]

function local_cast_long_notnull()
  local x = 0

  x = cql_to_integer(3.2)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_long ()
BEGIN
  DECLARE x LONG;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS LONG);
END;
--]]

function local_cast_long()
  local x
  local r

  r = 3.2
  x = cql_to_integer(r)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_real_notnull ()
BEGIN
  DECLARE x REAL!;
  SET x := CAST(3 AS REAL);
END;
--]]

function local_cast_real_notnull()
  local x = 0.0

  x = cql_to_float(3)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_real ()
BEGIN
  DECLARE x REAL;
  DECLARE r INT;
  SET r := nullable(3);
  SET x := CAST(r AS REAL);
END;
--]]

function local_cast_real()
  local x
  local r

  r = 3
  x = cql_to_float(r)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_bool_notnull ()
BEGIN
  DECLARE x BOOL!;
  SET x := CAST(3.2 AS BOOL);
END;
--]]

function local_cast_bool_notnull()
  local x = false

  x = cql_to_bool(3.2)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_bool ()
BEGIN
  DECLARE x BOOL;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS BOOL);
END;
--]]

function local_cast_bool()
  local x
  local r

  r = 3.2
  x = cql_to_bool(r)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_from_bool_notnull ()
BEGIN
  DECLARE b BOOL!;
  SET b := 1;
  DECLARE x REAL!;
  SET x := CAST(b AS REAL);
END;
--]]

function local_cast_from_bool_notnull()
  local b = false
  local x = 0.0

  b = true
  x = cql_to_float(b)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_from_bool ()
BEGIN
  DECLARE b BOOL;
  SET b := nullable(1);
  DECLARE x REAL;
  SET x := CAST(b AS REAL);
END;
--]]

function local_cast_from_bool()
  local b
  local x

  b = true
  x = cql_to_float(b)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_from_bool_no_op_notnull ()
BEGIN
  DECLARE x BOOL!;
  DECLARE b BOOL!;
  SET b := 0;
  SET x := CAST(b AS BOOL);
END;
--]]

function local_cast_from_bool_no_op_notnull()
  local x = false
  local b = false

  b = false
  x = (b)

end

-- The statement ending at line XXXX

--[[
PROC local_cast_from_bool_no_op ()
BEGIN
  DECLARE b BOOL;
  SET b := nullable(1);
  DECLARE x BOOL;
  SET x := CAST(b AS BOOL);
END;
--]]

function local_cast_from_bool_no_op()
  local b
  local x

  b = true
  x = (b)

end

-- The statement ending at line XXXX

--[[
PROC base_proc_savepoint ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    DECLARE X INT;
  END;
END;
--]]

function base_proc_savepoint(_db_)
  local _rc_ = CQL_OK
  local X

  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- try

    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_8; end
    goto catch_end_8

  ::catch_start_8:: 
  do
    local _rc_thrown_1 = _rc_
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_best_error(_rc_thrown_1)
    cql_error_trace(_rc_, _db_)
    goto cql_cleanup
  end

  ::catch_end_8::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC base_proc_savepoint_commit_return ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      COMMIT RETURN;
    END;
  END;
END;
--]]

function base_proc_savepoint_commit_return(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint_commit_return")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- try

    if true then
      _rc_ = cql_exec(_db_,
        "RELEASE base_proc_savepoint_commit_return")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_9; end
      _rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error
      goto cql_cleanup -- return
    end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_commit_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_9; end
    goto catch_end_9

  ::catch_start_9:: 
  do
    local _rc_thrown_1 = _rc_
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint_commit_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_commit_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_best_error(_rc_thrown_1)
    cql_error_trace(_rc_, _db_)
    goto cql_cleanup
  end

  ::catch_end_9::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC base_proc_savepoint_rollback_return ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      ROLLBACK RETURN;
    END;
  END;
END;
--]]

function base_proc_savepoint_rollback_return(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint_rollback_return")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- try

    if true then
      _rc_ = cql_exec(_db_,
        "ROLLBACK TO base_proc_savepoint_rollback_return")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_10; end
      _rc_ = cql_exec(_db_,
        "RELEASE base_proc_savepoint_rollback_return")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_10; end
      _rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error
      goto cql_cleanup -- return
    end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_rollback_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_10; end
    goto catch_end_10

  ::catch_start_10:: 
  do
    local _rc_thrown_1 = _rc_
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint_rollback_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_rollback_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_best_error(_rc_thrown_1)
    cql_error_trace(_rc_, _db_)
    goto cql_cleanup
  end

  ::catch_end_10::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE x INT!;
--]]
local x = 0

-- The statement ending at line XXXX

--[[
PROC window1 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window1(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window1_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window1(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window2 ()
BEGIN
  SELECT month, amount, 
    SUM(amount) OVER (ORDER BY month) AS RunningTotal
    FROM SalesInfo;
END;
--]]

function window2(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  SUM(amount) OVER (ORDER BY month) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window2_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window2(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "RunningTotal" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window3 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window3(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window3_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window3(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window4 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) FILTER (WHERE month = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window4(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) FILTER (WHERE month = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window4_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window4(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window5 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 3 PRECEDING AND 4 FOLLOWING EXCLUDE CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window5(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 3 PRECEDING AND 4 FOLLOWING EXCLUDE CURRENT ROW) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window5_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window5(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window6 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 4 PRECEDING AND 5 FOLLOWING EXCLUDE GROUP) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window6(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 4 PRECEDING AND 5 FOLLOWING EXCLUDE GROUP) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window6_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window6(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window7 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 6 PRECEDING AND 7 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window7(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 6 PRECEDING AND 7 FOLLOWING EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window7_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window7(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window8 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month RANGE BETWEEN 8 PRECEDING AND 9 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window8(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month RANGE BETWEEN 8 PRECEDING AND 9 FOLLOWING EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window8_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window8(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window9 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 10 PRECEDING AND 11 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window9(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 10 PRECEDING AND 11 FOLLOWING EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window9_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window9(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window10 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND 12 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window10(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND 12 FOLLOWING EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window10_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window10(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window11 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 13 FOLLOWING AND 14 PRECEDING) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window11(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 13 FOLLOWING AND 14 PRECEDING) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window11_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window11(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window12 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window12(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window12_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window12(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window13 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window13(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window13_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window13(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window14 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window14(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window14_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window14(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window15 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (PARTITION BY month ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window15(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (PARTITION BY month ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window15_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window15(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC window16 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (GROUPS CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window16(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (GROUPS CURRENT ROW) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window16_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window16(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC emit_rc (OUT result_code INT!)
BEGIN
  SET result_code := @RC;
END;
--]]

function emit_rc(_db_)
  local _rc_ = CQL_OK
  local result_code = 0

  result_code = CQL_OK
  _rc_ = CQL_OK

  return _rc_, result_code
end

-- The statement ending at line XXXX

--[[
PROC rc_test ()
BEGIN
  LET err := @RC;
  LET e0 := @RC;
  TRY
    TRY
      CREATE TABLE whatever_anything(
        id INT
      );
    CATCH
      SET err := @RC;
      LET e1 := @RC;
      TRY
        LET e2 := @RC;
        CREATE TABLE whatever_anything(
          id INT
        );
      CATCH
        LET e3 := @RC;
        SET err := @RC;
        THROW;
      END;
      LET e4 := @RC;
    END;
  CATCH
    LET e5 := @RC;
    CALL printf("Error %d\n", err);
  END;
  LET e6 := @RC;
END;
--]]

function rc_test(_db_)
  local _rc_ = CQL_OK
  local err = 0
  local e0 = 0
  local e1 = 0
  local e2 = 0
  local e3 = 0
  local e4 = 0
  local e5 = 0
  local e6 = 0

  err = CQL_OK
  e0 = CQL_OK
  -- try

    -- try

      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( id INTEGER )")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_12; end
      goto catch_end_12

    ::catch_start_12:: 
    do
      local _rc_thrown_1 = _rc_
      err = _rc_thrown_1
      e1 = _rc_thrown_1
      -- try

        e2 = _rc_thrown_1
        _rc_ = cql_exec(_db_,
          "CREATE TABLE whatever_anything( id INTEGER )")
        if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_13; end
        goto catch_end_13

      ::catch_start_13:: 
      do
        local _rc_thrown_2 = _rc_
        e3 = _rc_thrown_2
        err = _rc_thrown_2
        _rc_ = cql_best_error(_rc_thrown_2)
        cql_error_trace(_rc_, _db_)
        goto catch_start_11
      end

      ::catch_end_13::
      e4 = _rc_thrown_1
    end

    ::catch_end_12::
    goto catch_end_11

  ::catch_start_11:: 
  do
    local _rc_thrown_3 = _rc_
    e5 = _rc_thrown_3
    printf("Error %d\n", err)
  end

  ::catch_end_11::
  e6 = CQL_OK
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC rc_test_lazy1 ()
BEGIN
  TRY
    CREATE TABLE whatever_anything(
      id INT
    );
  CATCH
    TRY
      CREATE TABLE whatever_anything(
        id INT
      );
    CATCH
      THROW;
    END;
  END;
END;
--]]

function rc_test_lazy1(_db_)
  local _rc_ = CQL_OK
  -- try

    _rc_ = cql_exec(_db_,
      "CREATE TABLE whatever_anything( id INTEGER )")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_14; end
    goto catch_end_14

  ::catch_start_14:: 
  do
    -- try

      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( id INTEGER )")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_15; end
      goto catch_end_15

    ::catch_start_15:: 
    do
      local _rc_thrown_2 = _rc_
      _rc_ = cql_best_error(_rc_thrown_2)
      cql_error_trace(_rc_, _db_)
      goto cql_cleanup
    end

    ::catch_end_15::
  end

  ::catch_end_14::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC rc_test_lazy2 ()
BEGIN
  TRY
    CREATE TABLE whatever_anything(
      id INT
    );
  CATCH
    TRY
      CREATE TABLE whatever_anything(
        id INT
      );
    CATCH
      LET err := @RC;
    END;
  END;
END;
--]]

function rc_test_lazy2(_db_)
  local _rc_ = CQL_OK
  local err = 0

  -- try

    _rc_ = cql_exec(_db_,
      "CREATE TABLE whatever_anything( id INTEGER )")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_16; end
    goto catch_end_16

  ::catch_start_16:: 
  do
    -- try

      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( id INTEGER )")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_17; end
      goto catch_end_17

    ::catch_start_17:: 
    do
      local _rc_thrown_2 = _rc_
      err = _rc_thrown_2
    end

    ::catch_end_17::
  end

  ::catch_end_16::
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC virtual_table_creator ()
BEGIN
  CREATE VIRTUAL TABLE virt_table USING virt_module (ARGUMENTS FOLLOWING) AS (
    id INT,
    t TEXT
  );
END;
--]]

function virtual_table_creator(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE virt_table USING virt_module ( id INTEGER, t TEXT)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC out_arg_cursor (x INT!, OUT y INT!)
BEGIN
  CURSOR C LIKE out_arg_cursor ARGUMENTS;
  FETCH C(x, y) FROM VALUES (1, 1);
  CALL out_arg_cursor(C.x, C.y);
END;
--]]

function out_arg_cursor(x)
  cql_contract_argument_notnull(x, 1)

  local y = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "II"

  C._has_row_ = true
  C.x = 1
  C.y = 1
  C.y = out_arg_cursor(C.x)

  return y
end

-- The statement ending at line XXXX

--[[
PROC make_virt_table ()
BEGIN
  CREATE VIRTUAL TABLE v1 USING m1 AS (
    id INT
  );
  CREATE VIRTUAL TABLE v2 USING m2 (x) AS (
    id INT
  );
  CREATE VIRTUAL TABLE v3 USING m2 (ARGUMENTS FOLLOWING) AS (
    id INT
  );
END;
--]]

function make_virt_table(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v1 USING m1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v2 USING m2 (x)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v3 USING m2 ( id INTEGER)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC virtual1 ()
BEGIN
  SELECT virtual_with_hidden.vy
    FROM virtual_with_hidden;
END;
--]]

function virtual1(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT virtual_with_hidden.vy FROM virtual_with_hidden")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function virtual1_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = virtual1(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "i", { "vy" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC virtual2 ()
BEGIN
  SELECT vx, vy
    FROM virtual_with_hidden
    WHERE vx = 2;
END;
--]]

function virtual2(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vx, vy FROM virtual_with_hidden WHERE vx = 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function virtual2_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = virtual2(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Ii", { "vx", "vy" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ private ] ]
PROC private_proc (OUT x INT)
BEGIN
  SET x := 1;
END;
--]]

function private_proc()
  local x

  x = 1

  return x
end

-- The statement ending at line XXXX

--[[
[ [ private ] ]
PROC private_out_union ()
BEGIN
  CURSOR C LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES (1);
  OUT UNION C;
END;
--]]

function private_out_union_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C._has_row_ = true
  C.a_field = 1
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
PROC use_private_out_union ()
BEGIN
  CURSOR C FOR
    CALL private_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
--]]

function use_private_out_union(_db_)
  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C_result_set_ = private_out_union_fetch_results()
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  while true
  do
    C_row_num_ = C_row_num_ + 1
    if C_row_num_ <= C_row_count_ then
      C = C_result_set_[C_row_num_]
    else
      C = { _has_row_ = false }
    end
    if not C._has_row_ then break end
    printf("%d\n", C.a_field)
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ suppress_getters ] ]
PROC no_getters_out_union ()
BEGIN
  CURSOR C LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES (1);
  OUT UNION C;
END;
--]]

function no_getters_out_union_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C._has_row_ = true
  C.a_field = 1
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
PROC use_no_getters_out_union ()
BEGIN
  CURSOR C FOR
    CALL no_getters_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
--]]

function use_no_getters_out_union(_db_)
  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C_result_set_ = no_getters_out_union_fetch_results()
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  while true
  do
    C_row_num_ = C_row_num_ + 1
    if C_row_num_ <= C_row_count_ then
      C = C_result_set_[C_row_num_]
    else
      C = { _has_row_ = false }
    end
    if not C._has_row_ then break end
    printf("%d\n", C.a_field)
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ suppress_result_set ] ]
PROC suppress_results_out_union ()
BEGIN
  CURSOR C LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES (1);
  OUT UNION C;
END;
--]]

function suppress_results_out_union_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C._has_row_ = true
  C.a_field = 1
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
PROC use_suppress_results_out_union ()
BEGIN
  CURSOR C FOR
    CALL suppress_results_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
--]]

function use_suppress_results_out_union(_db_)
  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C_result_set_ = suppress_results_out_union_fetch_results()
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  while true
  do
    C_row_num_ = C_row_num_ + 1
    if C_row_num_ <= C_row_count_ then
      C = C_result_set_[C_row_num_]
    else
      C = { _has_row_ = false }
    end
    if not C._has_row_ then break end
    printf("%d\n", C.a_field)
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
[ [ private ] ]
PROC private_result (OUT x INT)
BEGIN
  SELECT 1 AS x;
END;
--]]

function private_result(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local x

  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt, x
end

-- The statement ending at line XXXX

--[[
[ [ private ] ]
DECLARE PROC private_fwd_ref (x INT!);
--]]

-- The statement ending at line XXXX

--[[
PROC set_out_arg_ref_test (OUT x TEXT)
BEGIN
END;
--]]

function set_out_arg_ref_test()
  local x


  return x
end

-- The statement ending at line XXXX

--[[
PROC set_out_arg_null_test (OUT x INT)
BEGIN
END;
--]]

function set_out_arg_null_test()
  local x


  return x
end

-- The statement ending at line XXXX

--[[
PROC set_out_arg_notnull_test (OUT x INT!)
BEGIN
END;
--]]

function set_out_arg_notnull_test()
  local x = 0


  return x
end
local global_cursor2 = { _has_row_ = false }
local global_cursor2_fields_ = { "x" }
local global_cursor2_types_ = "S"

-- The statement ending at line XXXX

--[[
PROC early_close_cursor ()
BEGIN
  CLOSE global_cursor;
  CLOSE global_cursor2;
END;
--]]

function early_close_cursor(_db_)
  local _rc_ = CQL_OK
  cql_finalize_stmt(global_cursor_stmt)
  global_cursor_stmt = nil
  global_cursor = { _has_row_ = false }
  global_cursor2 = { _has_row_ = false }
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC various_lets ()
BEGIN
  LET r := 1.0;
  LET i := 1;
  LET l := 1L;
  LET t := "T";
  LET nl := nullable(~2L);
  LET ni := nullable(2 + 2);
  LET nr := nullable(2.0);
  LET nt := nullable("NT");
  LET sl := sensitive(~3L);
  LET si := sensitive(3 + 3);
  LET sr := sensitive(3.0);
  LET st := sensitive("ST");
END;
--]]

function various_lets()
  local r = 0.0
  local i = 0
  local l = 0
  local t
  local nl
  local ni
  local nr
  local nt
  local sl = 0
  local si = 0
  local sr = 0.0
  local st

  r = 1.0
  i = 1
  l = 1
  t = "T"
  nl = (~2)
  ni = (2 + 2)
  nr = 2.0
  nt = "NT"
  sl = (~3)
  si = (3 + 3)
  sr = 3.0
  st = "ST"

end

-- The statement ending at line XXXX

--[[
PROC try_catch_rc ()
BEGIN
  CURSOR C FOR
    SELECT 'foo' AS extra2
      FROM bar;
  TRY
    FETCH C;
  CATCH
  END;
END;
--]]

function try_catch_rc(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "extra2" }
  local C_types_ = "S"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 'foo' FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- try

    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto catch_start_18; end
    goto catch_end_18

  ::catch_start_18:: 
  do
  end

  ::catch_end_18::
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC out2_proc (x INT, OUT y INT!, OUT z INT!);
--]]

-- The statement ending at line XXXX

--[[
PROC out_decl_test (x INT)
BEGIN
  DECLARE OUT CALL out2_proc(x, u, v);
  DECLARE OUT CALL out2_proc(x, u, v);
END;
--]]

function out_decl_test(x)
  local u = 0
  local v = 0

  u, v = out2_proc(x)
  u, v = out2_proc(x)

end

-- The statement ending at line XXXX

--[[
PROC out_decl_loop_test (x INT)
BEGIN
  WHILE 1
  BEGIN
    DECLARE OUT CALL out2_proc(x, u, v);
    DECLARE OUT CALL out2_proc(x, u, v);
  END;
END;
--]]

function out_decl_loop_test(x)
  local u = 0
  local v = 0

  while true
  do
    if not(true) then break end
    u, v = out2_proc(x)
    u, v = out2_proc(x)
  end

end

-- The statement ending at line XXXX

--[[
PROC binary_ops_with_null ()
BEGIN
  LET add0 := NULL + 42;
  LET add1 := 42 + NULL;
  LET bin_and0 := NULL & 42;
  LET bin_and1 := 42 & NULL;
  LET bin_or0 := NULL | 42;
  LET bin_or1 := 42 | NULL;
  LET div0 := NULL / 42;
  LET div1 := 42 / NULL;
  LET ge0 := NULL >= 42;
  LET ge1 := 42 >= NULL;
  LET gt0 := NULL > 42;
  LET gt1 := 42 > NULL;
  LET le0 := NULL <= 42;
  LET le1 := 42 <= NULL;
  LET like0 := NULL LIKE "foo";
  LET like1 := "foo" LIKE NULL;
  LET lshift0 := NULL << 42;
  LET lshift1 := 42 << NULL;
  LET lt0 := NULL < 42;
  LET lt1 := 42 < NULL;
  LET mod0 := NULL % 42;
  LET mod1 := 42 % NULL;
  LET mul0 := NULL * 42;
  LET mul1 := 42 * NULL;
  LET not_like0 := NULL NOT LIKE "foo";
  LET not_like1 := "foo" NOT LIKE NULL;
  LET rshift0 := NULL >> 42;
  LET rshift1 := 42 >> NULL;
  LET sub0 := NULL - 42;
  LET sub1 := 42 - NULL;
END;
--]]

function binary_ops_with_null()
  local add0
  local add1
  local bin_and0
  local bin_and1
  local bin_or0
  local bin_or1
  local div0
  local div1
  local ge0
  local ge1
  local gt0
  local gt1
  local le0
  local le1
  local like0
  local like1
  local lshift0
  local lshift1
  local lt0
  local lt1
  local mod0
  local mod1
  local mul0
  local mul1
  local not_like0
  local not_like1
  local rshift0
  local rshift1
  local sub0
  local sub1

  add0 = nil
  add1 = nil
  bin_and0 = nil
  bin_and1 = nil
  bin_or0 = nil
  bin_or1 = nil
  div0 = nil
  div1 = nil
  ge0 = nil
  ge1 = nil
  gt0 = nil
  gt1 = nil
  le0 = nil
  le1 = nil
  like0 = nil
  like1 = nil
  lshift0 = nil
  lshift1 = nil
  lt0 = nil
  lt1 = nil
  mod0 = nil
  mod1 = nil
  mul0 = nil
  mul1 = nil
  not_like0 = nil
  not_like1 = nil
  rshift0 = nil
  rshift1 = nil
  sub0 = nil
  sub1 = nil

end

-- The statement ending at line XXXX

--[[
PROC uses_throw ()
BEGIN
  THROW;
END;
--]]

function uses_throw(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_best_error(CQL_OK)
  cql_error_trace(_rc_, _db_)
  goto cql_cleanup
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC uses_ifnull_throw (x INT)
BEGIN
  LET y := ifnull_throw(x);
END;
--]]

function uses_ifnull_throw(_db_, x)
  local _rc_ = CQL_OK
  local y = 0

  if x == nil then
    _rc_ = CQL_ERROR
    cql_error_trace(_rc_, _db_)
    goto cql_cleanup
  end
  y = x
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC out_object (o OBJECT!)
BEGIN
  CURSOR C LIKE out_object ARGUMENTS;
  FETCH C(o) FROM VALUES (o);
  OUT C;
END;
--]]

function out_object(o)
  cql_contract_argument_notnull(o, 1)

  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "o" }
  local C_types_ = "O"

  C._has_row_ = true
  C.o = o
  _result_ = cql_clone_row(C)

  return _result_
end

function out_object_fetch_results(o)
  local result_set = nil
  _result_ = out_object(o)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC exercise_contracts (a INT, b INT!, c TEXT, d TEXT!, e BLOB, f BLOB!, g OBJECT, h OBJECT!, OUT i INT, OUT j INT!, OUT k TEXT, OUT l TEXT!, INOUT m INT, INOUT n INT!, INOUT o TEXT, INOUT p TEXT!)
BEGIN
  SET l := "text";
END;
--]]

function exercise_contracts(a, b, c, d, e, f, g, h, m, n, o, p)
  cql_contract_argument_notnull(b, 2)
  cql_contract_argument_notnull(d, 4)
  cql_contract_argument_notnull(f, 6)
  cql_contract_argument_notnull(h, 8)
  cql_contract_argument_notnull(n, 14)
  cql_contract_argument_notnull(p, 16)

  local i
  local j = 0
  local k
  local l

  l = "text"

  return i, j, k, l, m, n, o, p
end

-- The statement ending at line XXXX

--[[
PROC public_proc_with_a_contract (t TEXT!)
BEGIN
END;
--]]

function public_proc_with_a_contract(t)
  cql_contract_argument_notnull(t, 1)


end

-- The statement ending at line XXXX

--[[
[ [ private ] ]
PROC private_proc_without_a_contract (t TEXT!)
BEGIN
END;
--]]

function private_proc_without_a_contract(t)

end

-- The statement ending at line XXXX

--[[
PROC result_set_proc_with_contract_in_fetch_results (t TEXT!)
BEGIN
  SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar;
END;
--]]

function result_set_proc_with_contract_in_fetch_results(_db_, t)
  cql_contract_argument_notnull(t, 1)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function result_set_proc_with_contract_in_fetch_results_fetch_results(_db_, t)
  local result_set = nil
  local _rc_
  _rc_, stmt = result_set_proc_with_contract_in_fetch_results(_db_, t)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC out_proc_with_contract_in_fetch_results (t TEXT!)
BEGIN
  CURSOR C LIKE bar;
  OUT C;
END;
--]]

function out_proc_with_contract_in_fetch_results(t)
  cql_contract_argument_notnull(t, 1)

  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"

  _result_ = cql_clone_row(C)

  return _result_
end

function out_proc_with_contract_in_fetch_results_fetch_results(t)
  local result_set = nil
  _result_ = out_proc_with_contract_in_fetch_results(t)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
PROC nullability_improvements_are_erased_for_sql ()
BEGIN
  DECLARE a INT;
  IF a IS NOT NULL THEN
    SELECT a + 1 AS b;
  END;
END;
--]]

function nullability_improvements_are_erased_for_sql(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local a

  if a ~= nil then
    _rc_, _result_stmt = cql_prepare(_db_, 
      "SELECT ? + 1")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_multibind(_db_, _result_stmt, "i", a)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function nullability_improvements_are_erased_for_sql_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = nullability_improvements_are_erased_for_sql(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "b" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC nullability_improvements_do_not_change_access ()
BEGIN
  DECLARE a INT;
  IF a IS NOT NULL THEN
    LET b := a;
    SET a := 0;
  END;
END;
--]]

function nullability_improvements_do_not_change_access()
  local a
  local b = 0

  if a ~= nil then
    b = a
    a = 0
  end

end
local true_test = false
local false_test = false

-- The statement ending at line XXXX

--[[
PROC BigFormat ()
BEGIN
  CURSOR C FOR
    SELECT
        big_data.f1,
        big_data.f2,
        big_data.f3,
        big_data.f4,
        big_data.f5,
        big_data.f6,
        big_data.f7,
        big_data.f8,
        big_data.f9,
        big_data.f10,
        big_data.f11,
        big_data.f12,
        big_data.f13,
        big_data.f14,
        big_data.f15,
        big_data.f16,
        big_data.f17,
        big_data.f18,
        big_data.f19,
        big_data.f20,
        big_data.f21,
        big_data.f22,
        big_data.f23,
        big_data.f24,
        big_data.f25,
        big_data.f26,
        big_data.f27,
        big_data.f28,
        big_data.f29,
        big_data.f30,
        big_data.f31,
        big_data.f32,
        big_data.f33,
        big_data.f34,
        big_data.f35,
        big_data.f36,
        big_data.f38,
        big_data.f39,
        big_data.f40,
        big_data.f41,
        big_data.f42,
        big_data.f43,
        big_data.f44,
        big_data.f45,
        big_data.f46,
        big_data.f47,
        big_data.f48,
        big_data.f49,
        big_data.f50,
        big_data.f51,
        big_data.f52,
        big_data.f53,
        big_data.f54,
        big_data.f55,
        big_data.f56,
        big_data.f57,
        big_data.f58,
        big_data.f59,
        big_data.f60,
        big_data.f61,
        big_data.f62,
        big_data.f63,
        big_data.f64,
        big_data.f65,
        big_data.f66,
        big_data.f67,
        big_data.f68,
        big_data.f69,
        big_data.f70,
        big_data.f71,
        big_data.f72,
        big_data.f73,
        big_data.f74,
        big_data.f75
      FROM big_data;
  LOOP FETCH C
  BEGIN
    LET s := cql_cursor_format(C);
  END;
END;
--]]

function BigFormat(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15", "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23", "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31", "f32", "f33", "f34", "f35", "f36", "f38", "f39", "f40", "f41", "f42", "f43", "f44", "f45", "f46", "f47", "f48", "f49", "f50", "f51", "f52", "f53", "f54", "f55", "f56", "f57", "f58", "f59", "f60", "f61", "f62", "f63", "f64", "f65", "f66", "f67", "f68", "f69", "f70", "f71", "f72", "f73", "f74", "f75" }
  local C_types_ = "LIsSsslLLLLsFlfIIsisisiLsFFFsssilissLlfFsslFlIslsslIsLLssisilliLIIisdliili"
  local s

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT big_data.f1, big_data.f2, big_data.f3, big_data.f4, big_data.f5, big_data.f6, big_data.f7, big_data.f8, big_data.f9, big_data.f10, big_data.f11, big_data.f12, big_data.f13, big_data.f14, big_data.f15, big_data.f16, big_data.f17, big_data.f18, big_data.f19, big_data.f20, big_data.f21, big_data.f22, big_data.f23, big_data.f24, big_data.f25, big_data.f26, big_data.f27, big_data.f28, big_data.f29, big_data.f30, big_data.f31, big_data.f32, big_data.f33, big_data.f34, big_data.f35, big_data.f36, big_data.f38, big_data.f39, big_data.f40, big_data.f41, big_data.f42, big_data.f43, big_data.f44, big_data.f45, big_data.f46, big_data.f47, big_data.f48, big_data.f49, big_data.f50, big_data.f51, big_data.f52, big_data.f53, big_data.f54, big_data.f55, big_data.f56, big_data.f57, big_data.f58, big_data.f59, big_data.f60, big_data.f61, big_data.f62, big_data.f63, big_data.f64, big_data.f65, big_data.f66, big_data.f67, big_data.f68, big_data.f69, big_data.f70, big_data.f71, big_data.f72, big_data.f73, big_data.f74, big_data.f75 FROM big_data")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  while true
  do
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if not C._has_row_ then break end
    s = cql_cursor_format(C, C_types_, C_fields_)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end
local sign_val_int = 0
local sign_val_nullable
local abs_val_int = 0
local abs_val_nullable
local abs_val_long = 0
local abs_val_real = 0.0

-- The statement ending at line XXXX

--[[
PROC ltor_proc_int_not_null (a INT!, b INT!, OUT c INT!)
BEGIN
END;
--]]

function ltor_proc_int_not_null(a, b)
  cql_contract_argument_notnull(a, 1)
  cql_contract_argument_notnull(b, 2)

  local c = 0


  return c
end

-- The statement ending at line XXXX

--[[
PROC ltor_proc_int (a INT, b INT, OUT c INT)
BEGIN
END;
--]]

function ltor_proc_int(a, b)
  local c


  return c
end

-- The statement ending at line XXXX

--[[
PROC ltor_proc_text_not_null (a TEXT!, b TEXT!, OUT c TEXT!)
BEGIN
  SET c := "text";
END;
--]]

function ltor_proc_text_not_null(a, b)
  cql_contract_argument_notnull(a, 1)
  cql_contract_argument_notnull(b, 2)

  local c

  c = "text"

  return c
end

-- The statement ending at line XXXX

--[[
PROC ltor_proc_text (a TEXT, b TEXT, OUT c TEXT)
BEGIN
END;
--]]

function ltor_proc_text(a, b)
  local c


  return c
end

-- The statement ending at line XXXX

--[[
PROC arguments_are_evaluated_left_to_right ()
BEGIN
  LET a := ltor_proc_int_not_null(ltor_proc_int_not_null(1, 2), ltor_proc_int_not_null(3, 4));
  LET b := ltor_proc_int(ltor_proc_int(1, 2), ltor_proc_int(3, 4));
  LET c := ltor_proc_text_not_null(ltor_proc_text_not_null("1", "2"), ltor_proc_text_not_null("3", "4"));
  LET d := ltor_proc_text(ltor_proc_text("1", "2"), ltor_proc_text("3", "4"));
  LET e := ltor_func_int_not_null(ltor_func_int_not_null(1, 2), ltor_func_int_not_null(3, 4));
  LET f := ltor_func_int(ltor_func_int(1, 2), ltor_func_int(3, 4));
  LET g := ltor_func_text_not_null(ltor_func_text_not_null("1", "2"), ltor_func_text_not_null("3", "4"));
  LET h := ltor_func_text(ltor_func_text("1", "2"), ltor_func_text("3", "4"));
END;
--]]

function arguments_are_evaluated_left_to_right()
  local _tmp_int_1 = 0
  local _tmp_int_2 = 0
  local a = 0
  local _tmp_n_int_1
  local _tmp_n_int_2
  local b
  local _tmp_text_1
  local _tmp_text_2
  local c
  local _tmp_n_text_1
  local _tmp_n_text_2
  local d
  local e = 0
  local f
  local g
  local h

  _tmp_int_1 = ltor_proc_int_not_null(1, 2)
  _tmp_int_2 = ltor_proc_int_not_null(3, 4)
  a = ltor_proc_int_not_null(_tmp_int_1, _tmp_int_2)
  _tmp_n_int_1 = ltor_proc_int(1, 2)
  _tmp_n_int_2 = ltor_proc_int(3, 4)
  b = ltor_proc_int(_tmp_n_int_1, _tmp_n_int_2)
  _tmp_text_1 = ltor_proc_text_not_null("1", "2")
  _tmp_text_2 = ltor_proc_text_not_null("3", "4")
  c = ltor_proc_text_not_null(_tmp_text_1, _tmp_text_2)
  _tmp_n_text_1 = ltor_proc_text("1", "2")
  _tmp_n_text_2 = ltor_proc_text("3", "4")
  d = ltor_proc_text(_tmp_n_text_1, _tmp_n_text_2)
  _tmp_int_1 = ltor_func_int_not_null(1, 2)
  _tmp_int_2 = ltor_func_int_not_null(3, 4)
  e = ltor_func_int_not_null(_tmp_int_1, _tmp_int_2)
  _tmp_n_int_1 = ltor_func_int(1, 2)
  _tmp_n_int_2 = ltor_func_int(3, 4)
  f = ltor_func_int(_tmp_n_int_1, _tmp_n_int_2)
  _tmp_text_1 = ltor_func_text_not_null("1", "2")
  _tmp_text_2 = ltor_func_text_not_null("3", "4")
  g = ltor_func_text_not_null(_tmp_text_1, _tmp_text_2)
  _tmp_n_text_1 = ltor_func_text("1", "2")
  _tmp_n_text_2 = ltor_func_text("3", "4")
  h = ltor_func_text(_tmp_n_text_1, _tmp_n_text_2)

end

-- The statement ending at line XXXX

--[[
PROC f1 (OUT x INT!)
BEGIN
  SET x := 5;
END;
--]]

function f1()
  local x = 0

  x = 5

  return x
end

-- The statement ending at line XXXX

--[[
PROC f2 (OUT x INT)
BEGIN
  SET x := 5;
END;
--]]

function f2()
  local x

  x = 5

  return x
end

-- The statement ending at line XXXX

--[[
PROC f3 (y INT, OUT x INT)
BEGIN
  SET x := y;
END;
--]]

function f3(y)
  local x

  x = y

  return x
end

-- The statement ending at line XXXX

--[[
PROC multi_call_temp_reuse ()
BEGIN
  LET q := f1() + f1() + f1();
  LET r := f2() + f2() + f2();
  LET s := f3(0) + f3(1) + f3(2);
END;
--]]

function multi_call_temp_reuse()
  local _tmp_int_0 = 0
  local _tmp_int_1 = 0
  local _tmp_int_2 = 0
  local q = 0
  local _tmp_n_int_0
  local _tmp_n_int_1
  local _tmp_n_int_2
  local r
  local s

  _tmp_int_0 = f1()
  _tmp_int_1 = f1()
  _tmp_int_2 = f1()
  q = _tmp_int_0 + _tmp_int_1 + _tmp_int_2
  _tmp_n_int_0 = f2()
  _tmp_n_int_1 = f2()
  _tmp_n_int_2 = f2()
  r = cql_add(cql_add(_tmp_n_int_0, _tmp_n_int_1), _tmp_n_int_2)
  _tmp_n_int_0 = f3(0)
  _tmp_n_int_1 = f3(1)
  _tmp_n_int_2 = f3(2)
  s = cql_add(cql_add(_tmp_n_int_0, _tmp_n_int_1), _tmp_n_int_2)

end

-- The statement ending at line XXXX

--[[
PROC sensitive_function_is_a_no_op ()
BEGIN
  LET x := sensitive("hello");
  SELECT sensitive("hello") AS y;
END;
--]]

function sensitive_function_is_a_no_op(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local x

  x = "hello"
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 'hello'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function sensitive_function_is_a_no_op_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = sensitive_function_is_a_no_op(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "S", { "y" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC and_preserves_temps (a LONG, b LONG, c LONG)
BEGIN
  IF a > b AND (a < c OR c IS NULL) THEN
    SET c := a;
  END;
END;
--]]

function and_preserves_temps(a, b, c)
  if cql_shortcircuit_and(cql_gt(a, b), function() return cql_shortcircuit_or(cql_lt(a, c), function() return c == nil end) end) then
    c = a
  end

end

-- The statement ending at line XXXX

--[[
PROC or_preserves_temps (a LONG, b LONG, c LONG)
BEGIN
  IF c < 0 OR a > c AND b > c THEN
    SET c := a;
  END;
END;
--]]

function or_preserves_temps(a, b, c)
  if cql_shortcircuit_or(cql_lt(c, 0), function() return cql_shortcircuit_and(cql_gt(a, c), function() return cql_gt(b, c) end) end) then
    c = a
  end

end

-- The statement ending at line XXXX

--[[
PROC foo ()
BEGIN
  WITH
    shared_frag (shared_something) AS (CALL shared_frag())
  SELECT shared_frag.shared_something
    FROM shared_frag;
END;
--]]

function foo(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    3, nil,
    {
    "WITH shared_frag (shared_something) AS (",
    "SELECT 1234",
    ") SELECT shared_frag.shared_something FROM shared_frag"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function foo_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = foo(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "shared_something" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC shared_conditional_user (x INT!)
BEGIN
  WITH
    some_cte (id) AS (
      SELECT x
    ),
    shared_conditional (x) AS (CALL shared_conditional(1))
  SELECT
      bar.id,
      bar.name,
      bar.rate,
      bar.type,
      bar.size
    FROM bar
      INNER JOIN some_cte ON x = 5;
END;
--]]

function shared_conditional_user(_db_, x)
  cql_contract_argument_notnull(x, 1)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  local _p1_x_ = 0
  local _preds_1  -- 5 possible fragments
  local _vpreds_1 -- 8 possible bindings

  _preds_1 = {}
  _vpreds_1 = {}
  _p1_x_ = 1
  _preds_1[0] = true
  _vpreds_1[0] = true -- pred 0 known to be true
  if _p1_x_ == 1 then
    _preds_1[1] = true
    _vpreds_1[1] = true -- pred 1 known to be true
  else
    if _p1_x_ == 2 then
      _preds_1[2] = true
      _vpreds_1[2] = true -- pred 2 known to be true
      _vpreds_1[3] = true -- pred 2 known to be true
    else
      _preds_1[3] = true
      _vpreds_1[4] = true -- pred 3 known to be true
      _vpreds_1[5] = true -- pred 3 known to be true
      _vpreds_1[6] = true -- pred 3 known to be true
    end
  end
  _preds_1[4] = true
  _vpreds_1[7] = true -- pred 0 known to be true
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    5, _preds_1,
    {
    "WITH some_cte (id) AS ( SELECT ? ), shared_conditional (x) AS (",
    "SELECT ?",
    "SELECT ? + ?",
    "SELECT ? + ? + ?",
    ") SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar INNER JOIN some_cte ON ? = 5"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind_var(_db_, _result_stmt, 8, _vpreds_1, "IIIIIIII", x, _p1_x_, _p1_x_, _p1_x_, _p1_x_, _p1_x_, _p1_x_, x)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function shared_conditional_user_fetch_results(_db_, x)
  local result_set = nil
  local _rc_
  _rc_, stmt = shared_conditional_user(_db_, x)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC nested_shared_stuff ()
BEGIN
  WITH
    nested_shared_proc (x) AS (CALL nested_shared_proc(1))
  SELECT nested_shared_proc.x
    FROM nested_shared_proc;
END;
--]]

function nested_shared_stuff(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local _p1_x__ = 0
  local _p2_x_ = 0
  local _preds_1  -- 8 possible fragments
  local _vpreds_1 -- 8 possible bindings

  _preds_1 = {}
  _vpreds_1 = {}
  _p1_x__ = 1
  _preds_1[0] = true
  if _p1_x__ <= 5 then
    _preds_1[1] = true
    _p2_x_ = 1
    if _p2_x_ == 1 then
      _preds_1[2] = true
      _vpreds_1[0] = true -- pred 2 known to be true
    else
      if _p2_x_ == 2 then
        _preds_1[3] = true
        _vpreds_1[1] = true -- pred 3 known to be true
        _vpreds_1[2] = true -- pred 3 known to be true
      else
        _preds_1[4] = true
        _vpreds_1[3] = true -- pred 4 known to be true
        _vpreds_1[4] = true -- pred 4 known to be true
        _vpreds_1[5] = true -- pred 4 known to be true
      end
    end
    _preds_1[5] = _preds_1[1]
    _vpreds_1[6] = _preds_1[1]
  else
    _preds_1[6] = true
    _vpreds_1[7] = true -- pred 6 known to be true
  end
  _preds_1[7] = true
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    8, _preds_1,
    {
    "WITH nested_shared_proc (x) AS (",
    " WITH shared_conditional (x) AS (",
    "SELECT ?",
    "SELECT ? + ?",
    "SELECT ? + ? + ?",
    ") SELECT shared_conditional.x FROM shared_conditional WHERE ? = 5",
    "SELECT ?",
    ") SELECT nested_shared_proc.x FROM nested_shared_proc"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind_var(_db_, _result_stmt, 8, _vpreds_1, "IIIIIIII", _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p1_x__, _p1_x__)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function nested_shared_stuff_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = nested_shared_stuff(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC use_nested_select_shared_frag_form ()
BEGIN
  SELECT _select_.x
    FROM (CALL nested_shared_proc(1));
END;
--]]

function use_nested_select_shared_frag_form(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local _p1_x__ = 0
  local _p2_x_ = 0
  local _preds_1  -- 10 possible fragments
  local _vpreds_1 -- 8 possible bindings

  _preds_1 = {}
  _vpreds_1 = {}
  _p1_x__ = 1
  _preds_1[0] = true
  _preds_1[1] = true
  if _p1_x__ <= 5 then
    _preds_1[2] = true
    _p2_x_ = 1
    if _p2_x_ == 1 then
      _preds_1[3] = true
      _vpreds_1[0] = true -- pred 3 known to be true
    else
      if _p2_x_ == 2 then
        _preds_1[4] = true
        _vpreds_1[1] = true -- pred 4 known to be true
        _vpreds_1[2] = true -- pred 4 known to be true
      else
        _preds_1[5] = true
        _vpreds_1[3] = true -- pred 5 known to be true
        _vpreds_1[4] = true -- pred 5 known to be true
        _vpreds_1[5] = true -- pred 5 known to be true
      end
    end
    _preds_1[6] = _preds_1[2]
    _vpreds_1[6] = _preds_1[2]
  else
    _preds_1[7] = true
    _vpreds_1[7] = true -- pred 7 known to be true
  end
  _preds_1[8] = true
  _preds_1[9] = true
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    10, _preds_1,
    {
    "SELECT x FROM (",
    "(",
    " WITH shared_conditional (x) AS (",
    "SELECT ?",
    "SELECT ? + ?",
    "SELECT ? + ? + ?",
    ") SELECT shared_conditional.x FROM shared_conditional WHERE ? = 5",
    "SELECT ? AS x",
    ")",
    ")"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind_var(_db_, _result_stmt, 8, _vpreds_1, "IIIIIIII", _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p1_x__, _p1_x__)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function use_nested_select_shared_frag_form_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = use_nested_select_shared_frag_form(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ private ] ]
PROC simple_shared_frag ()
BEGIN
  SELECT _select_.shared_something
    FROM (CALL shared_frag());
END;
--]]

function simple_shared_frag(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    5, nil,
    {
    "SELECT shared_something FROM (",
    "(",
    "SELECT 1234 AS shared_something",
    ")",
    ")"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

-- The statement ending at line XXXX

--[[
PROC slash_star_and_star_slash ()
BEGIN
  LET x := "/*  */";
END;
--]]

function slash_star_and_star_slash()
  local x

  x = "/*  */"

end

-- The statement ending at line XXXX

--[[
PROC blob_serialization_test ()
BEGIN
  CURSOR C FOR
    SELECT 1 AS id, 'foo' AS name;
  FETCH C;
  DECLARE B BLOB<structured_storage>!;
  CALL cql_cursor_to_blob(C, B);
  CURSOR D LIKE C;
  CALL cql_cursor_from_blob(D, B);
END;
--]]

function blob_serialization_test(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name" }
  local C_types_ = "IS"
  local B
  local D = { _has_row_ = false }
  local D_fields_ = { "id", "name" }
  local D_types_ = "IS"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1, 'foo'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, B = cql_cursor_to_blob(_db_, C, C_types_, C_fields_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_cursor_from_blob(_db_, D, D_types_, D_fields_, B)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC deserialize_func ()
BEGIN
  CURSOR C LIKE structured_storage;
  CALL cql_cursor_from_blob(C, make_blob());
END;
--]]

function deserialize_func(_db_)
  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name" }
  local C_types_ = "IS"
  local _tmp_n_blob_0

  _tmp_n_blob_0 = make_blob()
  _rc_ = cql_cursor_from_blob(_db_, C, C_types_, C_fields_, _tmp_n_blob_0)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC bigstuff ()
BEGIN
  LET big1 := 0x7fffffffffffffffL;
  LET big2 := 0x8000000000000000L;
  LET big3 := -9223372036854775808L;
  LET big4 := -9223372036854775808L;
  LET big5 := 9223372036854775807L;
  LET big6 := 9223372036854775807L;
END;
--]]

function bigstuff()
  local big1 = 0
  local big2 = 0
  local big3 = 0
  local big4 = 0
  local big5 = 0
  local big6 = 0

  big1 = 0x7fffffffffffffff
  big2 = 0x8000000000000000
  big3 = (-9223372036854775807 - 1)
  big4 = (-9223372036854775807 - 1)
  big5 = 9223372036854775807
  big6 = 9223372036854775807

end

-- The statement ending at line XXXX
gr_cursor = { _has_row_ = false }
gr_cursor_fields_ = { "x", "y" }
gr_cursor_types_ = "IS"
gr_not_null_integer = 0
gr_not_null_bool = false
gr_blob_cursor = { _has_row_ = false }
gr_blob_cursor_fields_ = { "id", "name" }
gr_blob_cursor_types_ = "IS"

-- The statement ending at line XXXX

--[[
PROC use_gr_cursor_for_serialization (OUT b BLOB<structured_storage>!)
BEGIN
  CALL cql_cursor_to_blob(gr_blob_cursor, b);
END;
--]]

function use_gr_cursor_for_serialization(_db_)
  local _rc_ = CQL_OK
  local b

  _rc_, b = cql_cursor_to_blob(_db_, gr_blob_cursor, gr_blob_cursor_types_, gr_blob_cursor_fields_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, b
end

-- The statement ending at line XXXX

--[[
PROC mutated_in_param_ref (x TEXT)
BEGIN
  SET x := 'hi';
END;
--]]

function mutated_in_param_ref(x)
  x = "hi"

end

-- The statement ending at line XXXX

--[[
DECLARE PROC some_redeclared_out_proc () OUT (x INT) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC some_redeclared_out_proc () OUT (x INT) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
PROC some_redeclared_out_proc ()
BEGIN
  CURSOR c FOR
    SELECT nullable(1) AS x;
  FETCH c;
  OUT c;
END;
--]]

function some_redeclared_out_proc(_db_)
  local _rc_ = CQL_OK
  local _result_ = nil
  local c_stmt = nil
  local c = { _has_row_ = false }
  local c_fields_ = { "x" }
  local c_types_ = "i"

  _rc_, c_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(c_stmt, c, c_types_, c_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _result_ = cql_clone_row(c)
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(c_stmt)
  c_stmt = nil
  return _rc_, _result_
end

function some_redeclared_out_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, _result_ = some_redeclared_out_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
result_set = { _result_ }

::cql_cleanup::
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
DECLARE PROC some_redeclared_out_union_proc () OUT UNION (x INT) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC some_redeclared_out_union_proc () OUT UNION (x INT) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
PROC some_redeclared_out_union_proc ()
BEGIN
  CURSOR c FOR
    SELECT nullable(1) AS x;
  FETCH c;
  OUT UNION c;
END;
--]]

function some_redeclared_out_union_proc_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local c_stmt = nil
  local c = { _has_row_ = false }
  local c_fields_ = { "x" }
  local c_types_ = "i"

  _rc_, c_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(c_stmt, c, c_types_, c_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if c._has_row_ then
    table.insert(_rows_, cql_clone_row(c))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(c_stmt)
  c_stmt = nil
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
PROC external_cursor_caller ()
BEGIN
  CURSOR shape_storage LIKE SELECT 1 AS x;
  LET result := external_cursor_func(shape_storage);
END;
--]]

function external_cursor_caller()
  local shape_storage = { _has_row_ = false }
  local shape_storage_fields_ = { "x" }
  local shape_storage_types_ = "I"
  local result

  result = external_cursor_func(shape_storage, shape_storage_types_, shape_storage_fields_)

end

-- The statement ending at line XXXX

--[[
PROC clobber1 (INOUT x TEXT)
BEGIN
  SET x := "xyzzy";
END;
--]]

function clobber1(x)
  x = "xyzzy"

  return x
end

-- The statement ending at line XXXX

--[[
PROC clobber2 (OUT x TEXT)
BEGIN
  SET x := "xyzzy";
END;
--]]

function clobber2()
  local x

  x = "xyzzy"

  return x
end

-- The statement ending at line XXXX

--[[
PROC mutated_in_arg1 (x TEXT)
BEGIN
  CALL clobber1(x);
END;
--]]

function mutated_in_arg1(x)
  x = clobber1(x)

end

-- The statement ending at line XXXX

--[[
PROC mutated_in_arg2 (x TEXT)
BEGIN
  CALL clobber2(x);
END;
--]]

function mutated_in_arg2(x)
  x = clobber2()

end

-- The statement ending at line XXXX

--[[
PROC mutated_in_arg3 (x TEXT)
BEGIN
  CURSOR C FOR
    SELECT "x" AS x;
  FETCH C INTO x;
END;
--]]

function mutated_in_arg3(_db_, x)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "S"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 'x'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  x = C.x
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC mutated_not_null (INOUT x TEXT!)
BEGIN
  SET x := 'xyzzy';
END;
--]]

function mutated_not_null(x)
  cql_contract_argument_notnull(x, 1)

  x = "xyzzy"

  return x
end

-- The statement ending at line XXXX

--[[
PROC simple_child_proc ()
BEGIN
  SELECT 1 AS x, 2 AS y;
END;
--]]

function simple_child_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function simple_child_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = simple_child_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "x", "y" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
[ [ emit_setters ] ]
PROC simple_container_proc ()
BEGIN
  CURSOR C LIKE (a INT, b INT!, c OBJECT<simple_child_proc SET>);
  FETCH C(a, b, c) FROM VALUES (1, 2, simple_child_proc());
  OUT UNION C;
END;
--]]

function simple_container_proc_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "a", "b", "c" }
  local C_types_ = "iIo"
  local _tmp_object_0

  C._has_row_ = true
  C.a = 1
  C.b = 2
  _rc_, _tmp_object_0 = simple_child_proc_fetch_results(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  C.c = _tmp_object_0
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC num_arg (x INT!);
--]]

-- The statement ending at line XXXX

--[[
PROC call_num_with_bool ()
BEGIN
  CALL num_arg(TRUE);
END;
--]]

function call_num_with_bool()
  num_arg(1)

end

-- The statement ending at line XXXX

--[[
PROC big_switch_label (x LONG!)
BEGIN
  SWITCH x
    WHEN -9223372036854775808L THEN
      LET y := 0;
    WHEN 9223372036854775807L THEN
      LET z := 1;
  END;
END;
--]]

function big_switch_label(x)
  cql_contract_argument_notnull(x, 1)

  local _tmp_int64_0 = 0
  local y = 0
  local z = 0

  _tmp_int64_0 = x
  repeat
    if _tmp_int64_0 == (-9223372036854775807 - 1) then
      y = 0
      break
    end

    if _tmp_int64_0 == 9223372036854775807 then
      z = 1
      break
    end
  until true

end

-- The statement ending at line XXXX

--[[
[ [ private ] ]
PROC explain_equery_plan_backed (OUT x BOOL!)
BEGIN
  EXPLAIN QUERY PLAN
  WITH
    backed (rowid, pk, flag, id, name, age, storage) AS (CALL _backed())
  SELECT
      backed.pk,
      backed.flag,
      backed.id,
      backed.name,
      backed.age,
      backed.storage
    FROM backed;
END;
--]]

function explain_equery_plan_backed(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local x = false

  _rc_, _result_stmt = cql_prepare_var(_db_, 
    3, nil,
    {
    "EXPLAIN QUERY PLAN WITH backed (rowid, pk, flag, id, name, age, storage) AS (",
    "SELECT rowid, bgetkey(T.k, 0), bgetval(T.v, 1055660242183705531), bgetval(T.v, -9155171551243524439), bgetval(T.v, -6946718245010482247), bgetval(T.v, -3683705396192132539), bgetval(T.v, -7635294210585028660) FROM backing AS T WHERE bgetkey_type(T.k) = -5417664364642960231",
    ") SELECT backed.pk, backed.flag, backed.id, backed.name, backed.age, backed.storage FROM backed"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt, x
end

-- The statement ending at line XXXX

--[[
PROC stmt_in_loop ()
BEGIN
  LET i := 0;
  WHILE i < 10
  BEGIN
    DELETE FROM foo WHERE id = i;
    SET i := i + 1;
  END;
  LET x := ( SELECT EXISTS (SELECT 1
      FROM foo) );
END;
--]]

function stmt_in_loop(_db_)
  local _rc_ = CQL_OK
  local i = 0
  local _temp1_stmt = nil
  local x = false
  local _temp_stmt = nil

  i = 0
  while true
  do
    if not(i < 10) then break end
    if _temp1_stmt == nil then
      _rc_, _temp1_stmt = cql_prepare(_db_, 
      "DELETE FROM foo WHERE id = ?")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    end
    _rc_ = cql_multibind(_db_, _temp1_stmt, "I", i)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_step(_temp1_stmt)
    if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    cql_reset_stmt(_temp1_stmt)
    i = i + 1
  end
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT EXISTS (SELECT 1 FROM foo)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    x = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp1_stmt)
  _temp1_stmt = nil
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC cursor_in_loop ()
BEGIN
  LET i := 0;
  WHILE i < 10
  BEGIN
    CURSOR C FOR
      SELECT foo.id
        FROM foo
        WHERE id = i;
    FETCH C;
    SET i := i + 1;
  END;
  LET x := ( SELECT EXISTS (SELECT 1
      FROM foo) );
END;
--]]

function cursor_in_loop(_db_)
  local _rc_ = CQL_OK
  local i = 0
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id" }
  local C_types_ = "I"
  local x = false
  local _temp_stmt = nil

  i = 0
  while true
  do
    if not(i < 10) then break end
    cql_finalize_stmt(C_stmt)
    _rc_, C_stmt = cql_prepare(_db_, 
      "SELECT foo.id FROM foo WHERE id = ?")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_multibind(_db_, C_stmt, "I", i)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    i = i + 1
  end
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT EXISTS (SELECT 1 FROM foo)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    x = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC select_in_loop ()
BEGIN
  WHILE 1
  BEGIN
    LET z := ( SELECT 1 AS z );
  END;
END;
--]]

function select_in_loop(_db_)
  local _rc_ = CQL_OK
  local z = 0
  local _temp1_stmt = nil

  while true
  do
    if not(true) then break end
    if _temp1_stmt == nil then
      _rc_, _temp1_stmt = cql_prepare(_db_, 
      "SELECT 1")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    end
    _rc_ = cql_step(_temp1_stmt)
    if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
      z = cql_get_value(_temp1_stmt, 0)
    cql_reset_stmt(_temp1_stmt)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp1_stmt)
  _temp1_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC select_if_nothing_in_loop ()
BEGIN
  WHILE 1
  BEGIN
    LET z := ( SELECT 1 AS z IF NOTHING THEN 1 );
  END;
END;
--]]

function select_if_nothing_in_loop(_db_)
  local _rc_ = CQL_OK
  local _tmp_int_1 = 0
  local z = 0
  local _temp1_stmt = nil

  while true
  do
    if not(true) then break end
    if _temp1_stmt == nil then
      _rc_, _temp1_stmt = cql_prepare(_db_, 
      "SELECT 1")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    end
    _rc_ = cql_step(_temp1_stmt)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if _rc_ == CQL_ROW then
      _tmp_int_1 = cql_get_value(_temp1_stmt, 0)
      z = _tmp_int_1
    else
      z = 1
    end
    cql_reset_stmt(_temp1_stmt)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp1_stmt)
  _temp1_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC select_if_nothing_or_null_in_loop ()
BEGIN
  WHILE 1
  BEGIN
    LET z := ( SELECT 1 AS z IF NOTHING OR NULL THEN 1 );
  END;
END;
--]]

function select_if_nothing_or_null_in_loop(_db_)
  local _rc_ = CQL_OK
  local _tmp_int_1 = 0
  local z = 0
  local _temp1_stmt = nil

  while true
  do
    if not(true) then break end
    if _temp1_stmt == nil then
      _rc_, _temp1_stmt = cql_prepare(_db_, 
      "SELECT 1")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    end
    _rc_ = cql_step(_temp1_stmt)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if _rc_ == CQL_ROW then
      _tmp_int_1 = cql_get_value(_temp1_stmt, 0)
    end
    if _rc_ == CQL_DONE or _tmp_int_1 == nil then
      z = 1
    else
      z = _tmp_int_1
    end
    _rc_ = CQL_OK
    cql_reset_stmt(_temp1_stmt)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp1_stmt)
  _temp1_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC ignored_values ()
BEGIN
  1 + 2 + 3;
  4 + 5 + 6;
END;
--]]

function ignored_values()
  __cql_ignored__ = 1 + 2 + 3
  __cql_ignored__ = nil
  __cql_ignored__ = 4 + 5 + 6
  __cql_ignored__ = nil

end

-- The statement ending at line XXXX

--[[
PROC no_check_test_proc ()
BEGIN
  LET x := stew1('x');
  LET y := stew2(1, 2, 3);
  LET z := stew3('x', 1);
  SET x := stew1(z);
END;
--]]

function no_check_test_proc()
  local x = 0
  local y
  local z

  x = stew1("x")
  y = stew2(1, 2, 3)
  z = stew3("x", 1)
  x = stew1(z)

end

-- The statement ending at line XXXX

--[[
PROC declare_constant_variable ()
BEGIN
  CONST const_variable := 1;
END;
--]]

function declare_constant_variable()
  local const_variable = 0

  const_variable = 1

end

-- The statement ending at line XXXX

--[[
PROC real_caller ()
BEGIN
  LET z := real_func(1) + real_func(2);
END;
--]]

function real_caller()
  local _tmp_n_double_0
  local _tmp_n_double_1
  local z

  _tmp_n_double_0 = real_func(1)
  _tmp_n_double_1 = real_func(2)
  z = cql_add(_tmp_n_double_0, _tmp_n_double_1)

end

-- The statement ending at line XXXX

--[[
PROC insert_returning_cursor ()
BEGIN
  CURSOR C FOR
    INSERT INTO insert_returning_test(ix, iy)
      VALUES (1, 2)
      RETURNING ix + iy AS xy, ix, iy;
END;
--]]

function insert_returning_cursor(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "xy", "ix", "iy" }
  local C_types_ = "iii"

  _rc_, C_stmt = cql_prepare(_db_, 
    "INSERT INTO insert_returning_test(ix, iy) VALUES (1, 2) RETURNING ix + iy AS xy, ix, iy")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC insert_returning_resultset ()
BEGIN
  INSERT INTO insert_returning_test(ix, iy)
    VALUES (1, 2)
    RETURNING ix + iy AS xy, ix, iy;
END;
--]]

function insert_returning_resultset(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "INSERT INTO insert_returning_test(ix, iy) VALUES (1, 2) RETURNING ix + iy AS xy, ix, iy")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function insert_returning_resultset_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = insert_returning_resultset(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "iii", { "xy", "ix", "iy" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC delete_returning_cursor ()
BEGIN
  CURSOR C FOR
    DELETE FROM insert_returning_test
      RETURNING ix + iy AS xy, ix, iy;
END;
--]]

function delete_returning_cursor(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "xy", "ix", "iy" }
  local C_types_ = "iii"

  _rc_, C_stmt = cql_prepare(_db_, 
    "DELETE FROM insert_returning_test RETURNING ix + iy AS xy, ix, iy")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC delete_returning_resultset ()
BEGIN
  DELETE FROM insert_returning_test
    RETURNING ix + iy AS xy, ix, iy;
END;
--]]

function delete_returning_resultset(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "DELETE FROM insert_returning_test RETURNING ix + iy AS xy, ix, iy")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function delete_returning_resultset_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = delete_returning_resultset(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "iii", { "xy", "ix", "iy" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
PROC expand_returning_star ()
BEGIN
  CURSOR C FOR
    WITH
      _vals (id, name) AS (
        VALUES (1, 'foo')
      )
    INSERT INTO json_backing(k, v)
      SELECT cql_blob_create(jdata, V.name, jdata.name, V.id, jdata.id), cql_blob_create(jdata)
        FROM _vals AS V
      RETURNING 
        cql_blob_get(k, jdata.id),
        cql_blob_get(k, jdata.name),
        cql_blob_get(v, jdata.age),
        cql_blob_get(v, jdata.zip);
END;
--]]

function expand_returning_star(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "age", "zip" }
  local C_types_ = "ISil"

  _rc_, C_stmt = cql_prepare(_db_, 
    "WITH _vals (id, name) AS ( VALUES (1, 'foo') ) INSERT INTO json_backing(k, v) SELECT json_array(-1916485007726025434, V.name, V.id), json_object() FROM _vals AS V RETURNING  ((k)->>2), ((k)->>1), ((v)->>'$.age'), ((v)->>'$.zip')")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC upsert_returning_with_backing ()
BEGIN
  CURSOR C FOR
    WITH
      a_cte (x) AS (
        VALUES
          (1),
          (2),
          (3)
      ),
      _vals (`col 1`, `col 2`) AS (
        VALUES (1, 2)
      )
    INSERT INTO `a backing table`(`the key`, `the value`)
      SELECT cql_blob_create(`a table`, V.`col 1`, `a table`.`col 1`), cql_blob_create(`a table`, V.`col 2`, `a table`.`col 2`)
        FROM _vals AS V
        WHERE 1
    ON CONFLICT (`the key`)
    WHERE cql_blob_get(`the value`, `a table`.`col 2`) IN (SELECT a_cte.x
      FROM a_cte) 
    DO UPDATE
      SET `the key` = cql_blob_update(`the key`, ifnull(cql_blob_get(`the value`, `a table`.`col 2`), 0), `a table`.`col 1`)
      RETURNING cql_blob_get(`the key`, `a table`.`col 1`), cql_blob_get(`the value`, `a table`.`col 2`);
END;
--]]

function upsert_returning_with_backing(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "X_colX201", "X_colX202" }
  local C_types_ = "Ii"

  _rc_, C_stmt = cql_prepare(_db_, 
    "WITH a_cte (x) AS ( VALUES (1), (2), (3) ), _vals ([col 1], [col 2]) AS ( VALUES (1, 2) ) INSERT INTO [a backing table]([the key], [the value]) SELECT jsonb_array(-3079349931095810044, V.[col 1]), jsonb_object('X_colX202', V.[col 2]) FROM _vals AS V WHERE 1 ON CONFLICT ([the key]) WHERE (([the value])->>'$.X_colX202') IN (SELECT a_cte.x FROM a_cte)  DO UPDATE SET [the key] = jsonb_set([the key],  '$[1]', ifnull((([the value])->>'$.X_colX202'), 0)) RETURNING (([the key])->>1), (([the value])->>'$.X_colX202')")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC select_if_nothing_or_null_throw (a_local INT)
BEGIN
  LET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    LET x := ( SELECT a_local IF NOTHING OR NULL THEN THROW );
  END;
END;
--]]

function select_if_nothing_or_null_throw(_db_, a_local)
  local _rc_ = CQL_OK
  local i = 0
  local _tmp_n_int_1
  local x = 0
  local _temp1_stmt = nil

  i = 0
  while true
  do
    if not(i < 5) then break end
    i = i + 1
    if _temp1_stmt == nil then
      _rc_, _temp1_stmt = cql_prepare(_db_, 
      "SELECT ?")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    end
    _rc_ = cql_multibind(_db_, _temp1_stmt, "i", a_local)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_step(_temp1_stmt)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if _rc_ == CQL_ROW then
      _tmp_n_int_1 = cql_get_value(_temp1_stmt, 0)
    end
    if _rc_ == CQL_DONE or _tmp_n_int_1 == nil then
      cql_error_trace(_rc_, _db_)
      goto cql_cleanup
    else
      x = _tmp_n_int_1
    end
    _rc_ = CQL_OK
    cql_reset_stmt(_temp1_stmt)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp1_stmt)
  _temp1_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
PROC get_xy ()
BEGIN
  SELECT _select_.x, _select_.y
    FROM (CALL mapped_xy(1));
END;
--]]

function get_xy(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local _tmp_int64_0 = 0
  local _p1_y__ = 0
  local _p2_x__ = 0
  local _temp_stmt = nil
  local _p2_y__ = 0

  _p1_y__ = 1
  _rc_, _temp_stmt = cql_prepare(_db_, 
    " WITH mapping (map_x) AS ( SELECT map_x FROM map_xy WHERE map_y = ? ) SELECT map_x FROM mapping")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "L", _p1_y__)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_int64_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _p2_x__ = _tmp_int64_0
  _p2_y__ = _p1_y__
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    9, nil,
    {
    "SELECT x, y FROM (",
    "(",
    "SELECT x, y FROM (",
    "(",
    "SELECT ? AS x, ? AS y",
    ")",
    ")",
    ")",
    ")"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _result_stmt, "LL", _p2_x__, _p2_y__)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function get_xy_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = get_xy(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "LL", { "x", "y" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end

local this_is_the_end = 0

-- The statement ending at line XXXX

--[[
PROC end_proc ()
BEGIN
END;
--]]

function end_proc()

end

-- The statement ending at line XXXX

--[[
DECLARE end_marker INT;
--]]
local end_marker

function cql_startup(_db_)
  local _rc_ = CQL_OK
  local _tmp_int_1 = 0
  local _tmp_n_int_2
  local _tmp_int_2 = 0
  local _tmp_n_int_3
  local _tmp_bool_0 = false
  local _tmp_n_bool_3
  local _tmp_n_bool_0
  local _tmp_n_int_1
  local _tmp_text_0
  local _tmp_n_object_1
  local _tmp_object_1
  local _tmp_n_object_0
  local _tmp_n_blob_1
  local _tmp_blob_1
  local _tmp_blob_0
  local _tmp_n_blob_0
  local _tmp_n_int_0
  local _tmp_n_text_1
  local _tmp_int_0 = 0
  local _tmp_int64_0 = 0

  -- The statement ending at line XXXX

  --[[
  @IFDEF __rt__lua
    LET lua_runtime_generation := 1;
  @ENDIF
  ;
  --]]

    -- The statement ending at line XXXX

    --[[
    LET lua_runtime_generation := 1;
    --]]
    lua_runtime_generation = 1

  -- The statement ending at line XXXX

  --[[
  @IFNDEF __rt__lua
  @ELSE
    LET lua_runtime_generation_on_else := 1;
  @ENDIF
  ;
  --]]

    -- The statement ending at line XXXX

    --[[
    LET lua_runtime_generation_on_else := 1;
    --]]
    lua_runtime_generation_on_else = 1

  -- The statement ending at line XXXX

  --[[
  SET t2 := "text";
  --]]
  t2 = "text"

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1;
  --]]
  i2 = 1

  -- The statement ending at line XXXX

  --[[
  SET i1_nullable := 88;
  --]]
  i1_nullable = 88

  -- The statement ending at line XXXX

  --[[
  SET i1_nullable := NULL;
  --]]
  i1_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable;
  --]]
  i0_nullable = i1_nullable

  -- The statement ending at line XXXX

  --[[
  SET t0_nullable := NULL;
  --]]
  t0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET t0_nullable := t2;
  --]]
  t0_nullable = t2

  -- The statement ending at line XXXX

  --[[
  SET t0_nullable := NULL;
  --]]
  t0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET i2 := - -1;
  --]]
  i2 = - - 1

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := -i2;
  --]]
  i0_nullable = - i2

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := -NULL;
  --]]
  i0_nullable = cql_unary_uminus(nil)

  -- The statement ending at line XXXX

  --[[
  SET i1_nullable := -i0_nullable;
  --]]
  i1_nullable = cql_unary_uminus(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := 2.2;
  --]]
  r0_nullable = 2.2

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := NULL;
  --]]
  r0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET r2 := 3.5;
  --]]
  r2 = 3.5

  -- The statement ending at line XXXX

  --[[
  SET i1_nullable := NOT NOT i0_nullable;
  --]]
  i1_nullable = cql_to_num(cql_unary_not(cql_unary_not(cql_to_bool(i0_nullable))))

  -- The statement ending at line XXXX

  --[[
  SET i2 := NOT NOT b2;
  --]]
  i2 = cql_to_num(not not b2)

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 * 3 + 5;
  --]]
  i2 = 1 * 3 + 5

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := r0_nullable * i1_nullable;
  --]]
  r0_nullable = cql_mul(r0_nullable, i1_nullable)

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := r0_nullable * i2;
  --]]
  r0_nullable = cql_mul(r0_nullable, i2)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := 12 * i1_nullable;
  --]]
  i0_nullable = cql_mul(12, i1_nullable)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL * i1_nullable;
  --]]
  i0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := r0_nullable * i1_nullable + r0_nullable * i1_nullable;
  --]]
  r0_nullable = cql_add(cql_mul(r0_nullable, i1_nullable), cql_mul(r0_nullable, i1_nullable))

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := r0_nullable * i1_nullable + r0_nullable * i0_nullable + r0_nullable;
  --]]
  r0_nullable = cql_add(cql_add(cql_mul(r0_nullable, i1_nullable), cql_mul(r0_nullable, i0_nullable)), r0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET t2 := "This is a \" \\ test '' \n \" ";
  --]]
  t2 = "This is a \" \\ test '' \n \" "

  -- The statement ending at line XXXX

  --[[
  CALL printf("Hello, world\n");
  --]]
  printf("Hello, world\n")

  -- The statement ending at line XXXX

  --[[
  SET i2 := r2 AND l2;
  --]]
  i2 = cql_to_num(cql_to_bool(r2) and cql_to_bool(l2))

  -- The statement ending at line XXXX

  --[[
  SET i2 := coalesce(side_effect1(), 7) AND coalesce(side_effect2(), 5);
  --]]
  repeat
    _tmp_n_int_2 = side_effect1()
    if _tmp_n_int_2 ~= nil then
      _tmp_int_1 = _tmp_n_int_2
      break
    end
    _tmp_int_1 = 7
  until true
  _tmp_n_bool_3 = _tmp_int_1
  if cql_is_false(_tmp_n_bool_3) then
    _tmp_bool_0 = false
  else
    repeat
      _tmp_n_int_3 = side_effect2()
      if _tmp_n_int_3 ~= nil then
        _tmp_int_2 = _tmp_n_int_3
        break
      end
      _tmp_int_2 = 5
    until true
    _tmp_bool_0 = cql_logical_and(_tmp_n_bool_3, _tmp_int_2)
  end
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL AND NULL;
  --]]
  i0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i0_nullable AND i1_nullable;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_and(i0_nullable, function() return i1_nullable end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL AND i1_nullable;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_and(nil, function() return i1_nullable end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i0_nullable AND NULL;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_and(i0_nullable, function() return nil end))

  -- The statement ending at line XXXX

  --[[
  SET i2 := r2 OR l2;
  --]]
  i2 = cql_to_num(cql_to_bool(r2) or cql_to_bool(l2))

  -- The statement ending at line XXXX

  --[[
  SET i2 := coalesce(side_effect1(), 7) OR coalesce(side_effect2(), 5);
  --]]
  repeat
    _tmp_n_int_2 = side_effect1()
    if _tmp_n_int_2 ~= nil then
      _tmp_int_1 = _tmp_n_int_2
      break
    end
    _tmp_int_1 = 7
  until true
  _tmp_n_bool_3 = _tmp_int_1
  if cql_is_true(_tmp_n_bool_3) then
    _tmp_bool_0 = true
  else
    repeat
      _tmp_n_int_3 = side_effect2()
      if _tmp_n_int_3 ~= nil then
        _tmp_int_2 = _tmp_n_int_3
        break
      end
      _tmp_int_2 = 5
    until true
    _tmp_bool_0 = cql_logical_or(_tmp_n_bool_3, _tmp_int_2)
  end
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL OR NULL;
  --]]
  i0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i0_nullable OR i1_nullable;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_or(i0_nullable, function() return i1_nullable end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL OR i1_nullable;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_or(nil, function() return i1_nullable end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i0_nullable OR NULL;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_or(i0_nullable, function() return nil end))

  -- The statement ending at line XXXX

  --[[
  SET i2 := NULL IS NULL;
  --]]
  i2 = cql_to_num(nil == nil)

  -- The statement ending at line XXXX

  --[[
  SET i2 := i0_nullable + i1_nullable IS NULL;
  --]]
  i2 = cql_to_num(cql_add(i0_nullable, i1_nullable) == nil)

  -- The statement ending at line XXXX

  --[[
  SET i2 := NULL IS NOT NULL;
  --]]
  i2 = cql_to_num(nil ~= nil)

  -- The statement ending at line XXXX

  --[[
  SET i2 := i0_nullable + i1_nullable IS NOT NULL;
  --]]
  i2 = cql_to_num(cql_add(i0_nullable, i1_nullable) ~= nil)

  -- The statement ending at line XXXX

  --[[
  IF 1 THEN
    SET i2 := 1;
  ELSE IF i0_nullable = i1_nullable THEN
    SET i2 := 2;
  ELSE
    SET i2 := 3;
  END;
  --]]
  if true then
    i2 = 1
  else
    if cql_eq(i0_nullable, i1_nullable) then
      i2 = 2
    else
      i2 = 3
    end
  end

  -- The statement ending at line XXXX

  --[[
  IF 1 THEN
    SET i2 := 1;
  ELSE IF i0_nullable OR i1_nullable THEN
    SET i2 := 2;
  ELSE
    SET i2 := 3;
  END;
  --]]
  if true then
    i2 = 1
  else
    if cql_shortcircuit_or(i0_nullable, function() return i1_nullable end) then
      i2 = 2
    else
      i2 = 3
    end
  end

  -- The statement ending at line XXXX

  --[[
  SET b2 := 1 BETWEEN 0 AND 3;
  --]]
  _between_0_ = 1
  b2 = _between_0_ >= 0 and _between_0_ <= 3

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable BETWEEN i0_nullable AND r2;
  --]]
  _between_1_ = i1_nullable
  i0_nullable = cql_to_num(cql_shortcircuit_and(cql_ge(_between_1_, i0_nullable), function() return cql_le(_between_1_, r2) end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable BETWEEN r2 AND i0_nullable;
  --]]
  _between_2_ = i1_nullable
  i0_nullable = cql_to_num(cql_shortcircuit_and(cql_ge(_between_2_, r2), function() return cql_le(_between_2_, i0_nullable) end))

  -- The statement ending at line XXXX

  --[[
  SET b2 := 1 NOT BETWEEN 0 AND 3;
  --]]
  _between_3_ = 1
  b2 = _between_3_ < 0 or _between_3_ > 3

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable NOT BETWEEN i0_nullable AND r2;
  --]]
  _between_4_ = i1_nullable
  i0_nullable = cql_to_num(cql_shortcircuit_or(cql_lt(_between_4_, i0_nullable), function() return cql_gt(_between_4_, r2) end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable NOT BETWEEN r2 AND i0_nullable;
  --]]
  _between_5_ = i1_nullable
  i0_nullable = cql_to_num(cql_shortcircuit_or(cql_lt(_between_5_, r2), function() return cql_gt(_between_5_, i0_nullable) end))

  -- The statement ending at line XXXX

  --[[
  SET longint_var := (l0_nullable + l1_nullable) * 5;
  --]]
  longint_var = cql_mul(cql_add(l0_nullable, l1_nullable), 5)

  -- The statement ending at line XXXX

  --[[
  CURSOR foo_cursor FOR
    SELECT id, i2
      FROM foo
      WHERE id = i0_nullable;
  --]]
  _rc_, foo_cursor_stmt = cql_prepare(_db_, 
    "SELECT id, ? FROM foo WHERE id = ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, foo_cursor_stmt, "Ii", i2, i0_nullable)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  FETCH foo_cursor INTO i0_nullable, i2;
  --]]
  -- step and fetch
  _rc_ = cql_multifetch(foo_cursor_stmt, foo_cursor, foo_cursor_types_, foo_cursor_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  i0_nullable = foo_cursor.id
  i2 = foo_cursor.i2

  -- The statement ending at line XXXX

  --[[
  CURSOR basic_cursor FOR
    SELECT 1, 2.5;
  --]]
  _rc_, basic_cursor_stmt = cql_prepare(_db_, 
    "SELECT 1, 2.5")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  FETCH basic_cursor INTO col1, col2;
  --]]
  -- step and fetch
  _rc_ = cql_multifetch(basic_cursor_stmt, basic_cursor, basic_cursor_types_, basic_cursor_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  col1 = basic_cursor._anon0
  col2 = basic_cursor._anon1

  -- The statement ending at line XXXX

  --[[
  CLOSE basic_cursor;
  --]]
  cql_finalize_stmt(basic_cursor_stmt)
  basic_cursor_stmt = nil
  basic_cursor = { _has_row_ = false }

  -- The statement ending at line XXXX

  --[[
  SET arg1 := 7;
  --]]
  arg1 = 7

  -- The statement ending at line XXXX

  --[[
  SET arg2 := 11;
  --]]
  arg2 = 11

  -- The statement ending at line XXXX

  --[[
  CURSOR exchange_cursor FOR
    SELECT arg2, arg1;
  --]]
  _rc_, exchange_cursor_stmt = cql_prepare(_db_, 
    "SELECT ?, ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, exchange_cursor_stmt, "II", arg2, arg1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  FETCH exchange_cursor INTO arg1, arg2;
  --]]
  -- step and fetch
  _rc_ = cql_multifetch(exchange_cursor_stmt, exchange_cursor, exchange_cursor_types_, exchange_cursor_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  arg1 = exchange_cursor.arg2
  arg2 = exchange_cursor.arg1

  -- The statement ending at line XXXX

  --[[
  CLOSE exchange_cursor;
  --]]
  cql_finalize_stmt(exchange_cursor_stmt)
  exchange_cursor_stmt = nil
  exchange_cursor = { _has_row_ = false }

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT i2 + 1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT ? + 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "I", i2)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    i2 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := ( SELECT i0_nullable + 1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT ? + 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "i", i0_nullable)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    i0_nullable = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  DELETE FROM bar WHERE name LIKE '\\ " \n';
  --]]
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name LIKE '\\\\ \" \\n'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET i2 := CASE
    WHEN 1 THEN 100
    WHEN 2 THEN 200
    ELSE 300
  END;
  --]]
  repeat
    if true then
      i2 = 100
      break
    end
    if cql_to_bool(2) then
      i2 = 200
      break
    end
    i2 = 300
  until true

  -- The statement ending at line XXXX

  --[[
  SET i2 := 3 IN (1, 2, NULL, 4);
  --]]
  repeat
    _tmp_int_1 = 3
    _tmp_bool_0 = true
    if _tmp_int_1 == 1 then break end
    if _tmp_int_1 == 2 then break end
    if _tmp_int_1 == 4 then break end
    _tmp_bool_0 = false
  until true
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable IN (1, 2, NULL, b0_nullable);
  --]]
  repeat
    _tmp_n_int_1 = i1_nullable
    if _tmp_n_int_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = true
    if _tmp_n_int_1 == 1 then break end
    if _tmp_n_int_1 == 2 then break end
    if _tmp_n_int_1 == cql_to_num(b0_nullable) then break end
    _tmp_n_bool_0 = false
  until true
  i0_nullable = cql_to_num(_tmp_n_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := 3 NOT IN (1, 2, NULL, 4);
  --]]
  repeat
    _tmp_int_1 = 3
    _tmp_bool_0 = false
    if _tmp_int_1 == 1 then break end
    if _tmp_int_1 == 2 then break end
    if _tmp_int_1 == 4 then break end
    _tmp_bool_0 = true
  until true
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable NOT IN (1, 2, NULL, b0_nullable);
  --]]
  repeat
    _tmp_n_int_1 = i1_nullable
    if _tmp_n_int_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = false
    if _tmp_n_int_1 == 1 then break end
    if _tmp_n_int_1 == 2 then break end
    if _tmp_n_int_1 == cql_to_num(b0_nullable) then break end
    _tmp_n_bool_0 = true
  until true
  i0_nullable = cql_to_num(_tmp_n_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET b2 := 'b' BETWEEN 'a' AND 'c';
  --]]
  _between_6_ = "b"
  b2 = _between_6_ >= "a" and _between_6_ <= "c"

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := 'b' BETWEEN 'a' AND t0_nullable;
  --]]
  _between_7_ = "b"
  b0_nullable = cql_shortcircuit_and(_between_7_ >= "a", function() return cql_le(_between_7_, t0_nullable) end)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := 'b' BETWEEN t0_nullable AND 'c';
  --]]
  _between_8_ = "b"
  b0_nullable = cql_shortcircuit_and(cql_ge(_between_8_, t0_nullable), function() return _between_8_ <= "c" end)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := 'b' BETWEEN NULL AND 'c';
  --]]
  _between_9_ = "b"
  b0_nullable = cql_shortcircuit_and(nil, function() return _between_9_ <= "c" end)

  -- The statement ending at line XXXX

  --[[
  SET b2 := 'b' NOT BETWEEN 'a' AND 'c';
  --]]
  _between_10_ = "b"
  b2 = _between_10_ < "a" or _between_10_ > "c"

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := 'b' NOT BETWEEN 'a' AND t0_nullable;
  --]]
  _between_11_ = "b"
  b0_nullable = cql_shortcircuit_or(_between_11_ < "a", function() return cql_gt(_between_11_, t0_nullable) end)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := 'b' NOT BETWEEN t0_nullable AND 'c';
  --]]
  _between_12_ = "b"
  b0_nullable = cql_shortcircuit_or(cql_lt(_between_12_, t0_nullable), function() return _between_12_ > "c" end)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := 'b' NOT BETWEEN NULL AND 'c';
  --]]
  _between_13_ = "b"
  b0_nullable = cql_shortcircuit_or(nil, function() return _between_13_ > "c" end)

  -- The statement ending at line XXXX

  --[[
  SET i2 := ifnull(i0_nullable, 3);
  --]]
  repeat
    if i0_nullable ~= nil then
      i2 = i0_nullable
      break
    end
    i2 = 3
  until true

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := ifnull(i0_nullable, i1_nullable);
  --]]
  repeat
    if i0_nullable ~= nil then
        break
    end
    i0_nullable = i1_nullable
  until true

  -- The statement ending at line XXXX

  --[[
  CALL copy_int(i0_nullable, i1_nullable);
  --]]
  i1_nullable = copy_int(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET s := printf('%d and %d', 1, 2);
  --]]
  s = cql_printf("%d and %d", 1, 2)

  -- The statement ending at line XXXX

  --[[
  SET s := printf('%d and %d', 3, 4);
  --]]
  s = cql_printf("%d and %d", 3, 4)

  -- The statement ending at line XXXX

  --[[
  SET s := printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', CAST(4 AS LONG), CAST(nullable(5) AS LONG), CAST(TRUE AS LONG), 0L, CAST(FALSE AS INT), 0, 6L, 7, 0.0, 0.0, NULL, CAST(8 AS REAL));
  --]]
  s = cql_printf("%lld %lld %lld %llu %d %d %llu %d %f %f %s %f", cql_to_integer(4), cql_to_integer(5), cql_to_integer(true), 0, cql_to_integer(false), 0, 6, 7, 0.0, 0.0, nil, cql_to_float(8))

  -- The statement ending at line XXXX

  --[[
  SET s := ( SELECT printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', 5, nullable(5), TRUE, NULL, FALSE, NULL, 6L, 7, 0.0, NULL, NULL, 8) );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', 5, 5, 1, NULL, 0, NULL, 6, 7, 0.0, NULL, NULL, 8)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    s = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET S := 'x';
  --]]
  s = "x"

  -- The statement ending at line XXXX

  --[[
  LET result := simple_func(2);
  --]]
  result = simple_func(2)

  -- The statement ending at line XXXX

  --[[
  SET result := simple_func(simple_func(1));
  --]]
  _tmp_n_int_1 = simple_func(1)
  result = simple_func(_tmp_n_int_1)

  -- The statement ending at line XXXX

  --[[
  SET text_result := text_func(123, 456);
  --]]
  _tmp_text_0 = text_func(123, 456)
  text_result = _tmp_text_0

  -- The statement ending at line XXXX

  --[[
  SET obj_var := NULL;
  --]]
  obj_var = nil

  -- The statement ending at line XXXX

  --[[
  SET obj_var2 := obj_notnull_func();
  --]]
  obj_var2 = obj_notnull_func()

  -- The statement ending at line XXXX

  --[[
  SET obj_var := obj_var2;
  --]]
  obj_var = obj_var2

  -- The statement ending at line XXXX

  --[[
  SET obj_var := NULL;
  --]]
  obj_var = nil

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := obj_var = obj_var;
  --]]
  b0_nullable = cql_eq(obj_var, obj_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := obj_var IN (obj_var, obj_var);
  --]]
  repeat
    _tmp_n_object_1 = obj_var
    if _tmp_n_object_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = true
    if _tmp_n_object_1 == obj_var then break end
    if _tmp_n_object_1 == obj_var then break end
    _tmp_n_bool_0 = false
  until true
  b0_nullable = _tmp_n_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b2 := obj_var2 IN (obj_var2, obj_var2);
  --]]
  repeat
    _tmp_object_1 = obj_var2
    _tmp_bool_0 = true
    if _tmp_object_1 == obj_var2 then break end
    if _tmp_object_1 == obj_var2 then break end
    _tmp_bool_0 = false
  until true
  b2 = _tmp_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := obj_var NOT IN (obj_var, obj_var);
  --]]
  repeat
    _tmp_n_object_1 = obj_var
    if _tmp_n_object_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = false
    if _tmp_n_object_1 == obj_var then break end
    if _tmp_n_object_1 == obj_var then break end
    _tmp_n_bool_0 = true
  until true
  b0_nullable = _tmp_n_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b2 := obj_var2 NOT IN (obj_var2, obj_var2);
  --]]
  repeat
    _tmp_object_1 = obj_var2
    _tmp_bool_0 = false
    if _tmp_object_1 == obj_var2 then break end
    if _tmp_object_1 == obj_var2 then break end
    _tmp_bool_0 = true
  until true
  b2 = _tmp_bool_0

  -- The statement ending at line XXXX

  --[[
  SET i2 := CASE obj_var
    WHEN obj_var THEN 1
    ELSE 2
  END;
  --]]
  repeat
    _tmp_n_object_1 = obj_var
    if _tmp_n_object_1 == nil then goto case_else_1 end
    if _tmp_n_object_1 == obj_var then
      i2 = 1
      break
    end
    ::case_else_1::
    i2 = 2
  until true

  -- The statement ending at line XXXX

  --[[
  SET obj_var := CASE 1
    WHEN 1 THEN obj_var2
    ELSE NULL
  END;
  --]]
  repeat
    _tmp_int_1 = 1
    if _tmp_int_1 == 1 then
      obj_var = obj_var2
      break
    end
    obj_var = nil
  until true

  -- The statement ending at line XXXX

  --[[
  SET obj_var := obj_func();
  --]]
  obj_var = obj_func()

  -- The statement ending at line XXXX

  --[[
  SET obj_var := obj_func_create();
  --]]
  obj_var = obj_func_create()

  -- The statement ending at line XXXX

  --[[
  SET text_result := text_func_create();
  --]]
  text_result = text_func_create()

  -- The statement ending at line XXXX

  --[[
  SET obj_var2 := ifnull_crash(obj_func());
  --]]
  _tmp_n_object_0 = obj_func()
  cql_invariant(_tmp_n_object_0 ~= nil)
  obj_var2 = _tmp_n_object_0

  -- The statement ending at line XXXX

  --[[
  SET obj_var2 := ifnull_throw(obj_func());
  --]]
  _tmp_n_object_0 = obj_func()
  if _tmp_n_object_0 == nil then
    _rc_ = CQL_ERROR
    cql_error_trace(_rc_, _db_)
    goto cql_cleanup
  end
  obj_var2 = _tmp_n_object_0

  -- The statement ending at line XXXX

  --[[
  SET obj_var2 := ifnull_crash(obj_func_create());
  --]]
  _tmp_n_object_0 = obj_func_create()
  cql_invariant(_tmp_n_object_0 ~= nil)
  obj_var2 = _tmp_n_object_0

  -- The statement ending at line XXXX

  --[[
  SET i2 := ifnull_crash(i0_nullable);
  --]]
  cql_invariant(i0_nullable ~= nil)
  i2 = i0_nullable

  -- The statement ending at line XXXX

  --[[
  SET i2 := ifnull_throw(i0_nullable);
  --]]
  if i0_nullable == nil then
    _rc_ = CQL_ERROR
    cql_error_trace(_rc_, _db_)
    goto cql_cleanup
  end
  i2 = i0_nullable

  -- The statement ending at line XXXX

  --[[
  INSERT OR REPLACE INTO bar(id, type)
    VALUES (1, 5);
  --]]
  _rc_ = cql_exec(_db_,
    "INSERT OR REPLACE INTO bar(id, type) VALUES (1, 5)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  INSERT INTO foo DEFAULT VALUES;
  --]]
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo DEFAULT VALUES")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET b2 := ( SELECT EXISTS (SELECT 1
      FROM bar) );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT EXISTS (SELECT 1 FROM bar)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    b2 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  CURSOR expanded_select FOR
    SELECT
        bar.id,
        bar.name,
        bar.rate,
        bar.type,
        bar.size
      FROM bar;
  --]]
  _rc_, expanded_select_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  CURSOR table_expanded_select FOR
    SELECT
        bar.id,
        bar.name,
        bar.rate,
        bar.type,
        bar.size
      FROM bar;
  --]]
  _rc_, table_expanded_select_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET l2 := 3147483647L;
  --]]
  l2 = 3147483647

  -- The statement ending at line XXXX

  --[[
  SET l2 := 3147483647L;
  --]]
  l2 = 3147483647

  -- The statement ending at line XXXX

  --[[
  SET blob_var2 := blob_notnull_func();
  --]]
  blob_var2 = blob_notnull_func()

  -- The statement ending at line XXXX

  --[[
  SET blob_var := NULL;
  --]]
  blob_var = nil

  -- The statement ending at line XXXX

  --[[
  SET blob_var := blob_var2;
  --]]
  blob_var = blob_var2

  -- The statement ending at line XXXX

  --[[
  SET blob_var := NULL;
  --]]
  blob_var = nil

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var = blob_var;
  --]]
  b0_nullable = cql_blob_eq(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var IS NULL;
  --]]
  b0_nullable = blob_var == nil

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var <> blob_var;
  --]]
  b0_nullable = cql_blob_ne(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var <> blob_var;
  --]]
  b0_nullable = cql_blob_ne(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var IS blob_var;
  --]]
  b0_nullable = cql_blob_is_eq(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var IS NOT blob_var;
  --]]
  b0_nullable = cql_blob_is_ne(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var IN (blob_var, blob_var);
  --]]
  repeat
    _tmp_n_blob_1 = blob_var
    if _tmp_n_blob_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = true
    if cql_blob_eq(_tmp_n_blob_1, blob_var) then break end
    if cql_blob_eq(_tmp_n_blob_1, blob_var) then break end
    _tmp_n_bool_0 = false
  until true
  b0_nullable = _tmp_n_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b2 := blob_var2 IN (blob_var, blob_var2);
  --]]
  repeat
    _tmp_blob_1 = blob_var2
    _tmp_bool_0 = true
    if cql_blob_eq(_tmp_blob_1, blob_var) then break end
    if cql_blob_eq(_tmp_blob_1, blob_var2) then break end
    _tmp_bool_0 = false
  until true
  b2 = _tmp_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var NOT IN (blob_var, blob_var2);
  --]]
  repeat
    _tmp_n_blob_1 = blob_var
    if _tmp_n_blob_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = false
    if cql_blob_eq(_tmp_n_blob_1, blob_var) then break end
    if cql_blob_eq(_tmp_n_blob_1, blob_var2) then break end
    _tmp_n_bool_0 = true
  until true
  b0_nullable = _tmp_n_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b2 := blob_var2 NOT IN (blob_var, blob_var2);
  --]]
  repeat
    _tmp_blob_1 = blob_var2
    _tmp_bool_0 = false
    if cql_blob_eq(_tmp_blob_1, blob_var) then break end
    if cql_blob_eq(_tmp_blob_1, blob_var2) then break end
    _tmp_bool_0 = true
  until true
  b2 = _tmp_bool_0

  -- The statement ending at line XXXX

  --[[
  SET i2 := CASE blob_var
    WHEN blob_var THEN 1
    ELSE 2
  END;
  --]]
  repeat
    _tmp_n_blob_1 = blob_var
    if _tmp_n_blob_1 == nil then goto case_else_2 end
    if _tmp_n_blob_1 == blob_var then
      i2 = 1
      break
    end
    ::case_else_2::
    i2 = 2
  until true

  -- The statement ending at line XXXX

  --[[
  SET blob_var := CASE 1
    WHEN 1 THEN blob_var2
    ELSE NULL
  END;
  --]]
  repeat
    _tmp_int_1 = 1
    if _tmp_int_1 == 1 then
      blob_var = blob_var2
      break
    end
    blob_var = nil
  until true

  -- The statement ending at line XXXX

  --[[
  SET blob_var := blob_func();
  --]]
  blob_var = blob_func()

  -- The statement ending at line XXXX

  --[[
  SET blob_var := blob_func_create();
  --]]
  blob_var = blob_func_create()

  -- The statement ending at line XXXX

  --[[
  SET blob_var := ( SELECT b_nullable
    FROM blob_table
    WHERE blob_id = 1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT b_nullable FROM blob_table WHERE blob_id = 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    blob_var = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET blob_var := ( SELECT b_notnull
    FROM blob_table
    WHERE blob_id = 1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT b_notnull FROM blob_table WHERE blob_id = 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_blob_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  blob_var = _tmp_blob_0

  -- The statement ending at line XXXX

  --[[
  SET blob_var_notnull := blob_notnull_func();
  --]]
  blob_var_notnull = blob_notnull_func()

  -- The statement ending at line XXXX

  --[[
  INSERT INTO blob_table(blob_id, b_nullable, b_notnull)
    VALUES (0, blob_var, blob_var_notnull);
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO blob_table(blob_id, b_nullable, b_notnull) VALUES (0, ?, ?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "bB", blob_var, blob_var_notnull)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET obj_var := CASE
    WHEN 1 THEN obj_var
  END;
  --]]
  repeat
    if true then
      break
    end
    obj_var = nil
  until true

  -- The statement ending at line XXXX

  --[[
  SET i2 := outparm_test();
  --]]
  _rc_, i2 = outparm_test(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET i2 := compute(compute(1));
  --]]
  _tmp_int_1 = compute(1)
  i2 = compute(_tmp_int_1)

  -- The statement ending at line XXXX

  --[[
  SET i2 := dml_compute(dml_compute(1));
  --]]
  _rc_, _tmp_int_1 = dml_compute(_db_, 1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, i2 = dml_compute(_db_, _tmp_int_1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  WITH
    x (a) AS (
      SELECT 111
    )
  INSERT INTO foo(id)
    VALUES (ifnull(( SELECT a
      FROM x ), 0));
  --]]
  _rc_ = cql_exec(_db_,
    "WITH x (a) AS ( SELECT 111 ) INSERT INTO foo(id) VALUES (ifnull(( SELECT a FROM x ), 0))")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET r2 := ( SELECT SqlUserFunc(123) );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT SqlUserFunc(123)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    r2 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  CURSOR global_cursor FOR
    SELECT 1 AS a, 2 AS b;
  --]]
  _rc_, global_cursor_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  FETCH global_cursor;
  --]]
  -- step and fetch
  _rc_ = cql_multifetch(global_cursor_stmt, global_cursor, global_cursor_types_, global_cursor_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET i2 := 'x' LIKE 'y';
  --]]
  i2 = cql_to_num(cql_like("x", "y"))

  -- The statement ending at line XXXX

  --[[
  SET i2 := 'x' NOT LIKE 'y';
  --]]
  i2 = cql_to_num(cql_not_like("x", "y"))

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT 'x' LIKE 'y' );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 'x' LIKE 'y'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_bool_0 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT 'x' NOT LIKE 'y' );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 'x' NOT LIKE 'y'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_bool_0 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT 'x' MATCH 'y' );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 'x' MATCH 'y'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_bool_0 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT 'x' GLOB 'y' );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 'x' GLOB 'y'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_bool_0 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 << 2 | 1 << 4 & 1 >> 8;
  --]]
  i2 = ((1 << 2 | 1) << 4 & 1) >> 8

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 << 2 | (1 << 4) & (1 >> 8);
  --]]
  i2 = (1 << 2 | 1 << 4) & 1 >> 8

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 << 2 | (1 << 4 & (1 >> 8));
  --]]
  i2 = 1 << 2 | 1 << 4 & 1 >> 8

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 | ~i2;
  --]]
  i2 = 1 | ~ i2

  -- The statement ending at line XXXX

  --[[
  WITH
    some_cte (id) AS (
      SELECT 1 AS id
    )
  INSERT INTO bar(id) VALUES (ifnull(( SELECT id
    FROM some_cte ), 0)) @DUMMY_SEED(1337);
  --]]
  _seed_ = 1337
  _rc_ = cql_exec(_db_,
    "WITH some_cte (id) AS ( SELECT 1 AS id ) INSERT INTO bar(id) VALUES (ifnull(( SELECT id FROM some_cte ), 0))")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  INSERT INTO bar(id) VALUES (1) @DUMMY_SEED(1338)
  ON CONFLICT (id)
  DO UPDATE
    SET id = 10;
  --]]
  _seed_ = 1338
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id) VALUES (1) ON CONFLICT (id) DO UPDATE SET id = 10")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET l0_nullable := cql_get_blob_size(( SELECT blob_var ));
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "b", blob_var)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_n_blob_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  l0_nullable = cql_get_blob_size(_tmp_n_blob_0)

  -- The statement ending at line XXXX

  --[[
  SET l2 := cql_get_blob_size(blob_var2);
  --]]
  l2 = cql_get_blob_size(blob_var2)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * (4 / 3);
  --]]
  x = 1 * cql_idiv(4, 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * 2 / 3;
  --]]
  x = cql_idiv(1 * 2, 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 + 2 / 3;
  --]]
  x = 1 + cql_idiv(2, 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 + (2 - 3);
  --]]
  x = 1 + (2 - 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 + 2 * 3;
  --]]
  x = 1 + 2 * 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * (2 + 3);
  --]]
  x = 1 * (2 + 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 - (2 + 3);
  --]]
  x = 1 - (2 + 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 - (2 - 3);
  --]]
  x = 1 - (2 - 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 - 2 - (2 - 3);
  --]]
  x = 1 - 2 - (2 - 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 - 2 - (2 - 3);
  --]]
  x = 1 - 2 - (2 - 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 / 2 / 3;
  --]]
  x = cql_idiv(cql_idiv(1, 2), 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 / (4 / 3);
  --]]
  x = cql_idiv(1, cql_idiv(4, 3))

  -- The statement ending at line XXXX

  --[[
  SET x := 1 / 2;
  --]]
  x = cql_idiv(1, 2)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * 2 * (3 * 4);
  --]]
  x = 1 * 2 * (3 * 4)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * 2 * (3 * 4);
  --]]
  x = 1 * 2 * (3 * 4)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | 2 & 3;
  --]]
  x = (1 | 2) & 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (2 & 3);
  --]]
  x = 1 | 2 & 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | 2 | 3;
  --]]
  x = 1 | 2 | 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (2 | 3);
  --]]
  x = 1 | (2 | 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (3 + 4 | 5);
  --]]
  x = 1 | (3 + 4 | 5)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | 3 + (4 | 5);
  --]]
  x = 1 | 3 + (4 | 5)

  -- The statement ending at line XXXX

  --[[
  SET x := (1 | 3) + (4 | 5);
  --]]
  x = (1 | 3) + (4 | 5)

  -- The statement ending at line XXXX

  --[[
  SET x := (1 + 2) * 5;
  --]]
  x = (1 + 2) * 5

  -- The statement ending at line XXXX

  --[[
  SET x := 1 + 2 - 1;
  --]]
  x = 1 + 2 - 1

  -- The statement ending at line XXXX

  --[[
  SET x := 1 << 2 | 3;
  --]]
  x = 1 << 2 | 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 << (2 | 3);
  --]]
  x = 1 << (2 | 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (2 << 3);
  --]]
  x = 1 | 2 << 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 << (2 << 3);
  --]]
  x = 1 << (2 << 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 < (2 > 3);
  --]]
  x = cql_to_num(1 < cql_to_num((2 > 3)))

  -- The statement ending at line XXXX

  --[[
  SET x := 1 << (2 >> 3);
  --]]
  x = 1 << (2 >> 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (2 | 3);
  --]]
  x = 1 | (2 | 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | 2 | 3;
  --]]
  x = 1 | 2 | 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 = 2 <> 3;
  --]]
  x = cql_to_num(1 == cql_to_num((2 ~= 3)))

  -- The statement ending at line XXXX

  --[[
  @EMIT_ENUMS some_ints;
  --]]
  cql_emit_constants("enum", "some_ints", {
    foo = 12,
    bar = 3
  })

  -- The statement ending at line XXXX

  --[[
  @EMIT_ENUMS;
  --]]
  cql_emit_constants("enum", "some_ints", {
    foo = 12,
    bar = 3
  })
  cql_emit_constants("enum", "some_reals", {
    foo = 1.200000e+01,
    bar = 3.000000e+00
  })
  cql_emit_constants("enum", "some_longs", {
    foo = 9223372036854775807,
    bar = 3
  })

  -- The statement ending at line XXXX

  --[[
  INSERT INTO virtual_with_hidden(vy)
    VALUES (1);
  --]]
  _rc_ = cql_exec(_db_,
    "INSERT INTO virtual_with_hidden(vy) VALUES (1)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  INSERT INTO virtual_with_hidden(vx, vy)
    VALUES (1, 2);
  --]]
  _rc_ = cql_exec(_db_,
    "INSERT INTO virtual_with_hidden(vx, vy) VALUES (1, 2)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := ( SELECT type
    FROM bar IF NOTHING THEN -1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT type FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if _rc_ == CQL_ROW then
    _tmp_n_int_1 = cql_get_value(_temp_stmt, 0)
    i0_nullable = _tmp_n_int_1
  else
    i0_nullable = - 1
  end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := ( SELECT type
    FROM bar IF NOTHING THEN THROW );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT type FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_n_int_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i0_nullable = _tmp_n_int_0

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT type
    FROM bar IF NOTHING OR NULL THEN -1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT type FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if _rc_ == CQL_ROW then
    _tmp_n_int_1 = cql_get_value(_temp_stmt, 0)
  end
  if _rc_ == CQL_DONE or _tmp_n_int_1 == nil then
    i2 = - 1
  else
    i2 = _tmp_n_int_1
  end
  _rc_ = CQL_OK
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET t0_nullable := ( SELECT name
    FROM bar IF NOTHING THEN "" );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT name FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if _rc_ == CQL_ROW then
    _tmp_n_text_1 = cql_get_value(_temp_stmt, 0)
    t0_nullable = _tmp_n_text_1
  else
    t0_nullable = ""
  end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET t2 := ( SELECT name
    FROM bar IF NOTHING OR NULL THEN "garbonzo" );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT name FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if _rc_ == CQL_ROW then
    _tmp_n_text_1 = cql_get_value(_temp_stmt, 0)
  end
  if _rc_ == CQL_DONE or _tmp_n_text_1 == nil then
    t2 = "garbonzo"
  else
    t2 = _tmp_n_text_1
  end
  _rc_ = CQL_OK
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SWITCH i2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4 THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
    ELSE
      SET i2 := 50;
  END;
  --]]
  _tmp_int_0 = i2
  repeat
    if _tmp_int_0 == 1 or _tmp_int_0 == 3 then
      i2 = 30
      break
    end

    if _tmp_int_0 == 4 then
      i2 = 40
      break
    end

    if _tmp_int_0 == 5 then
      break
    end

    -- default
      i2 = 50
  until true

  -- The statement ending at line XXXX

  --[[
  SWITCH i2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4 THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
  END;
  --]]
  _tmp_int_0 = i2
  repeat
    if _tmp_int_0 == 1 or _tmp_int_0 == 3 then
      i2 = 30
      break
    end

    if _tmp_int_0 == 4 then
      i2 = 40
      break
    end
  until true

  -- The statement ending at line XXXX

  --[[
  SWITCH l2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4L THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
  END;
  --]]
  _tmp_int64_0 = l2
  repeat
    if _tmp_int64_0 == 1 or _tmp_int64_0 == 3 then
      i2 = 30
      break
    end

    if _tmp_int64_0 == 4 then
      i2 = 40
      break
    end
  until true

  -- The statement ending at line XXXX

  --[[
  SWITCH i2
    WHEN 1, 2, 3 THEN NOTHING
    ELSE
      SET i2 := 123;
  END;
  --]]
  _tmp_int_0 = i2
  repeat
    if _tmp_int_0 == 1 or _tmp_int_0 == 2 or _tmp_int_0 == 3 then
      break
    end

    -- default
      i2 = 123
  until true

  -- The statement ending at line XXXX

  --[[
  SWITCH i2
    WHEN 1 THEN
      IF i2 THEN
        LEAVE;
      END;
      SET i2 := 999;
    ELSE
      SET i2 := 1;
  END;
  --]]
  _tmp_int_0 = i2
  repeat
    if _tmp_int_0 == 1 then
      if cql_to_bool(i2) then
        break
      end
      i2 = 999
      break
    end

    -- default
      i2 = 1
  until true

  -- The statement ending at line XXXX

  --[[
  LET true_test := 1 IS TRUE;
  --]]
  true_test = (1 ~= 0)

  -- The statement ending at line XXXX

  --[[
  LET false_test := 0 IS FALSE;
  --]]
  false_test = (0 == 0)

  -- The statement ending at line XXXX

  --[[
  SET true_test := i0_nullable IS TRUE;
  --]]
  true_test = cql_is_true(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET false_test := i0_nullable IS FALSE;
  --]]
  false_test = cql_is_false(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET true_test := 1 IS NOT TRUE;
  --]]
  true_test = (1 == 0)

  -- The statement ending at line XXXX

  --[[
  SET false_test := 0 IS NOT FALSE;
  --]]
  false_test = (0 ~= 0)

  -- The statement ending at line XXXX

  --[[
  SET true_test := i0_nullable IS NOT TRUE;
  --]]
  true_test = cql_is_not_true(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET false_test := i0_nullable IS NOT FALSE;
  --]]
  false_test = cql_is_not_false(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  LET sign_val_int := sign(-2);
  --]]
  sign_val_int = cql_unary_sign(- 2)

  -- The statement ending at line XXXX

  --[[
  LET sign_val_nullable := sign(nullable(-2));
  --]]
  sign_val_nullable = cql_unary_sign((-2))

  -- The statement ending at line XXXX

  --[[
  LET abs_val_int := abs(-2);
  --]]
  abs_val_int = cql_unary_abs(- 2)

  -- The statement ending at line XXXX

  --[[
  LET abs_val_nullable := abs(nullable(-2));
  --]]
  abs_val_nullable = cql_unary_abs((-2))

  -- The statement ending at line XXXX

  --[[
  LET abs_val_long := abs(-2L);
  --]]
  abs_val_long = cql_unary_abs(- 2)

  -- The statement ending at line XXXX

  --[[
  LET abs_val_real := abs(-2.0);
  --]]
  abs_val_real = cql_unary_abs(- 2.0)

  -- The statement ending at line XXXX

  --[[
  @EMIT_CONSTANTS some_constants;
  --]]
  cql_emit_constants("const", "some_constants", {
    const_u = 0,
    const_w = 3.500000e+00,
    const_x = 1,
    const_y = 5,
    const_z = "hello, world\n"
  })

  -- The statement ending at line XXXX

  --[[
  @EMIT_CONSTANTS big_constants;
  --]]
  cql_emit_constants("const", "big_constants", {
    big_long_constants_max = 9223372036854775807,
    big_long_constants_min = (-9223372036854775807 - 1),
    big_long_constants_almost_min = -9223372036854775807
  })

  -- The statement ending at line XXXX

  --[[
  GROUP var_group
  BEGIN
    CURSOR gr_cursor LIKE SELECT 1 AS x, "2" AS y;
    DECLARE gr_integer INT;
    DECLARE gr_bool BOOL;
    DECLARE gr_text TEXT;
    DECLARE gr_not_null_integer INT!;
    DECLARE gr_not_null_bool BOOL!;
    CURSOR gr_blob_cursor LIKE structured_storage;
  END;
  --]]
  -- group emits no lua

  -- The statement ending at line XXXX

  --[[
  SET b2 := ( SELECT likely(1) );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT likely(1)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_int_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  b2 = cql_to_bool(_tmp_int_0)

  -- The statement ending at line XXXX

  --[[
  LET this_is_the_end := 0xf00d;
  --]]
  this_is_the_end = 0xf00d

::cql_cleanup::
  cql_finalize_stmt(foo_cursor_stmt)
  foo_cursor_stmt = nil
  cql_finalize_stmt(basic_cursor_stmt)
  basic_cursor_stmt = nil
  cql_finalize_stmt(exchange_cursor_stmt)
  exchange_cursor_stmt = nil
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  cql_finalize_stmt(expanded_select_stmt)
  expanded_select_stmt = nil
  cql_finalize_stmt(table_expanded_select_stmt)
  table_expanded_select_stmt = nil
  cql_finalize_stmt(global_cursor_stmt)
  global_cursor_stmt = nil
  return _rc_
end
