DECLARE PROC printf NO CHECK;

-- The statement ending at line XXXX

DECLARE SELECT FUNC is_declare_func_enabled () BOOL NOT NULL;
DECLARE SELECT FUNC is_declare_func_wall (id LONG_INT) BOOL NOT NULL;
DECLARE SELECT FUNC array_num_at (array_object_ptr LONG_INT NOT NULL, idx INTEGER NOT NULL) LONG_INT;
DECLARE SELECT FUNC select_virtual_table (b TEXT) (id LONG_INT, t TEXT, b BLOB, r REAL);
@attribute(cql:deterministic)
DECLARE SELECT FUNC bgetkey_type (x BLOB NOT NULL) LONG_INT NOT NULL;
@attribute(cql:deterministic)
DECLARE SELECT FUNC bgetval_type (x BLOB NOT NULL) LONG_INT NOT NULL;
@attribute(cql:deterministic)
DECLARE SELECT FUNC bgetkey NO CHECK BLOB;
@attribute(cql:deterministic)
DECLARE SELECT FUNC bgetval NO CHECK BLOB;
@attribute(cql:deterministic)
DECLARE SELECT FUNC bcreatekey NO CHECK BLOB;
@attribute(cql:deterministic)
DECLARE SELECT FUNC bcreateval NO CHECK BLOB;
@attribute(cql:deterministic)
DECLARE SELECT FUNC bupdatekey NO CHECK BLOB;
@attribute(cql:deterministic)
DECLARE SELECT FUNC bupdateval NO CHECK BLOB;
DECLARE SELECT FUNC stuff () INTEGER NOT NULL;

CREATE PROC create_schema()
BEGIN
  CREATE TABLE t1(
    id INTEGER PRIMARY KEY,
    name TEXT
  );
  CREATE TABLE t2(
    id INTEGER PRIMARY KEY,
    name TEXT
  );
  CREATE TABLE t3(
    id INTEGER PRIMARY KEY,
    name TEXT
  );
  CREATE TABLE t4(
    id LONG_INT PRIMARY KEY AUTOINCREMENT,
    data BLOB
  );
  CREATE TABLE t5(
    id LONG_INT,
    FOREIGN KEY (id) REFERENCES t4 (id) ON UPDATE CASCADE ON DELETE CASCADE
  );
  CREATE TABLE scan_ok(
    id INTEGER
  );
  CREATE TABLE foo(
    id INTEGER
  );
  CREATE TABLE _foo(
    id INTEGER
  );
  CREATE TABLE foo_(
    id INTEGER
  );
  CREATE INDEX it1 ON t1 (name, id);
  CREATE INDEX it4 ON t4 (data, id);
  CREATE VIEW my_view AS
  SELECT *
    FROM t1
    INNER JOIN t2 USING (id);
  CREATE TRIGGER my_trigger
    AFTER INSERT ON t1
    WHEN is_declare_func_enabled() AND is_declare_func_wall(new.id) = 1
  BEGIN
  DELETE FROM t2 WHERE id > new.id;
  END;
  CREATE TABLE virtual_table(
    id INTEGER,
    t TEXT,
    b BLOB,
    r REAL
  );
  CREATE TABLE C(
    id INTEGER NOT NULL,
    name TEXT
  );
  CREATE TABLE select_virtual_table (
    id INTEGER,
    t TEXT,
    b BLOB,
    r REAL
  );
  @attribute(cql:backing_table)
  CREATE TABLE backing(
    k BLOB PRIMARY KEY,
    v BLOB NOT NULL
  );
  CREATE INDEX backing_index ON backing (bgetkey_type(k));
  CREATE TABLE sql_temp(
    id INT NOT NULL PRIMARY KEY,
    sql TEXT NOT NULL
  ) WITHOUT ROWID;
  CREATE TABLE plan_temp(
    iselectid INT NOT NULL,
    iorder INT NOT NULL,
    ifrom INT NOT NULL,
    zdetail TEXT NOT NULL,
    sql_id INT NOT NULL,
    FOREIGN KEY (sql_id) REFERENCES sql_temp(id)
  );
  CREATE TABLE no_table_scan(
    table_name TEXT NOT NULL PRIMARY KEY
  );
  CREATE TABLE table_scan_alert(
    info TEXT NOT NULL
  );
  CREATE TABLE b_tree_alert(
    info TEXT NOT NULL
  );
  CREATE TABLE ok_table_scan(
    sql_id INT NOT NULL PRIMARY KEY,
    proc_name TEXT NOT NULL,
    table_names TEXT NOT NULL
  ) WITHOUT ROWID;
END;
@attribute(cql:backed_by=backing)
CREATE TABLE backed(
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE PROC populate_no_table_scan()
BEGIN
  INSERT OR IGNORE INTO no_table_scan(table_name) SELECT "t1"
  UNION  SELECT "t2"
  UNION  SELECT "scan_ok"
  UNION  SELECT "foo";
END;

CREATE PROC populate_query_plan_1()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT *\\n  FROM t1\\n  WHERE name = 'Nelly' AND id IN (SELECT id\\n  FROM t2\\n  WHERE id = 1\\nUNION\\nSELECT id\\n  FROM t3)\\nORDER BY name ASC";
  INSERT INTO sql_temp(id, sql) VALUES(1, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT *
    FROM t1
    WHERE name = 'Nelly' AND id IN (SELECT id
    FROM t2
    WHERE id = 1
  UNION
  SELECT id
    FROM t3)
  ORDER BY name ASC;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(1, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_2()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT is_declare_func_wall(id)\\n  FROM t4\\n  WHERE data = cast('1' as blob)";
  INSERT INTO sql_temp(id, sql) VALUES(2, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT is_declare_func_wall(id)
    FROM t4
    WHERE data = cast('1' as blob);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(2, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_3()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "UPDATE t1\\nSET id = 1,\\nname = '1'\\n  WHERE name IN (SELECT NAME\\n  FROM t3)";
  INSERT INTO sql_temp(id, sql) VALUES(3, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  UPDATE t1
  SET id = 1,
  name = '1'
    WHERE name IN (SELECT NAME
    FROM t3);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(3, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_4()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "WITH\\nsome_cte (id, name) AS (SELECT 1 AS id, 'Irene' AS name)\\nUPDATE t1\\nSET id = 1,\\nname = '1'\\n  WHERE name IN (SELECT name\\n  FROM some_cte)";
  INSERT INTO sql_temp(id, sql) VALUES(4, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  WITH
  some_cte (id, name) AS (SELECT 1 AS id, 'Irene' AS name)
  UPDATE t1
  SET id = 1,
  name = '1'
    WHERE name IN (SELECT name
    FROM some_cte);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(4, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_5()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "DELETE FROM t1 WHERE name IN (SELECT t2.name\\n  FROM t2\\n  INNER JOIN t3 USING (name))";
  INSERT INTO sql_temp(id, sql) VALUES(5, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  DELETE FROM t1 WHERE name IN (SELECT t2.name
    FROM t2
    INNER JOIN t3 USING (name));
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(5, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_6()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "WITH\\nsome_cte (name) AS (SELECT t2.name\\n  FROM t2\\n  INNER JOIN t3 USING (id))\\nDELETE FROM t1 WHERE name NOT IN (SELECT *\\n  FROM some_cte)";
  INSERT INTO sql_temp(id, sql) VALUES(6, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  WITH
  some_cte (name) AS (SELECT t2.name
    FROM t2
    INNER JOIN t3 USING (id))
  DELETE FROM t1 WHERE name NOT IN (SELECT *
    FROM some_cte);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(6, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_7()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "INSERT INTO t1(id, name) SELECT *\\n  FROM t2\\nUNION ALL\\nSELECT *\\n  FROM t3";
  INSERT INTO sql_temp(id, sql) VALUES(7, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  INSERT INTO t1(id, name) SELECT *
    FROM t2
  UNION ALL
  SELECT *
    FROM t3;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(7, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_8()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "WITH\\nsome_cte (id, name) AS (SELECT 1, 'x')\\nINSERT INTO t1(id, name) SELECT *\\n  FROM some_cte";
  INSERT INTO sql_temp(id, sql) VALUES(8, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  WITH
  some_cte (id, name) AS (SELECT 1, 'x')
  INSERT INTO t1(id, name) SELECT *
    FROM some_cte;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(8, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_9()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "BEGIN";
  INSERT INTO sql_temp(id, sql) VALUES(9, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  BEGIN;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(9, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_10()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "INSERT INTO t1(id, name) VALUES(1, 'Irene')\\nON CONFLICT (id) DO UPDATE\\nSET name = excluded.name || 'replace' || ' \\u00e2\\u0080\\u00a2 ' || '\\\\x01\\\\x02\\\\xA1\\\\x1b\\\\x00\\\\xg' || 'it''s high noon\\\\r\\\\n\\\\f\\\\b\\\\t\\\\v' || \\\"it's\\\" || name";
  INSERT INTO sql_temp(id, sql) VALUES(10, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  INSERT INTO t1(id, name) VALUES(1, 'Irene')
  ON CONFLICT (id) DO UPDATE
  SET name = excluded.name || 'replace' || ' • ' || '\x01\x02\xA1\x1b\x00\xg' || 'it''s high noon\r\n\f\b\t\v' || "it's" || name;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(10, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_11()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "WITH\\nsome_cte (id, name) AS (SELECT 1, 'Irene')\\nINSERT INTO t1(id, name) SELECT *\\n  FROM some_cte\\n  WHERE id = 1\\nON CONFLICT (id) DO UPDATE\\nSET name = excluded.name || 'replace' || ' \\u00e2\\u0080\\u00a2 ' || '\\\\x01\\\\x02\\\\xA1\\\\x1b\\\\x00\\\\xg' || 'it''s high noon\\\\r\\\\n\\\\f\\\\b\\\\t\\\\v' || \\\"it's\\\" || name";
  INSERT INTO sql_temp(id, sql) VALUES(11, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  WITH
  some_cte (id, name) AS (SELECT 1, 'Irene')
  INSERT INTO t1(id, name) SELECT *
    FROM some_cte
    WHERE id = 1
  ON CONFLICT (id) DO UPDATE
  SET name = excluded.name || 'replace' || ' • ' || '\x01\x02\xA1\x1b\x00\xg' || 'it''s high noon\r\n\f\b\t\v' || "it's" || name;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(11, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_12()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "COMMIT";
  INSERT INTO sql_temp(id, sql) VALUES(12, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  COMMIT;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(12, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_13()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "DROP TABLE IF EXISTS t1";
  INSERT INTO sql_temp(id, sql) VALUES(13, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  DROP TABLE IF EXISTS t1;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(13, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_14()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "DROP VIEW my_view";
  INSERT INTO sql_temp(id, sql) VALUES(14, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  DROP VIEW my_view;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(14, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_15()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "DROP INDEX it1";
  INSERT INTO sql_temp(id, sql) VALUES(15, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  DROP INDEX it1;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(15, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_16()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "WITH\\nsome_cte (name) AS (SELECT t2.name\\n  FROM t2\\n  INNER JOIN t3 USING (id))\\nSELECT *\\n  FROM some_cte";
  INSERT INTO sql_temp(id, sql) VALUES(16, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  WITH
  some_cte (name) AS (SELECT t2.name
    FROM t2
    INNER JOIN t3 USING (id))
  SELECT *
    FROM some_cte;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(16, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_17()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT array_num_at(ptr(cast('1' as object)), id) AS idx\\n  FROM t1";
  INSERT INTO sql_temp(id, sql) VALUES(17, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT array_num_at(ptr(cast('1' as object)), id) AS idx
    FROM t1;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(17, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_18()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT *\\n  FROM scan_ok";
  INSERT INTO sql_temp(id, sql) VALUES(18, stmt);
  INSERT INTO ok_table_scan(sql_id, proc_name, table_names) VALUES(18, "use_ok_table_scan_attr", "#scan_ok#,#t3#");
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT *
    FROM scan_ok;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(18, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_19()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT 1 AS n\\n  FROM foo_,\\n_foo";
  INSERT INTO sql_temp(id, sql) VALUES(19, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT 1 AS n
    FROM foo_,
  _foo;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(19, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_20()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT ifnull(nullable(1), 42) AS nullable_result";
  INSERT INTO sql_temp(id, sql) VALUES(20, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT ifnull(nullable(1), 42) AS nullable_result;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(20, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

@attribute(cql:shared_fragment)
CREATE PROC split_commas (str TEXT)
BEGIN
WITH
splitter (tok, rest) AS (SELECT "", IFNULL(nullable('1') || ",", "")
UNION ALL
SELECT substr(rest, 1, instr(rest, ",") - 1), substr(rest, instr(rest, ",") + 1)
  FROM splitter
  WHERE rest <> "")
SELECT tok
  FROM splitter
  WHERE tok <> "";
END;

@attribute(cql:shared_fragment)
CREATE PROC ids_from_string (str TEXT)
BEGIN
WITH
toks (tok) AS (CALL split_commas(nullable('1')))
SELECT CAST(tok AS LONG_INT) AS id
  FROM toks;
END;

CREATE PROC populate_query_plan_21()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "WITH\\nI (id) AS (CALL ids_from_string('1')),\\nE (id) AS (CALL ids_from_string('1'))\\nSELECT C.*\\n  FROM C\\n  WHERE C.id IN (SELECT *\\n  FROM I) AND C.id NOT IN (SELECT *\\n  FROM E)";
  INSERT INTO sql_temp(id, sql) VALUES(21, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  WITH
  I (id) AS (CALL ids_from_string('1')),
  E (id) AS (CALL ids_from_string('1'))
  SELECT C.*
    FROM C
    WHERE C.id IN (SELECT *
    FROM I) AND C.id NOT IN (SELECT *
    FROM E);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(21, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

@attribute(cql:shared_fragment)
@attribute(cql:query_plan_branch=11)
CREATE PROC frag1 (x INTEGER)
BEGIN
SELECT 2 AS a;
END;

@attribute(cql:shared_fragment)
@attribute(cql:query_plan_branch=4)
CREATE PROC frag2 (y INTEGER)
BEGIN
SELECT 40 AS b;
END;

@attribute(cql:shared_fragment)
CREATE PROC frag3 (z INTEGER)
BEGIN
SELECT 100 AS c;
END;

@attribute(cql:shared_fragment)
CREATE PROC frag_with_select ()
BEGIN
WITH
cte (a) AS (SELECT 1 AS a)
SELECT *
  FROM cte;
END;

@attribute(cql:shared_fragment)
@attribute(cql:query_plan_branch=2)
CREATE PROC frag_with_select_nothing ()
BEGIN
SELECT 1 AS a;
END;

CREATE PROC populate_query_plan_22()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT one.id, one.t, one.b, one.r, two.id AS id_, two.t AS t_, two.b AS b_, two.r AS r_\\n  FROM select_virtual_table AS one,\\nselect_virtual_table AS two";
  INSERT INTO sql_temp(id, sql) VALUES(22, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT one.id, one.t, one.b, one.r, two.id AS id_, two.t AS t_, two.b AS b_, two.r AS r_
    FROM select_virtual_table AS one,
  select_virtual_table AS two;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(22, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_23()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "WITH\\nbacked (rowid, id, name) AS (CALL _backed())\\nSELECT *\\n  FROM backed\\n  WHERE name = 'x'";
  INSERT INTO sql_temp(id, sql) VALUES(23, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  WITH
  backed (rowid, id, name) AS (CALL _backed())
  SELECT *
    FROM backed
    WHERE name = 'x';
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(23, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_24()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT CAST(1L AS INTEGER)";
  INSERT INTO sql_temp(id, sql) VALUES(24, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT CAST(1L AS INTEGER);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(24, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_25()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT CAST(1.0 AS INTEGER)";
  INSERT INTO sql_temp(id, sql) VALUES(25, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT CAST(1.0 AS INTEGER);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(25, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_26()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT CAST(1 AS REAL)";
  INSERT INTO sql_temp(id, sql) VALUES(26, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT CAST(1 AS REAL);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(26, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_27()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT CAST(true AS INTEGER)";
  INSERT INTO sql_temp(id, sql) VALUES(27, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT CAST(true AS INTEGER);
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(27, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

@attribute(cql:shared_fragment)
CREATE PROC notnull_int_frag (v INTEGER NOT NULL)
BEGIN
SELECT 1 AS val;
END;

CREATE PROC populate_query_plan_28()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT *\\n  FROM (CALL notnull_int_frag(1))";
  INSERT INTO sql_temp(id, sql) VALUES(28, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT *
    FROM (CALL notnull_int_frag(1));
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(28, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;

CREATE PROC populate_query_plan_29()
BEGIN
  DECLARE stmt TEXT NOT NULL;
  SET stmt := "SELECT stuff() AS x, notnull_int_frag(1) AS y, T1.*\\n  FROM (CALL notnull_int_frag(1 + 1)) AS T1";
  INSERT INTO sql_temp(id, sql) VALUES(29, stmt);
  DECLARE C CURSOR FOR EXPLAIN QUERY PLAN
  SELECT stuff() AS x, notnull_int_frag(1) AS y, T1.*
    FROM (CALL notnull_int_frag(1 + 1)) AS T1;
  LOOP FETCH C
  BEGIN
    INSERT INTO plan_temp(sql_id, iselectid, iorder, ifrom, zdetail) VALUES(29, C.iselectid, C.iorder, C.ifrom, C.zdetail);
  END;
END;


CREATE PROC populate_table_scan_alert_table(table_ text not null)
BEGIN
  INSERT OR IGNORE INTO table_scan_alert
    SELECT upper(table_) || '(' || count(*) || ')' as info FROM plan_temp
    WHERE ( zdetail GLOB ('*[Ss][Cc][Aa][Nn]* ' || table_) OR 
            zdetail GLOB ('*[Ss][Cc][Aa][Nn]* ' || table_ || ' *')
          )
    AND sql_id NOT IN (
      SELECT sql_id from ok_table_scan
        WHERE table_names GLOB ('*#' || table_ || '#*')
    ) GROUP BY table_;
END;

CREATE PROC populate_b_tree_alert_table()
BEGIN
  INSERT OR IGNORE INTO b_tree_alert
    SELECT '#' || sql_id || '(' || count(*) || ')' as info FROM plan_temp
    WHERE zdetail LIKE '%temp b-tree%'
    GROUP BY sql_id;
END;

CREATE PROC print_query_violation()
BEGIN
  CALL populate_b_tree_alert_table();
  DECLARE C CURSOR FOR SELECT table_name FROM no_table_scan;
  LOOP FETCH C
  BEGIN
    CALL populate_table_scan_alert_table(C.table_name);
  END;

  LET first := true;
  CALL printf("\"alerts\" : {\n");
  DECLARE C2 CURSOR FOR
    SELECT 'tableScanViolation' AS key, group_concat(info, ', ') AS info_list FROM table_scan_alert
    UNION ALL
    SELECT 'tempBTreeViolation' AS key, group_concat(info, ', ') AS info_list FROM b_tree_alert;
  LOOP FETCH C2
  BEGIN
    IF C2.info_list IS NOT NULL THEN
      CALL printf("%s", IIF(first, "", ",\n"));
      CALL printf("  \"%s\" : ", C2.key);
      CALL printf("\"%s\"", C2.info_list);
      SET first := false;
    END IF;
  END;
  CALL printf("\n},\n");
END;

CREATE PROC print_sql_statement(sql_id integer not null)
BEGIN
  DECLARE C CURSOR FOR SELECT * FROM sql_temp WHERE id = sql_id LIMIT 1;
  FETCH C;
  CALL printf("   \"query\" : \"%s\",\n", C.sql);
END;

CREATE PROC print_query_plan_stat(id_ integer not null)
BEGIN
  CALL printf("   \"stats\" : [\n");
  DECLARE Ca CURSOR FOR
  WITH
    scan(name, count, priority) AS (
      SELECT 'SCAN', COUNT(*), 0 
        FROM plan_temp 
        WHERE zdetail LIKE '%scan%' AND sql_id = id_
    ),
    search(name, count, priority) AS (
      SELECT 'SEARCH', COUNT(*), 4 
        FROM plan_temp 
        WHERE zdetail LIKE '%search%' AND iselectid NOT IN (
          SELECT iselectid 
          FROM plan_temp 
          WHERE zdetail LIKE '%search%using%covering%'
        ) AND sql_id = id_
    ),
    search_fast(name, count, priority) AS (
      SELECT 'SEARCH USING COVERING', COUNT(*), 5 
        FROM plan_temp 
        WHERE zdetail LIKE '%search%using%covering%' AND sql_id = id_
    ),
    b_tree(name, count, priority) AS (
      SELECT 'TEMP B-TREE', COUNT(*), 1 
        FROM plan_temp 
        WHERE zdetail LIKE '%temp b-tree%' AND sql_id = id_
    ),
    compound_subqueries(name, count, priority) AS (
      SELECT 'COMPOUND SUBQUERIES', COUNT(*), 2 
        FROM plan_temp 
        WHERE zdetail LIKE '%compound subqueries%' AND sql_id = id_
    ),
    execute_scalar(name, count, priority) AS (
      SELECT 'EXECUTE SCALAR', COUNT(*), 3 
        FROM plan_temp 
        WHERE zdetail LIKE '%execute scalar%' AND sql_id = id_
    )
  SELECT 
   '"' || name || '"' name,
   count value
   FROM (
   SELECT * FROM scan
   UNION ALL
   SELECT * FROM search
   UNION ALL
   SELECT * FROM search_fast
   UNION ALL
   SELECT * FROM b_tree
   UNION ALL
   SELECT * FROM compound_subqueries
   UNION ALL
   SELECT * FROM execute_scalar
  )
  WHERE count > 0 ORDER BY priority ASC, count DESC;
  LET first := true;
  LOOP FETCH Ca
  BEGIN
    CALL printf("%s", IIF(first, "", ",\n"));
    CALL printf("      [%s, %d]", Ca.name, Ca.value);
    SET first := false;
  END;
  CALL printf("\n    ],\n");
END;

CREATE PROC print_query_plan_graph(id_ integer not null)
BEGIN
  DECLARE C CURSOR FOR
  WITH RECURSIVE
    plan_chain(iselectid,  zdetail, level) AS (
     SELECT 0 as  iselectid, 'QUERY PLAN' as  zdetail, 0 as level
     UNION ALL
     SELECT plan_temp.iselectid, plan_temp.zdetail, plan_chain.level+1 as level
      FROM plan_temp JOIN plan_chain ON plan_temp.iorder=plan_chain.iselectid WHERE plan_temp.sql_id = id_
     ORDER BY 3 DESC
    )
    SELECT
     level,
     substr('                              ', 1, max(level - 1, 0)*3) ||
     substr('|.............................', 1, min(level, 1)*3) ||
     zdetail as graph_line FROM plan_chain;

  CALL printf("   \"plan\" : \"");
  LOOP FETCH C
  BEGIN
    CALL printf("%s%s", IIF(C.level, "\\n", ""), C.graph_line);
  END;
  CALL printf("\"\n");
END;

CREATE PROC print_query_plan(sql_id integer not null)
BEGIN
  CALL printf("  {\n");
  CALL printf("   \"id\" : %d,\n", sql_id);
  CALL print_sql_statement(sql_id);
  CALL print_query_plan_stat(sql_id);
  CALL print_query_plan_graph(sql_id);
  CALL printf("  }");
END;

CREATE PROC query_plan()
BEGIN
  CALL create_schema();
  BEGIN TRY
    CALL populate_no_table_scan();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating no_table_scan table\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_1();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 1\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_2();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 2\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_3();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 3\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_4();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 4\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_5();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 5\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_6();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 6\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_7();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 7\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_8();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 8\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_9();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 9\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_10();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 10\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_11();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 11\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_12();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 12\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_13();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 13\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_14();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 14\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_15();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 15\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_16();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 16\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_17();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 17\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_18();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 18\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_19();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 19\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_20();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 20\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_21();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 21\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_22();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 22\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_23();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 23\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_24();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 24\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_25();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 25\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_26();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 26\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_27();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 27\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_28();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 28\n");
    THROW;
  END CATCH;
  BEGIN TRY
    CALL populate_query_plan_29();
  END TRY;
  BEGIN CATCH
    CALL printf("failed populating query 29\n");
    THROW;
  END CATCH;
  CALL printf("{\n");
  CALL print_query_violation();
  CALL printf("\"plans\" : [\n");
  LET q := 1;
  WHILE q <= 29
  BEGIN
    CALL printf("%s", IIF(q == 1, "", ",\n"));
    CALL print_query_plan(q);
    SET q := q + 1;
  END;
  CALL printf("\n]\n");
  CALL printf("}");
END;
