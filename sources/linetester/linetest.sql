/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* This file generates linetest.h, and linetest.c */

@echo c, '
//
// This file is auto-generated by linetest.sql, it is checked in just
// in case CQL is broken by a change.  The Last Known Good Verifier
// can be used to verify the tests pass again, or report failures
// while things are still otherwise broken.  Rebuild with regen.sh
//

// enable detailed error tracing
#undef cql_error_trace
#define cql_error_trace() fprintf(stderr, "SQL Failure %d %s: %s %d\n", _rc_, sqlite3_errmsg(_db_), __FILE__, __LINE__)
';

declare procedure printf no check;

-- these are the standard helper methods from cqlhelp.c
-- they give us basic file and string handling needed for simple
-- command line tools.
func cql_fopen(name text!, mode text!) create object<file>;
func readline_object_file(f object<file>!) create text;
func atoi_at_text(str text, `offset` int!) int!;
func len_text(self text) int!;
func octet_text(self text, `offset` int!) int!;
func after_text(self text, `offset` int!) create text;
func starts_with_text(haystack text!, needle text!) bool!;
func index_of_text(haystack text!, needle text!) int!;
func contains_at_text(haystack text!, needle text!, `offset` int!) bool!;

-- map the methods to operators for easier use
-- this enables things like :len, :after, :starts_with, etc.
@op object<file>: call readline as readline_object_file;
@op text: call atoi_at as atoi_at_text;
@op text: call len as len_text;
@op text: call octet as octet_text;
@op text: call after as after_text;
@op text: call starts_with as starts_with_text;
@op text: call index_of as index_of_text;
@op text: call contains_at as contains_at_text;
@op text: call mid as str_mid;
@op text: call right as str_right;
@op text: call left as str_left;

-- global variables to track state, mostly stats.
var proc_count int!;
var compares int!;
var errors int!;
var expected_name text;
var actual_name text;

-- setup the table and the index
[[private]]
-- This procedure sets up the necessary tables and indexes for the linetest tool.
proc setup()
begin
  create table linedata(
     source text!,
     procname text!,
     line int!,
     data text!,
     physical_line int!
  );

  create table procs(
     procname text! primary key);

  create index __idx__test_lines on linedata (source, procname);
end;

-- add a row to the results table
[[private]]
-- This procedure adds a row to the linedata table and ensures the procname is added to the procs table.
proc add_linedata(like linedata)
begin
  insert into linedata from arguments;
  insert or ignore into procs from arguments(like procs);
end;

[[private]]
-- This procedure dumps all records for a given procedure and source from the linedata table.
proc dump_proc_records(source_ text!, procname_ text!)
begin
  declare C cursor for select * from linedata where procname = procname_ and source = source_;
  loop fetch C
  begin
    printf("%5d %s\n", C.line, C.data);
  end;
end;

[[private]]
-- This procedure prints the differences between the expected and actual data for a given procedure.
proc dump(procname text!)
begin
  printf("%s: difference encountered\n", procname);
  printf("<<<< EXPECTED\n");
  dump_proc_records("exp", procname);
  printf(">>>> ACTUAL\n");
  dump_proc_records("act", procname);
end;

[[private]]
-- This procedure compares the lines of the expected and actual data, reporting any differences.
proc compare_lines()
begin
  declare p cursor for select * from procs;
  loop fetch p
  begin
    proc_count += 1;

    cursor actual for
      select * from linedata where
        source = 'act' and
        procname = p.procname;

    cursor expected for
      select * from linedata where
        source = 'exp' and
        procname = p.procname;

    fetch actual;
    fetch expected;

    while actual and expected
    begin
      compares += 1;
      if actual.line != expected.line or actual.data != expected.data then
          dump(p.procname);
          printf("\nFirst difference:\n");
          printf("expected: %5d %s\n", expected.line, expected.data);
          printf("  actual: %5d %s\n", actual.line, actual.data);
          printf("\nDifferences at:\n line %d in expected\n line %d in actual", expected.physical_line, actual.physical_line);
          printf("\n");
          errors += 1;
          leave;
      end if;
      fetch actual;
      fetch expected;
    end;

    if actual != expected then
      if not actual then
          p.procname:dump;
          printf("\nRan out of lines in actual:\n");
          printf("\nDifferences at:\n line %d in expected\n", expected.physical_line);
          printf("\n");
          errors += 1;
      end if;

      if not expected then
          p.procname:dump;
          printf("\nRan out of lines in expected:\n");
          printf("\nDifferences at:\n line %d in actual\n", actual.physical_line);
          printf("\n");
          errors += 1;
      end if;
    end if;
  end;
end;

[[private]]
-- This procedure reads a file, processes its lines, and adds the data to the linedata table.
proc read_file(input_name text!, source text!)
begin
  let proc_start_prefix := '#define _PROC_ ';
  let proc_undef_prefix := '#undef _PROC_';
  let line_directive_prefix := '#line ';
  let short_line_directive_prefix := '# ';

  let proc_start_prefix_len := proc_start_prefix:len;
  let proc_undef_prefix_len := proc_undef_prefix:len;
  let line_directive_prefix_len := line_directive_prefix:len;
  let short_line_directive_prefix_len := short_line_directive_prefix:len;

  let input_file := cql_fopen(input_name, "r");
  if input_file is null then
    printf("unable to open file '%s'\n", input_name);
    throw;
  end if;

  -- this means the next line will be the first line of a new proc
  let base_at_next_line := false;

  -- this is the current logical line in the proc
  let line := 0;

  -- this is the base adjustment, we normalize the first line of a proc to 1
  -- so even if it starts at 3000 or whatever that becomes the new 1.  We do
  -- this so that changes in the file that add or remove lines before the proc
  -- don't cause all the line numbers to shift and break everything.  All we're
  -- doing is making sure that the lines in the proc are consistent with
  -- the expected line numbers in the baseline.
  let line_base := 0;

  -- this is the actual physical line in the file, used for error reporting
  let physical_line := 0;

  -- current procedure name, null means no current proc
  var procname text;

  while true
  begin
    let data := input_file:readline();
    if data is null leave;

    -- we need to track the actual line number in the file for error reporting
    -- this is a bit weird because we are tracking line numbers and checking
    -- for differences but the errors have to relative to the input stream
    -- not relative to the logical line number the compiler would see/emit.
    physical_line += 1;

    -- Check for procedure start
    if data:starts_with(proc_start_prefix) then
      -- we keep the name quotes and all, it doesn't matter
      -- as long as it's unique
      procname := data:after(proc_start_prefix_len);
      base_at_next_line := true;
      line := 0;
    end if;

    -- undef means no current proc
    if data:starts_with(proc_undef_prefix) then
      procname := null;
      line := 0;
      line_base := 0;
    end if;

    let line_start := -1;

    -- Check for line directive (#line form)
    let line_directive_position := data:index_of(line_directive_prefix);
    if line_directive_position >= 0 then
      line_start := line_directive_position + line_directive_prefix_len;
    end if;

    -- Check for short line directive (# form)
    let short_line_directive_position := data:index_of(short_line_directive_prefix);
    if short_line_directive_position >= 0 then
      line_start := short_line_directive_position + short_line_directive_prefix_len;
    end if;

    -- If we found a line directive, parse the line number
    if line_start >= 0 then
      line := data:atoi_at(line_start);
      if base_at_next_line then
        -- we're normalizing to the start of the proc
        -- we will verify as though the proc started at line 1
        line_base := line - 1;
        base_at_next_line := false;
      end if;
      -- all lines within the proc are adjusted by line_base
      line -= line_base;
      continue;
    end if;

    -- skip non-proc lines
    if procname is null continue;

    -- we have something to record
    add_linedata(source, procname, line, data, physical_line);
  end;
end;

[[private]]
-- This procedure parses the command-line arguments and sets the expected and actual file names.
proc parse_args(args cql_string_list!)
begin
  let argc := args.count;

  if argc != 3 then
    printf("usage cql-linetest expected actual\n");
    printf("cql-linetest is a test tool.  It processes the input files\n");
    printf("normalizing the lines to the start of each procedure\n");
    printf("and verifies that the line numbers are as expected\n");
    return;
  end if;

  set expected_name := args[1]:ifnull_throw;
  set actual_name := args[2]:ifnull_throw;
end;

-- main entry point
-- This is the main entry point for the linetest tool, orchestrating the setup, file reading, and comparison.
proc linetest_main(args cql_string_list!)
begin
  setup();
  parse_args(args);

  if expected_name is null return;
  read_file(expected_name, "exp");

  if actual_name is null return;
  read_file(actual_name, "act");

  compare_lines();

  printf("\n");
  if errors then
    printf("EXPECTED INPUT FILE: %s\n", expected_name);
    printf("  ACTUAL INPUT FILE: %s\n", actual_name);
  end if;

  printf("Verification results: %d procedures matched %d patterns of which %d were errors.\n",
     proc_count, compares, errors);
end;

@echo c, '
#include "cqlhelp.h"

// super cheesy error handling

#define E(x) \
  if (SQLITE_OK != (x)) { \
   fprintf(stderr, "error encountered at: %s (%s:%d)\n", #x, __FILE__, __LINE__); \
   fprintf(stderr, "sqlite3_errmsg: %s\n", sqlite3_errmsg(db)); \
   errors = -1; \
   goto error; \
  }

int main(int argc, char **argv) {
  cql_object_ref args = create_arglist(argc, argv);

  sqlite3 *db = NULL;
  E(sqlite3_open(":memory:", &db));
  E(linetest_main(db, args));

error:
  if (db) sqlite3_close(db);
  cql_object_release(args);
  exit(errors ? 1 : 0);
}
';
